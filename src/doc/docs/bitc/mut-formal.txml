<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <book id="mut-formal" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo ptsz='default'>
    <title>Formalization of the BitC Type System</title>
    <subtitle>SRL Technical Report SRL2007-01</subtitle>
    <authorgroup>
      <author>
	<firstname>Swaroop</firstname>
	<surname>Sridhar</surname>
      </author>
      <author>
	<firstname>Jonathan</firstname>
        <othername>S.</othername>
	<surname>Shapiro</surname>
	<degree>Ph.D.</degree>
      </author>
      <author>
	<firstname>Scott</firstname>
        <othername>F.</othername>
	<surname>Smith</surname>
	<degree>Ph.D.</degree>
      </author>
      <affiliation>
	<address>Dept. of Computer Science</address>
	<address>Johns Hopkins University</address>
      </affiliation>
    </authorgroup>
    <!-- <pubdate></pubdate> -->
    <!--     <categories> -->
    <!--       <category>dev/bitc</category> -->
    <!--     </categories> -->
    <synopsis>
      <p>
      </p>
    </synopsis>
  </docinfo>  
  <toc/>
  <chapter>
    <title>Abstract</title>
    <p>
      There is a persistent gap between modern language designs and
      the requirements of systems programmers. Systems programs rely
      on fine-grain control of data representation and use of state to
      achieve performance, conformance to hardware specification, and
      temporal predictability. Modern type systems such as those used
      in ML and Haskell rely on boxed representation of composite
      types and restricted support for mutability to enable features
      such as polymorphism, type inference, and sound type systems. No
      current language fully supports both feature sets, partly
      because no mutability model has been proposed that adequately
      combines explicitly unboxed types with consistent typing of
      mutability.  C's ``const'' type qualifier is unsound, while from
      a systems programming perspective ML's ``ref'' construct is
      insufficiently expressive.
    </p>
    <p>
      This paper introduces a new type system in which deep mutability
      is a first-class component of type. The type system is provably
      sound, expresses unboxed composite types, supports polymorphism
      and type inference, and reduces the amount of state that must be
      handled by stateful verification methods. The resulting system
      integrates these features in a way that is subjectively natural
      to systems programmers &mdash; in particular supporting
      na&iuml;ve programmer intuitions about locations. A key element
      of this success is the adoption of certain ``hinting''
      mechanisms that guide the inference process to the
      programmer-expected result.  A practical and efficient
      implementation of this type system and inference mechanism has
      been constructed as part of the BitC programming language.
    </p>
  </chapter>
  <chapter>
    <title>Introduction</title>
    <p>
      Safe systems programming is a focal topic for researchers in
      systems as well as programming languages and verification
      communities in the recent years. Although there seems to be a
      consensus about the fact that thirty years of programming in
      high level assembly is long enough&nbsp;<cite
        ref="brewer2005thirty"/>, the level of correctness guarantee
      sought in the proposed alternatives vary greatly &mdash; ranging
      from memory safety&nbsp;<cites> <cite ref="Jim2002Cyclone"/> <cite
                                                                     ref="necula2002CCured"/> </cites> to static analysis or model
      checking to validate certain safety properties&nbsp;<cite
        ref="ball2002debugging"/> to full semantic correctness
      verification&nbsp;<cite ref="hallgren2005principled"/> We are
      currently working on the Coyotos project&nbsp;<cite
        ref="shapiro2006coyotos"/>, which investigates the possibility
      of a fully verified implementation of a secure microkernel.  In
      order to achieve this, there is a need for a language framework
      that has the the right combination of expressiveness, formally
      founded semantics, control over low-level representation, and
      integration with modern verification technology.
    </p>
    <p>
      Modern programming languages such as ML&nbsp;<cite
        ref="milner97definition"/> or Haskell&nbsp;<cite
        ref="peytonjones2003haskellrevisedreport"/> provide newer,
      stronger, and more expressive type systems than systems
      programming languages such as C&nbsp;<cites> 
        <cite ref="Kernighan1988C"/> 
        <cite ref="ISO1999ANSI-C"/> </cites> or Ada&nbsp;<cite
        ref="ISO1995Ada"/>.  These features improve the
      robustness and safety of programs, and it is desirable to
      incorporate them into languages that can be used for
      high-performance systems codes. Polymorphism facilitates
      better code reuse and organization.  Type inference achieves
      the consistency advantages of static typing with a  lower
      burden on the programmer, facilitating more rapid prototyping
      and development.
    </p>
    <p>
      A key property of these ML-like languages is that the
      mutability model is a part of the type system. A term subset
      language suitable for modern logical frameworks&nbsp;<cites> 
        <cite ref="Pfenning1999twelf"/> 
        <cite ref="Nipkow2002Isabelle"/> 
        <cite ref="kaufmann00acl2"/> 
        <cite ref="inria2004coq"/> </cites> can be achieved simply
      by removing the ``ref'' construct.  ML Types are decisive
      about the mutability of all locations (memory cells): every
      location has one and only one type across all aliases.  Tools
      that perform static analysis or model checking benefit from
      the ML mutability model because conclusions drawn about
      location immutability need never be conservative&nbsp;<cite
        ref="ball2002ppabs"/>. This also reduces the state space
      that must be examined by stateful reasoning techniques. Since
      mutable values must not be let-polymorphic&nbsp;<cite
        ref="wrightValRes1995"/>, automatic
      inference of polymorphism requires a mathematically
      well-founded notion of mutability.
    </p>
    <p>
      Unfortunately, most modern programming language implementations
      do not support certain key features that are essential for
      systems programming &mdash; most notably support for low-level
      representation management, and support for first class
      mutability. The support for mutability must be first class in
      the sense that a value of any type (and not just references) can
      be mutable, and we should be able to specify mutability at field
      level granularity. 
    </p>
    <p>
      Efforts have been made to retrofit safety and other high level
      language features into C-like low level languages. Systems like
      CCured&nbsp;<cite ref="necula2002CCured"/>  and Cyclone&nbsp;<cite
        ref="Jim2002Cyclone"/>  use a combination of sound static
      analysis techniques, dynamic checks, user annotations, pointer
      restrictions and conservative garbage collection to ensure
      memory safety of C (or C-like) programs.  First, a fundamental
      problem with the safe C-like languages is the lack of a rigorous
      semantic specification. 
      Second, these systems conform to the C model of mutability,
      where all data is mutable (that is, types do not authentically
      distinguish mutable and immutable values see section&nbsp;<xref
        ref="mut_model"/>). This promiscuity of mutability presents a
      great challenge for integration into a verification framework
      &mdash; we will either have to perform complex and whole program
      alias analyses, or draw conservative and weak conclusions about
      the semantic behavior of programs.  The mutability model also
      limits the ability to perform polymorphic type inference. For
      example, Cyclone supports first class polymorphism only for
      function definitions&nbsp;<cite ref="Grossman2006qtypes"/> that are
      explicitly annotated with a polymorphic type.
    </p>
    <p>
      In this paper, we propose a new language BitC&nbsp;<cite
        ref="shapBitcSpec2006"/> which integrates all of the
      desirable features mentioned above into a single, consistent
      language framework. BitC is a type safe, higher order
      programming language that exposes machine-level representation
      of types, supports polymorphic type inference and well-founded
      first class mutability. BitC is a call-by-value expression
      language. Support for unboxed mutability means that we can
      allow some freedom in the compatibility of types with respect
      to their mutability at copy boundaries. This kind of
      compatibility has interesting ramifications for type
      inference, because there is no longer a unique way to type an
      expression. In this paper, we discuss some of these issues,
      and present a solution based on a simple extension to the
      Hindley-Milner inference algorithm&nbsp;<cite
        ref="Milner1978W"/>. A partial sketch of this approach was
      given in an earlier workshop paper&nbsp;<cite
        ref="sridhar2006plos"/>; the current paper presents the
      first complete treatment, consisting of a formalization and
      proof of soundness, as well as an implementation.
    </p>
  </chapter>
  <chapter>
    <title>Mutability Model and Type Inference</title>
    <sect1 id="BitC">
      <title>BitC</title>
      <p>
        In this section, we give a brief introduction to BitC and the
        facilities available in BitC to suit systems programming. 
        BitC supports a rich set of primitive datatypes and bit-fields:
        <progident>int8</progident>,
        <progident>int64</progident>, 
        <progident>(bitfield uint32 8)</progident>, 
        <progident>float</progident>,
        <progident>double</progident>,
        <foreignphrase>etc</foreignphrase>. It also supports type 
        classes&nbsp;<cite ref="jones1995qualtypes"/> to support operator
        overloading over these types. 
        For example:<footnote>
          <p>
            We use <progident>texttt</progident> font to show program
            fragments and an emphasized
            <progident><em>texttt</em></progident> font to show the
            inferred types.
          </p>
        </footnote>
      </p>
      <literallayout indent="no">
(define (inc x) (+ x 1))
<em>inc: (forall ((Arith 'a) (IntLit 'a)) (fn ('a) 'a))</em></literallayout>
      <p>
        Like C, BitC provides full control over data structure
        representation, which is necessary for high-performance systems
        programming. Composite types (structures and unions) may be
        explicitly declared as boxed (<progident>:ref</progident>) or
        unboxed (<progident>:val</progident>). The default
        representation is boxed. For example: 
      </p>
      <literallayout indent="no">
 (defstruct (pair 'a 'b):val fst: 'a snd: 'b)
 (defunion (list 'a) nil 
                    (cons car:'a cdr:(list 'a)))</literallayout>
      <p>
        BitC also has homogeneous aggregate types in the form of arrays
        (unboxed) and vectors (boxed).
      </p>
      <p>
        BitC is a stateful language. Variables or individual fields may
        be given a mutable type. In the following example,
        <progident>rec</progident> defines an unboxed structure in which
        one of the fields is mutable, while <progident>xyz</progident>
        is a stack variable that is mutable.
      </p>
      <literallayout indent="no">
(defstruct rec:val id:uint32 mVal:(mutable int64))
(let ((xyz:(mutable bool) #t)) ...)
<em>xyz: (mutable bool)</em></literallayout>
      <p>
        The <progident>dup</progident> operator performs a heap copy
        and returns the corresponding heap location. For example:  
      </p>
      <literallayout>
(define bPtr (dup #t))
<em>bPtr: (ref bool)</em></literallayout>    
      <p>
        Unlike ML, heap copy does not entail mutability. The type of
        <progident>bPtr</progident> in the above example is
        <progident>(ref bool)</progident>, which just states that
        <progident>bPtr</progident> is a reference (pointer) to a
        location containing an immutable value of type
        <progident>bool</progident>. Expressions that have a reference
        type can later be dereferenced through the
        <progident>deref</progident> (or <progident>^</progident>)
        operator. BitC does not have an address-of
        (<progident>&amp;</progident>) operator to obtain the address of
        stack locations. As in the case of most safe languages,  heap
        locations are first class values, but stack locations are not.
        We use the unqualified term ``location'' wherever both stack and
        heap locations are applicable.   
      </p>
      <p>
        BitC supports let-polymorphism as in ML. Polymorphism is
        supported even over unboxed types. However, in some cases, we
        may want to restrict the polymorphism to reference types only,
        in order to ensure that the definition is not polyinstantiated
        (or otherwise adjusted to handle unboxed types). In BitC, there
        is a built in type classes called
        <progident>ref-type</progident> to which all boxed types
        belong. Now, we can write a polymorphic identity function that
        only works on reference types as:
      </p>
      <literallayout indent="no">
 (define id:(forall ((ref-type 'a)) (fn ('a) 'a))
   (lambda (x) x))</literallayout>
      <p>
        There are several syntactic constructs in BitC to support a
        metalanguage, which allows application-specific safety
        properties to be embedded within a program. This meta-language
        will eventually be interfaced with a theorem prover in order to
        discharge the proof obligations expressed by the programmer.
      </p>
    </sect1>
    <sect1 id="mut_model">
      <title>Mutability Model in BitC</title>
      <p>
        Traditionally, there are two models of mutability studied in the
        case of imperative languages. One of them is the ML model, where
        there is a clear separation between name bindings and updatable
        locations. All updatable (mutable) locations live in the heap
        within ``ref cells''. Fetching the value inside a ref cell
        requires an explicit dereferencing operation. The major
        advantage of this approach is that types are definitive about the
        mutability of every location, across all aliases. In this sense,
        we can say that the support for mutability is mathematically
        ``well-founded.''  
      </p>
      <p>
        The other well known model of mutability is the C model, wherein
        the support for mutability is ``first-class'' in the sense that
        mutation of stack variables and unboxed values are
        supported. There is a notion of <em>lvalues</em> which are
        expressions that can be the target of an assignment, and
        <em>rvalues</em>, that are otherwise used in computations. The
        extraction of the value from a (mutable) location is implicit,
        and does not require dereferencing. However, in this model,
        types cannot distinguish mutable values from immutable ones.
        For example, in C (and safe-C languages) it is legal to write: 
      </p>
      <literallayout>
const int *cpi = ...;
int *pi = cpi;   // Warning only.
*pi = 5;         // OK!</literallayout>
      <p> 
        The alleged ``constness'' of the location pointed to by
        <progident>cpi</progident> is a local property with (only)
        respect to this alias (<progident>cpi</progident>) and not a
        statement of true immutability of the location referenced by it.
        The compiler or other analytical engines are not entitled to
        believe that certain locations or fields are constant even if so
        declared.
      </p>
      <p>
        BitC supports well-founded first class mutability. Similar to
        ML, we impose the  the ``one location, one type'' rule. 
      </p>    
      <literallayout>
(let ((cpi:(ref int32) (dup 10)))
  (let ((pi:(ref (mutable int32)) cpi)) ;ERROR</literallayout>
      <p>
        In order to support unboxed mutability, we still need to have a
        notion of lvalues. It is necessary for both preserving the
        programmer's mental model of the relationship between locations
        and storage, as well as ensuring that compiler transformations
        are semantics preserving. In an assignment context, the
        following syntactic forms in BitC accept only lvalues at
        positions indicated as <progident><em>lval</em></progident>, and
        return lvalues (except <progident>set!</progident>, which
        returns <progident>unit</progident>):
      </p>
      <literallayout>
id
(array-nth <em>lval</em> ndx)
(vector-nth e ndx)
(member <em>lval</em> ident)
(deref e)
(set! <em>lval</em> e)</literallayout>
      <p>
        C's <progident>const</progident> notion of immutability-by-alias
        offers localized checking of immutability properties, and
        encourages good programming practice by serving as documentation
        of programmers intentions.  Other systems have proposed
        immutability-by-name&nbsp;<cite ref="DeLine2001Vault"/> (a
        simplified form of <progident>const</progident>), referential
        immutability&nbsp;<cite ref="tschantz2005javari"/>
        (immutability-by-reference that can be enforced shallowly or
        transitively) <foreignphrase>etc.</foreignphrase>, which have
        versatile applications. These techniques are orthogonal and
        complementary to the immutability-by-location property that we
        have in BitC. For example, we could have types like
        <progident>(const (mutable &tau;))</progident> that can express
        both global and local usage properties of a location.
      </p>
    </sect1>
    <sect1 id="copy_compat">
      <title>Copy Compatibility</title> 
      <p>
        Since BitC is a call-by-value language, it is desirable that we
        allow some freedom in the compatibility of types with respect to
        their mutability at argument passing, assignment, and binding
        boundaries.  We will refer to this as <term>copy
          compatibility</term>, denoted by &cong;. For example:
      </p>
      <literallayout>
(define (plus1 x:(mutable int32)) 
  (set! x (+ x 1)) x)       
<em>plus1: (fn (mutable int32) int32)</em>

(define v1 (plus1 10:int32))
<em>v1: int32</em></literallayout>
      <p indent="no">
        In the application <progident>(plus1 10:int32)</progident>
        above, the type of the actual parameter
        <progident>10</progident> is <progident>int32</progident> and
        that of the formal parameter <progident>x</progident> is
        <progident>(mutable&nbsp;int32)</progident>. Here, we allow
        <progident>int32</progident>&nbsp;&cong;&nbsp;<progident>(mutable&nbsp;int32)</progident>.
      </p>
      <p>
        Copy compatibility need not be restricted to the outermost
        mutability compatibility, but must not extend past a reference
        boundary. This is necessary to enforce the the invariant that
        every location must have a unique type, since the target of the
        reference is not copied. We define copy compatibility as
        follows:
      </p>
      <ul>
        <li>
          <p>
            &tau;&nbsp;&cong;&nbsp;(<progident>mutable</progident>&nbsp;&tau;) 
            for any type &tau; (direct compatibility).
          </p>
        </li>
        <li>
          <p>
            (<progident>array</progident>&nbsp;&tau;)&nbsp;&cong;&nbsp;(<progident>array</progident>&nbsp;(<progident>mutable</progident>&nbsp;&tau;)). 
            Arrays are unboxed types, the entire array is copied by
            value.
          </p>
        </li>
        <li>
          <p>
            (<progident>vector</progident>&nbsp;&tau;)&nbsp;&ncong;&nbsp;(<progident>vector</progident>&nbsp;(<progident>mutable</progident>&nbsp;&tau;))
          </p>
        </li>
        <li>
          <p>
            (<progident>ref</progident>&nbsp;&tau;)&nbsp;&ncong;&nbsp;(<progident>ref</progident>&nbsp;(<progident>mutable</progident>&nbsp;&tau;)).
          </p>
        </li>
        <li>
          <p>
            Compatibility of composites: Composite types are copy
            compatible if and only if all of their fields have equal
            types in the case of boxed types and copy compatible types
            in the case of unboxed types. In order to enforce this rule,
            the following restriction must be imposed for unboxed
            parametric types: instantiations of any type variable used
            within another reference type must match exactly. For
            example in the following structure:
          </p>
          <literallayout indent="no">
(defstruct (St 'a 'b):val f1:'a f2:(ref 'b))</literallayout>
          <p indent="no">
            instantiations of
            <progident>'a</progident> are only required to be copy
            compatible, but instantiations of
            <progident>'b</progident> must match exactly.
          </p>
          <literallayout indent="no">
(St char char) &cong; (St (mutable char) char)
(St char char) &ncong; (St char (mutable char))</literallayout>
        </li>
      </ul>
      <p>
        In addition to argument passing, and new variable bindings, we
        can also permit copy compatibility at argument and return
        position of all expressions that do not return an lvalue. This
        is because we can think of them in terms of equivalent SSA
        forms, which introduce temporary bindings for all intermediate
        results. For example, we can permit the various branches of
        conditional expressions to have to have different but copy
        compatible types:
      </p>
      <literallayout>
(if #t m:(mutable int32) 10:int32)</literallayout>
    </sect1>
    <sect1 id="expl-infer">
      <title>Type Inference</title>
      <p>
        When an exact type compatibility requirement is replaced in the
        language design by copy compatibility, it is no longer possible
        to infer a unique type for the expression. For example, in the
        following expression:
      </p>
      <literallayout>
(let ((p 10:int32)) ... )</literallayout>
      <p indent="no">
        we know that the type of the literal <progident>10</progident>
        is <progident>int32</progident>, but the type of
        <progident>p</progident> could either be
        <progident>int32</progident>, or
        <progident>(mutable&nbsp;int32)</progident>. When we cannot
        ascertain the mutability status of a bound identifier, we give
        it the so-called ``maybe'' type <progident>(?mutable?
          int32)</progident>, which is actually a shorthand for the
        constrained type 
        <btypes:TYPE> 
          <ctype> 
            <tvar name="alpha"/> 
            <set>
              <ceq> 
                <tvar name="alpha"/> 
                <int sz="32"/> 
              </ceq> 
            </set>
          </ctype> 
        </btypes:TYPE>.
        That is, it is undecided as to whether the actual type is
        <progident>int32</progident>, or
        <progident>(mutable&nbsp;int32)</progident>, and can be resolved
        by later unification. If it is not, a choice must eventually be
        fixed by the language definition.
        For example, the <progident>let</progident> form: 
      </p>
      <literallayout>
(let ((p (pair 1:int32 #t))) ... )</literallayout>
      <p indent="no">
        introduces copy compatibility at both the
        <progident>pair</progident> constructor application, and the
        formation of a new binding for <progident>p</progident>. The
        types assigned by the compiler are:
      </p>
      <literallayout>
<em>p:(?mutable? (pair (?mutable? int32) 
                   (?mutable? bool))</em></literallayout>
      <sect2>
        <title>Why Should We Infer Mutability?</title>
        <p>
          It is natural to ask why mutability should be inferred at all.
          That is: why not require explicit annotation for all mutable
          values, and infer immutable types by default? In an expression
          language with copy compatibility, inferring immutable types
          by default will result in a proliferation of type
          annotations. Constructor applications, 
          (polymorphic) type instantiations, accessor functions,
          <foreignphrase>etc.</foreignphrase> 
          will have to be explicitly annotated with their types. For
          example, if <progident>fst</progident> is an accessor that
          returns the first element of a pair and
          <progident>m</progident> is a variable with type
          <progident>(mutable bool)</progident>, we will have to write: 
        </p>
        <literallayout>
(define xyz 
  (vector (fst (pair m 10)
               :(pair (mutable bool) int32)))
  :(vector (mutable int32)))</literallayout>
        <p>
          Pierce and Turner have conducted a study on the impact of
          requiring explicit type annotations in higher order typed
          programming languages&nbsp;<cite ref="Pierce1998local"/>. Their
          measurements on about 1,60,000 lines of Objective Caml&nbsp;<cite
            ref="LeroyOcaml"/> code revealed that polymorphic type
          instantiations happen every third line of code, anonymous
          function definitions happen once in 10-100 lines of code and
          local bindings occur about once every twelve lines. Therefore,
          in BitC, not inferring mutability would make
          type inference a liability rather than an asset in the case of
          stateful programs.
        </p>
      </sect2>
      <sect2>
        <title>Incompleteness of Inference</title>
        <p>
          The key idea of maybe types is to defer commitments about the
          mutability status of types, and thus infer most-general 
          types wherever possible. BitC is a let-polymorphic
          language and enforces the value restriction&nbsp;<cite
            ref="wrightValRes1995"/>. This means that the decision about
          the mutability of types cannot be deferred past their let
          bindings, since mutable types must not be generalized. For
          example, in the case of the expression:
        </p>
        <literallayout>
(let ((p nil)) ... )</literallayout>
        <p indent="no">
          we cannot give <progident>p</progident> the type
        </p>
        <literallayout>
<em>(forall ('a) (?mutable? (list 'a)))</em></literallayout>
        <p>
          We must instead choose one of:
        </p>
        <literallayout>
<em>(forall ('a) (list 'a))</em> ; polymorphic
<em>(?mutable? (list 'a))</em>   ; monomorphic</literallayout>
        <p indent="no">
          That is, there is no principal type that we can infer for
          <progident>p</progident>. Given this, we must fix these maybe
          types to either mutable or immutable at a let-boundary. In the
          next section, we will identify various choices for how to fix
          these maybe types, and discuss their merits and limitations.
        </p>
        <p>
          In contrast, ML is able to infer principal types since its
          inference rules are purely syntax directed. In BitC, we trade
          completeness of inference to obtain a more expressive language
          without making any major changes to the core type system.
        </p>
      </sect2>
      <sect2 id="tradeoffs">
        <title>Inference Considerations</title>
        <p>
          In this section we outline certain design considerations
          for a type inference scheme in the presence of copy
          compatibility. An ideal scheme must not require excessive
          programmer annotations in the common case, and must be  
          capable of inferring all sound types at least when guided by
          explicit annotation.
        </p>
        <p>
          The problem with programmer annotations is pragmatic
          rather than ideological: we do not view programmer
          specification of types as bad <foreignphrase>per
            se</foreignphrase> (indeed, in certain places BitC
          requires annotations), but ease of prototyping
          requires that these annotations be minimized. As a matter of
          good programming ideology and interfacing with other static
          analysis or verification tools, the inferred types must not be
          promiscuous with respect to mutability.
        </p>
        <p>
          First, we consider how to solve the copy compatibility
          constraints introduced by the maybe types. One possibility is
          to fix all unresolved maybe types to immutable
          versions. For example: 
        </p>
        <literallayout>
(let ((p (pair n:(mutable int32) 
               (lambda (x) x)))) ...)
<em>p: (pair int32 (fn ('a) 'a))</em></literallayout>
        <p indent="no">
          This scheme will preserve all polymorphism possible, but will
          mandate a programmer annotation for every mutable location.
          The alternative would be to choose the mutable variants, in
          which case we will effectively have no polymorphism (by
          default). In the case of local definitions, we can collect
          more usage information and fix maybe-ness accordingly.
        </p>  
        <p>
          The previous section argued that we ``lose'' precision of
          inferred types (with respect to mutability) by the
          introduction of copy compatibility. We can think of this as a
          trade-off between freedom in type compatibility and precision
          of inference. Therefore, we can choose whether to (or not to)
          introduce copy compatibility at various constructs like new
          bindings, function application/return, constructors,
          conditional expressions, <foreignphrase>etc</foreignphrase>.
          Another dimension of trade-off is whether we permit copy
          compatibility to the maximum permissible limit (as defined in
          section&nbsp;<xref
            ref="copy_compat"/>), or restrict it to top-level shallow
          mutability compatibility only. A further option is to require
          that all polymorphism be contained within function types,
          since we can make function types polymorphic even if they
          abstract over mutable or maybe types.
        </p>
        <p>
          Unless handled with care, full use of copy compatibility can
          result in the inferred types that are counter-intuitive to the
          programmer. For example:
        </p>
        <literallayout>
(import ls bitc.list)
(define (list2vec lst)
  (make-vector (length lst) 
    (lambda (n) (ls.list-nth lst n))))</literallayout> 
        <p indent="no">
          For a na&iuml;ve reader, the type of
          <progident>list2vec</progident> appears to be
          <progident>(fn ((list 'a)) (vector 'a))</progident>, 
          but is actually the more general type:
        </p>
        <literallayout>
<em>(forall ((copy-compat 'a 'b)) 
            (fn ((list 'a)) (vector 'b)))</em></literallayout>
        <p indent="no">
          <progident>copy-compat</progident> is a special type class
          that relates two copy compatible types. Now, if we default
          maybe types that are ultimately unresolved to immutable, in
          the following definition we obtain:
        </p>
        <literallayout indent="no">
(define mVec (list2vec mLst:(list (mutable bool)))
<em>mVec: (vector bool)</em>  ;; !!!</literallayout>
        <p>
          which is a correct typing, but is most likely not what the
          programmer expects. In this case, even though the both the
          argument and return types of
          <progident>list2vec</progident> are reference types, they are
          only required to be copy compatible because
          <progident>list2vec</progident> copies the constituent
          elements, thereby using new locations.   
        </p>
      </sect2>
    </sect1>
    <sect1 id="proposal">
      <title>Type Inference in BitC</title>
      <p>
        Having identified the various issues and trade-offs involved in
        type inference, we now describe the particular design choices
        made in BitC for handling copy compatibility. This is by no
        means ``the'' solution to the problem, but reflects our judgment
        of the best way to capture the programmer's intuition about the
        flow of types in the language. It has been driven in part by our
        experience writing BitC programs. 
        In BitC, we allow copy compatibility to the full extent, up to a
        reference boundary. We allow copy compatibility to be invoked at
        arguments and return positions of all expressions that do not
        expect a location. 
      </p>
      <p>
        Every time we form a ``maybe'' type due to a copy operation, we
        remember the original type as a hint to resolve the copy
        compatibility constraints in the resultant type. At a let
        boundary, we resolve any unresolved compatibility constraints by
        unifying with this hint. Intuitively, this means that we will
        default maybe types to the types of their original copies,
        unless overridden by an explicit annotation. Here, we are
        approximating the user's intent to the lexical ``flow'' of type
        information. For example:
      </p>
      <literallayout>
(define mb:(mutable bool) #t))
<em>mb: (mutable bool)</em>

(define p (vector mb))
<em>p: (vector (mutable bool))</em>

(define q:(vector bool) (vector mb))
<em>q: (vector bool)</em></literallayout>
      <p>
        The type of <progident>p</progident> shows how maybe types are
        defaulted based on hint information, and the type of
        <progident>q</progident> shows how this can be overridden by
        programmer annotation. Since we default unresolved maybe-types
        to original ones the <progident>list2vec</progident> example
        described in section&nbsp;<xref ref="tradeoffs"/> now gets
        the more intuitive type:
      </p>
      <literallayout>
<em>list2vec: (fn ((list 'a)) (vector 'a))</em></literallayout>
      <p>
        In the case of locally defined identifiers, the top-most
        mutability is inferred by studying the syntactic usage of the
        identifier. That is, if the identifier is used as the target of
        a <progident>set!</progident>, it is given a shallowly mutable
        type. This is an <foreignphrase>ad hoc</foreignphrase> rule that
        tries to reduce the need for explicit type qualifications by the
        programmer in the common case (ex: iterators). However, this
        rule must not be invoked for top-level (global) definitions.
        Otherwise, inferred types will no longer be deterministic, as
        the top level definitions have unlimited scope.
      </p>
      <literallayout>
(define (fact x) (do ((ans 1 ans) 
		      (i x (- i 1)))
		     ((== i 0) ans)
		     (set! ans (* ans i))))</literallayout>
      <p>
        In the case of conflicting hints in the different branches of
        conditional expressions, we pick the most immutable of all
        hints. This ensures that inferred types are always
        deterministic. For example:
      </p>
      <literallayout>
(define boolPair 
  (if #t 
    (pair #t #f):((mutable bool), bool) 
    (pair #f #t):(bool, (mutable bool))))
<em>p: (bool, bool)</em></literallayout>
      <p>
        If there are any residual compatibility constraints even
        after unifying with hints, we resolve them to immutable
        variants.
      </p>    
      <p>
        Due to copy compatibility, two function types are <em>equal</em>
        regardless of the shallow mutability of the argument and return
        types. Therefore, we enforce a syntactic restriction that all
        function types must be written with immutable types at copy
        compatible positions. The intuition here is that type of a
        function must be described in the interface form (the external
        type), and must hide the ``internal'' mutability information.
      </p>
      <literallayout>
(define (f x) (set! x x))
Internal Type <em>f: (fn ((mutable 'a)) ())</em>
External Type <em>f: (fn ('a) ())</em></literallayout>
      <p indent="no">
        Even though function types must be written in external form, any
        type-qualifications on the arguments of a function within its
        body correspond to the internal types, and may contain mutable
        qualifications.
      </p>    
      <literallayout indent="no">
(define <em>abc:(fn ((mutable bool)) 'a) ...)</em> ;; ERROR
(define <em>(abc x:(mutable bool)) ... )</em>      ;; OK</literallayout>
      <p>
        This internal/external type notion is also important in the
        process of resolving copy compatibility constraints using
        hints. We should be sure that the internal types of a function
        do not influence the result type of applications, but the effect
        of arguments on the return types must be preserved. For example: 
      </p>
      <literallayout>
(define p:(mutable bool) #t)
(define (f x) p)  ;; <em>f: (fn ('a) bool)</em>
(define (g x) x)  ;; <em>g: (fn ('a) 'a)</em>

(define ff (f p)) ;; <em>ff: bool</em>
(define gg (g p)) ;; <em>gg: (mutable bool)</em></literallayout>
      <p>
        Further, two instances of a type class can co-exist only if all
        methods have different external signatures. For example:
      </p> 
      <literallayout indent="no">
(deftypeclass (TCL 'a 'b)
  mtd: (fn ('a (vector 'b)) 'a)))

(definstance (TCL bool bool) ...)
(definstance (TCL (mutable bool) bool) ..) ;CONFLICT!
(definstance (TCL bool (mutable bool)) ..) ;OK.</literallayout>
    </sect1>
  </chapter>
  <chapter>
    <title>Formalization</title>
    <sect1 id="language">
      <title>The Language</title>
      <p>
        In the interest of brevity, we will limit ourselves
        to the following core calculus:
      </p>
      <btypes:TYPE>
        <grammar>
          <bnf desc="Identifiers">
            <id/>
            <alternatives etc="yes">
              <id name="y"/>
              <id name="z"/>
            </alternatives>
          </bnf>
          <bnf desc="Stack Locations">
            <sLoc/>
            <alternatives etc="yes">
              <sLoc num="1"/>
              <sLoc num="2"/>
            </alternatives>
          </bnf>
          <bnf desc="Heap Locations">
            <hLoc/>
            <alternatives etc="yes">
              <hLoc num="1"/>
              <hLoc num="2"/>
            </alternatives>
          </bnf>
          <bnf desc="Values">
            <aVal/>
            <alternatives>
              <Unit/>
              <true/>
              <false/>
              <hLoc/>
              <lambda>
                <id/>
                <aExpr/>
              </lambda>
              <!-- <Pair>
              <aVal/>
              <aVal/>
            </Pair> -->
            </alternatives>
          </bnf>
          <bnf desc="lvalues">
            <lVal/>
            <alternatives>
              <sLoc/>
              <deref>
                <hLoc/>
              </deref>
            </alternatives>
          </bnf>
          <bnf desc="Expressions">
            <aExpr/>
            <alternatives>
              <aVal/>
              <apply>
                <aExpr/>
                <aExpr/>
              </apply>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
              <assign>
                <aExpr/>
                <aExpr/>
              </assign> 
              <let kind="k">
                <tqExpr optional="yes">
                  <id/>
                  <type/>
                </tqExpr>
                <aExpr/>
                <aExpr/>
              </let>
            </alternatives>
          </bnf>
          <bnfc desc="">
            <alternatives>
              <dup>
                <aExpr/>
              </dup>
              <deref>
                <aExpr/>
              </deref>
              <if>
                <aExpr/>
                <aExpr/>
                <aExpr/>
              </if>
              <!-- <Pair>
              <aExpr/>
              <aExpr/>
            </Pair>
              <fst>
              <aExpr/>
            </fst>
              <snd>
              <aExpr/>
            </snd> -->
            </alternatives>
          </bnfc>
          <bnf desc="Let-kinds">
            <symbol name="kappa"/>
            <alternatives>
              <text content="-"/>
              <symbol name="alpha"/>
              <symbol name="psi"/>
              <symbol name="forall"/>
            </alternatives>
          </bnf>
        </grammar>
      </btypes:TYPE>
      <p>
        All syntactic forms introduced in this
        document can be parenthesized without change in meaning.
        An optional qualification is provided on the identifier defined
        in a <progident>let</progident> expression since the same effect
        cannot be obtained by qualifying the defining expression (due to
        copy compatibility). The let-kind ``-'' is a placeholder for the
        unkinded <progident>let</progident> form.
      </p>
    </sect1>
    <sect1 id="opsem">
      <title>Dynamic Semantics</title>
      <btypes:TYPE>
        <grammar>
          <bnf desc="Stack">
            <stack/>
            <alternatives>
              <Empty/>
              <extend>
                <stack/>
                <mapping>
                  <sLoc/>
                  <aVal/>
                </mapping>
              </extend>
            </alternatives>
          </bnf>
          <bnf desc="Heap">
            <heap/>
            <alternatives>
              <Empty/>
              <extend>
                <heap/>
                <mapping>
                  <hLoc/>
                  <aVal/>
                </mapping>
              </extend>
            </alternatives>
          </bnf>
        </grammar>
      </btypes:TYPE>
      <p>
        The system state is represented by the triple 
        <btypes:TYPE>
          <opState>
            <stack/>
            <heap/>
            <aExpr/>
          </opState>
        </btypes:TYPE>
        consisting of the stack, the heap, and the expression to be
        evaluated. Evaluation itself is a two place relationship   
        <btypes:TYPE>
          <eval>
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
          </eval>
        </btypes:TYPE>
        that denotes transformation in the system state due to a single
        step of execution.
      </p>
      <xi:include href="include/formal/opsem.xmli"/>
      <p>
        Table&nbsp;<xref ref="dyn_sem"/> shows the evaluation
        rules for our core language. Following the theoretical
        development in&nbsp;<cites>
          <cite ref="Grossman2006qtypes"/>
          <cite ref="Grossman2003dissertation"/>
        </cites>, we give separate execution semantics for left and
        right execution (evaluation of expressions that appear on the LHS and RHS
        of an assignment 
        <btypes:TYPE>
          <assign>
            <aExpr num="l"/>
            <aExpr num="r"/>
          </assign>
        </btypes:TYPE>) denoted by 
        <btypes:TYPE><levalOp/></btypes:TYPE> and 
        <btypes:TYPE><evalOp/></btypes:TYPE> respectively. 
      </p>
      <p>
        In the above operational semantics rules, a distinction is
        made between the stack and the heap in order to ensure that we
        can only capture references to heap cells (E-DUP,
        E-LEFT-DEREF, and E-DEREF work only on the heap).  The heap
        locations are first class values but stack locations are not.
        Therefore stack locations cannot escape beyond their scope
        (although the bindings themselves are not removed from the
        stack, in the interest of of simplicity). E-RVAL represents
        implicit value extraction for stack locations. State updates
        can be performed either on the stack or on the heap
        (E-SET-STACK and E-SET-HEAP). We assume that the program is
        alpha-converted so that there are no name collisions due to
        inner bindings. We do not model garbage collection, and assume
        an infinite supply of stack and heap cells.
      </p>
      <p>
        We cannot give <em>one</em> correct execution semantics for the
        (unkinded) expression: 
        <btypes:TYPE> 
          <let> 
            <id/> 
            <aVal/> 
            <aExpr/>
          </let> 
        </btypes:TYPE>, since
        there is not enough syntactic support to determine whether
        <btypes:TYPE> 
          <id/> 
        </btypes:TYPE> is a (mutable) location or a polymorphic
        immutable term. The correct step to take is always clear from
        static type information. We must take the LET-M path for all
        mutable definitions, and the LET-P path for all polymorphic
        definitions. For immutable non-polymorphic definitions, either
        step will work, but we always choose LET-M. 
      </p>
      <p>
        Therefore, we make a distinction among two ``kinds'' of  
        <progident>let</progident> definitions as:
        <btypes:TYPE>
          <let kind="m"/>
        </btypes:TYPE>
        (monomorphic, possibly mutable definition)
        and 
        <btypes:TYPE>
          <let kind="p"/>
        </btypes:TYPE>
        (polymorphic definition).
        The non-polymorphic version of let is shown as 
        <btypes:TYPE>
          <let kind="m"/>
        </btypes:TYPE>
        and not 
        <btypes:TYPE>
          <let kind="M"/>
        </btypes:TYPE>
        because an immutable monomorphic/concrete definition is also
        defined using this construct.
        Now, we give separate execution semantics for each of there
        <progident>let</progident> forms.
        Since the type rules only derive a type for the correct kinds of
        <progident>let</progident> in each case, execution of typed
        expressions is always expected to take the correct path.
      </p>
      <p>
        We use 
        <btypes:TYPE>
          <let kind="a"/>
        </btypes:TYPE> to range over 
        <btypes:TYPE>
          <let kind="m"/>
        </btypes:TYPE> and
        <btypes:TYPE>
          <let kind="p"/>
        </btypes:TYPE>.
        and will still use the unkinded term 
        <btypes:TYPE>
          <let/>
        </btypes:TYPE>, when either version is (equally)
        applicable. Note that 
        <btypes:TYPE>
          <let/>
        </btypes:TYPE>
        is different from 
        <btypes:TYPE>
          <let kind="a"/>
        </btypes:TYPE> because two occurrences of 
        <btypes:TYPE>
          <let kind="a"/>
        </btypes:TYPE> in the same context correspond to the same kind,
        whereas two occurrences of 
        <btypes:TYPE>
          <let/>
        </btypes:TYPE> need not match the same kind.
      </p>      
    </sect1>
  <pagebreak/>
  <sect1 id="static_sem">
    <title>Static Semantics</title>
    <btypes:TYPE>
      <grammar>
	<bnf desc="Types">
	  <type/>
	  <alternatives>
	    <tvar name="alpha"/>
	    <unit/>
	    <bool/>
	    <fn><type/><type/></fn>                  
	  </alternatives>                
	</bnf>
	<bnfc desc="ref / pointer">
	  <alternatives>
	    <ref><type/></ref>
	  </alternatives>
	</bnfc>
	<bnfc desc="Mutable type">
	  <alternatives>
	    <mutable><type/></mutable>
	  </alternatives>
	</bnfc>
	<bnf desc="Type Scheme">
	  <aTS/>
	  <alternatives>
	    <type/>
	    <forall>                    
	      <tvar name="alpha"/>
	      <aTS/>
	    </forall>
	  </alternatives>
	</bnf>
	<bnf desc="Binding Environment">
	  <gamma/>
	  <alternatives>
	    <Empty/>
	    <extend>
	      <gamma/>
	      <mapping>
		<id/>
		<aTS/>
	      </mapping>
	    </extend>
	  </alternatives>
	</bnf>
	<bnf desc="Store Typing">
	  <store/>
	  <alternatives>
	    <Empty/>
	    <extend>
	      <store/>
	      <mapping>
		<hLoc/>
		<type/>
	      </mapping>
	    </extend>
	    <extend>
	      <store/>
	      <mapping>
		<sLoc/>
		<type/>
	      </mapping>
	    </extend>
	  </alternatives>
	</bnf>
	<bnf desc="Logical Relations">
	  <LOGIC/>
	  <alternatives>
	    <TRUE/>
	    <FALSE/>
	    <AND>
	      <LOGIC/>
	      <LOGIC/>
	    </AND>
	    <OR>
	      <LOGIC/>
	      <LOGIC/>
	    </OR>
	    <NOT>
	      <LOGIC/>
	    </NOT>
	    <pred name="Predicate">
	      <plural>
		<LOGIC/>
	      </plural>
	    </pred>
	  </alternatives>
	</bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      A substitution is of Z for Y in X is written using the standard
      notation:
      <btypes:TYPE>
	<subst>
	  <text content="X"/>
	  <text content="Y"/>
	  <text content="Z"/>          
	</subst>
      </btypes:TYPE>.
      Substitutions within a type up to a ref boundary are written as:
      <btypes:TYPE>
	<Csubst>
	  <type/>
	  <text content="Y"/>
	  <text content="Z"/>          
	</Csubst>
      </btypes:TYPE>.
    </p>    
    <sect2 id="copy_sem">      
      <title>Copy Compatibility</title>
      <p>
        Compatibility of types that differ in shallow mutability at
        copy boundaries is called copy compatibility <cite
          ref="sridharmutinfer2006"/>, denoted by
        <btypes:TYPE><ceqOp/></btypes:TYPE>, and is defined as:
      </p>
      <example>        
        <p>
          <btypes:TYPE>
            <ceq>                
              <type/>
              <type/>
            </ceq>
            <br/>
            <ceq>                
              <mutable><type/></mutable>
              <type/>
            </ceq>
          </btypes:TYPE> 
        </p>
      </example>      
      <p>
        In our algebra of types, we have the equation 
        <btypes:TYPE>
          <equiv>
            <mutable>
              <mutable>
                <type/>
              </mutable>
            </mutable>
            <mutable>
              <type/>
            </mutable>
          </equiv>
        </btypes:TYPE>.
      </p>
      <p> We also define the operators
        <btypes:TYPE><maxzOp/></btypes:TYPE> and
        <btypes:TYPE><minzOp/></btypes:TYPE> that increase or
        decrease the mutability of a type, defined as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <eq>                
              <maxz>
                <mutable>
                  <type/>
                </mutable>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            <text content="  and  "/>
            <eq> 
              <maxz>
                <type/>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            `<text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
	    <br/>
            <eq>                
              <minz>
                <mutable>
                  <type/>
                </mutable>
              </minz>
              <type/>
            </eq>
            <text content="  and  "/>
            <eq> 
              <minz>
                <type/>
              </minz>
              <type/>
            </eq>
            <text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
          </btypes:TYPE> 
        </p>
      </example>
      <p>
        It is obvious that 
        <btypes:TYPE>
          <forall>
            <type/>
            <ceq> 
              <minz>
                <type/>
              </minz>
              <type/>
              <maxz>
                <type/>
              </maxz>
            </ceq>
          </forall>
          <text content=", and "/>
          <forall>
            <type/>
            <type dash="'"/>
            <iff>
              <ceq> 
                <type/>
                <type dash="'"/>
              </ceq>
              <eq>
                <minz>
                  <type/>
                </minz>
                <minz>
                  <type dash="'"/>
                </minz>
              </eq>
              <eq>
                <maxz>
                  <type/>
                </maxz>
                <maxz>
                  <type dash="'"/>
                </maxz>
              </eq>                
            </iff>
          </forall>          
          <text content="."/>
        </btypes:TYPE>
      </p>
    </sect2>
    <sect2 id="metaCT">
      <title>Compatibility of Function Types</title>
      <p>
        Two function types are <em>equal</em> regardless of the
        shallow mutability of the argument and 
        return types <cite ref="sridharmutinfer2006"/>. 
        
        Due to copy compatibility, two function types are equivalent in
        all respects regardless of the (shallow) mutability of the
        argument and return positions.

        Therefore we always write all function types in the following
        normalized form:<footnote>
          <p>
            Of course, types are not displayed in this form to the user.
            Function types are always printed in ``interface form,''
            which does not expose the ``internal'' mutability of
            argument or return types <cite
              ref="sridharmutinfer2006"/>. 
          </p>
        </footnote>
      </p>
      <ol>
        <li>
          <p>
            The (contravariant) argument type is written in the
            maximally immutable form (devoid of shallow mutability). 
          </p>
        </li>
        <li>
          <p>
            The (covariant) return type is written in the
            maximally mutable form.
          </p>
        </li>
      </ol>
      <p>
        This ensures that the ``external'' type of a function is
        maximally permissive with respect to  mutability. 
        However, during type inference, if we infer the type
        <btypes:TYPE>
          <fn>
            <minz>
              <type num="arg"/>
            </minz>
            <maxz>
              <type num="ret"/>
            </maxz>            
          </fn>
        </btypes:TYPE>
        as the external type of a function, this normalization can
        later get violated due to substitution of type-variables. 
        Therefore, we define the 
        <btypes:TYPE>
          <floor>
            <type/>
          </floor>
        </btypes:TYPE> and 
        <btypes:TYPE>
          <ceil>
            <type/>
          </ceil>
        </btypes:TYPE> ``meta-constructors''
        which (respectively)  minimize and maximize the mutability of
        a type, but are interpreted lazily. 
      </p>
      <p>
        We also define (and implicitly use) the following
        equivalences in the algebra of types:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <equiv>
              <floor>
                <type/>
              </floor>
              <minz>
                <type/>
              </minz>              
            </equiv>
            <text content=" (lazily)"/>
            <br/>
            <equiv>
              <ceil>
                <type/>
              </ceil>
              <maxz>
                <type/>
              </maxz>              
            </equiv>
            <text content=" (lazily)"/>
          </btypes:TYPE>          
        </p>
      </example>
    </sect2>
    <sect2 id="copy_coercions">
      <title>Copy Coercions</title>
      <xi:include href="include/formal/subtype.xmli"/>
      <p>
        Table&nbsp;<xref ref="sub_rules"/> shows how we can obtain
	copy compatibility by copy coercions (similar to subtyping).
	We can now define copy compatibility as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <equiv>
              <ceq>
                <type num="1"/>
                <type num="2"/>
              </ceq>
              <Tsub>
                <type num="1"/>
                <minz>
                  <type num="2"/>
                </minz>
              </Tsub>
            </equiv>              
          </btypes:TYPE>
        </p>
      </example>
      <p>
	The TS-REF rule ensures that copy compatibility does not
	extend beyond a ref-boundary. Since two function types are
	equivalent in all respects regardless of the (shallow)
	mutability of the argument and return positions, we will write
	all function types in normalized form.  The (contravariant)
	argument type is written in the maximally immutable form
	(devoid of shallow mutability), and the (covariant) return
	type is written in the maximally mutable form.  This ensures
	that the ``outer'' type of a function is maximally permissive
	with respect to mutability. The TS-FN rule therefore is
	invariant in terms of its arguments and return types.
      </p>
      <p>
        We will also write 
        <btypes:TYPE>
          <TDjudge sub="yes">
            <aExpr/>                  
            <type/>                  
          </TDjudge>
        </btypes:TYPE> as a shorthand for:
        <btypes:TYPE>
          <TDjudge>
            <aExpr/>                  
            <type dash="'"/>                  
          </TDjudge>
          <text content=", "/>
          <Tsub>
            <type dash="'"/>
            <type/>
          </Tsub>
        </btypes:TYPE>.
      </p>
      <sect3>
        <title>Problem with Subsumption-like Coercion Rule</title>
        <p>
          In BitC, explicit qualifications are a statement of absolute
          typing and not type compatibility. Preserving this rule,
          requires that we must not have generic subsumption like
          rules for copy coercion. That is, if we have the following
          subsumption like rules:
        </p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule name="TW-TQEXPR (WRONG)">
	      <tyPre>
		<TDjudge>
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <paren>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>  
		  </paren>        
		  <type/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	    <tyRule name="TW-SUB">
	      <tyPre>
		<TDjudge>
		  <aExpr/>                  
		  <type dash="'"/>
		</TDjudge>                
		<Tsub>
		  <type dash="'"/>
		  <type/>
		</Tsub>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
        <p indent="no">
          We can then write:
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <let>
                <id name="x"/>
                <Unit/>
                <if>
                  <true/>
                  <tqExpr>
                    <id name="x"/>
                    <unit/>
                  </tqExpr>
                  <assign>
                    <id name="x"/>
                    <Unit/>
                  </assign>
                </if>
              </let>
            </btypes:TYPE>
          </p>
        </example>    
        <p indent="no">
          Here, in the <progident>else</progident> branch of
          <progident>if</progident>, we can derive the typing
          <btypes:TYPE>
            <tqExpr>
              <id/>
              <mutable>
                <unit/>
              </mutable>
            </tqExpr>
          </btypes:TYPE>
          and in the <progident>then</progident>, through subsumption
          also obtain
          <btypes:TYPE>
            <tqExpr>
              <id/>              
              <unit/>              
            </tqExpr>
          </btypes:TYPE>, which violates our absolute-compatibility at
          qualification rule.
        </p>
        <p>
          Therefore, we will not introduce this rule, but instead
          introduce copy coercion operations at all copy compatible
          positions in the type rules.
        </p>
      </sect3>
    </sect2>
    <sect2 id="lval">
      <title>Location Semantics</title>
      <p>
        The lvalue rules shown in Table&nbsp;<xref ref="lval_rules"/>
        ensure that only those expressions 
        permitted by location semantics&nbsp;<cites>
          <cite ref="shapBitcSpec2006"/>
          <cite ref="sridharmutinfer2006"/>
        </cites> appear on the left hand side of an 
        assignment expression.
      </p>
      <xi:include href="include/formal/locsem.xmli"/>
    </sect2>
    <sect2>      
      <title>Declarative Type Rules</title>
      <xi:include href="include/formal/decl.xmli"/>
      <p>
	Declarative Type rules are given in 
	Table&nbsp;<xref ref="decl_type_rules"/>.
	The standard type judgment 
	<btypes:TYPE>
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</btypes:TYPE> is understood as: given a binding environment 
	<btypes:TYPE>
	  <gamma/>
	</btypes:TYPE> and store typing
	<btypes:TYPE>
	  <store/>
	</btypes:TYPE> the expression
	<btypes:TYPE>
	  <aExpr/>
	</btypes:TYPE> has type
	<btypes:TYPE>
	  <type/>
	</btypes:TYPE>. We write 
	<btypes:TYPE>
	  <Tsub>
	    <aExpr/>                  
	    <type/>                  
	  </Tsub>
	</btypes:TYPE> as a shorthand for:
	<btypes:TYPE>
	  <tqExpr>
	    <aExpr/>                  
	    <type dash="'"/>                  
	  </tqExpr>
	  <text content=", "/>
	  <Tsub>
	    <type dash="'"/>
	    <type/>
	  </Tsub>
	</btypes:TYPE>, for some type
	<btypes:TYPE>
	  <type dash="'"/>                  
	</btypes:TYPE>.
	In the type rules, we introduce copy coercions at
	all positions where copy compatibility is applicable.
        Type generalization at a
	<progident>let</progident> is decided by the judgment 
	<btypes:TYPE>
	  <judgeOp name="gen"/>
	</btypes:TYPE>.
      </p>
    </sect2>
    <sect2 id="gen">
      <title>Generalization</title>
      <p>
        This section uses the ``full'' value restriction as proposed
        by Wright <cite ref="wrightValRes1995"/>. Relaxations to
        this rule based on Garriague's scheme <cite
          ref="garrigueValRes2004"/> were proposed in <cite
          ref="sridharmutinfer2006"/>. Those rules must be
        incorporated at a later stage.
      </p>
      <!-- <p>
      We also define a ordering 
      <btypes:TYPE>          
      <spEqOp/>
    </btypes:TYPE> on types and type schemes that decides whether
      a type (or type scheme) is more specific than another.      
    </p>
      <btypes:TYPE>          
      <Hrules>
      <tyRule>
      <tyPre>
      <notin>
      <tvars name="beta"/>
      <ftvs>
      <forall>
      <tvars name="alpha"/>
      <type/>
    </forall>
    </ftvs>
    </notin>              
    </tyPre>
      <tyConc>
      <spEq>
      <forall>
      <tvars name="alpha"/>
      <type/>
    </forall>
      <forall>
      <tvars name="beta"/>
      <subst>
      <type/>
      <tvars name="alpha"/>
      <type dash="'"/>
    </subst>
    </forall>
    </spEq>
    </tyConc>
    </tyRule>
    </Hrules>
    </btypes:TYPE> -->
      <xi:include href="include/formal/gen.xmli"/>
      <p>
        The type generalization rules are shown in Table&nbsp;<xref
          ref="gen_rules"/>. The rule G-VALUE-PF is not actually used
        for typing user programs, but is only necessary to prove
        preservation of types. 
      </p>
      <sect3 id="ftvs">
        <title>DEFINITION: Free Type Variables</title>
        <p>
          We denote the set of free type variables in a type
          <btypes:TYPE><type/></btypes:TYPE> as
          <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>. 
        </p>
        <example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<ftvs>
		  <tvar name="alpha"/>
		</ftvs>
		<tvar name="alpha"/>                
	      </eq>
	      <br/>
	      <eq>
		<ftvs>
		  <unit/>
		</ftvs>
		<empty/>                
	      </eq>
	      <br/>
	      <eq>
		<ftvs>
		  <bool/>
		</ftvs>
		<empty/>                
	      </eq>
	      <br/>
	      <eq>
		<ftvs>
		  <ref>
		    <type/>
		  </ref>
		</ftvs>
		<ftvs>                  
		  <type/>                  
		</ftvs>
	      </eq>              
	      <br/>
	      <eq>
		<ftvs>
		  <mutable>
		    <type/>
		  </mutable>
		</ftvs>
		<ftvs>                  
		  <type/>                  
		</ftvs>
	      </eq>          
	      <br/>
	      <eq>
		<ftvs>
		  <fn>
		    <type num="1"/>
		    <type num="2"/>
		  </fn>
		</ftvs>                                  
		<unin>
		  <ftvs>
		    <type num="1"/>
		  </ftvs>                    
		  <ftvs>
		    <type num="2"/>
		  </ftvs>                    
		</unin>                
	      </eq>          
	      <br/>
	      <text content="We also write:"/>              
	      <br/>
	      <eq>
		<ftvs>
		  <types/>
		</ftvs>
		<Unin>
		  <ftvs>
		    <type/>
		  </ftvs>
		</Unin>
	      </eq>
	      <br/>
	      <eq>
		<ftvs>
		  <aTS/>
		</ftvs>
		<unin>
		  <ftvs>
		    <tvars name="alpha"/>
		  </ftvs>
		  <ftvs>
		    <type/>
		  </ftvs>                  
		</unin>
	      </eq>
	      <text content=" where "/>
	      <eq>
		<aTS/>
		<forall>
		  <tvars name="alpha"/>
		  <type/>
		</forall>
	      </eq>              
	      <br/>
	      <eq>
		<ftvs>
		  <gamma/>
		</ftvs>
		<Unin>
		  <ftvs>
		    <aTS/>
		  </ftvs>
		</Unin>                  
	      </eq>
	      <text content=" forall "/>
	      <in>
		<tqExpr>
		  <id/>
		  <aTS/>
		</tqExpr>
		<gamma/>
	      </in>
	      <br/>
	      <eq>
		<ftvs>
		  <store/>
		</ftvs>
		<Unin>
		  <ftvs>
		    <type/>
		  </ftvs>
		</Unin>                  
	      </eq> 
	      <text content=" forall "/>
	      <in>
		<tqExpr>
		  <hLoc/>
		  <type/>
		</tqExpr>
		<store/>
	      </in>
	      <text content=" or "/>
	      <in>
		<tqExpr>
		  <sLoc/>
		  <type/>
		</tqExpr>
		<store/>
	      </in>
	      
	      <br/>
	      <eq>
		<ftvs>
		  <aCtset/>
		</ftvs>
		<Unin>
		  <ftvs>
		    <type/>
		  </ftvs>
		</Unin>
	      </eq>
	      <text content=" where "/>
	      <aCtset/>
	      <text content=" is a set of constraints, and "/>
	      <type/>
	      <text content=" is a type involved "/>
	      <text content=" in any constituent constraint."/>
	      <br/>
	    </btypes:TYPE>
	    FTVS(<em>X</em>, <em>Y</em>, ... ) = FTVS(<em>X</em>)   
	    <btypes:TYPE><uninOp/></btypes:TYPE>
	    FTVS(<em>Y</em>)
	    <btypes:TYPE><uninOp/></btypes:TYPE>
	    ..., where <em>X</em>, <em>Y</em>, ... are any of the
	    above permissible arguments.
	  </p>
	</example>
      </sect3>
      <sect3 id="val_res">
        <title>DEFINITION: Value Restriction</title>
	<example>
	  <p>
	    <btypes:TYPE>
	      <fnxn name="Value">
		<aVal/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<id/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<hLoc/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<sLoc/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
		<pred name="Value">
		  <aExpr/>
		</pred>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<dup>
		  <aExpr/>
		</dup>
		<pred name="Value">
		  <aExpr/>
		</pred>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<deref>
		  <aExpr/>
		</deref>
		<pred name="Value">
		  <aExpr/>
		</pred>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<if>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		  <aExpr num="3"/>
		</if>
		<AND>
		  <pred name="Value">
		    <aExpr num="1"/>
		  </pred>
		  <pred name="Value">
		    <aExpr num="2"/>
		  </pred>
		  <pred name="Value">
		    <aExpr num="3"/>
		  </pred>
		</AND>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<let>
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
		<AND>
		  <pred name="Value">
		    <aExpr num="1"/>
		  </pred>
		  <pred name="Value">
		    <aExpr num="2"/>
		  </pred>
		</AND>
	      </fnxn>
	      <br/>
	      <fnxn name="Value">
		<aExpr/>
		<FALSE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<unit/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<bool/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<tvar name="alpha"/>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
		<TRUE/>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<ref>
		  <type/>
		</ref>                
		<pred name="Immut">
		  <type/>
		</pred>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<forall>
		  <tvars name="alpha"/>
		  <type/>
		</forall>
		<pred name="Immut">                
		  <type/>
		</pred>
	      </fnxn>
	      <br/>
	      <fnxn name="Immut">
		<type/>
		<FALSE/>
	      </fnxn>
	    </btypes:TYPE>
	  </p>
	</example>
      </sect3>
    </sect2>
    <sect2>
      <title>Soundness of Declarative system</title>
      <sect3>
	<title>DEFINITION: Stack and Heap Typing</title>
	<p>
	  A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
	  <btypes:TYPE><stack/></btypes:TYPE> are said to be
	  <em>well typed</em> with respect to a binding context 
	  <btypes:TYPE><gamma/></btypes:TYPE> and store typing
	  <btypes:TYPE><store/></btypes:TYPE>, and written 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	    <text content=" if "/>
	  </btypes:TYPE>
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <dom><store/></dom>
		  <unin>
		    <dom><heap/></dom>
		    <dom><stack/></dom>
		  </unin>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<forall>
		  <in>
		    <hLoc/>
		    <dom><heap/></dom>
		  </in>
		</forall>
		<text content=", "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <Tsub>
		    <mapsto><heap/><hLoc/></mapsto>
		    <mapsto><store/><hLoc/></mapsto>
		  </Tsub>
		</Sjudge>            
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<forall>
		  <in>
		    <sLoc/>
		    <dom><stack/></dom>
		  </in>
		</forall>
		<text content=", "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <Tsub>
		    <mapsto><stack/><sLoc/></mapsto>
		    <mapsto><store/><sLoc/></mapsto>
		  </Tsub>
		</Sjudge>            
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
      </sect3>      
      <!-- <sect3 id="rexec">
      <title>DEFINITION: Correct Right execution</title>
      <p>
      We define a right evaluation
      operation  
      <btypes:TYPE> 
      <eval>
      <opState>
      <stack/>
      <heap/>
      <aExpr/>
    </opState>
      <opState>
      <stack dash="'"/>
      <heap dash="'"/>
      <aExpr dash="'"/>
    </opState>
    </eval>
    </btypes:TYPE> that is parametrized over the pair 
      <btypes:TYPE> 
      <eq>
      <text content="r"/>
      <collection paren="yes">
      <gamma/>
      <store/>
    </collection>
    </eq> 
    </btypes:TYPE>. The semantics of           
      <btypes:TYPE> 
      <evalOp/>
    </btypes:TYPE> are similar to that of 
      <btypes:TYPE> 
      <evalOp/>
    </btypes:TYPE> but has the additional constraint that
      when 
      <btypes:TYPE> 
      <eq>
      <aExpr/>
      <let>              
      <id/>
      <aVal num="1"/>
      <aExpr num="2"/>
    </let>              
    </eq>
      <text content=", "/>
      <TDjudge sub="yes">
      <aExpr
      num="1"/>
      <type num="1"/>
    </TDjudge>
      <text content=", "/>
      <Tsub>
      <type/>
      <type
      num="1"/>
    </Tsub>
      <text content=" and "/>
      <Sjudge name="gen">
      <assume>
      <gamma/>
      <store/>
      <aExpr num="1"/>
    </assume>
      <GEN>
      <type/>
      <aTS/>
    </GEN>
    </Sjudge>
    </btypes:TYPE>,
      <btypes:TYPE> 
      <tqExpr>
      <id/>
      <aTS/>
    </tqExpr>
    </btypes:TYPE>,          
      it must take the LET-P step when 
      <btypes:TYPE> 
      <eq>
      <aTS/>
      <forall>
      <tvars name="alpha"/>
      <type/>
    </forall>
    </eq>
    </btypes:TYPE>
      and the LET-M path when
      <btypes:TYPE> 
      <eq>
      <aTS/>
      <type/>
    </eq>
    </btypes:TYPE>.
    </p>
    </sect3> -->
      <sect3 id="T-inversion">
        <title>LEMMA: Inversion of Typing Relation</title>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <Unit/>
                  <type/>
                </TDjudge>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <unit/>
                </eq>
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <true/>
                  <type/>
                </TDjudge>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <bool/>
                </eq>
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <false/>
                  <type/>
                </TDjudge>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <bool/>
                </eq>
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <hLoc/>
                  <type/>
                </TDjudge>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <ref>
                    <type dash="'"/>
                  </ref>
                </eq>
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <lambda>
                    <id/>
                    <aExpr/>
                  </lambda>
                  <type/>
                </TDjudge>
                <text content=" then "/>
                <eq>
                  <type/>
                  <fn>
                    <type num="1" dash="'"/>
                    <type num="2" dash="'"/>
                  </fn>
                </eq>
                <text content=" such that "/>
                <eq>
                  <type num="1" dash="'"/>
                  <minz>
                    <type num="1"/>
                  </minz>
                </eq>
                <text content=", "/>
                <eq>
                  <type num="2" dash="'"/>
                  <maxz>
                    <type num="2"/>
                  </maxz>
                </eq>
                <text content=", and, "/>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>                        
                        <type num="1"/>                        
                      </mapping>
                    </extend>
                    <store/>
                  </assume>                  
                  <tqExpr>
                    <aExpr/>                    
                    <type num="2"/>                    
                  </tqExpr>            
                </Sjudge>
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li> 
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <TDjudge>
                  <deref>
                    <aExpr/>
                  </deref>
                  <type/>
                </TDjudge>
                <text content=" then "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <Tsub>
                    <aExpr/>                      
                    <type dash="'"/>
                  </Tsub>                    
                </Sjudge>                  
                <text content="."/>                
              </btypes:TYPE>
            </p>
          </li>          
          <li>
            <p>
              Other cases are similar.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> Immediate from the definition of
          typing relation.
        </p>
      </sect3>
      <sect3 id="T-sub-inversion">
        <title>LEMMA: Inversion of Copy Coercion</title>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <bool/>
                </Tsub>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <bool/>
                </eq>
                <text content=" or "/>                
                <eq>
                  <type/>
                  <mutable>
                    <bool/>
                  </mutable>
                </eq>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <unit/>
                </Tsub>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <unit/>
                </eq>
                <text content=" or "/>                
                <eq>
                  <type/>
                  <mutable>
                    <bool/>
                  </mutable>
                </eq>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </Tsub>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>                  
                </eq>
                <text content=" or "/>
                <eq>
                  <type/>
                  <mutable>
                    <fn>
                      <type num="1"/>
                      <type num="2"/>
                    </fn>     
                  </mutable>             
                </eq>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <ref>
                    <type dash="'"/>
                  </ref>
                </Tsub>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <ref>
                    <type dash="'"/>
                  </ref>                  
                </eq>
                <text content=" or "/>
                <eq>
                  <type/>
                  <mutable>
                    <ref>
                      <type dash="'"/>
                    </ref>                  
                  </mutable>             
                </eq>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <mutable>
                    <type dash="'"/>
                  </mutable>
                </Tsub>
                <text content=" then "/>                
                <eq>
                  <type/>
                  <mutable>
                    <type dash="''"/>
                  </mutable>
                </eq>
                <text content=" such that "/>                
                <Tsub>
                  <type dash="''"/>
                  <type dash="'"/>                  
                </Tsub>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/> 
                <Tsub>
                  <type/>
                  <mutable>
                    <type dash="'"/>
                  </mutable>
                </Tsub>
                <text content=" then "/>                
                <Tsub>
                  <type/>
                  <type dash="'"/>
                </Tsub>
                <text content="."/>                                
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> By induction on the 
          copy coercion derivation. 
        </p>
      </sect3>
      <sect3 id="T-canonical">
        <title>LEMMA: Canonical Forms</title>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <aVal/>
                <text content=" is a value, and "/>                
                <TDjudge sub="yes">
                  <aVal/>
                  <unit/>
                </TDjudge>
                <text content=", then, "/>
                <aVal/>
                <text content=" is "/>
                <Unit/>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <aVal/>
                <text content=" is a value, and "/>
                <TDjudge sub="yes">
                  <aVal/>
                  <bool/>
                </TDjudge>
                <text content=", then, "/>
                <aVal/>
                <text content=" is either "/>
                <true/>
                <text content=" or "/>
                <false/>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <aVal/>
                <text content=" is a value, and "/>
                <TDjudge sub="yes">
                  <aVal/>
                  <ref><type/></ref>
                </TDjudge>
                <text content=", then, "/>
                <aVal/>
                <text content=" is "/>
                <hLoc/>
                <text content=", "/>
                <in>
                  <hLoc/>
                  <dom>
                    <store/>
                  </dom>
                </in>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <aVal/>
                <text content=" is a value, and "/>
                <TDjudge sub="yes">
                  <aVal/>
                  <fn><type num="1"/><type num="2"/></fn>
                </TDjudge>
                <text content=", then, "/>
                <aVal/>
                <text content=" is "/>
                <lambda><id/><aExpr/></lambda>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> By induction on the derivation of
          <btypes:TYPE>
            <TDjudge sub="yes">
              <aVal/>
              <type/>
            </TDjudge>
          </btypes:TYPE>.
        </p>
        <p>
          If 
          <btypes:TYPE>
            <TDjudge sub="yes">
              <aVal/>
              <bool/>
            </TDjudge>
          </btypes:TYPE>, 
          
          we have
          <btypes:TYPE>
            <TDjudge>
              <aVal/>
              <type/>
            </TDjudge>
            <text content=" and "/>
            <Tsub>
              <type/>
              <bool/>
            </Tsub>
          </btypes:TYPE> 
          
          by Inversion of copy coercion relation,
          <btypes:TYPE>
            <eq>
              <type/>
              <bool/>
            </eq>
            <text content=" or "/>
            <eq>
              <type/>
              <mutable>
                <bool/>
              </mutable>
            </eq>
          </btypes:TYPE>.
          
          If 
          <btypes:TYPE>
            <eq>
              <type/>
              <bool/>
            </eq>
          </btypes:TYPE>, it is clear that the final rule in the
          derivation must be T-TRUE, or T-FALSE, in which case the
          result is immediate. 

          The case  
          <btypes:TYPE>
            <eq>
              <type/>
              <mutable>
                <bool/>
              </mutable>
            </eq>
          </btypes:TYPE> cannot happen because there is no rule that
          derives a mutable type for a value, and we assume that the
          induction hypothesis 
          <btypes:TYPE>
            <TDjudge>
              <aVal/>
              <type/>
            </TDjudge>
          </btypes:TYPE> holds.
        </p>
        <p>
          Other cases of the lemma are similar.
        </p>
      </sect3>
      <sect3 id="T-progress">
        <title>LEMMA: Progress</title>
        <p>
          <btypes:TYPE>
            <text content="If "/>
            <aExpr/>
            <text content=" is a closed, well typed term, "/> 
            <text content="that is, "/> 
            <Sjudge>
              <assume>
                <Empty/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=" for some "/> 
            <type/>
            <text content=" and "/> 
            <store/>
            <text content=", given any heap "/> 
            <heap/>
            <text content=" and stack "/> 
            <stack/>
            <text content=" such that "/> 
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <plus>
                <heap/>
                <stack/>
              </plus>
            </Sjudge> 
            <text content=", "/>            
          </btypes:TYPE>
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content=" If "/>                
                <Sjudge name="lval">
                  <assume/>
                  <aExpr/>
                </Sjudge>
                <text content=", then "/>              
                <aExpr/>
                <text content=" is either a valid lvalue "/> 
                <lVal/>
                <text content=" (that is, "/>
                <eq>
                  <lVal/>
                  <sLoc/>
                </eq>
                <text content=", "/>
                <in>
                  <sLoc/>
                  <dom>
                    <stack/>
                  </dom>
                </in>
                <text content=" or "/> 
                <eq>
                  <lVal/>
                  <deref>
                    <hLoc/>
                  </deref>
                </eq>
                <text content=", "/>
                <in>
                  <hLoc/>
                  <dom>
                    <heap/>
                  </dom>
                </in>
                <text content=") or else "/>
                <Exists>
                  <aExpr dash="'"/>
                  <stack dash="'"/>
                  <heap dash="'"/>
                </Exists>
                <text content=" such that:"/>               
                <leval>
                  <opState>
                    <stack/>
                    <heap/>
                    <aExpr/>
                  </opState>
                  <opState>
                    <stack dash="'"/>
                    <heap dash="'"/>
                    <aExpr dash="'"/>
                  </opState>
                </leval>
                <text content="."/>   
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>              
              <btypes:TYPE>
                <aExpr/>
                <text content=" is a value "/> 
                <aVal/>
                <text content=" or else "/> 
                <Exists>
                  <aExpr dash="'"/>
                  <stack dash="'"/>
                  <heap dash="'"/>
                </Exists>
                <text content=" such that "/>               
                <eval>
                  <opState>
                    <stack/>
                    <heap/>
                    <aExpr/>
                  </opState>
                  <opState>
                    <stack dash="'"/>
                    <heap dash="'"/>
                    <aExpr dash="'"/>
                  </opState>
                </eval>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> By induction on the typing
          derivation. 
        </p>
        <ol>
          <li>
            <p>
              Case T-UNIT, T-TRUE, T-FALSE, T-HLOC, T-LAMBDA:
              (Values) Result is immediate for right execution, and
              cannot happen for right execution
            </p>
          </li>
          <li>
            <p>
              Case T-ID: cannot happen, there is no execution rule for
              variables. 
            </p>
          </li>
          <li>
            <p>
              Case T-SLOC: Immediate for left execution. Right
              execution and can always continue with E-RVAL rule as the
              stack is well typed 
              (<btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <heap/>
                    <stack/>
                  </plus>
                </Sjudge> 
              </btypes:TYPE>).
            </p>
          </li>
          <li>
            <p>
              Case T-APP: Only right execution is possible, no application is well
              typed as an lvalue. We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <apply>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </apply>                  
                </eq>
                <text content=", "/>
                <Tsub>
                  <aExpr num="1"/>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </Tsub>                  
                <text content=", and "/>
                <Tsub>
                  <aExpr num="2"/>
                  <type num="1"/>
                </Tsub>                
              </btypes:TYPE>.
              If 
              <btypes:TYPE>
                <aExpr num="1"/>
                <text content=" or "/>
                <aExpr num="2"/>
              </btypes:TYPE>
              is not a value, we can take E-APP-STEP-FN or
              E-APP-STEP-ARG. Otherwise, when both 
              <btypes:TYPE>
                <aExpr num="1"/>
                <text content=" and "/>
                <aExpr num="2"/>
              </btypes:TYPE>
              are values, by canonical forms lemma, 
              <btypes:TYPE>
                <aExpr num="1"/>
              </btypes:TYPE>
              is of the form
              <btypes:TYPE>
                <lambda>
                  <id/>
                  <aExpr dash="'"/>
                </lambda>
              </btypes:TYPE>,
              and we can take the step E-APP. 
            </p>
          </li>
          <li>
            <p>
              Case T-IF: Similar to T-APP, only right execution is
              permitted.
            </p>
          </li>
          <li>
            <p>
              Case T-SET: Only right execution is applicable. We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <assign>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </assign>  
                </eq>
                <text content=", "/>
                <Tsub>
                  <aExpr num="1"/>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </Tsub>                  
                <text content=", "/>
                <TDjudge sub="yes">
                  <aExpr num="1"/>
                  <mutable>
                    <type/>
                  </mutable>
                </TDjudge>
                <text content=", "/>
                <TDjudge sub="yes">
                  <aExpr num="2"/>
                  <type/>
                </TDjudge>
                <text content=", and "/>
                <Sjudge name="lval">
                  <assume/>                  
                  <aExpr num="1"/>                  
                </Sjudge>
              </btypes:TYPE>.
              If 
              <btypes:TYPE>
                <aExpr num="1"/>
              </btypes:TYPE>
              not an lvalue, since we have  
              <btypes:TYPE>
                <Sjudge name="lval">
                  <assume/>                  
                  <aExpr num="1"/>                  
                </Sjudge>
              </btypes:TYPE>
              we can take E-SET-STEP-LHS by induction hypothesis.
              Similarly, if 
              <btypes:TYPE>
                <aExpr num="2"/>
              </btypes:TYPE>
              is not a value, we can take E-SET-STEP-RHS.
              Finally, if
              <btypes:TYPE>
                <eq>
                  <aExpr num="1"/>
                  <lVal/>
                </eq>
                <text content=" and "/>
                <eq>
                  <aExpr num="1"/>
                  <aVal/>
                </eq>
              </btypes:TYPE>,
              we can take the step E-SET-STACK or E-SET-HEAP as
              applicable. 
            </p>
          </li>
          <li>
            <p>
              Case T-DUP: Only right execution is
              permitted, and can take E-DUP-STEP or E-SUP-STEP as
              applicable. 
            </p>
          </li>
          <li>
            <p>
              Case T-DEREF: We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <deref>
                    <aExpr num="1"/>
                  </deref>
                </eq>
                <text content=", and "/>
                <TDjudge sub="yes">
                  <aExpr num="1"/>                  
                  <ref>
                    <type/>
                  </ref>                  
                </TDjudge>
              </btypes:TYPE>.
              Execution can take E-LEFT-DEREF-STEP or E-DEREF-STEP as
              applicable if  
              <btypes:TYPE>
                <aExpr num="1"/>
              </btypes:TYPE>
              is not a value.
              If 
              <btypes:TYPE>
                <Tsub>
                  <aExpr num="1"/>
                  <ref>
                    <type/>
                  </ref>
                </Tsub>
              </btypes:TYPE>
              is a value, then, from the canonical forms lemma, 
              <btypes:TYPE>
                <eq>
                  <aExpr num="1"/>
                  <hLoc/>
                </eq>
                <text content=", "/>
                <in>
                  <hLoc/>
                  <dom>
                    <store/>
                  </dom>
                </in>
              </btypes:TYPE>.            
              Now, since this is an lvalue, we are done in the case of
              left execution. In the case of right execution, we can
              take step E-DEREF since the heap is well typed 
              (<btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <heap/>
                    <stack/>
                  </plus>
                </Sjudge> 
              </btypes:TYPE>).
            </p>
          </li>
          <li>
            <p>
              Case T-LET-M: Only right execution is applicable. We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <paren>
                    <let kind="m">
                      <id/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </let>
                  </paren>
                </eq>
                <text content=", "/>
                <Tsub>
                  <type/>
                  <type num="1"/>
                </Tsub>
                <text content=", "/>
                <Sjudge name="gen">
                  <assume>
                    <gamma/>
                    <store/>
                    <aExpr num="1"/>
                  </assume>                
                  <GEN>
                    <type/>
                    <aTS/>
                  </GEN>
                </Sjudge>      
                <text content=", and"/>
                <Sjudge name="loc">
                  <assume/>
                  <tqExpr>
                    <id/>
                    <aTS/>	
                  </tqExpr>
                </Sjudge>
                <text content=", and"/>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>                      
                        <aTS/>
                      </mapping>
                    </extend>
                    <store/>
                  </assume>                
                  <tqExpr>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </tqExpr>                
                </Sjudge>
              </btypes:TYPE>.
              If 
              <btypes:TYPE>
                <aExpr num="1"/>
              </btypes:TYPE>
              is not a value, we can take E-LET-STEP.
              Otherwise, we can take E-STEP-M.              
            </p>
          </li>
          <li>
            <p>
              Case T-LET-P: Only right execution is applicable. We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <paren>
                    <let kind="m">
                      <id/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </let>
                  </paren>
                </eq>
                <text content=", "/>
                <Tsub>
                  <type/>
                  <type num="1"/>
                </Tsub>
                <text content=", "/>
                <Sjudge name="gen">
                  <assume>
                    <gamma/>
                    <store/>
                    <aExpr num="1"/>
                  </assume>                
                  <GEN>
                    <type/>
                    <aTS/>
                  </GEN>
                </Sjudge>      
                <text content=", and"/>
                <Sjudge name="term">
                  <assume/>
                  <tqExpr>
                    <id/>
                    <aTS/>	
                  </tqExpr>
                </Sjudge>
                <text content=", and"/>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>                      
                        <aTS/>
                      </mapping>
                    </extend>
                    <store/>
                  </assume>                
                  <tqExpr>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </tqExpr>                
                </Sjudge>
              </btypes:TYPE>.
              If 
              <btypes:TYPE>
                <aExpr num="1"/>
              </btypes:TYPE>
              is not a value, we can take E-LET-STEP.
              Otherwise, can take E-LET-P.
            </p>
          </li>
          <li>
            <p>
              Case T-TQEXPR and Case T-LET-M-TQ, T-LET-P-TQ are
              similar.  
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="T-Weakening">
        <title>LEMMA: Weakening</title>
        <p>
          We will write
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </tqExpr>
            </Sjudge>
            <text content=" as a shorthand for "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=", and "/>            
            <Sjudge name="gen">
              <assume>
                <gamma/>
                <store/>
                <aExpr/>
              </assume>
              <GEN>
                <type/>
                <aTS/>
              </GEN>
            </Sjudge>
            <text content="."/>
          </btypes:TYPE>           
        </p>
        <ol>
          <li>          
            <p>
              If 
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <type/>
                  </tqExpr>
                </Sjudge>                
              </btypes:TYPE>
              then,
            </p>
            <ol>
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <supeq>
                      <gamma dash="'"/>
                      <gamma/>
                    </supeq>
                    <text content=" then "/>
                    <Sjudge>
                      <assume>
                        <gamma dash="'"/>
                        <store/>
                      </assume>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <supeq>
                      <store dash="'"/>
                      <store/>
                    </supeq>
                    <text content=" then "/>
                    <Sjudge>
                      <assume>
                        <gamma/>
                        <store dash="'"/>
                      </assume>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              If 
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <GEN>
                      <type/>
                      <aTS/>
                    </GEN>
                  </tqExpr>
                </Sjudge>
                <text content=", "/>
                <eq>
                  <aTS/>
                  <forall>
                    <tvars name="alpha"/>
                    <type/>
                  </forall>
                </eq>
              </btypes:TYPE>
            </p>
            <ol>
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <supeq>
                      <gamma dash="'"/>
                      <gamma/>
                    </supeq>                
                    <text content=" and "/>
                    <eq>
                      <inter>
                        <ftvs>
                          <gamma dash="'"/>
                        </ftvs>
                        <ftvs>
                          <tvars name="alpha"/>
                        </ftvs>
                      </inter>
                      <Empty/>
                    </eq>
                    <text content=" then "/>
                    <Sjudge>
                      <assume>
                        <gamma dash="'"/>
                        <store/>
                      </assume>
                      <tqExpr>
                        <aExpr/>
                        <GEN>
                          <type/>
                          <aTS/>
                        </GEN>
                      </tqExpr>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <supeq>
                      <store dash="'"/>
                      <store/>
                    </supeq>
                    <text content=" and "/>
                    <eq>
                      <inter>
                        <ftvs>
                          <store dash="'"/>
                        </ftvs>
                        <ftvs>
                          <tvars name="alpha"/>
                        </ftvs>
                      </inter>
                      <Empty/>
                    </eq>               
                    <text content=" then "/>
                    <Sjudge>
                      <assume>
                        <gamma/>
                        <store dash="'"/>
                      </assume>
                      <tqExpr>
                        <aExpr/>
                        <GEN>
                          <type/>
                          <aTS/>
                        </GEN>
                      </tqExpr>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
              </li>
            </ol>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> Straightforward induction on the
          typing derivation.
        </p>
      </sect3>
      <sect3 id="T-VSubstitution">
        <title>LEMMA: Value Substitution</title>
        <p>
          If
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <aTS/>
                  </tqExpr>
                </extend>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=", "/>            
            <pred name="Immut">
              <aTS/>
            </pred>
            <text content=" and "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <aVal/>
                <type num="v"/>
              </tqExpr>
            </Sjudge>
            <text content=", and "/>
            <Sjudge name="gen">
              <assume>
                <gamma/>
                <store/>
                <aExpr/>
              </assume>
              <GEN>
                <type num="v"/>
                <aTS/>
              </GEN>
            </Sjudge>
            <text content=" then "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <subst>
                  <aExpr/>
                  <id/>
                  <aVal/>
                </subst>
                <type/>
              </tqExpr>
            </Sjudge>            
          </btypes:TYPE>          
        </p>
        <p>
          <leadin>Proof:</leadin> By induction on the typing
          derivation of
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <aTS/>
                  </tqExpr>
                </extend>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>.
          We proceed by case analysis on the final step of the
          derivation. 
        </p>
        <ol>
          <li>
            <p>
              Case T-ID: We have 
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <id name="y"/>
                </eq>
                <text content=" where "/>
                <in>
                  <id name="y"/>
                  <extend>
                    <gamma/>
                    <id/>
                    <aTS/>
                  </extend>
                </in>
              </btypes:TYPE>.
            </p>
            <p>
              There are two sub cases to consider. If 
              <btypes:TYPE>
                <eq>
                  <id name="x"/>
                  <id name="y"/>
                </eq>
              </btypes:TYPE>,
              then, 
              <btypes:TYPE>
                <eq>
                  <subst>
                    <id name="y"/>
                    <id name="x"/>
                    <aVal/>
                  </subst>
                  <aVal/>                
                </eq>
              </btypes:TYPE>,
              and the result type 
              <btypes:TYPE>
                <type/>
              </btypes:TYPE> is an instantiation of the type scheme 
              <btypes:TYPE>
                <aTS/>
              </btypes:TYPE>.
              One of the assumptions of the lemma states that
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <aVal/>
                    <GEN>
                      <type num="v"/>
                      <aTS/>
                    </GEN>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>. That is, 
              <btypes:TYPE>
                <spEq>
                  <type/>
                  <aTS/>
                </spEq>
              </btypes:TYPE>, and we can infer any more-specific type
              (and in particular the type being instantiated at the
              T-ID rule) instead for this substitution of the
              expression    
              <btypes:TYPE>
                <aVal/>
              </btypes:TYPE>.
              Therefore, we have
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <subst>
                      <aExpr/>
                      <id/>
                      <aVal/>
                    </subst>
                    <type/>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>.
            </p>
            <p>
              If 
              <btypes:TYPE>
                <neq>
                  <id name="x"/>
                  <id name="y"/>
                </neq>
              </btypes:TYPE>, then 
              <btypes:TYPE>
                <eq>
                  <subst>
                    <id name="y"/>
                    <id name="x"/>
                    <aVal/>
                  </subst>
                  <id name="y"/>
                </eq>
              </btypes:TYPE>,
              and the result is immediate.
            </p>
          </li>
          <li>
            <p>
              Case T-LAMBDA: We have 
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <lambda>
                    <id name="y"/>
                    <aExpr dash="'"/>
                  </lambda>
                </eq>
                <text content=", and "/>
                <eq>
                  <type/>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </eq>
                
                <text content=", and "/>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <tqExpr>
                        <id/>
                        <aTS/>
                      </tqExpr>
                      <tqExpr>
                        <id name="y"/>
                        <type num="1"/>
                      </tqExpr>
                    </extend>
                    <store/>
                  </assume>
                  <tqExpr>
                    <aExpr dash="'"/>
                    <type num="2"/>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>.              
            </p>
            <p>
              We can assume that
              <btypes:TYPE>
                <neq>
                  <id/>
                  <id name="y"/>
                </neq>
              </btypes:TYPE>.
              Since it is clear that the type
              <btypes:TYPE>
                <type num="1"/>
              </btypes:TYPE>
              of 
              <btypes:TYPE>
                <id name="y"/>
              </btypes:TYPE>
              can either use variables already in               
              <btypes:TYPE>
                <gamma/>
              </btypes:TYPE>
              or fresh type variables, we know that 
              <btypes:TYPE>
                <eq>
                  <inter>
                    <ftvs>
                      <extend>
                        <gamma/>
                        <tqExpr>
                          <id name="y"/>
                          <type num="1"/>
                        </tqExpr>
                      </extend>
                    </ftvs>
                    <ftvs>
                      <aTS/>
                    </ftvs>
                  </inter>
                  <Empty/>
                </eq>
              </btypes:TYPE>.
              Thus, by weakening lemma, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <tqExpr>
                        <id name="y"/>
                        <type num="1"/>
                      </tqExpr>
                    </extend>
                    <store/>
                  </assume>
                  <tqExpr>
                    <aVal/>
                    <GEN>
                      <type num="v"/>
                      <aTS/>
                    </GEN>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>
              , and, by induction hypothesis, 
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <tqExpr>
                        <id name="y"/>
                        <type num="1"/>
                      </tqExpr>
                    </extend>
                    <store/>
                  </assume>
                  <tqExpr>
                    <subst>
                      <aExpr dash="'"/>
                      <id/>
                      <aVal/>
                    </subst>
                    <type num="2"/>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>.
              Finally, by the T-LAMBDA rule, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <lambda>
                      <id num="y"/>
                      <paren>
                        <subst>
                          <aExpr dash="'"/>
                          <id/>                      
                          <aVal/>
                        </subst>
                      </paren>
                    </lambda>
                    <fn>
                      <type num="1"/>
                      <type num="2"/>
                    </fn>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>, and thus
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <tqExpr>
                    <subst>
                      <lambda>
                        <id num="y"/>
                        <aExpr dash="'"/>
                      </lambda>                    
                      <id/>                      
                      <aVal/>                  
                    </subst>
                    <fn>
                      <type num="1"/>
                      <type num="2"/>
                    </fn>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>, which is the desired result.
            </p>
          </li>
          <li>
            <p>
              T-SET case is similar, except that the substitution
              cannot happen on the LHS of an assignment, since we do
              not perform substitution of mutable values. 
            </p>
          </li>
          <li>
            <p>
              Other cases are similar.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="T-LSubstitution">
        <title>LEMMA: Location Substitution</title>
        <p>
          If
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <type num="0"/>
                  </tqExpr>
                </extend>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=", and for some "/>
            <supeq>
              <store dash="'"/>
              <store/>
            </supeq>
            <text content=", "/>
            <tqExpr>
              <mapsto>
                <store/>
                <sLoc/>
                <type num="0"/>
              </mapsto>
            </tqExpr>
            <text content=", then "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store dash="'"/>
              </assume>
              <tqExpr>
                <subst>
                  <aExpr/>
                  <id/>
                  <sLoc/>
                </subst>
                <type/>
              </tqExpr>
            </Sjudge>            
          </btypes:TYPE>.          
        </p>
        <p>
          <leadin>Proof:</leadin> By induction on the typing
          derivation of
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <type/>
                  </tqExpr>
                </extend>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>, similar to lemma <xref
            ref="T-VSubstitution"/>.
        </p>
      </sect3>
      <sect3 id="T-sh-safety">
        <title>LEMMA: Stack and Heap Assignment</title>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <extend>
                      <heap/>
                      <mapping>
                        <hLoc/>
                        <aVal/>
                      </mapping>
                    </extend>
                    <stack/>
                  </plus>
                </Sjudge>
                <text content=", and "/>
                <Tsub>
                  <mapsto>
                    <store/>
                    <hLoc/>
                  </mapsto>
                  <type/>
                </Tsub>
                <text content=", and "/>
                <TDjudge>
                  <aVal dash="'"/>
                  <type/>
                </TDjudge>
                <text content=", then, "/>               
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <extend>
                      <heap/>
                      <mapping>
                        <hLoc/>
                        <aVal dash="'"/>
                      </mapping>
                    </extend>
                    <stack/>
                  </plus>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="Similarly, if "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <heap/>
                    <extend>
                      <stack/>
                      <mapping>
                        <sLoc/>
                        <aVal/>
                      </mapping>
                    </extend>
                  </plus>
                </Sjudge>
                <text content=" and  "/>
                <Tsub>
                  <mapsto>
                    <store/>
                    <sLoc/>
                  </mapsto>
                  <type/>
                </Tsub>
                <text content=", and "/>
                <TDjudge>
                  <aVal dash="'"/>
                  <type/>
                </TDjudge>
                <text content=", then, "/>                 
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <heap/>
                    <extend>
                      <stack/>
                      <mapping>
                        <sLoc/>
                        <aVal dash="'"/>
                      </mapping>
                    </extend>
                  </plus>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> Immediate from the definition of
          stack and heap typing.
        </p>
      </sect3>
      <sect3 id="T-preservation">
        <title>LEMMA: Preservation</title>
        <p>
          <btypes:TYPE>          
            <text content="If "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=" and "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <plus>
                <heap/>
                <stack/>
              </plus>
            </Sjudge> 
            <text content=" then, "/>    
          </btypes:TYPE>
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="If "/>
                <leval>
                  <opState>
                    <stack/>
                    <heap/>
                    <aExpr/>
                  </opState>
                  <opState>
                    <stack dash="'"/>
                    <heap dash="'"/>
                    <aExpr dash="'"/>
                  </opState>
                </leval>
                <text content=", then, there exists a "/>
                <supeq>
                  <store dash="'"/>
                  <store/>
                </supeq>
                <text content=" such that "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store dash="'"/>
                  </assume>
                  <tqExpr>
                    <aExpr dash="'"/>
                    <type/>
                  </tqExpr>                    
                </Sjudge>
                <text content=" and "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store dash="'"/>
                  </assume>
                  <plus>
                    <heap dash="'"/>
                    <stack dash="'"/>
                  </plus>
                </Sjudge>
                <text content="."/>
              </btypes:TYPE>              
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>          
                <text content="If "/>
                <eval>
                  <opState>
                    <stack/>
                    <heap/>
                    <aExpr/>
                  </opState>
                  <opState>
                    <stack dash="'"/>
                    <heap dash="'"/>
                    <aExpr dash="'"/>
                  </opState>
                </eval>
                <text content=", there exists a "/>
                <supeq>
                  <store dash="'"/>
                  <store/>
                </supeq>                
                <text content=" such that "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store dash="'"/>
                  </assume>
                  <Tsub>
                    <aExpr dash="'"/>
                    <type dash="'"/>
                  </Tsub>                    
                </Sjudge>
                <text content=",  "/>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store dash="'"/>
                  </assume>
                  <plus>
                    <heap dash="'"/>
                    <stack dash="'"/>
                  </plus>
                </Sjudge>
                <text content=" and "/>
                <eq>
                  <minz>
                    <type/>
                  </minz>
                  <minz>
                    <type dash="'"/>
                  </minz>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> By induction on the 
          derivation of 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>. We proceed by the case analysis of the final
          step. 
        </p>
        <ol>
          <li>
            <p>
              Case T-ID, T-TRUE, T-FALSE, T-HLOC, T-LAMBDA  cannot
              happen. 
            </p>
          </li>
          <li>
            <p>
              Case T-SLOC: Only right execution is applicable. 
              We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <sLoc/>
                </eq>
                <text content=" and "/>
                <tqExpr>
                  <mapsto>
                    <store/>
                    <sLoc/>
                  </mapsto>
                  <type/>
                </tqExpr>
              </btypes:TYPE>.
              The only applicable step is E-RVAL, and we have
              <btypes:TYPE>
                <eq>
                  <aExpr dash="'"/>
                  <mapsto>
                    <stack/>
                    <sLoc/>
                  </mapsto>
                </eq>
              </btypes:TYPE>.
              From the definition of stack typing, we have:
              <btypes:TYPE>
                <Tsub>
                  <mapsto>
                    <stack/>
                    <sLoc/>
                  </mapsto>
                  <mapsto>
                    <store/>
                    <sLoc/>
                  </mapsto>
                </Tsub>
              </btypes:TYPE>              
              and thus 
              <btypes:TYPE>
                <Tsub>
                  <aExpr dash="'"/>
                  <type/>
                </Tsub>
              </btypes:TYPE>              
              which implies
              <btypes:TYPE>              
                <eq>
                  <minz>
                    <type/>
                  </minz>
                  <minz>
                    <type dash="'"/>
                  </minz>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              Case T-APP:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <apply>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </apply>
                </eq>
                <text content=", and "/>
                <TDjudge sub="yes">
                  <aExpr num="1"/>
                  <fn>
                    <type num="2"/>
                    <type num="0"/>
                  </fn>
                </TDjudge>
                <text content=", and "/>
                <TDjudge sub="yes">
                  <aExpr num="2"/>
                  <type num="2"/>
                </TDjudge>
                <text content=", and "/>
                <Tsub>
                  <type num="0"/>
                  <type/>
                </Tsub>
                <text content=", and "/>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
                <text content = " where "/>
                <eq>
                  <type num="2"/>
                  <minz>
                    <type num="2" dash="'"/>
                  </minz>
                </eq>                
                <eq>
                  <type num="0"/>
                  <maxz>
                    <type num="0" dash="'"/>
                  </maxz>
                </eq>
                <text content=" and "/>
              </btypes:TYPE>.
            </p>
            <p>              
              This cannot happen for left execution. 
              For right execution, we proceed by further case
              analysis of the applicable execution rules for
              <btypes:TYPE>
                <eval>
                  <opState>
                    <stack/>
                    <heap/>
                    <aExpr/>
                  </opState>
                  <opState>
                    <stack dash="'"/>
                    <heap dash="'"/>
                    <aExpr dash="'"/>
                  </opState>
                </eval>
              </btypes:TYPE>.
            </p>
            <ol>
              <li>
                <p>
                  Case E-APP-STEP-FN:
                  We have:
                  <btypes:TYPE>
                    <eval>
                      <opState>
                        <stack/>
                        <heap/>
                        <aExpr num="1"/>
                      </opState>
                      <opState>
                        <stack dash="'"/>
                        <heap dash="'"/>
                        <aExpr num="1" dash="'"/>
                      </opState>
                    </eval>
                    <text content=" and "/>
                    <eq>
                      <aExpr dash="'"/>
                      <apply>
                        <aExpr num="1" dash="'"/>
                        <aExpr num="2"/>
                      </apply>
                    </eq>
                  </btypes:TYPE>.
                  By induction hypothesis, we have:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <gamma/>
                        <store dash="'"/>
                      </assume>
                      <Tsub>
                        <aExpr num="1" dash="'"/>
                        <fn>
                          <type num="2"/>
                          <type num="0"/>
                        </fn>     
                      </Tsub>                 
                    </Sjudge>                    
                    <text content=" for some "/>
                    <supeq>
                      <store dash="'"/>
                      <store/>
                    </supeq>
                  </btypes:TYPE>.
                  One of the assumptions of the T-APP rule states that 
                  <btypes:TYPE>                    
                    <TDjudge sub="yes">
                      <aExpr num="2"/>
                      <type num="2"/>
                    </TDjudge>
                  </btypes:TYPE>, and by weakening lemma, we have, 
                  <btypes:TYPE>                    
                    <Sjudge>
                      <assume>
                        <gamma/>
                        <store dash="'"/>
                      </assume>
                      <Tsub>
                        <aExpr num="2"/>
                        <type num="2"/>
                      </Tsub>
                    </Sjudge>
                  </btypes:TYPE>. Finally, by the T-APP rule, we
                  conclude that
                  <btypes:TYPE>                    
                    <tqExpr>
                      <paren>
                        <apply>
                          <aExpr num="1" dash="'"/>                        
                          <aExpr num="2"/>
                        </apply>
                      </paren>
                      <type/>
                    </tqExpr>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  Case E-APP-STEP-ARG: Similar to the previous
                  sub-case. 
                </p>
              </li>
              <li>
                <p>
                  Case E-APP: We have:
                  <btypes:TYPE>
                    <eq>
                      <aExpr num="1"/>
                      <lambda>
                        <id/>
                        <aExpr num="0"/>
                      </lambda>
                    </eq>
                    <text content=" and "/>
                    <eq>
                      <aExpr num="2"/>
                      <aVal/>
                    </eq>
                    <text content=" and "/>
                    <text content=" and "/>
                    <eq>
                      <aExpr dash="'"/>
                      <subst>
                        <aExpr num="0"/>
                        <id/>
                        <sLoc/>
                      </subst>
                    </eq>
                    <text content=" and "/>
                    <eval>
                      <opState>
                        <extend>
                          <stack/>
                          <mapping>
                            <sLoc/>
                            <aVal/>
                          </mapping>
                        </extend>
                        <heap/>
                        <aExpr num="1"/>
                      </opState>
                      <opState>
                        <stack dash="'"/>
                        <heap dash="'"/>
                        <aExpr num="1" dash="'"/>
                      </opState>
                    </eval>
                  </btypes:TYPE>.
                </p>
                <p>
                  By the inversion lemma for 
                  <btypes:TYPE>
                    <lambda>
                      <id/>
                      <aExpr num="0"/>
                    </lambda>
                  </btypes:TYPE> we have
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <extend>
                          <gamma>
                            <id/>
                            <type num="2" dash="'"/>
                          </gamma>
                          <store/>
                        </extend>
                      </assume>
                      <tqExpr>
                        <aExpr num="0"/>
                        <type num="0" dash="'"/>
                      </tqExpr>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
                <p>
                  Further from location substitution lemma, we have 
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <gamma/>
                        <store dash="'"/>
                      </assume>
                      <tqExpr>
                        <subst>
                          <aExpr num="0"/>
                          <id/>
                          <sLoc/>
                        </subst>
                        <type num="0" dash="'"/>
                      </tqExpr>
                    </Sjudge>
                    <text content=" where "/>
                    <supeq>
                      <store dash="'"/>
                      <store/>
                    </supeq>
                    <text content=" and "/>
                    <tqExpr>
                      <mapsto>
                        <store/>
                        <sLoc/>
                      </mapsto>
                      <type num="2" dash="'"/>
                    </tqExpr>
                  </btypes:TYPE>.
                </p>
                <p>
                  Thus, we have 
                  <btypes:TYPE>
                    <Tsub>
                      <type num="0"/>
                      <type num="0" dash="'"/>
                    </Tsub>
                    <text content=" and "/>
                    <Tsub>
                      <type num="0"/>
                      <type/>
                    </Tsub>
                  </btypes:TYPE>.
                  Therefore, it is clear that
                  <btypes:TYPE>
                    <eq>
                      <minz>
                        <type num="0" dash="'"/>
                      </minz>
                      <minz>
                        <type/>
                      </minz>
                    </eq>
                  </btypes:TYPE>.                  
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              Case T-SET:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <assign>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </assign>
                </eq>
                <text content=", and "/>
                <TDjudge sub="yes">
                  <aExpr num="1"/>
                  <mutable>
                    <type/>
                  </mutable>
                </TDjudge>
                <text content=", and "/>
                <TDjudge sub="yes">
                  <aExpr num="2"/>
                  <type/>
                </TDjudge>
                <Sjudge name="lval">
                  <assume/>                  
                  <aExpr num="1"/>                  
                </Sjudge>                
              </btypes:TYPE>
            </p>
            <p>
              If the step taken is E-SET-STEP-LHS or E-SET-STEP-RHS,
              the result follows from the induction hypothesis and
              T-SET rule (as in the case of T-APP).               
              If the step taken is E-SET-STACK or E-SET-HEAP, the
              result follows from the stack and heap assignment lemma.
            </p>
          </li>
          <li>
            <p>
              Case T-DEREF: We have: 
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <deref>
                    <aExpr dash="'"/>
                  </deref>
                </eq>
                <text content=" and "/>
                <TDjudge sub="yes">
                  <aExpr dash="'"/>                  
                  <ref>
                    <type/>
                  </ref>                  
                </TDjudge>
              </btypes:TYPE>.
              If the step taken is E-LEFT-DEREF-STEP or E-LEFT-DEREF,
              the result follows from induction hypothesis and T-DEREF
              rule. 

              If the step taken is E-DEREF (right execution only) 
              <btypes:TYPE>
                <aExpr dash="'"/>                  
              </btypes:TYPE> is a value, and from canonical forms
              lemma, we know that 
              <btypes:TYPE>
                <eq>
                  <aExpr dash="'"/>                  
                  <hLoc/>
                </eq>
                <text content=" and "/>
                <in>
                  <hLoc/>
                  <dom>
                    <store/>
                  </dom>
                </in>
              </btypes:TYPE>
              and the result follows from the fact that
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <gamma/>
                    <store/>
                  </assume>
                  <plus>
                    <heap/>
                    <stack/>
                  </plus>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              Case T-LET-P: Right execution only. We have:
              <btypes:TYPE>
                <eq>
                  <aExpr/>
                  <paren>
                    <let kind="p">
                      <id/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </let>
                  </paren>
                </eq>
                <text content=" and "/>
                <TDjudge sub="yes">
                  <aExpr num="1"/>                
                  <type num="1"/>                
                </TDjudge>
                <text content=" and "/>
                <Tsub>
                  <type/>
                  <type num="1"/>
                </Tsub>
                <text content=" and "/>
                <Sjudge name="gen">
                  <assume>
                    <gamma/>
                    <store/>
                    <aExpr num="1"/>
                  </assume>                
                  <GEN>
                    <type/>
                    <aTS/>
                  </GEN>
                </Sjudge>      
                <text content=" and "/>
                <Sjudge>
                  <assume>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>                      
                        <aTS/>
                      </mapping>
                    </extend>
                    <store/>
                  </assume>                
                  <tqExpr>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </tqExpr>                
                </Sjudge>
              </btypes:TYPE>.
              There are two sub-cases to consider:
            </p>
            <ol>
              <li>
                <p>
                  If we take step E-LET-STEP,                   
                  <btypes:TYPE>
                    <eval>
                      <opState>
                        <stack/>
                        <heap/>
                        <aExpr num="1"/>
                      </opState>
                      <opState>
                        <stack dash="'"/>
                        <heap dash="'"/>
                        <aExpr num="1" dash="'"/>
                      </opState>
                    </eval>
                  </btypes:TYPE>
                  and 
                  <btypes:TYPE>
                    <eq>
                      <aExpr dash="'"/>
                      <paren>
                        <let kind="p">
                          <id/>
                          <aExpr num="1" dash="'"/>
                          <aExpr num="2"/>
                        </let>
                      </paren>
                    </eq>
                    <text content=". If "/>                    
                    <eq>
                      <aExpr/>
                      <aVal/>
                    </eq>
                  </btypes:TYPE>
                  It is clear that 
                  <btypes:TYPE>
                    <pred name="Value">
                      <aExpr num="1"/>
                    </pred>
                  </btypes:TYPE> implies
                  <btypes:TYPE>
                    <pred name="Value">
                      <aExpr num="1" dash="'"/>
                    </pred>
                  </btypes:TYPE>.                     
                  Now, the result follows
                  from the induction hypothesis and the E-LET-P rule.
                </p>
              </li>
              <li>
                <p>
                  If we take the step E-LET-P, 
                  <btypes:TYPE>
                    <eq>
                      <aExpr/>
                      <paren>
                        <let kind="p">
                          <id/>
                          <aVal/>
                          <aExpr num="2"/>
                        </let>
                      </paren>
                    </eq>
                  </btypes:TYPE>
                  Since 
                  <btypes:TYPE>
                    <tqExpr>
                      <id/>
                      <aTS/>
                    </tqExpr>
                  </btypes:TYPE>
                  has a polymorphic type, 
                  (that is,
                  <btypes:TYPE>
                    <eq>
                      <aTS/>
                      <forall>
                        <tvars name="alpha"/>
                        <type name="s"/>
                      </forall>
                    </eq>
                  </btypes:TYPE>)
                  we know that
                  <btypes:TYPE>
                    <pred name="Immut">
                      <type/>
                    </pred>
                  </btypes:TYPE>.
                  Also, from canonical forms lemma, all values have
                  an immutable type. Therefore, 
                  <btypes:TYPE>
                    <eq>
                      <type/>
                      <type num="1"/>
                    </eq>
                  </btypes:TYPE>. Now, the result follows from
                  value substitution lemma. 
                </p>
              </li>
            </ol>            
          </li>
          <li>
            <p>
              Case T-LET-M: Similar to T-LET-P, except that we should
              always use the GEN-EXPANSIVE rule during generalization,
              and use the location substitution lemma instead of 
              the value substitution lemma
            </p>
          </li>
          <li>
            <p>
              Cases T-IF, T-DUP, T-TQEXPR, and T-LET-M-TQ T-LET-P-TQ are
              similar.  
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="stuck_state">
        <title>DEFINITION: Stuck State</title>
        <p>
          A system state 
          <btypes:TYPE>
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
          </btypes:TYPE>
          is said to be <term>stuck</term> if
          <btypes:TYPE>
            <neq>
              <aExpr/>
              <aVal/>
            </neq>
          </btypes:TYPE>
          and there are no 
          <btypes:TYPE>
            <stack dash="'"/>
            <text content=", "/>
            <heap dash="'"/>
            <text content=", and "/>
            <aExpr dash="'"/>
          </btypes:TYPE>   
          such that 
          <btypes:TYPE>
            <eval>
              <opState>
                <stack/>
                <heap/>
                <aExpr/>
              </opState>
              <opState>
                <stack dash="'"/>
                <heap dash="'"/>
                <aExpr dash="'"/>
              </opState>
            </eval>
          </btypes:TYPE>.
        </p>
      </sect3>      
      <sect3 id="T-soundness">
        <title>THEOREM: Type Soundness</title>
        <p>
          If 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <Empty/>
                <store/>
              </assume>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </Sjudge>
            <text content=" and "/>
            <Sjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <plus>
                <heap/>
                <stack/>
              </plus>
            </Sjudge> 
            <text content=" and "/>
            <eval many="yes">
              <opState>
                <stack/>
                <heap/>
                <aExpr/>
              </opState>
              <opState>
                <stack dash="'"/>
                <heap dash="'"/>
                <aExpr dash="'"/>
              </opState>
            </eval>
            <text content=" then "/>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
            <text content=" is not stuck."/>            
          </btypes:TYPE>
          That is, execution of a well typed expression cannot lead to
          a stuck state. Here, 
          <btypes:TYPE>
            <evalOp many="yes"/>
          </btypes:TYPE> represents the 
          reflexive-transitive-closure of 
          <btypes:TYPE>
            <evalOp/>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof:</leadin> By straightforward induction on the
          length of   
          <btypes:TYPE>
            <evalOp many="yes"/>
          </btypes:TYPE>. If 
          <btypes:TYPE>
            <eq>
              <aExpr/>
              <aVal/>
            </eq>
          </btypes:TYPE>, proof is immediate. Otherwise, from 
          Lemma&nbsp;<xref ref="T-progress"/> (Progress),
          we know that we can take at least one step forward. Further,
          from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation),
          we know that a (left/right) execution of a well
          typed expression in with respect to a well typed stack and heap
          will always result in another well typed expression, stack
          and heap. Proof now follows from induction hypothesis.  
        </p>
      </sect3>      
    </sect2>
    <sect2 id="cc_infer">
      <title>Equational Inference Algorithm</title>
      <btypes:TYPE>
	<grammar>
	  <bnf desc="Types">
	    <type/>
	    <alternatives>
	      <text content="..."/>
	    </alternatives>
	  </bnf>
	  <bnfc desc="Constrained Type">
	    <alternatives>
	      <ctype>
		<type/>
		<aCtset/>
	      </ctype>
	    </alternatives>
	  </bnfc>
	  <bnf desc="Constraint Sets">
	    <aCtset/>
	    <alternatives>
	      <Empty/>
	      <set>
		<plural>
		  <paren>
		    <alternatives>                      
		      <eq>
			<type/>
			<type/>
		      </eq>
		      <ceq>
			<type/>
			<type/> 
		      </ceq>
		      <Tsub>
			<type/>
			<type/> 
		      </Tsub>
		    </alternatives>
		  </paren>
		</plural>
	      </set>
	    </alternatives>            
	  </bnf>
	  <bnf desc="Substitutions">            
	    <aSubMap/>            
	    <alternatives>
	      <Empty/>
	      <SubMap>
		<tvar name="alpha"/>
		<type/>
	      </SubMap>
	      <compose>
		<aSubMap/>
		<aSubMap/>
	      </compose>
	    </alternatives>
	  </bnf>
	</grammar>
      </btypes:TYPE>
      <p>
        We will denote applications of a list of substitutions
        of these substitutions as 
        <btypes:TYPE>
          <Subst>
            <aSubMap/>
            <text content="X"/>
          </Subst>
        </btypes:TYPE>, while an individual substitution is written
        using the standard notation
        <btypes:TYPE>
          <subst>
            <text content="X"/>
            <text content="Y"/>
            <text content="Z"/>          
          </subst>
        </btypes:TYPE>.
      </p>
      <p>        
        The inference judgment 
        <btypes:TYPE>
          <TEjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <constrain>
              <aCtset/>
            </constrain>
          </TEjudge>
        </btypes:TYPE>
        should be understood as: given the stack (binding) context
        <btypes:TYPE><gamma/></btypes:TYPE> and heap (store) context
        <btypes:TYPE><store/></btypes:TYPE>, we can infer the type 
        <btypes:TYPE><type/></btypes:TYPE> for the expression 
        <btypes:TYPE><aExpr/></btypes:TYPE> under the set of
        constraints <btypes:TYPE><aCtset/></btypes:TYPE>. In the
        interest brevity, we will not track the freshness of type
        variables. We just write
        <btypes:TYPE>
          <Sjudge name="new">
            <assume/>
            <tvars name="alpha"/>
          </Sjudge>
        </btypes:TYPE> to mean that the sequence of type variables
        <btypes:TYPE>
          <tvars name="alpha"/>
        </btypes:TYPE> are new type variables.
      </p>
      <xi:include href="include/formal/eq-infer.xmli"/>
      <p>
        Equational Inference rules are shown in Table&nbsp;<xref
          ref="eq_infer"/>. We will hereinafter write LET-&alpha; to
        range over LET-M and LET-P. We propagate solved constraints at
        a let-boundary (TE-LET-&alpha; and TE-LET-&alpha;-TQ rules) as
        equality constraints rather then substitutions. This is done
        just to present the rules in a simple form. A real
        implementation must propagate the substitutions so that
        closure computation does not increase exponentially. In this
        equational presentation of inference, types can be fixed by
        equality constraints, or compatibility requirements expressed
        as copy coercion constraints. The coercion constraints are used
        as hints and we obtain the substituted type by subsumption.
        The solution to these constraints closely corresponds to the
        rule defined in BitC. In this section, we do not present the
        fact that mutability of local variables are determined by
        examining the expression in which they are used.  The actual
        implementation in BitC uses an eager unification algorithm,
        and is explained in the next section. 
      </p>
    </sect2>
    <sect2>
      <title>Unification</title>
      <p>
        Unification Rules are shown in Table&nbsp;<xref
          ref="eq_unify"/>.
        We write
        <btypes:TYPE>
          <models>
            <aSubMap/>
            <aCtset/>                  
          </models>
        </btypes:TYPE>
        to mean that the substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>
        <em>satisfies</em> the set of constraints
        <btypes:TYPE>
          <aCtset/>                  
        </btypes:TYPE>.
        A constraint set 
        <btypes:TYPE>
          <canonical>
            <aCtset/>
          </canonical>
        </btypes:TYPE> is said to be the normalized form of 
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE>
        if it is written as a set of atomic constraints by using the
        copy coercion rules defined in Table&nbsp;<xref
          ref="sub_rules"/> (note that this conversion is total).
        Further this set is closed, such that all transitive
        relationships are explicitly added. 
        (see Definition&nbsp;<xref ref="closure"/>). 
        The unification judgment
        <btypes:TYPE>
          <models name="UNF">
	    <nothing/>
            <canonical>
              <aCtset/>                  
            </canonical>
          </models>
        </btypes:TYPE>
        says that the constraint set 
        <btypes:TYPE>
          <aCtset/>                  
        </btypes:TYPE> when written equivalent canonical form as 
        <btypes:TYPE>
          <aCtset dash="'"/>                  
        </btypes:TYPE> is consistent and acyclic.
        The statement
        <btypes:TYPE>
          <models name="unf">
            <aSubMap/>
            <aCtset/>                  
          </models>
        </btypes:TYPE> is understood as: The substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>
        obtained as a result of unification and constraint solving
        satisfies the set of constraints
        <btypes:TYPE>
          <aCtset/>                  
        </btypes:TYPE>.
      </p>
      <xi:include href="include/formal/eq-unify.xmli"/>
      <sect3 id="closure">
        <title>DEFINITION: Constraint Set Closure</title>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <eq>
                    <fn>
                      <type num="1"/>
                      <type num="2"/>
                    </fn>
                    <fn>
                      <type num="1" dash="'"/>
                      <type num="2" dash="'"/>
                    </fn>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>                  
		  <type num="1"/>                                    
		  <type num="1" dash="'"/>                  
                </eq>
                <text content=" and "/>                
                <eq>                  
		  <type num="2"/>                                    
		  <type num="2" dash="'"/>                  
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <Tsub>
                    <fn>
                      <type num="1"/>
                      <type num="2"/>
                    </fn>
                    <fn>
                      <type num="1" dash="'"/>
                      <type num="2" dash="'"/>
                    </fn>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>                  
		  <type num="1"/>                                    
		  <type num="1" dash="'"/>                  
                </eq>
                <text content=" and "/>                
                <eq>                  
		  <type num="2"/>
		  <type num="2" dash="'"/>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <eq>
                    <ref>
                      <type/>
                    </ref>
                    <ref>
                      <type dash="'"/>
                    </ref>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <Tsub>
                    <ref>
                      <type/>
                    </ref>
                    <ref>
                      <type dash="'"/>
                    </ref>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <eq>
                    <mutable>
                      <type/>
                    </mutable>
                    <mutable>
                      <type dash="'"/>
                    </mutable>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <Tsub>
                    <mutable>
                      <type/>
                    </mutable>
                    <mutable>
                      <type dash="'"/>
                    </mutable>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <Tsub>
                  <type/>
                  <type dash="'"/>
                </Tsub>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <eq>
                    <type num="1"/>
                    <type num="2"/>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" and "/>                
                <in>
                  <eq>
                    <type num="2"/>
                    <type num="3"/>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <eq>
                  <type num="1"/>
                  <type num="3"/>
                </eq>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <Tsub>
                    <type num="1"/>
                    <type num="2"/>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" and "/>                
                <in>
                  <Tsub>
                    <type num="2"/>
                    <type num="3"/>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <Tsub>
                  <type num="1"/>
                  <type num="3"/>
                </Tsub>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <eq>
                    <type num="1"/>
                    <type num="2"/>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" and "/>                
                <in>
                  <Tsub>
                    <type num="2"/>
                    <type num="3"/>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <Tsub>
                  <type num="1"/>
                  <type num="3"/>
                </Tsub>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <text content="For each "/>
                <in>
                  <Tsub>
                    <type num="1"/>
                    <type num="2"/>
                  </Tsub>
                  <aCtset/>
                </in>
                <text content=" and "/>                
                <in>
                  <eq>
                    <type num="2"/>
                    <type num="3"/>
                  </eq>
                  <aCtset/>
                </in>
                <text content=" add "/>                
                <Tsub>
                  <type num="1"/>
                  <type num="3"/>
                </Tsub>
                <text content="."/>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Continue till no more constraints can be added.
        </p>
      </sect3>
      <sect3>
        <title>Solving the Constraints</title>
        <xi:include href="include/formal/eq-solve.xmli"/>
        <p>
          Judgments to solve equational constraints are shown in
          Table&nbsp;<xref ref="eq_solve"/>.
        </p>
      </sect3>
    </sect2>
    <sect2>
      <title>Soundness of Equational Inference</title>
      <sect3>
        <title>THEOREM: Soundness of Constraint Closure</title>
        <p>
          If 
          <btypes:TYPE>
            <models>
              <aSubMap/>
              <aCtset/>                  
            </models>
          </btypes:TYPE>
          then 
          <btypes:TYPE>
            <models>
              <aSubMap/>
              <Xform name="Close">
                <aCtset/>                
              </Xform>
            </models>
          </btypes:TYPE>.
        </p>
        <p>          
          <leadin>Proof: </leadin> Immediate from the definition of
          closure computation and copy coercion rules. 
        </p>
      </sect3>
      <sect3 id="TE-solve-correct">
        <title>THEOREM: Correctness of Constraint Solver</title>
        <p>
          <btypes:TYPE>
            <iff>
              <models name="Sol">
                <aSubMap/>
                <aCtset/>                  
              </models>
              <models>
                <aSubMap/>
                <aCtset/>                  
              </models>
            </iff>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof:</leadin> Evident from the definition of
          the constraint solver.
        </p>
      </sect3>
      <sect3 id="TE-unify-correct">
        <title>THEOREM: Correctness of Unification</title>
        <p>
          Unification produces <em>a</em> valid substitution that
          satisfies all the constraints in a constraint set. That is,
          if 
          <btypes:TYPE>
            <models name="unf">
              <aSubMap/>
	      <aCtset/>                  
            </models>
          </btypes:TYPE>
          then 
          <btypes:TYPE>
            <models>
              <aSubMap/>
              <aCtset/>                  
            </models>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof: </leadin> Evident the definition of
          unification, and Theorem&nbsp;<xref ref="TE-solve-correct"/>.
        </p>
      </sect3>
      <sect3>
        <title>THEOREM: Decidability of Unification</title>
        <p>
          <btypes:TYPE>
            <models name="unf">
              <aSubMap/>
              <aCtset/>                  
            </models>
          </btypes:TYPE>
          is decidable.
        </p>
        <p>
          <leadin>Proof: </leadin> Follows from following facts:
        </p>
        <ol>
          <li>
            <p>
              The constraint set 
              <btypes:TYPE>
                <aCtset/>                  
              </btypes:TYPE> is finite.
              Closure computation follows set-union semantics and will
              eventually terminate after all possible constraints are
              added (as evident from the cope coercion relationships).
            </p>
          </li>
          <li>
            <p>
              Consistency check is bounded by the cardinality of the
              constraint set and is thus decidable.
            </p>
          </li>
          <li>
            <p>
              There are no forms that introduce cyclic types in this
              system. Even otherwise, cycle check is also bounded by
              the cardinality of the constraint set.
            </p>
          </li>
          <li>
            <p>
              The constraint solver builds a solution tree by always
              invoking itself on <em>smaller</em> sets. Therefore,
              there can be no infinite derivations.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="decl-sub">
        <title>LEMMA: Substitution on Declarative Derivation</title>
        <p>
          <btypes:TYPE>	    
	    <text content="If "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	    <text content=" then "/>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<Subst>
		  <aSubMap/>		
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
        </p>	
        <p>
	  <leadin>Proof:</leadin> Straightforward induction on the
	  derivation of 
          <btypes:TYPE>	    
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, except for the fact that we should use
	  appropriate &alpha;-renaming on generalized variables 
          <btypes:TYPE>	    
	    <forall>
	      <in>
		<aTS/>
		<gamma/>
	      </in>
	    </forall>
	  </btypes:TYPE>, so that generalized variables do not get
	  substituted. 	  
        </p>
      </sect3>
      <sect3 id="sub-weakening">
        <title>LEMMA: Weakening of Substitutions</title>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<models>
		  <aSubMap/>              
		  <unin>
		    <aCtset num="1"/>              		    
		    <aCtset num="2"/>              
		  </unin>
		</models>
		<text content=" then "/>
		<models>
		  <aSubMap/>              
		  <aCtset num="1"/>              		    
		</models>
		<text content=" and "/>
		<models>
		  <aSubMap/>              
		  <aCtset num="2"/>              
		</models>
	      </btypes:TYPE>.          
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<models name="Sol">
		  <aSubMap/>              
		  <unin>
		    <aCtset num="1"/>              		    
		    <aCtset num="2"/>              
		  </unin>
		</models>
		<text content=" then "/>
		<models>
		  <aSubMap/>              
		  <aCtset num="1"/>              		    
		</models>
		<text content=" and "/>
		<models>
		  <aSubMap/>              
		  <aCtset num="2"/>              
		</models>
	      </btypes:TYPE>.          
	    </p>
	  </li>
	</ol>
        <p>
	  <leadin>Proof:</leadin> Part (1) is immediate. Part(2)
          follows from Theorem&nbsp;<xref ref="TE-solve-correct"/>. 
        </p>
      </sect3>
      <sect3 id="eq-sub-composition">
        <title>LEMMA: Composition of Solutions and Substitutions</title>
	<p>
	  If 
	  <btypes:TYPE>
	    <models name="unf">
	      <aSubMap num="1"/>              
	      <aCtset num="1"/>              		    
	    </models>
	    <text content=" and "/>
	    <subeq>
	      <aCtset num="2"/>
	      <aCtset num="1"/>              		    
	    </subeq>
	    <text content=" then "/>
	    <Exists>
	      <aSubMap num="2"/>
	    </Exists>
	    <text content=" such that "/>
	    <eq>
	      <aSubMap num="1"/>
	      <compose>
		<aSubMap num="2"/>
		<aSubMap num="0"/>
	      </compose>
	    </eq>
	    <text content=" and "/>
	    <models name="unf">
	      <aSubMap num="2"/>              
	      <aCtset num="2"/>              		    
	    </models>
	  </btypes:TYPE>.	 
	</p>
      </sect3>
      <sect3 id="TE-soundness">
        <title>THEOREM: Soundness of Equational Inference</title>
        <p>
          <btypes:TYPE>
            <text content="If "/>
            <TEjudge>
              <assume>
                <gamma/>
                <store/>
              </assume>
              <conclude>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </conclude>
              <constrain>
                <aCtset/>
              </constrain>
            </TEjudge>
            <text content=" and "/>
            <models name="unf">
              <aSubMap/>
              <aCtset/>
            </models>
            <text content=" then "/>          
            <Sjudge>
              <assume>
                <Subst>
                  <aSubMap/>
                  <gamma/>
                </Subst>
                <Subst>
                  <aSubMap/>
                  <store/>
                </Subst>
              </assume>
              <tqExpr>
                <aExpr/>
                <Subst>
                  <aSubMap/>
                  <type/>
                </Subst>
              </tqExpr>
            </Sjudge>
            <text content="."/>
          </btypes:TYPE>      
        </p>
        <p>
          <leadin>Proof:</leadin>
          By induction on the equational inference derivation,
          proceeding by case analysis on the final step of
          derivation (we vacuously assume &alpha;-reduction):
        </p>
        <ol>
          <li>
            <p>
              Cases TE-UNIT, TE-TRUE, TE-FALSE, TE-ID, TE-HLOC,
              TE-SLOC are trivial. 
            </p>
          </li>
          <li>
            <p>
              Case TE-LAMBDA: From induction hypothesis, we have:              
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <tvar name="alpha"/>
                        </mapping>
                      </extend>
                    </Subst>
                    <Subst>
                      <aSubMap/>                      
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <aExpr dash="'"/>
                    <Subst>
                      <aSubMap/>                                          
                      <type/>
                    </Subst>
                  </tqExpr>
                </Sjudge>                
              </btypes:TYPE>.
              This can be re-written as:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <extend>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                      <mapping>
                        <id/>
                        <Subst>
                          <aSubMap/>
                          <tvar name="alpha"/>
                        </Subst>
                      </mapping>
                    </extend>
                    <Subst>
                      <aSubMap/>                      
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>                    
                    <aExpr dash="'"/>
                    <Subst>
                      <aSubMap/>                                          
                      <type/>
                    </Subst>
                  </tqExpr>
                </Sjudge>                
              </btypes:TYPE>.
              Now, from the T-LAMBDA rule, we can conclude that
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>                      
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <lambda>
                      <id/>
                      <aExpr dash="'"/>
                    </lambda>
                    <fn>
                      <Subst>
                        <aSubMap/>
                        <tvar name="alpha"/>
                      </Subst>
                      <Subst>
                        <aSubMap/>                                          
                        <type/>
                      </Subst>
                    </fn>
                  </tqExpr>
                </Sjudge>                
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              Case TE-APP: By induction hypothesis, and
              Lemma&nbsp;<xref ref="decl-sub"/> and 
	      Lemma&nbsp;<xref ref="eq-sub-composition"/> we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </assume>
                  <Tsub>
                    <aExpr num="1"/>                
                    <Subst>
                      <aSubMap/>                    
                      <type num="1"/>
                    </Subst>
                  </Tsub>
                  <text content = " and "/>
                </Sjudge>
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </assume>
                  <Tsub>
                    <aExpr num="2"/>                
                    <Subst>
                      <aSubMap/>                      
                      <type num="2"/>
                    </Subst>
                  </Tsub>
                </Sjudge>
              </btypes:TYPE>.
              By inspecting the constraints that get added at the
              T-APP step we can conclude that the result of
              substitution must imply              
              <btypes:TYPE>            
                <Tsub>
                  <Subst>
                    <aSubMap/>                                          
                    <type num="1"/>
                  </Subst>
                  <fn>
                    <minz>
                      <Subst>
                        <aSubMap/>                                          
                        <type num="2"/>
                      </Subst>
                    </minz>
                    <maxz>
                      <Subst>
                        <aSubMap/>                                          
                        <tvar name="alpha"/>
                      </Subst>
                    </maxz>
                  </fn>
                </Tsub>
              </btypes:TYPE>. 
              We also have the axiom
              <btypes:TYPE>            
                <Tsub>
                  <maxz>
                    <Subst>
                      <aSubMap/>                                          
                      <tvar name="alpha"/>
                    </Subst>
                  </maxz>                
                  <Subst>
                    <aSubMap/>                                          
                    <tvar name="alpha"/>
                  </Subst>
                </Tsub>
              </btypes:TYPE>.
              Now, from T-APP rule, we can obtain
              <btypes:TYPE>            
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <apply>
                      <aExpr num="1"/>                
                      <aExpr num="2"/>                
                    </apply>
                    <Subst>
                      <aSubMap/>                    
                      <tvar name="alpha"/>
                    </Subst>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              Cases TE-IF, TE-SET, TE-DUP, TE-DEREF and TE-SET are
              similar.  
            </p>
          </li>
          <li>
            <p>
              Case TE-LET-&alpha;: By induction hypothesis, (similar to TE-APP
              case) we have:
              <btypes:TYPE>            
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u"/>                    
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <aExpr num="1"/>
                    <Subst>
                      <aSubMap num="u"/>                      
                      <type num="1"/>
                    </Subst>
                  </tqExpr>
                </Sjudge>
		<text content=" and "/>
		<models name="unf">
		  <aSubMap num="u"/>
		  <aCtset num="1" dash="'"/>
		</models>
              </btypes:TYPE>.
              Let 
              <btypes:TYPE>            
                <type/>
              </btypes:TYPE> be a type such that
              <btypes:TYPE>            
                <Tsub>
                  <type/>
                  <floor>
                    <Subst>
                      <aSubMap/>                  
                      <type num="1"/>
                    </Subst>
                  </floor>
                </Tsub>
              </btypes:TYPE>.
              This can be re-written as:
              <btypes:TYPE>            
                <Tsub>
                  <Subst>
                    <aSubMap/>                  
                    <type num="1"/>
                  </Subst>
                  <type dash="'"/>
                </Tsub>
                <text content=" and "/>
                <Tsub>
                  <type/>
                  <type dash="'"/>
                </Tsub>
              </btypes:TYPE> to match the requirements of
              T-LET-&alpha; rule. 
              Also, since both T-LET-&alpha; and TE-LET-&alpha; use the same
              generalization rules, we can obtain:
              <btypes:TYPE>            
                <Sjudge name="gen">
                  <assume>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <store/>
                    </Subst>
                    <aExpr num="1"/>
                  </assume>
                  <GEN>
                    <type/>
                    <Subst>
                      <aSubMap/>                  
                      <aTS/>
                    </Subst>
                  </GEN>       
                </Sjudge>
              </btypes:TYPE>.
	      By Lemma&nbsp;<xref ref="eq-sub-composition"/>
              <btypes:TYPE>            
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>                  
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>                    
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <aExpr num="1"/>
                    <Subst>
                      <aSubMap/>                      
                      <type num="1"/>
                    </Subst>
                  </tqExpr>
                </Sjudge>
		<text content=" and by suitable variable renaming"/>
		<text content=" we can obtain"/>
                <Sjudge name="gen">
                  <assume>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <store/>
                    </Subst>
                    <aExpr num="1"/>
                  </assume>
                  <GEN>
                    <type/>
                    <Subst>
                      <aSubMap/>                  
                      <aTS/>
                    </Subst>
                  </GEN>       
                </Sjudge>
              </btypes:TYPE>.
              By induction hypothesis, we also have:
              <btypes:TYPE>            
                <Sjudge>
                  <assume>
                    <extend>
                      <Subst>
                        <aSubMap/> 
                        <gamma/>
                      </Subst>
                      <mapping>
                        <id/>
                        <Subst>
                          <aSubMap/>                                          
                          <aTS/>
                        </Subst>
                      </mapping>
                    </extend>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <aExpr num="2"/>
                    <Subst>
                      <aSubMap/>                      
                      <type num="2"/>
                    </Subst>
                  </tqExpr>
                </Sjudge>              
              </btypes:TYPE>.
              Therefore, from T-LET-&alpha; rule, we can obtain
              <btypes:TYPE>            
                <Sjudge>
                  <assume>
                    <Subst>
                      <aSubMap/>                      
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </assume>
                  <tqExpr>
                    <let kind="a">
                      <id/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </let>
                    <Subst>
                      <aSubMap/>                      
                      <type num="2"/>
                    </Subst>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              Cases TE-TQEXPR and TE-LET-&alpha;-TQ are similar.
            </p>
          </li>
        </ol>
      </sect3>
      <!-- <sect3 id="TE-soundness-corollary">
      <title>LEMMA: Corollary to Soundness Theorem</title>
      <p>
      <btypes:TYPE>
      <text content="If "/>
      <TEjudge>
      <assume>
      <gamma/>
      <store/>
    </assume>
      <conclude>
      <tqExpr>
      <aExpr/>
      <type/>
    </tqExpr>
    </conclude>
      <constrain>
      <aCtset/>
    </constrain>
    </TEjudge>
      <text content=" and "/>
      <models name="UNF">
      <nothing/>
      <canonical>
      <aCtset/>
    </canonical>
    </models>
      <text content=" then "/>          
      <Exists/>
      <text content=" a substitution "/>                      
      <aSubMap/>
      <text content=" such that "/>          
      <Sjudge>
      <assume>
      <Subst>
      <aSubMap/>
      <gamma/>
    </Subst>
      <Subst>
      <aSubMap/>
      <store/>
    </Subst>
    </assume>
      <tqExpr>
      <aExpr/>
      <Subst>
      <aSubMap/>
      <type/>
    </Subst>
    </tqExpr>
    </Sjudge>
      <text content="."/>
    </btypes:TYPE>      
    </p>
      <p>
      <leadin>Proof:</leadin>
      Follows from Theorem&nbsp;<xref ref="TE-soundness"/> and the
      definition of unification.
    </p>
    </sect3> -->
    </sect2>
    <sect2 id="infer">
      <title>Inference with Eager Unification</title> 
      <btypes:TYPE>
        <grammar>
          <bnf desc="Types">
            <type/>
            <alternatives>
	      <text content="..."/>
            </alternatives>
          </bnf>
          <bnfc desc="Maybe Type">
            <alternatives>
              <mbpair>
                <type/>
		<type dash="'"/>
              </mbpair>              
            </alternatives>
          </bnfc>
        </grammar>
      </btypes:TYPE>      
      <p>
        While performing eager unification, we cannot always infer a
        mutable type and later apply subsumption to obtain a less
        mutable type in favor of polymorphism. This is because, we must
        differentiate between types whose mutability is fixed (equality
        constraint due to the TE-SET rule) or, we have inferred a
        mutable type that is subject to change (copy coercion
        constraint). In order to achieve this, we maintain compatibility
        constraints on types themselves. 
        We write
        <btypes:TYPE>
          <mbpair>
            <type/>
            <type dash="'"/>
          </mbpair>
        </btypes:TYPE> as a shorthand for the constrained type
        <btypes:TYPE>
          <ctype>
            <type/>
            <set>
              <ceq>
                <type/>
                <type dash="'"/>
              </ceq>
            </set>
          </ctype>
        </btypes:TYPE>. We can think of the type 
        <btypes:TYPE>
          <mbpair>
            <type/>
	    <type dash="'"/>
          </mbpair>
        </btypes:TYPE> as a ``maybe type'' 
        <btypes:TYPE>
          <type/>
        </btypes:TYPE>
        which must be copy compatible but not necessarily equal to the
        type 
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE>. The type
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE> is used as a hint to default the mutability of
        <btypes:TYPE>
          <type/>
        </btypes:TYPE>, unless it gets automatically fixed as a result
        of unification.
        In out language we <em>only</em> have maybe-mutability
        constraints, but we will still continue to use the
        constrained type notation
        <btypes:TYPE>
          <ctype>
            <type/>
            <aCtset/>
          </ctype>
        </btypes:TYPE>
        in some cases while expressing generic mathematical properties
        over constrained types.
      </p>
      <xi:include href="include/formal/hm-infer.xmli"/>
      <p>
        The inference judgment 
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
              <tape/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
              <tape dash="'"/>              
            </propagate>
          </TIjudge>
        </btypes:TYPE>
        should be understood as: given the stack (binding) context
        <btypes:TYPE><gamma/></btypes:TYPE> and heap (store) context
        <btypes:TYPE><store/></btypes:TYPE>, we can infer the type 
        <btypes:TYPE><type/></btypes:TYPE> for the expression 
        <btypes:TYPE><aExpr/></btypes:TYPE>.
        <btypes:TYPE><aSubMap/></btypes:TYPE> is list of substitutions 
        obtained as a result of unifications performed in the process
        of inference, which must be propagate to further
        derivations.  We thread a tape of type variables   
        <btypes:TYPE><tape/></btypes:TYPE> through the derivations (as
        in <cite ref="vaughanHM"/>) so that fresh type variables can
        be introduced reliably. 
        <btypes:TYPE><tape/></btypes:TYPE> is a tape that supplies
        fresh type variables. 
        <btypes:TYPE><tape
            dash="'"/></btypes:TYPE> is the tape rolled past the
        current derivation. Also, we write
        <btypes:TYPE>
          <roll>
            <tape/>
            <tvars name="alpha"/>
          </roll>
        </btypes:TYPE> to denote denotes the tape that is rolled past
        the type variables     
        <btypes:TYPE>
          <tvars name="alpha"/>
        </btypes:TYPE>.
        Hindley Milner style inference rules are shown in 
        Table&nbsp;<xref ref="hm_infer"/>.
      </p>
      <p>
	The TI-LAMBDA rule uses
	the meta-constructors defined above to infer a
	normalized type for functions. The TI-APP rule infers copy
	compatible types by introducing maybe types at three
	positions &mdash; the function type itself (by unifying 
	<btypes:TYPE>
	  <Subst>
	    <aSubMap num="2"/>
	    <type num="1"/>
	  </Subst>
	</btypes:TYPE> and
	<btypes:TYPE>
	  <mbpair>
	    <tvar name="beta"/>
	    <fn>
	      <floor>
		<tvar name="delta"/>
	      </floor>
	      <ceil>
		<tvar name="alpha"/>
	      </ceil>
	    </fn>
	  </mbpair>
	</btypes:TYPE>), the argument type (by unifying 
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE> with 
	<btypes:TYPE>
	  <mbpair>
	    <tvar name="gamma"/>
	    <floor>
	      <Subst>
		<aSubMap/>
		<tvar name="delta"/>
	      </Subst>
	    </floor>
	  </mbpair>
	</btypes:TYPE>) and the return type (through
	<btypes:TYPE>
	  <mbpair>
	    <tvar name="epsiv"/>
	    <Subst>
	      <aSubMap num="2" dash="'"/>			      
	      <type/>
	    </Subst>
	  </mbpair>
	</btypes:TYPE>).
	Computing the type
	<btypes:TYPE>
	  <type/>
	</btypes:TYPE> shows how the the hint for the result
	of an application is calculated. We start with an
	immutable version of the return type
	<btypes:TYPE>
	  <minz>
	    <Subst>
	      <aSubMap/>
	      <tvar name="alpha"/>
	    </Subst>
	  </minz>
	</btypes:TYPE>.
	<btypes:TYPE>
	  <tvars name="thetas"/>
	</btypes:TYPE> is the set of type variables that appear in
	the return type of the function but not in its argument
	type. We constrain 
	<btypes:TYPE>
	  <tvars name="thetas"/>
	</btypes:TYPE>
	to be immutable by shallow substitution with 
	<btypes:TYPE>
	  <plural>
	    <floor>
	      <tvar name="thetas"/>
	    </floor>
	  </plural>
	</btypes:TYPE>. This ensures that mutability not 
	induced by the argument does not affect the return
	type. Later unification with  
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE> ensures that the mutability
	induced by the actual argument is preserved in the
	hint. Similarly, the TI-IF rule infers copy compatible types
	for the two branches and the result. It calculates the most
	immutable type as the hint for the result type by computing
	the <em>join</em>&nbsp;<cite ref="pierce2002TypesBook"/> of 
	<btypes:TYPE>
	  <Subst>
	    <aSubMap dash="'"/>
	    <type num="2"/>
	  </Subst>
	  <text content=" and "/>
	  <Subst>
	    <aSubMap dash="'"/>
	    <type num="3"/>
	  </Subst>
	</btypes:TYPE> (note that two copy compatible types always
	have a join). Other rules are similar.
      </p>      
    </sect2>
    <sect2>
      <title>Unification</title>
      <p>
        The unification judgment
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>                  
            <type num="2"/>
            <aSubMap/>
          </UNIFY>
        </btypes:TYPE>
        is understood as 
        <btypes:TYPE>
          <type num="1"/>                  
        </btypes:TYPE>
        unifies with (can be transformed to structurally equal) 
        <btypes:TYPE>
          <type num="2"/>
        </btypes:TYPE>
        under the substitution
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>.
        Eager unification rules can be found in 
        Table&nbsp;<xref ref="hm_unify"/>. Definitions for some
        auxiliary functions used by the unifier are given in 
        Table&nbsp;<xref ref="hm_unify_aux"/>.       
      </p>
      <xi:include href="include/formal/hm-unify.xmli"/>
      <xi:include href="include/formal/hm-unify.aux.xmli"/>
      <p>
	The unification judgment
	<btypes:TYPE>
	  <UNIFY>
	    <type num="1"/>                  
	    <type num="2"/>
	    <aSubMap/>
	  </UNIFY>
	</btypes:TYPE>
	is understood as 
	<btypes:TYPE>
	  <type num="1"/>                  
	</btypes:TYPE>
	unifies with
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE>
	under the substitution
	<btypes:TYPE>
	  <aSubMap/>
	</btypes:TYPE>. The interesting cases are U-CT1 and
	U-CT2. U-CT1 shown the unification of a maybe type 
	<btypes:TYPE>
	  <mbpair>
	    <type num="1"/>
	    <type num="1" dash="'"/>
	  </mbpair>
	</btypes:TYPE> 
	with an unconstrained type  
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE>. In this case, an immutable version of the
	constraint is extracted by the 
	<btypes:TYPE>
	  <inner/>
	</btypes:TYPE> operator, and is unified with an immutable
	version of 
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE>. Once compatibility is established, we unify
	the type 
	<btypes:TYPE>
	  <type num="1"/>
	</btypes:TYPE> to equal 
	<btypes:TYPE>
	  <type num="2"/>
	</btypes:TYPE>.  U-CT2 shows the unification of two maybe
	types. After establishing compatibility, 
	we unify the actual types  
	<btypes:TYPE>
	  <type num="1"/>
	</btypes:TYPE> and 
	<btypes:TYPE>
	  <type num="2"/> 
	</btypes:TYPE> so that they ultimately resolve to the same
	type. 
      </p>	
      <p>
        The function 
	<btypes:TYPE>
	  <Xform name="real" isEntity="yes">
            <type/>
          </Xform>          
	</btypes:TYPE> transforms a type
  	<btypes:TYPE>
          <type/>
	</btypes:TYPE> into an equivalent canonical form where all
	meta constructors are made explicit at all structural levels
	of 
  	<btypes:TYPE>
          <type/>
	</btypes:TYPE>. Strictly speaking, unified types are equal
	only under the
	<btypes:TYPE>
	  <Xform name="real" isEntity="yes"/>
          <nothing/>
          <text content="relationship"/>
	</btypes:TYPE>. However, since   
	<btypes:TYPE>
          <equiv>
            <Xform name="real" isEntity="yes">
              <type/>
            </Xform>   
            <type/>
          </equiv>
	</btypes:TYPE>, we will just say that unified types are
	equal. 
      </p>
    </sect2>
    <sect2>
      <title>Solving Copy Compatibility Constraints</title>
      <p>
        The judgment 
        <btypes:TYPE>
          <Sjudge name="solve">
            <assume>
              <aSubMap/>
              <id/>
              <aExpr/>
            </assume>
            <corUp>
              <type num="1"/>
              <type num="2"/>
            </corUp>
          </Sjudge>
        </btypes:TYPE>
        should be read as: the (possibly) constrained type 
        <btypes:TYPE>
          <type num="1"/>
        </btypes:TYPE>
        for the identifier
        <btypes:TYPE>
          <id/>
        </btypes:TYPE>
        (possibly) used in the expression
        <btypes:TYPE>
          <aExpr/>
        </btypes:TYPE>
        is transformed<footnote><p>This transformation can be thought
            of as a (safe) coercion. Hence the use of the operator 
            <btypes:TYPE>
              <corUpOp/>
            </btypes:TYPE>.
          </p>
        </footnote>
        to the unconstrained type
        <btypes:TYPE>
          <type num="2"/>
        </btypes:TYPE>
        by solving all the copy compatibility constraints in
        <btypes:TYPE>
          <type num="1"/>
        </btypes:TYPE>. The 
        <btypes:TYPE>
          <judgeOp name="solve"/>
        </btypes:TYPE> rule fixes the top-level mutability of an
        ``open'' type by examining whether
        <btypes:TYPE>
          <id/>
        </btypes:TYPE>
        is the target of an assignment in the expression
        <btypes:TYPE>
          <aExpr/>
        </btypes:TYPE>. 
        The judgment         
        <btypes:TYPE>
          <judgeOp name="sol"/>
        </btypes:TYPE> will actually solve the constraints, either
        trivially (there are no constraints, or the constraints have
        already been solved by unification), or by unifying the type
        with the constraint.  
        Rules for solving copy compatibility constraints can be found
        in Table&nbsp;<xref ref="hm_solve"/>. 
        The relation 
        <btypes:TYPE>
	  <models name="consistent">
            <assume/>
	    <mbpair>
	      <type num="1"/>
	      <type num="2"/>
	    </mbpair>
	  </models>
        </btypes:TYPE> is defined in 
        Section&nbsp;<xref ref="consistent-constrained-types"/>.
      </p>
      <xi:include href="include/formal/hm-solve.xmli"/>
    </sect2>
    <sect2>
      <title>Soundness of Eager Inference</title>
      <sect3 id="normalized-ctr-types">
        <title>DEFINITION: Normalization of Constrained Types</title>
        <p>
          The eager unification algorithm maintains constraints on
          types. However, these can be written in a normal form as
          in the case of equational inference so that all constraints
          only appear on the outermost type. For example:          
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <eq>
                <mbpair>
                  <tvar name="alpha"/>
                  <ref>
                    <mbpair>
                      <tvar name="beta"/>
                      <type/>
                    </mbpair>
                  </ref>
                </mbpair>
                <ctype>
                  <tvar name="alpha"/>
                  <set>
                    <ceq>
                      <tvar name="alpha"/>
                      <ref>
                        <paren>
                          <ctype>
                            <tvar name="beta"/>
                            <set>
                              <ceq>
                                <tvar name="beta"/>
                                <type/>
                              </ceq>
                            </set>
                          </ctype>                            
                        </paren>
                      </ref>
                    </ceq>
                  </set>
                </ctype>
              </eq>
              <br/>
              <eq>
                <nothing/>
                <ctype>
                  <tvar name="alpha"/>
                  <set>
                    <ceq>
                      <tvar name="alpha"/>
                      <ref>
                        <tvar name="beta"/>
                      </ref>
                    </ceq>
                    <ceq>
                      <tvar name="beta"/>
                      <type/>
                    </ceq>
                  </set>
                </ctype>
              </eq>
              <br/>
              <equiv>
                <nothing/>
                <ctype>
                  <tvar name="alpha"/>
                  <set>
                    <Tsub>
                      <tvar name="alpha"/>
                      <tvar name="gamma"/>
                    </Tsub>
                    <Tsub>
                      <ref>
                        <tvar name="beta"/>
                      </ref>
                      <tvar name="gamma"/>
                    </Tsub>
                    <Tsub>
                      <tvar name="beta"/>
                      <tvar name="delta"/>
                    </Tsub>
                    <Tsub>
                      <type/>
                      <tvar name="delta"/>
                    </Tsub>
                  </set>
                </ctype>
              </equiv>
            </btypes:TYPE>
          </p>          
        </example>        
        <p>
          Therefore we define a normalization of inferred types as: 
          <btypes:TYPE>
            <eq>              
              <normalize>
                <type/>
              </normalize>
              <ctype>
                <canonical>
                  <type/>
                </canonical>
                <aCtset/>
              </ctype>
            </eq>
          </btypes:TYPE>, wherein:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <canonical>
                  <type/>
                </canonical>
              </btypes:TYPE>
              contains no constraints within it.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <aCtset/>
              </btypes:TYPE> only contains copy coercion or equality
              constraints.
            </p>
          </li>
          <li>
            <p>
              All meta-constructors in 
              <btypes:TYPE>
                <canonical>
                  <type/>
                </canonical>
              </btypes:TYPE>      
              are fully interpreted using the equivalences defined in
              section&nbsp;<xref ref="metaCT"/>. 
              That is, the type  
              <btypes:TYPE>
                <canonical>
                  <type/>
                </canonical>
              </btypes:TYPE> contains no meta-constructors.          
            </p>
          </li>
        </ol>
        <p>
          We write  
          <btypes:TYPE>
            <eq>
              <normalize>
                <type/>
              </normalize>
              <canonical>
                <type/>
              </canonical>
            </eq>
          </btypes:TYPE> if
          <btypes:TYPE>
            <eq>              
              <normalize>
                <type/>
              </normalize>
              <ctype>
                <canonical>
                  <type/>
                </canonical>
                <aCtset/>
              </ctype>
            </eq>
          </btypes:TYPE>, and 
          <btypes:TYPE>
            <aCtset/>
          </btypes:TYPE> consists only of tautological constraints. 
        </p>
      </sect3>
      <sect3>
        <title>DEFINITION: Normalization of Constraint Sets</title>
	<p>
          A constraint set 
          <btypes:TYPE>
            <canonical>
              <aCtset/>
            </canonical>
          </btypes:TYPE> is said to be the normalized form of 
          <btypes:TYPE>
	    <aCtset/>
          </btypes:TYPE> 
          (that is, 
          <btypes:TYPE>
            <eq>              
              <normalize>
                <aCtset/>
              </normalize>
              <canonical>
                <aCtset/>
              </canonical>
            </eq>
          </btypes:TYPE>) if:          
        </p>
        <ul>
          <li>
            <p>
              Let 
              <btypes:TYPE>
                <aCtset dash="'"/>
              </btypes:TYPE> be a set of constraints equivalent to  
              <btypes:TYPE>
                <aCtset/>
              </btypes:TYPE>, but expressed only using subtype and
              equality constraints.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <canonical>
                    <aCtset/>
                  </canonical>
                  <pred name="close">
                    <aCtset dash="'"/>
                  </pred>
                </eq>
              </btypes:TYPE>.
              That is, 
              <btypes:TYPE>
                <canonical>
                  <aCtset/>
                </canonical>
              </btypes:TYPE>
              is written as a set of atomic constraints by using the 
              copy coercion rules defined in Table&nbsp;<xref
                ref="sub_rules"/> (note that this conversion is total).
              Further, all transitive relationships are explicitly added
            </p>
          </li>
        </ul>
      </sect3>
      <sect3>
        <title>DEFINITION: Normalization of Contexts</title>
	<p>
          The binding context 
          <btypes:TYPE>
            <canonical>
              <gamma/>
            </canonical>
          </btypes:TYPE> is said to be the normalized form of 
          <btypes:TYPE>
	    <gamma/>
          </btypes:TYPE> 
          (that is, 
          <btypes:TYPE>
            <eq>              
              <normalize>
                <gamma/>
              </normalize>
              <canonical>
                <gamma/>
              </canonical>
            </eq>
          </btypes:TYPE>) if          
          <btypes:TYPE>
            <Forall>
              <in>
                <tqExpr>
                  <id/>
                  <type/>
                </tqExpr>
                <gamma/>
              </in>
            </Forall>
            <text content=", "/>
            <in>
              <tqExpr>
                <id/>
                <canonical>
                  <type/>
                </canonical>
              </tqExpr>
              <canonical>
                <gamma/>
              </canonical>
            </in>
            <text content=" and "/>
            <eq>
              <normalize>
                <type/>
              </normalize>
              <canonical>
                <type/>
              </canonical>
            </eq>
          </btypes:TYPE>.
        </p>
	<p>
          Similarly, the store context 
          <btypes:TYPE>
            <canonical>
              <store/>
            </canonical>
          </btypes:TYPE> is said to be the normalized form of 
          <btypes:TYPE>
	    <store/>
          </btypes:TYPE> 
          (that is, 
          <btypes:TYPE>
            <eq>              
              <normalize>
                <store/>
              </normalize>
              <canonical>
                <store/>
              </canonical>
            </eq>
          </btypes:TYPE>) if          
          <btypes:TYPE>
            <Forall>
              <in>
                <tqExpr>
                  <hLoc/>
                  <type/>
                </tqExpr>
                <store/>
              </in>
            </Forall>
            <text content=", it is true that "/>
            <in>
              <tqExpr>
                <hLoc/>
                <canonical>
                  <type/>
                </canonical>
              </tqExpr>
              <canonical>
                <store/>
              </canonical>
            </in>
            <text content=" and "/>
            <eq>
              <normalize>
                <type/>
              </normalize>
              <canonical>
                <type/>
              </canonical>
            </eq>
            <text content="; and "/>
            <Forall>
              <in>
                <tqExpr>
                  <sLoc/>
                  <type/>
                </tqExpr>
                <store/>
              </in>
            </Forall>
            <text content=", it is true that "/>
            <in>
              <tqExpr>
                <sLoc/>
                <canonical>
                  <type/>
                </canonical>
              </tqExpr>
              <canonical>
                <store/>
              </canonical>
            </in>
            <text content=", and "/>
            <eq>
              <normalize>
                <type/>
              </normalize>
              <canonical>
                <type/>
              </canonical>
            </eq>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="solvable-entities">
        <title>DEFINITION: Solvable Entities</title>
        <btypes:TYPE>
          <grammar>
            <bnf desc="Solvable Entities">
              <solvable/>
              <alternatives>
                <type/>
                <gamma/>
                <store/>
                <plus>
                  <solvable/>
                  <solvable/>
                </plus>
              </alternatives>
            </bnf>
          </grammar>
        </btypes:TYPE>
	<p>
          Note that:
        </p>
        <ol>
          <li>
            <p>              
              Normalization is defined on all atomic solvable
              entities. We add the rule: If
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <solvable num="1"/>
                  </normalize>
                  <constrained>
                    <canonical>
                      <solvable num="1"/>
                    </canonical>
                    <aCtset num="1"/>
                  </constrained>
                </eq>
                <text content=" and "/>
                <eq>                  
                  <normalize>
                    <solvable num="2"/>
                  </normalize>
                  <constrained>
                    <canonical>
                      <solvable num="2"/>
                    </canonical>
                    <aCtset num="2"/>
                  </constrained>
                </eq>
                <text content=" then "/>                
                <eq>
                  <normalize>
                    <plus>
                      <solvable num="1"/>
                      <solvable num="2"/>
                    </plus>
                  </normalize>
                  <constrained>
                    <plus>
                      <canonical>
                        <solvable num="1"/>
                      </canonical>                      
                      <canonical>
                        <solvable num="2"/>
                      </canonical>
                    </plus>
                    <unin>
                      <aCtset num="1"/>
                      <aCtset num="2"/>
                    </unin>
                  </constrained>                  
                </eq>
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              As usual, we write
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <solvable/>
                  </normalize>
                  <canonical>
                    <solvable/>
                  </canonical>
                </eq>
              </btypes:TYPE>
              if 
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <solvable/>
                  </normalize>
                  <constrained>
                    <canonical>
                      <solvable/>
                    </canonical>
                    <aCtset/>
                  </constrained>
                </eq>
              </btypes:TYPE>
              where
              <btypes:TYPE>                
                <aCtset/>
              </btypes:TYPE>
              consists only of tautological constraints.
            </p>
          </li>
          <li>
            <p>
              Substitution is defined on all atomic solvable
              entities. We define:
              <btypes:TYPE>
                <eq>
                  <Subst>
                    <aSubMap/>
                    <plus>
                      <solvable num="1"/>
                      <solvable num="2"/>
                    </plus>
                  </Subst>
                  <plus>
                    <Subst>
                      <aSubMap/>
                      <solvable num="1"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <solvable num="2"/>
                    </Subst>
                  </plus>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              For the sake of brevity, we write
              <btypes:TYPE>
                <eq>
                  <plus>
                    <Empty/>
                    <solvable/>
                  </plus>
                  <plus>
                    <solvable/>
                    <Empty/>
                  </plus>
                  <solvable/>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              Definition of 
              <btypes:TYPE>
                <subeqOp/>
              </btypes:TYPE>
              over solvable entities:
            </p>
            <ol>
              <li>
                <p>
                  <btypes:TYPE>
                    <subeq>
                      <type/>
                      <type dash="'"/>
                    </subeq>
                  </btypes:TYPE>
                  if the type  
                  <btypes:TYPE>
                    <type/>
                    <text content=" is structurally a part "/>
                    <text content="of the type "/>
                    <type dash="'"/>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  <btypes:TYPE>
                    <subeq>
                      <gamma/>
                      <gamma dash="'"/>
                    </subeq>
                  </btypes:TYPE>
                  if  
                  <btypes:TYPE>
                    <gamma dash="'"/>
                  </btypes:TYPE>
                  contains all the mappings in 
                  <btypes:TYPE>
                    <gamma/>
                  </btypes:TYPE>, and possibly more.
                </p>
              </li>
              <li>
                <p>
                  <btypes:TYPE>
                    <subeq>
                      <store/>
                      <store dash="'"/>
                    </subeq>
                  </btypes:TYPE>
                  if 
                  <btypes:TYPE>
                    <store dash="'"/>
                  </btypes:TYPE>
                  contains all the mappings in 
                  <btypes:TYPE>
                    <store/>
                  </btypes:TYPE>, and possibly more.
                </p>
              </li>              
              <li>
                <p>
                  <btypes:TYPE>
                    <subeq>
                      <plus>
                        <solvable num="1"/>
                        <solvable num="2"/>
                      </plus>
                      <plus>
                        <solvable num="1" dash="'"/>
                        <solvable num="2" dash="'"/>
                      </plus>
                    </subeq>
                  </btypes:TYPE>
                  if 
                  <btypes:TYPE>
                    <subeq>
                      <solvable num="1"/>
                      <solvable num="1" dash="'"/>
                    </subeq>
                    <text content=" and "/>
                    <subeq>
                      <solvable num="2"/>
                      <solvable num="2" dash="'"/>
                    </subeq>
                  </btypes:TYPE>.                  
                </p>
              </li> 
            </ol>
          </li>          
          <li>
            <p>
              Definition of 
              <btypes:TYPE>
                <supeqOp/>
              </btypes:TYPE>
              over solvable entities:
            </p>
            <ol>
              <li>
                <p>
                  <btypes:TYPE>
                    <supeq>
                      <type/>
                      <type dash="'"/>
                    </supeq>
                  </btypes:TYPE>
                  if the type  
                  <btypes:TYPE>
                    <type dash="'"/>
                    <text content=" is structurally a part "/>
                    <text content="of the type "/>
                    <type/>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  <btypes:TYPE>
                    <supeq>
                      <gamma/>
                      <gamma dash="'"/>
                    </supeq>
                  </btypes:TYPE>
                  if
                  <btypes:TYPE>
                    <gamma/>
                  </btypes:TYPE>
                  contains all the mappings in 
                  <btypes:TYPE>
                    <gamma dash="'"/>
                  </btypes:TYPE>, and possibly more.
                </p>
              </li>
              <li>
                <p>
                  <btypes:TYPE>
                    <supeq>
                      <store/>
                      <store dash="'"/>
                    </supeq>
                  </btypes:TYPE>
                  if 
                  <btypes:TYPE>
                    <store/>
                  </btypes:TYPE>
                  contains all the mappings in 
                  <btypes:TYPE>
                    <store dash="'"/>
                  </btypes:TYPE>, and possibly more.
                </p>
              </li>              
              <li>
                <p>
                  <btypes:TYPE>
                    <supeq>
                      <plus>
                        <solvable num="1"/>
                        <solvable num="2"/>
                      </plus>
                      <plus>
                        <solvable num="1" dash="'"/>
                        <solvable num="2" dash="'"/>
                      </plus>
                    </supeq>
                  </btypes:TYPE>
                  if 
                  <btypes:TYPE>
                    <supeq>
                      <solvable num="1"/>
                      <solvable num="1" dash="'"/>
                    </supeq>
                    <text content=" and "/>
                    <supeq>
                      <solvable num="2"/>
                      <solvable num="2" dash="'"/>
                    </supeq>
                  </btypes:TYPE>.                  
                </p>
              </li> 
            </ol>
          </li>     
        </ol>
      </sect3>
      <sect3 id="consistent-constrained-types">
        <title>DEFINITION: Consistency of Solvable Entities</title>
        A (possibly) constrained type or context 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>
        is said to be consistent, that is,
        <btypes:TYPE>
          <models name="consistent">
            <assume/>
            <solvable/>
          </models>
        </btypes:TYPE>
        iff
        <btypes:TYPE>
          <eq>
            <normalize>
              <solvable/>
            </normalize>
            <constrained>
              <canonical>
                <solvable/>
              </canonical>
              <aCtset/>
            </constrained>
          </eq>
          <text content=" and "/>
          <models name="consistent">
            <assume/>
            <canonical>
              <aCtset/>
            </canonical>
          </models>
        </btypes:TYPE>.
      </sect3>
      <sect3 id="reachable-store">
        <title>DEFINITION: Reachable Store</title>
        <p>
          We define
          <btypes:TYPE>
            <relevant>
              <store/>
              <collection etc="yes">
                <aExpr num="1"/>
                <aExpr num="2"/>                
              </collection>
            </relevant>
          </btypes:TYPE>
          as a store such that 
          <btypes:TYPE>
            <subeq>
              <Subst>
                <relevant>
                  <store/>
                  <collection etc="yes">
                    <aExpr num="1"/>
                    <aExpr num="2"/>                
                  </collection>
                </relevant>
                <store/>
              </Subst>
            </subeq>
          </btypes:TYPE>
          and 
          <btypes:TYPE>
            <relevant>
              <store/>
              <collection etc="yes">
                <aExpr num="1"/>
                <aExpr num="2"/>                
              </collection>
            </relevant>
          </btypes:TYPE>
          contains mappings for <em>only</em>
          those locations that are reachable from
          <btypes:TYPE>
            <collection etc="yes">
              <aExpr num="1"/>
              <aExpr num="2"/>                
            </collection>
          </btypes:TYPE>
          (that is, the location is syntactically a part of 
          <btypes:TYPE>
            <collection etc="yes">
              <aExpr num="1"/>
              <aExpr num="2"/>                
            </collection>
          </btypes:TYPE>).
        </p>
      </sect3>
      <sect3 id="MTVs">
        <title>DEFINITION: MTVs</title>
        <p>
          We define the function 
          <btypes:TYPE>
            <fnxn name="MTVS">
              <solvable/>
              <tvars name="alpha"/>
            </fnxn>
          </btypes:TYPE> to be the set of all type variables within
          the solvable entity 
          <btypes:TYPE>
            <solvable/>
          </btypes:TYPE>. That is, it returns the set of all
          type-variables 
          <btypes:TYPE>
            <tvars name="alpha"/>
          </btypes:TYPE> where  
          <btypes:TYPE>
            <tvar name="alpha"/>
          </btypes:TYPE> occurs within a maybe type as 
          <btypes:TYPE>
            <mbpair>
              <tvar name="alpha"/>
              <type num="h"/>
            </mbpair>            
          </btypes:TYPE>.
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <fnxn name="MTVS">
                <tvar name="alpha"/>
                <empty/>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <unit/>
                <empty/>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <bool/>
                <empty/>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <mbpair>
                  <tvar name="alpha"/>
                  <type num="h"/>
                </mbpair>                            
                <unin>
                  <tvar name="alpha"/>
                  <pred name="MTVS">
                    <type num="h"/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <mbpair>
                  <type/>
                  <type num="h"/>
                </mbpair>                            
                <pred name="MTVS">
                  <type/>
                </pred>
              </fnxn>
              <text content=" where "/>
              <neq>
                <type/>
                <tvar name="alpha"/>
              </neq>
              <br/>
              <fnxn name="MTVS">
                <ref>
                  <type/>
                </ref>                            
                <pred name="MTVS">
                  <type/>
                </pred>
              </fnxn>              
              <br/>
              <fnxn name="MTVS">
                <mutable>
                  <type/>
                </mutable>                            
                <pred name="MTVS">
                  <type/>
                </pred>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>                            
                <unin>
                  <pred name="MTVS">
                    <type num="1"/>
                  </pred>
                  <pred name="MTVS">
                    <type num="2"/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <Empty/>
                <empty/>
              </fnxn>
              <text content=" (empty context)."/>
              <br/>
              <fnxn name="MTVS">
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="MTVS">
                    <gamma/>
                  </pred>
                  <pred name="MTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <extend>
                  <store/>
                  <tqExpr>
                    <hLoc/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="MTVS">
                    <store/>
                  </pred>
                  <pred name="MTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <extend>
                  <store/>
                  <tqExpr>
                    <sLoc/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="MTVS">
                    <store/>
                  </pred>
                  <pred name="MTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="MTVS">
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
                <unin>                  
                  <pred name="MTVS">
                    <solvable num="1"/>
                  </pred>
                  <pred name="MTVS">
                    <solvable num="2"/>
                  </pred>
                </unin>
              </fnxn>
            </btypes:TYPE>
          </p>
        </example>              
      </sect3>
      <sect3 id="ext-ftvs">
        <title>DEFINITION: FTVs (Extension)</title>
        <p>
          We need to enhance the definition of FTVS as:
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <text content="..."/>
              <br/>
              <eq>
                <ftvs>
                  <mbpair>
                    <type num="1"/>
                    <type num="2"/>
                  </mbpair>
                </ftvs>
                <unin>
                  <ftvs>
                    <type num="1"/>
                  </ftvs>
                  <ftvs>
                    <inner>
                      <type num="2"/>
                    </inner>
                  </ftvs>
                </unin>
              </eq>
              <br/>
              <eq>
                <ftvs>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </ftvs>                
                <unin>                  
                  <ftvs>
                    <solvable num="1"/>
                  </ftvs>
                  <ftvs>
                    <solvable num="2"/>
                  </ftvs>
                </unin>
              </eq>              
            </btypes:TYPE>.
          </p>
        </example>
      </sect3>
      <sect3 id="NTVs">
        <title>DEFINITION: NTVs</title>
        <p>
          We define the set of unconstrained variables as:
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <fnxn name="NTVS">
                <tvar name="alpha"/>
                <set>
                  <tvar name="alpha"/>
                </set>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <unit/>
                <empty/>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <bool/>
                <empty/>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <mbpair>
                  <tvar name="alpha"/>
                  <type num="h"/>
                </mbpair>                            
                <pred name="NTVS">
                  <type num="h"/>
                </pred>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <mbpair>
                  <type/>
                  <type num="h"/>
                </mbpair>                            
                <pred name="NTVS">
                  <type/>
                </pred>
              </fnxn>
              <text content=" where "/>
              <neq>
                <type/>
                <tvar name="alpha"/>
              </neq>
              <br/>
              <fnxn name="NTVS">
                <ref>
                  <type/>
                </ref>                            
                <pred name="NTVS">
                  <type/>
                </pred>
              </fnxn>              
              <br/>
              <fnxn name="NTVS">
                <mutable>
                  <type/>
                </mutable>                            
                <pred name="NTVS">
                  <type/>
                </pred>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>                            
                <unin>
                  <pred name="NTVS">
                    <type num="1"/>
                  </pred>
                  <pred name="NTVS">
                    <type num="2"/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <Empty/>
                <empty/>
              </fnxn>
              <text content=" (empty context)."/>
              <br/>
              <fnxn name="NTVS">
                <extend>
                  <gamma/>
                  <tqExpr>
                    <id/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="NTVS">
                    <gamma/>
                  </pred>
                  <pred name="NTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <extend>
                  <store/>
                  <tqExpr>
                    <hLoc/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="NTVS">
                    <store/>
                  </pred>
                  <pred name="NTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <extend>
                  <store/>
                  <tqExpr>
                    <sLoc/>
                    <type/>
                  </tqExpr>
                </extend>
                <unin>
                  <pred name="NTVS">
                    <store/>
                  </pred>
                  <pred name="NTVS">
                    <type/>
                  </pred>
                </unin>
              </fnxn>
              <br/>
              <fnxn name="NTVS">
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
                <unin>                  
                  <pred name="NTVS">
                    <solvable num="1"/>
                  </pred>
                  <pred name="NTVS">
                    <solvable num="2"/>
                  </pred>
                </unin>
              </fnxn>
            </btypes:TYPE>
          </p>
        </example>              
      </sect3>
      <sect3 id="TVs">
        <title>DEFINITION: TVs</title>
        <p>
          The set of all type variables in a solvable entity is given
          by TVS() function, defined as follows: Note that this
          function is different from FTVS().
          (see Definition&nbsp;<xref ref="ext-ftvs"/>. 
        </p>
        <example>
          <p>
            <btypes:TYPE>
              <fnxn name="TVS">
                <solvable/>
                <unin>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                  <pred name="NTVS">
                    <solvable/>
                  </pred>
                </unin>
              </fnxn>
            </btypes:TYPE>
          </p>
        </example>
      </sect3>
      <sect3 id="sol-entities">
        <title>DEFINITION: 
          <btypes:TYPE><Sjudge name="sol"/></btypes:TYPE></title>        
        <p>
          We write 
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <type/>
            </Sjudge>
          </btypes:TYPE>
          to mean that the substitution is 
          <btypes:TYPE>
            <aSubMap/>
          </btypes:TYPE>
          is obtained by solving the copy compatibility constraints in  
          <btypes:TYPE>
            <type/>
          </btypes:TYPE>. We define solving all solvable entities as
          follows: 
        </p>
        <btypes:TYPE>
          <Hrules vspace="yes">
            <tyRule name="S-EMPTY-CTX">
              <tyPre/>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <Empty/>
                  </assume>
                  <Empty/>
                </Sjudge>
              </tyConc>
            </tyRule>
            <tyRule name="S-EMPTY-TYPE">
              <tyPre>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <corUp>
                    <type/>
                    <type dash="''"/>
                  </corUp>
                </Sjudge>              
              </tyPre>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <type/>
                </Sjudge>              
              </tyConc>             
            </tyRule>
            <tyRule name="S-GAMMA">
              <tyPre>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <type/>
                </Sjudge>              
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap num="1"/>
                    <gamma/>
                  </Subst>
                </Sjudge>              
              </tyPre>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <compose>
                      <aSubMap num="1"/>
                      <aSubMap num="2"/>
                    </compose>
                  </assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id/>
                      <type/>
                    </tqExpr>
                  </extend>
                </Sjudge>
              </tyConc>
            </tyRule>
          </Hrules>
          <Hrules vspace="yes">
            <tyRule name="S-STORE-HL">
              <tyPre>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <type/>
                </Sjudge>              
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap num="1"/>
                    <store/>
                  </Subst>
                </Sjudge>              
              </tyPre>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <compose>
                      <aSubMap num="1"/>
                      <aSubMap num="2"/>
                    </compose>
                  </assume>
                  <extend>
                    <store/>
                    <tqExpr>
                      <hLoc/>
                      <type/>
                    </tqExpr>
                  </extend>
                </Sjudge>
              </tyConc>
            </tyRule>
            <tyRule name="S-STORE-SL">
              <tyPre>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <type/>
                </Sjudge>              
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap num="1"/>
                    <store/>
                  </Subst>
                </Sjudge>              
              </tyPre>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <compose>
                      <aSubMap num="1"/>
                      <aSubMap num="2"/>
                    </compose>
                  </assume>
                  <extend>
                    <store/>
                    <tqExpr>
                      <sLoc/>
                      <type/>
                    </tqExpr>
                  </extend>
                </Sjudge>
              </tyConc>
            </tyRule>
            <tyRule name="S-MULTIPLE">
              <tyPre>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <solvable num="1"/>
                </Sjudge>              
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap num="1"/>
                    <solvable num="2"/>
                  </Subst>
                </Sjudge>              
              </tyPre>
              <tyConc>
                <Sjudge name="sol">
                  <assume>
                    <compose>
                      <aSubMap num="1"/>
                      <aSubMap num="2"/>
                    </compose>
                  </assume>                  
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>                  
                </Sjudge>
              </tyConc>
            </tyRule>
          </Hrules>
        </btypes:TYPE>
      </sect3>
      <sect3 id="sol-math">
        <title>DEFINITION: 
          <btypes:TYPE><models name="sol"/></btypes:TYPE></title>
        <btypes:TYPE>
          <Hrules vspace="yes">
            <tyRule>
              <tyPre>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>
                <eq>
                  <aSubMap/>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="o"/>
                  </compose>
                </eq>
                <eq>
                  <dom>
                    <aSubMap num="s"/>
                  </dom>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                </eq>
                <eq>
                  <Subst>
                    <aSubMap num="o"/>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <solvable/>
                      </Subst>
                    </canonical>
                  </Subst>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>
              </tyPre>
              <tyConc>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>
              </tyConc>
            </tyRule>
          </Hrules>
        </btypes:TYPE>            
        <p>
          That is, 
          <btypes:TYPE>
            <aSubMap/>
          </btypes:TYPE> solves all copy compatibility
          constraints in  
          <btypes:TYPE>
            <solvable/>
          </btypes:TYPE>, but does not otherwise affect the resultant
          <btypes:TYPE>
            <canonical>
              <Subst>
                <aSubMap/>
                <solvable/>
              </Subst>
            </canonical>
          </btypes:TYPE>. It is, however, free to contain other
          substitutions that do not matter wrt
          <btypes:TYPE>
            <canonical>
              <Subst>
                <aSubMap/>
                <solvable/>
              </Subst>
            </canonical>
          </btypes:TYPE>.
          Note that 
          <btypes:TYPE>
            <models name="sol"/>
          </btypes:TYPE> is a special case of 
          <btypes:TYPE>
            <models/>
          </btypes:TYPE> and
          <btypes:TYPE>
            <models name="Sol"/>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="cst">
        <title>DEFINITION: Strong Consistency</title>
        <btypes:TYPE>
          <Hrules vspace="yes">
            <tyRule>
              <tyPre>
                <models name="consistent">
                  <assume/>
                  <solvable/>
                </models>
                <eq>
                  <inter>
                    <pred name="MTVS">
                      <solvable/>
                    </pred>
                    <pred name="NTVS">
                      <solvable/>
                    </pred>
                  </inter>
                  <Empty/>
                </eq>
              </tyPre>
              <tyConc>
                <models name="cst">
                  <assume/>
                  <solvable/>
                </models>
              </tyConc>
            </tyRule>
          </Hrules>
        </btypes:TYPE>            
        <p>
          Since we have
          <btypes:TYPE>
            <models name="consistent">
              <assume/> 
              <solvable/>
            </models>
          </btypes:TYPE>, if 
          <btypes:TYPE>
            <mbpair>
              <tvar name="alpha"/>
              <type num="h1"/>
            </mbpair>
          </btypes:TYPE> and
          <btypes:TYPE>
            <mbpair>
              <tvar name="alpha"/>
              <type num="h2"/>
            </mbpair>
          </btypes:TYPE> are structurally a part of
          <btypes:TYPE>
            <solvable/>
          </btypes:TYPE>, we must have
          <btypes:TYPE>
            <ceq>
              <inner>
                <mbpair>
                  <tvar name="alpha"/>
                  <type num="h1"/>
                </mbpair>
              </inner>
              <inner>
                <mbpair>
                  <tvar name="alpha"/>
                  <type num="h2"/>
                </mbpair>
              </inner>
            </ceq>
          </btypes:TYPE>.
          Further, 
          <btypes:TYPE>
            <eq>
              <inter>
                <pred name="MTVS">
                  <solvable/>
                </pred>
                <pred name="NTVS">
                  <solvable/>
                </pred>
              </inter>
              <Empty/>
            </eq>
          </btypes:TYPE>
          guarantees that constrained type variables do not appear
          unconstrained elsewhere in 
          <btypes:TYPE>
            <solvable/>
          </btypes:TYPE>.
          We call this property strong consistency, denoted by 
          <btypes:TYPE>
            <models name="cst"/>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="compat-subst">
        <title>DEFINITION: Compatible Solutions (Substitutions)</title>
	<p>
          We write 
          <btypes:TYPE>
            <ceq>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </ceq>
            <text content=" if "/>
            <Forall>
              <in>
                <SubMap>
                  <tvar name="alpha"/>
                  <type num="1"/>
                </SubMap>
                <aSubMap num="1"/>
              </in>
            </Forall>
            <text content=", it is true that "/>
            <in>
              <SubMap>
                <tvar name="alpha"/>
                <type num="2"/>
              </SubMap>
              <aSubMap num="2"/>
            </in>
            <text content=" (that is,"/>
            <eq>
              <dom>
                <aSubMap num="1"/>
              </dom>
              <dom>
                <aSubMap num="2"/>
              </dom>
            </eq>
            <text content="), and "/>
            <ceq>
              <type num="1"/>
              <type num="2"/>
            </ceq>
          </btypes:TYPE>.
	</p>
      </sect3>
      <sect3 id="equiv-subst">
        <title>DEFINITION: Equivalent Substitutions</title>
	<p>
          We write 
          <btypes:TYPE>
            <Sjudge name="eqi">
              <assume>
                <solvable/>
              </assume>              
              <approx>
                <aSubMap num="1"/>
                <aSubMap num="2"/>
              </approx>
            </Sjudge>
            <text content=" if "/>
            <eq>
              <Subst>
                <aSubMap num="1"/>
                <solvable/>
              </Subst>
              <Subst>
                <aSubMap num="2"/>
                <solvable/>
              </Subst>            
            </eq>
          </btypes:TYPE>
	</p> 
        <p>
          For example:
          <btypes:TYPE>            
            <Sjudge name="eqi">
              <assume>
                <tvar name="alpha"/>
              </assume>              
              <approx>
                <SubMap>
                  <tvar name="alpha"/>
                  <type/>
                </SubMap>
                <compose>
                  <SubMap>                  
                    <tvar name="alpha"/>
                    <tvar name="beta"/>
                  </SubMap>
                  <SubMap>
                    <tvar name="beta"/>
                    <type/>
                  </SubMap>
                </compose>
              </approx>
            </Sjudge>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="sub-subst">
        <title>DEFINITION: Sub-Substitutions</title>
        <ol>
          <li>
            <p>
              We write           
              <btypes:TYPE>
                <subeq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </subeq>
                <text content=" if "/>
                <Exists>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </Exists>
                <text content=" such that "/>            
                <eq>
                  <aSubMap/>
                  <compose>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </compose>
                </eq>
                <text content=", and "/>
                <eq>
                  <aSubMap dash="'"/>
                  <aSubMap num="1"/>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              We write           
              <btypes:TYPE>
                <spEq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </spEq>
                <text content=" if "/>
                <Exists>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </Exists>
                <text content=" such that "/>            
                <eq>
                  <aSubMap/>
                  <compose>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </compose>
                </eq>
                <text content=", and "/>
                <ceq>
                  <aSubMap dash="'"/>
                  <aSubMap num="1"/>
                </ceq>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="TI-unify-correct">
        <title>THEOREM: Correctness of Eager Unification</title>
        <p>
          If
          <btypes:TYPE>
            <eq>
              <normalize>
                <type num="1"/>
              </normalize>
              <ctype>
                <canonical>
                  <type num="1"/>
                </canonical>
                <aCtset num="1"/>
              </ctype>
            </eq>            
            <text content=", and "/>
            <eq>
              <normalize>
                <type num="2"/>
              </normalize>
              <ctype>
                <canonical>
                  <type num="2"/>
                </canonical>		
                <aCtset num="2"/>
              </ctype>
            </eq>
            <text content=", and "/>
            <UNIFY>
              <type num="1"/>
              <type num="2"/>              
              <aSubMap/>
            </UNIFY>
          </btypes:TYPE>, then:          
        </p>
        <ol>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="UNF">   
                  <nothing/>
                  <canonical>
                    <aCtset num="1"/>
                  </canonical>
                </models>          
                <text content=" and "/>
                <models name="UNF">   
                  <nothing/>
                  <canonical>
                    <aCtset num="2"/>
                  </canonical>
                </models>          
                <text content=", then "/>
                <models name="UNF">   
                  <nothing/>
                  <canonical>
                    <unin>
                      <set>
                        <eq>
                          <canonical>
                            <type num="1"/>
                          </canonical>
                          <canonical>
                            <type num="2"/>
                          </canonical>
                        </eq>
                      </set> 
                      <aCtset num="1"/>
                      <aCtset num="2"/>
                    </unin>
                  </canonical>
                </models>                          
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="consistent">   
                  <nothing/>
                  <type num="1"/>
                </models>          
                <text content=" and "/>
                <models name="consistent">   
                  <nothing/>
                  <type num="2"/>
                </models>          
                <text content=" then "/>
                <models name="consistent">   
                  <nothing/>
                  <plus>
                    <Subst>
                      <aSubMap/>
                      <type num="1"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <type num="2"/>
                    </Subst>
                  </plus>
                </models> 
                <text content=" and "/>
                <models name="acyclic">   
                  <nothing/>
                  <aSubMap/>
                </models> 
              </btypes:TYPE>
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="TI-solve-correct">
        <title>THEOREM: Correctness of the Constraint Solver</title>
        <p>
          If
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <solvable/>
            </Sjudge>              
          </btypes:TYPE>,
          then 
          <btypes:TYPE>
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <solvable/>
            </models>              
          </btypes:TYPE>.
        </p>
        <p>
          We will also use the following equivalent forms (or special
          cases of the above statement): 
        </p>
        <ol>
          <li>
            <p>
              If
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </Sjudge>              
              </btypes:TYPE>,
              then 
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </models>              
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </Sjudge>              
              </btypes:TYPE>,
              then 
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If          
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <corUp>
                    <type/>
                    <type dash="'"/>
                  </corUp>
                </Sjudge>
                <text content=" then "/>
                <eq>
                  <normalize>
                    <type dash="'"/>
                  </normalize>
                  <canonical>
                    <type dash="'"/>
                  </canonical>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="TI-solve-total">
        <title>THEOREM: Totality of the Constraint Solver</title>
        <ol>
          <li>
            <p>
              If          
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <solvable/>
                </models>
                <text content=" then "/>
                <Exists>
                  <aSubMap/>
                </Exists>
                <text content=" such that "/>            
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If          
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>
                <text content=" then "/>
                <Exists>
                  <spEq>
                    <aSubMap dash="'"/>
                    <aSubMap/>
                  </spEq>
                </Exists>
                <text content=" such that "/>            
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3>
        <title>THEOREM: Decidability of Unification and Solver</title>
        <p>
          <btypes:TYPE>
            <UNIFY>
              <type num="1"/>
              <type num="2"/>
              <aSubMap/>
            </UNIFY>
            <text content=" and "/>
            <Sjudge name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <corUp>
                <type/>
                <type dash="'"/>
              </corUp>
            </Sjudge>
            <text content=" are decidable."/>
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof: </leadin>
          The unifier and constraint solver builds a solution tree by
          always invoking itself types having <em>smaller</em> shapes
          of types (except for the U-COMMUT rule, but we can consider
          a canonical derivation in which no two U-COMMUT rules are 
          used consecutively in the unification derivation). Since
          types are of bounded size, and there are no 
          infinite or circular substitutions, these derivations must
          be bounded. 
        </p>
      </sect3>
      <sect3 id="sol-math-properties"> 
        <title>LEMMA: Properties of 
          <btypes:TYPE><models name="sol"/></btypes:TYPE></title>
        <ol>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>              
                <text content=" then "/>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </models>              
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </models>              
                <text content=" then "/>
                <Exists>
                  <aSubMap/>
                </Exists>
                <text content=" such that "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>              
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <iff>
                  <models name="sol">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <solvable/>
                  </models>              
                  <eq>
                    <normalize>
                      <Subst>
                        <aSubMap/>
                        <solvable/>
                      </Subst>
                    </normalize>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <solvable/>
                      </Subst>
                    </canonical>
                  </eq>
                </iff>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="eqi-sol-properties">
        <title>LEMMA: Properties of Equivalent Substitutions</title>
        <p>
          <btypes:TYPE>
            <text content = " If "/>            
            <Sjudge name="eqi">
              <assume>
                <solvable/>
              </assume>
              <approx>
                <aSubMap num="1"/>
                <aSubMap num="2"/>
              </approx>
            </Sjudge>
            <text content = ", then:"/>
          </btypes:TYPE>
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <solvable/>
                </models>
                <text content=" implies "/>
                <models name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <solvable/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap num="1"/>
                    <solvable/>
                  </Subst>
                </models>
                <text content=" implies "/>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap num="2"/>
                    <solvable/>
                  </Subst>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <Subst>
                    <aSubMap num="1"/>
                    <solvable/>
                  </Subst>
                </models>
                <text content=" implies "/>
                <models name="cst">
                  <assume/>
                  <Subst>
                    <aSubMap num="2"/>
                    <solvable/>
                  </Subst>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="1"/>
                      <solvable/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>                  
                <text content=" implies "/>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="2"/>
                      <solvable/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap num="2"/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>                  
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof: </leadin> Evident from the definition of
          equivalent substitutions.
        </p>
      </sect3>
      <sect3 id="cst-implies-consistent">
        <title>LEMMA: Strong Consistency Implies Consistency</title>
        <p>
          If
          <btypes:TYPE>
            <models name="cst">
              <assume/> 
              <solvable/>
            </models>
            <text content=", then "/>
            <models name="consistent">
              <assume/> 
              <solvable/>
            </models>
          </btypes:TYPE>.         
        </p>
        <p>
          <leadin>Proof:</leadin> Evident from 
          Definition&nbsp;<xref ref="cst"/>.
        </p>
      </sect3>
      <sect3 id="ctr-compat-properties">
        <title>LEMMA: Properties of 
          Compatible Constrained Types</title>
        <ol>
          <li>
            <p>
              If 
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <type/>
                  </normalize>
                  <canonical>
                    <type/>
                  </canonical>
                </eq>
                <text content=", and "/>
                <eq>
                  <normalize>
                    <type dash="'"/>
                  </normalize>
                  <canonical>
                    <type dash="'"/>
                  </canonical>
                </eq>
                <text content=", and "/>
                <ceq>
                  <type/>
                  <type dash="'"/>
                </ceq>
              </btypes:TYPE>, then 
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <ceil>
                      <type/>
                    </ceil>
                  </canonical>
                  <canonical>
                    <type dash="'"/>
                  </canonical>
                  <canonical>
                    <floor>
                      <type/>
                    </floor>
                  </canonical>                  
                </Tsub>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              If 
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                </eq>
              </btypes:TYPE>, then 
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <ceil>
                      <Subst>
                        <aSubMap/>                            
                        <type/>
                      </Subst>
                    </ceil>
                  </canonical>
                  <canonical>
                    <maxz>
                      <Subst>
                        <aSubMap/>                            
                        <type/>
                      </Subst>
                    </maxz>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <minz>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </minz>
                  </canonical>
                  <canonical>
                    <floor>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </floor>
                  </canonical>
                </Tsub>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              If 
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                </eq>
                <text content=" and "/>
                <subeq>
                  <set>
                    <tvars name="thetas"/>
                  </set>
                  <ftvs>
                    <type/>
                  </ftvs>
                </subeq>
                <text content=" and "/>
                <eq>
                  <type dash="'"/>
                  <Csubst>
                    <type/>
                    <tvars name="thetas"/>
                    <plural>
                      <floor>
                        <tvar name="thetas"/>
                      </floor>
                    </plural>
                  </Csubst>
                </eq>
                <text content=", then "/>
                <Tsub>
                  <canonical>
                    <ceil>
                      <Subst>
                        <aSubMap/>                            
                        <type/>
                      </Subst>
                    </ceil>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type dash="'"/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <minz>
                      <Subst>
                        <aSubMap/>
                        <type dash="'"/>
                      </Subst>
                    </minz>
                  </canonical>
                </Tsub>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              If 
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                </eq>
                <text content=" and "/>
                <subeq>
                  <set>
                    <tvars name="thetas"/>
                  </set>
                  <ftvs>
                    <type/>
                  </ftvs>
                </subeq>
                <text content=" and "/>
                <eq>
                  <type dash="'"/>
                  <Csubst>
                    <type/>
                    <tvars name="thetas"/>
                    <plural>
                      <ceil>
                        <tvar name="thetas"/>
                      </ceil>
                    </plural>
                  </Csubst>
                </eq>
                <text content=", then "/>
                <Tsub>
                  <canonical>
                    <maxz>
                      <Subst>
                        <aSubMap/>
                        <type dash="'"/>
                      </Subst>
                    </maxz>
                  </canonical>                  
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type dash="'"/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <floor>
                      <Subst>
                        <aSubMap/>                            
                        <type/>
                      </Subst>
                    </floor>
                  </canonical>
                </Tsub>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof:</leadin> Evident from the definition of
          copy coercion relationships in 
          Section&nbsp;<xref ref="copy_coercions"/>.
        </p>
      </sect3>            
      <sect3 id="coequal-solve-OK">
        <title>LEMMA: Relationship of Solutions</title>
        <p>
          If
          <btypes:TYPE>
            <models name="sol">
              <assume>
                <aSubMap num="1"/>
              </assume>
              <solvable/>
            </models>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap num="2"/>
              </assume>
              <solvable/>
            </models>
            <text content = " then  "/>
            <Exists>
              <aSubMap num="11"/>
              <aSubMap num="12"/>
              <aSubMap num="21"/>
              <aSubMap num="22"/>
            </Exists>
            <text content = " such that "/>
          </btypes:TYPE>
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <aSubMap num="1"/>
                  <compose>
                    <aSubMap num="11"/>
                    <aSubMap num="12"/>
                  </compose>
                </eq>
                <text content = " and  "/>
                <eq>
                  <aSubMap num="2"/>
                  <compose>
                    <aSubMap num="21"/>
                    <aSubMap num="22"/>
                  </compose>
                </eq>           
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <dom>
                    <aSubMap num="11"/>
                  </dom>
                  <dom>
                    <aSubMap num="21"/>
                  </dom>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <ceq>
                  <aSubMap num="11"/>
                  <aSubMap num="21"/>              
                </ceq>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <Subst>
                    <aSubMap num="12"/>
                    <canonical>
                      <solvable/>
                    </canonical>
                  </Subst>
                  <Subst>
                    <aSubMap num="22"/>
                    <canonical>
                      <solvable/>
                    </canonical>
                  </Subst>
                  <canonical>
                    <solvable/>
                  </canonical>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="unique-solve-solutions">
        <title>LEMMA: Uniqueness of Solutions Produced by the
          Solver</title> 
	<p>
          If
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap num="1"/>
              </assume>
              <solvable/>
            </Sjudge>
            <text content=" and "/>
            <Sjudge name="sol">
              <assume>
                <aSubMap num="2"/>
              </assume>
              <solvable/>
            </Sjudge>
            <text content=", then "/>
            <eq>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </eq>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="solve-sol-compat">
        <title>LEMMA: Relationship between 
          <btypes:TYPE><Sjudge name="solve"/></btypes:TYPE> and  
          <btypes:TYPE><Sjudge name="sol"/></btypes:TYPE></title>
        <p>
          If
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap num="1"/>
              </assume>
              <corUp>
                <type/>
                <type dash="'"/>
              </corUp> 
            </Sjudge>           
            <text content=" and "/>
            <Sjudge name="solve">
              <assume>
                <aSubMap num="2"/>
                <id/>
                <aExpr/>
              </assume>
              <corUp>
                <type/>
                <type dash="''"/>
              </corUp> 
            </Sjudge>
            <text content=" then "/>
            <ceq>
              <type dash="'"/>
              <type dash="''"/>
            </ceq>
            <text content=" and "/>
            <ceq>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </ceq>            
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="sol-plus-commut">
        <title>LEMMA: Commutativity 
          of<btypes:TYPE><plus><nothing/><nothing/></plus></btypes:TYPE>over
          Solvable Entities</title>
        <ol>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <solvable num="2"/>
                    <solvable num="1"/>
                  </plus>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </Sjudge>
                <text content=" then "/>
                <Exists>
                  <ceq>
                    <aSubMap dash="'"/>
                    <aSubMap/>
                  </ceq>
                </Exists>
                <text content=" such that "/>            
                <Sjudge name="sol">
                  <assume>
                    <aSubMap dash="'"/>
                  </assume>
                  <plus>
                    <solvable num="2"/>
                    <solvable num="1"/>
                  </plus>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="consistent">
                  <assume/>
                  <plus>
                    <solvable num="2"/>
                    <solvable num="1"/>
                  </plus>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable num="2"/>
                    <solvable num="1"/>
                  </plus>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="solvable-weakening">
        <title>LEMMA: Weakening over Solvable Entities</title>
        <ol>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="consistent">
                  <assume/>
                  <solvable num="1"/>
                </models>
                <text content=" and "/>
                <models name="consistent">
                  <assume/>
                  <solvable num="2"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <solvable/>
                </models>
                <text content=" and "/>
                <subeq>
                  <solvable dash="'"/>
                  <solvable/>
                </subeq>  
                <text content=" then "/>
                <models name="consistent">
                  <assume/>
                  <solvable dash="'"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="cst">
                  <assume/>
                  <solvable num="1"/>
                </models>
                <text content=" and "/>
                <models name="cst">
                  <assume/>
                  <solvable num="2"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <solvable/>
                </models>
                <text content=" and "/>
                <subeq>
                  <solvable dash="'"/>
                  <solvable/>
                </subeq>  
                <text content=" then "/>
                <models name="cst">
                  <assume/>
                  <solvable dash="'"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <solvable/>
                    </Subst>
                  </canonical>
                </eq>
                <text content=" and "/>
                <subeq>
                  <solvable dash="'"/>
                  <solvable/>
                </subeq>  
                <text content=", then "/>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <solvable dash="'"/>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <solvable dash="'"/>
                    </Subst>
                  </canonical>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <Exists>
                  <subeq>
                    <aSubMap dash="'"/>
                    <aSubMap/>
                  </subeq>
                </Exists>
                <text content=" and "/>
                <Exists>
                  <subeq>
                    <aSubMap dash="''"/>
                    <aSubMap/>
                  </subeq>
                </Exists>
                <text content=" such that "/>
                <models name="sol">
                  <assume>
                    <aSubMap dash="'"/>
                  </assume>
                  <solvable num="1"/>
                </models>
                <text content=" and "/>
                <models name="sol">
                  <assume>
                    <aSubMap dash="''"/>
                  </assume>
                  <solvable num="2"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>
                <text content=" and "/>
                <subeq>
                  <solvable dash="'"/>
                  <solvable/>
                </subeq>  
                <text content=", then "/>
                <Exists>
                  <subeq>
                    <aSubMap dash="'"/>
                    <aSubMap/>
                  </subeq>
                </Exists>
                <text content=" such that "/>
                <models name="sol">
                  <assume>
                    <aSubMap dash="'"/>
                  </assume>
                  <solvable dash="'"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" and "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <solvable num="1"/>
                    <solvable num="2"/>
                  </plus>
                </models>
                <text content=" then "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable num="1"/>
                </models>
                <text content=" and "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable num="2"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              If
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable/>
                  </plus>
                </models>
                <text content=" and "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable/>
                </models>
                <text content=" and "/>
                <subeq>
                  <solvable dash="'"/>
                  <solvable/>
                </subeq>  
                <text content=", then "/>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <solvable dash="'"/>
                </models>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="T-Weakening-ext">
        <title>LEMMA: Extension to 
          Weakening Lemma&nbsp;<xref ref="T-Weakening"/>.</title>
        <p>
          If 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <gamma/>
                </canonical>
                <canonical>
                  <store/>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <type/>
                </canonical>
              </tqExpr>
            </Sjudge>                
            <text content=" and "/>
            <supeq>
              <gamma dash="'"/>
              <gamma/>
            </supeq>
            <text content=" and "/>
            <supeq>
              <store dash="'"/>
              <store/>
            </supeq>
            <text content=" and "/>
            <eq>
              <normalize>
                <gamma dash="'"/>
              </normalize>
              <canonical>
                <gamma dash="'"/>
              </canonical>
            </eq>
            <text content=" and "/>
            <eq>
              <normalize>
                <store dash="'"/>
              </normalize>
              <canonical>
                <store dash="'"/>
              </canonical>
            </eq>            
            <text content=", then, "/>
            <Sjudge>
              <assume>
                <canonical>
                  <gamma dash="'"/>
                </canonical>
                <canonical>
                  <store dash="'"/>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <type/>
                </canonical>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="cst-sust">
        <title>LEMMA: Substitution on 
          Strongly Compatible Entities</title>
	<p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <plus>
                    <solvable num="f"/>
                    <solvable/>
                    <solvable num="s"/>
                  </plus>
                </models>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <models name="cst">
                  <assume/>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </models>
              </btypes:TYPE>
              for some substitution 
              <btypes:TYPE>
                <aSubMap/>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>                
                <subeq>
                  <inter>
                    <dom>
                      <aSubMap/>
                    </dom>
                    <pred name="TVS">
                      <plus>
                        <solvable num="f"/>
                        <solvable/>
                        <solvable num="s"/>
                      </plus>
                    </pred>                    
                  </inter>                    
                  <pred name="TVS">
                    <solvable/>
                  </pred>                    
                </subeq>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
        <p>
          Then, 
          <btypes:TYPE>
            <models name="cst">
              <assume/>
              <Subst>
                <aSubMap/>                
                <plus>
                  <solvable num="f"/>
                  <solvable/>
                  <solvable num="s"/>
                </plus>
              </Subst>
            </models>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof:</leadin> 
          From assumption (3), we know that only substitutions in 
          <btypes:TYPE>                
            <aSubMap/>
          </btypes:TYPE> that can affect 
          <btypes:TYPE>                
            <plus>
              <solvable num="f"/>
              <solvable/>
              <solvable num="s"/>
            </plus>
          </btypes:TYPE>
          are substitutions to type variables that are present in 
          <btypes:TYPE>                
            <solvable/>
          </btypes:TYPE>.
          From the definition of strong solubility, we know that all
          constrained types are compatibly constrained throughout the
          solvable entity. Therefore a substitution for some type
          variable within  
          <btypes:TYPE>
            <solvable/>
          </btypes:TYPE> cannot violate the strong consistency of
          <btypes:TYPE>
            <plus>
              <solvable num="f"/>
              <solvable/>
              <solvable num="s"/>
            </plus>
          </btypes:TYPE>. 
        </p>
        <p>
          Note that
          <btypes:TYPE>
            <solvable num="f"/>
            <text content=" or "/>
            <solvable num="s"/>
            <text content=" need not always present since"/>
            <text content=" we can imagine the presence of "/>
            <Empty/>
            <text content=" in that position. "/>
          </btypes:TYPE>            
        </p>
      </sect3>
      <sect3 id="sol-subst-must-be-compat">
        <title>LEMMA: Substitution Preserves 
          Compatibility of Solutions</title>
	<p>
          If
        </p>
        <ol>         
          <li>
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <solvable/>
                </models>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>          
                <models name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>              
                </models>            
                <text content=" for some "/>
                <aSubMap/>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <inter>
                    <dom>
                      <aSubMap num="1"/>
                    </dom>
                    <dom>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                    </dom>
                  </inter>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then,
          <btypes:TYPE>
            <Exists>
              <aSubMap num="1" dash="'"/>
              <aSubMap num="0"/>
            </Exists>
          </btypes:TYPE>
          such that
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <ceq>
                  <aSubMap num="1"/>
                  <aSubMap num="1" dash="'"/>
                </ceq>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="eqi">
                  <assume>
                    <solvable/>
                  </assume>                  
                  <approx>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>                
                    <compose>
                      <aSubMap num="1" dash="'"/>
                      <aSubMap num="0"/>
                    </compose>
                  </approx>
                </Sjudge>
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Proof: </leadin> By construction of 
          <btypes:TYPE>
            <aSubMap num="1" dash="'"/>
            <text content=" and "/>
            <aSubMap num="0"/>
          </btypes:TYPE>.
        </p>
        <ol>
          <li>
            <p>
              For every substitution
              <btypes:TYPE>
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type/>
                  </SubMap>
                  <aSubMap num="1"/>
                </in>
                <text content=", where "/>
                <notin>
                  <tvar name="alpha"/>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                </notin>
                <text content=", add it to "/>
                <aSubMap num="1" dash="'"/>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              For every substitution 
              <btypes:TYPE>
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type/>
                  </SubMap>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                </in>
                <text content=", where "/>
                <notin>
                  <tvar name="alpha"/>
                  <pred name="MTVS">
                    <solvable/>
                  </pred>
                </notin>
                <text content=", add it to "/>
                <aSubMap num="0"/>
              </btypes:TYPE>.
            </p>
          </li>          
          <li>
            <p>
              <btypes:TYPE>
                <Forall>
                  <in>
                    <tvar name="alpha"/>
                    <pred name="MTVS">
                      <solvable/>
                    </pred>
                  </in>
                </Forall>
                <text content=", "/>
                <Exists>                  
                  <in>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type/>
                    </SubMap>
                    <aSubMap num="1"/>
                  </in>
                </Exists>
                <text content=" and "/>
                <Exists>                  
                  <in>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type dash="'"/>
                    </SubMap>
                    <compose>                      
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                  </in>
                </Exists>
                <text content=". If "/>
                <tvar name="alpha"/>
                <text content=" appears within  "/>
                <solvable/>                
                <text content=" in the form  "/>
                <mbpair>
                  <tvar name="alpha"/>
                  <type num="h"/>
                </mbpair>
                <text content=", we must have "/>
                <ceq>
                  <type/>
                  <Subst>
                    <aSubMap num="1"/>
		    <inner>
                      <type num="h"/>
		    </inner>
                  </Subst>
                </ceq>
                <text content=". We must also have "/>
                <ceq>
                  <type dash="'"/>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
		    <inner>
                      <type num="h"/>
    		    </inner>
                  </Subst>
                </ceq>                
              </btypes:TYPE>
            </p>
            <ol>
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <ceq>
                      <type/>
                      <type dash="'"/>
                    </ceq>
                    <text content=", then add "/>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type dash="'"/>
                    </SubMap>
                    <text content=" to "/>                
                    <aSubMap num="1" dash="'"/>
                  </btypes:TYPE>.              
                </p>
              </li> 
              <li>
                <p>
                  If
                  <btypes:TYPE>
                    <nceq>
                      <type/>
                      <type dash="'"/>
                    </nceq>
                  </btypes:TYPE>
                  Since we have
                  <btypes:TYPE>
                    <models name="consistent">
                      <assume/>
                      <Subst>
                        <compose>
                          <aSubMap num="2"/>
                          <aSubMap/>
                        </compose>
                        <solvable/>
                      </Subst>
                    </models>              
                  </btypes:TYPE>
                  (from assumption (2) and 
                  Theorem&nbsp;<xref ref="TI-solve-correct"/>) and the
                  fact that substitution must preserve the shape of a
                  solvable entity, 
                  <btypes:TYPE>                     
                    <type dash="'"/>
                  </btypes:TYPE>
                  can only differ from 
                  <btypes:TYPE>                     
                    <type/>
                  </btypes:TYPE>
                  in top-level mutability, and/or by being a more
                  specialized type (has some substitutions for type
                  variables within 
                  <btypes:TYPE>                     
                    <type/>
                  </btypes:TYPE>).
                  Therefore,                    
                  <btypes:TYPE>
                    <Exists>
                      <aSubMap dash="''"/>
                    </Exists>
                    <text content=" (which possibly uses"/>
                    <text content=" fresh type variables)"/>
                    <text content=" such that the substitution"/>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type dash="'"/>
                    </SubMap>                    
                    <text content=" in "/>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <text content=" can be equivalently"/>                    
                    <text content=" re-written as "/>                    
                    <compose>
                      <SubMap>
                        <tvar name="alpha"/>
                        <type dash="''"/>
                      </SubMap>       
                      <aSubMap dash="''"/>
                    </compose>
                    <text content=" where "/>
                    <ceq>
                      <type/>
                      <type dash="''"/>
                    </ceq>
                    <text content=". Now add "/>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type dash="''"/>
                    </SubMap>       
                    <text content=" to "/>
                    <aSubMap num="1" dash="'"/>
                    <text content=" and "/>
                    <aSubMap dash="''"/>
                    <text content=" to "/>
                    <aSubMap num="0"/>
                    <text content="."/>
                  </btypes:TYPE>.
                </p>
              </li>
            </ol>
          </li>                    
        </ol>
      </sect3>
      <sect3 id="unify-strong-consistent">
        <title>LEMMA: Unification Preserves Strong Consistency</title>
        <p>
          If
          <btypes:TYPE>
            <models name="cst">   
              <nothing/>
              <plus>
                <type num="1"/>
                <type num="2"/>
              </plus>
            </models>          
            <text content=" and "/>
            <UNIFY>
              <type num="1"/>
              <type num="2"/>
              <aSubMap/>
            </UNIFY>
            <text content=" then "/>
            <models name="cst">   
              <nothing/>
              <plus>
                <Subst>
                  <aSubMap/>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <aSubMap/>
                  <type num="2"/>
                </Subst>
              </plus>
            </models> 
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof: </leadin>
          Follows from Theorem&nbsp;<xref ref="TI-unify-correct"/>, and
          by observing the rules U-TVAR, U-CT1 and U-CT2. 
        </p>
      </sect3>
      <sect3 id="unify-strong-consistent-cor">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="unify-strong-consistent"/>.</title>
        <p>
          If
          <btypes:TYPE>
            <models name="cst">
              <assume/>
              <plus>
                <solvable/>
                <type/>
                <type dash="'"/>
              </plus>
            </models>
            <text content=" and "/>
            <UNIFY>
              <type dash="'"/>
              <type/>
              <aSubMap num="v"/>
            </UNIFY>
            <text content=" then "/> 
            <models name="cst">
              <assume/>
              <plus>
                <Subst>
                  <aSubMap num="v"/>                      
                  <solvable/>
                </Subst>
                <Subst>
                  <aSubMap num="v"/>                      
                  <type/>
                </Subst>
                <Subst>
                  <aSubMap num="v"/>                      
                  <type dash="'"/>
                </Subst>
              </plus>
            </models>
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof:</leadin> 
          Follows from 
          Lemma&nbsp;<xref ref="unify-strong-consistent"/> and
          Lemma&nbsp;<xref ref="cst-sust"/>.
        </p>
      </sect3>
      <sect3 id="unify-maybe">
        <title>LEMMA: Unification of Maybe Types</title>
        <p>
          If 
          <btypes:TYPE>
            <UNIFY>
              <type num="1"/>
              <mbpair>
                <type num="0"/>
                <type num="2"/>
              </mbpair>
              <aSubMap num="u"/>
            </UNIFY>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>              
              <plus>
                <Subst>
                  <aSubMap num="u"/>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <aSubMap num="u"/>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </plus>
            </models>
          </btypes:TYPE>,
          then:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <floor>
                      <Subst>
                        <compose>
                          <aSubMap num="u"/>
                          <aSubMap num="s"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </floor>
                  </canonical>
                </Tsub>
                <text content = " and "/>
                <Tsub>
                  <canonical>
                    <ceil>
                      <Subst>
                        <compose>
                          <aSubMap num="u"/>
                          <aSubMap num="s"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </ceil>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                </Tsub>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <minz>
                      <Subst>
                        <compose>
                          <aSubMap num="u"/>
                          <aSubMap num="s"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </minz>
                  </canonical>
                </Tsub>
                <text content = " and "/>
                <Tsub>
                  <canonical>
                    <maxz>
                      <Subst>
                        <compose>
                          <aSubMap num="u"/>
                          <aSubMap num="s"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </maxz>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                </Tsub>	    
              </btypes:TYPE>
            </p>
          </li>
        </ol>
	<p>
	  <leadin>Proof: </leadin> 
          From the definition of maybe types, we have
          <btypes:TYPE>
            <ceq>
              <type num="0"/>
              <type num="2"/>
            </ceq>
          </btypes:TYPE>.
          Due to the unification 
          <btypes:TYPE>
            <UNIFY>
              <type num="1"/>
              <mbpair>
                <type num="0"/>
                <type num="2"/>
              </mbpair>
              <aSubMap num="u"/>
            </UNIFY>
          </btypes:TYPE>, we have
          <btypes:TYPE>
            <ceq>
              <Subst>
                <aSubMap num="u"/>
                <type num="1"/>
              </Subst>
              <Subst>
                <aSubMap num="u"/>
                <type num="2"/>
              </Subst>
            </ceq>
          </btypes:TYPE>.
          From 
          <btypes:TYPE>
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>              
              <plus>
                <Subst>
                  <aSubMap num="u"/>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <aSubMap num="u"/>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </plus>
            </models>
          </btypes:TYPE>
          and Lemma&nbsp;<xref ref="sol-math-properties"/>, we have:
          <btypes:TYPE>
            <models name="consistent">
              <assume/>
              <plus>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </plus>
            </models>
          </btypes:TYPE>
          Therefore, we must have:
          <btypes:TYPE>
            <ceq>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="1"/>
              </Subst>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="2"/>
              </Subst>
            </ceq>
          </btypes:TYPE>.
          Again, from Lemma&nbsp;<xref ref="sol-math-properties"/>, 
          we have:          
          <btypes:TYPE>
            <eq>
              <normalize>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <type num="1"/>
                </Subst>
              </normalize>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <type num="1"/>
                </Subst>
              </canonical>
            </eq>        
            <text content=" and "/>
            <eq>
              <normalize>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </normalize>
              <canonical>
                <Subst>
                  <aSubMap num="u"/>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </canonical>
            </eq>              
          </btypes:TYPE>.
          Since normalization does not violate any properties, we
          have: 
          <btypes:TYPE>
            <ceq>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <type num="1"/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="u"/>
                  <type num="2"/>
                </Subst>
              </canonical>
            </ceq>              
          </btypes:TYPE>.
          The conclusions are now evident from the definition of
          copy coercions in 
          Section&nbsp;<xref ref="copy_coercions"/>.
	</p>
      </sect3>      
      <sect3 id="unify-maybe-cor">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="unify-maybe"/></title>
        <p>
          If 
          <btypes:TYPE>
            <UNIFY>
              <type num="1"/>
              <mbpair>
                <type num="0"/>
                <type num="2"/>
              </mbpair>
              <aSubMap num="u"/>
            </UNIFY>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>              
              <plus>
                <Subst>
                  <compose>
                    <aSubMap/>                  
                    <aSubMap num="u"/>                  
                  </compose>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <compose>
                    <aSubMap/>                  
                    <aSubMap num="u"/>                  
                  </compose>
                  <mbpair>
                    <type num="0"/>
                    <type num="2"/>
                  </mbpair>
                </Subst>
              </plus>
            </models>
          </btypes:TYPE>,
          then:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <floor>
                      <Subst>
                        <compose>
                          <aSubMap num="s"/>
                          <aSubMap/>
                          <aSubMap num="u"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </floor>
                  </canonical>
                </Tsub>
                <text content = " and "/>
                <Tsub>
                  <canonical>
                    <ceil>
                      <Subst>
                        <compose>
                          <aSubMap num="s"/>
                          <aSubMap/>
                          <aSubMap num="u"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </ceil>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                </Tsub>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Tsub>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                    </Subst>
                  </canonical>
                  <canonical>
                    <minz>
                      <Subst>
                        <compose>
                          <aSubMap num="s"/>
                          <aSubMap/>
                          <aSubMap num="u"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </minz>
                  </canonical>
                </Tsub>
                <text content = " and "/>
                <Tsub>
                  <canonical>
                    <maxz>
                      <Subst>
                        <compose>
                          <aSubMap num="s"/>
                          <aSubMap/>
                          <aSubMap num="u"/>
                        </compose>
                        <type num="2"/>
                      </Subst>
                    </maxz>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="1"/>
                    </Subst>
                  </canonical>
                </Tsub>	    
              </btypes:TYPE>
            </p>
          </li>
        </ol>
	<p>
	  <leadin>Proof: </leadin> Straightforward extension to 
          Lemma&nbsp;<xref ref="unify-maybe"/>.          
	</p>
      </sect3>      
      <sect3 id="inf-subst-valid">
        <title>LEMMA: Inferred Substitutions are Consistent.</title>
        <p>
          If
          <btypes:TYPE>
            <TIjudge>
              <assume>
                <gamma/>
                <store/>
                <tape/>
              </assume>
              <conclude>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </conclude>
              <propagate>
                <aSubMap num="u"/>
                <tape dash="'"/>              
              </propagate>
            </TIjudge>                
          </btypes:TYPE>,
          then 
          <btypes:TYPE>
            <models name="cst">
              <assume/>
              <plus>
                <Subst>
                  <aSubMap num="u"/>                      
                  <gamma/>
                </Subst>
                <Subst>
                  <aSubMap num="u"/>                      
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </Subst>
                <type/>
              </plus>
            </models>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof: </leadin> By induction on the derivation of 
          <btypes:TYPE>
            <TIjudge>
              <assume>
                <gamma/>
                <store/>
                <tape/>
              </assume>
              <conclude>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </conclude>
              <propagate>
                <aSubMap num="u"/>
                <tape dash="'"/>              
              </propagate>
            </TIjudge>                
          </btypes:TYPE> using 
          Lemma&nbsp;<xref ref="unify-strong-consistent"/>, and noting the
          fact that (1) all substitutions produced during inference are in
          turn produced by the unifier (or the solver) (2) all maybe
          types in the inference rules are introduced with fresh type variables
          (3) the two parts of a maybe type are never separated from
          each other.
        </p>
        <p>
          Since the store
          <btypes:TYPE>            
            <store/>
          </btypes:TYPE>
          can contain arbitrary typing assumptions in addition to the
          ones required for this derivation, we define the property on
          a canonicalized subset of the store.
        </p>
      </sect3>
      <sect3 id="inf-subst-valid-add">
        <title>LEMMA: Inferred Substitutions are 
          Cumulatively Consistent.</title>
        <p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <TIjudge>
                  <assume>
                    <gamma/>
                    <store/>
                    <tape/>
                  </assume>
                  <conclude>
                    <tqExpr>
                      <aExpr num="1"/>
                      <type num="1"/>
                    </tqExpr>
                  </conclude>
                  <propagate>
                    <aSubMap num="u1"/>
                    <tape dash="'"/>              
                  </propagate>
                </TIjudge>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <TIjudge>
                  <assume>
                    <Subst>
                      <aSubMap num="u1"/>                      
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u1"/>                      
                      <store/>
                    </Subst>
                    <tape dash="'"/>
                  </assume>
                  <conclude>
                    <tqExpr>
                      <aExpr num="2"/>
                      <type num="2"/>
                    </tqExpr>
                  </conclude>
                  <propagate>
                    <aSubMap num="u2"/>
                    <tape dash="''"/>              
                  </propagate>
                </TIjudge>                
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then 
          <btypes:TYPE>
            <models name="cst">
              <assume/>
              <plus>
                <Subst>
                  <compose>
                    <aSubMap num="u2"/>                      
                    <aSubMap num="u1"/>                      
                  </compose>
                  <gamma/>
                </Subst>
                <Subst>
                  <compose>
                    <aSubMap num="u2"/>                      
                    <aSubMap num="u1"/>                      
                  </compose>                  
                  <relevant>
                    <store/>
                    <collection>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </collection>
                  </relevant>
                </Subst>                
                <Subst>
                  <aSubMap num="u2"/>                      
                  <type num="1"/>
                </Subst>
                <type num="2"/>
              </plus>
            </models>
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof:</leadin> 
          Since 
          <btypes:TYPE>
            <aSubMap num="u2"/>                  
          </btypes:TYPE> is obtained in an environment that already
          has applied the substitutions in
          <btypes:TYPE>
            <aSubMap num="u1"/>                  
          </btypes:TYPE>, and since this derivation occurs on a
          different tape,
          <btypes:TYPE>
            <aSubMap num="u1"/>                  
            <text content=" and "/>
            <aSubMap num="u2"/>                  
          </btypes:TYPE> contain mutually exclusive substitutions.     
        </p>
        <p>
          The only effect 
          <btypes:TYPE>
            <aSubMap num="u2"/>                  
          </btypes:TYPE>
          can have on 
          <btypes:TYPE>
            <type num="1"/>
          </btypes:TYPE> is by providing a substitution for some
          type variable 
          <btypes:TYPE>
            <tvar name="alpha"/>
          </btypes:TYPE>
          which is a non-universally quantified free type variables in 
          <btypes:TYPE>
            <Subst>
              <aSubMap num="u1"/>                  
              <gamma/>
            </Subst>
          </btypes:TYPE> and is present in 
          <btypes:TYPE>
            <type num="1"/>
          </btypes:TYPE>.
          The result now follows from 
          Lemma&nbsp;<xref ref="inf-subst-valid"/> and
          Lemma&nbsp;<xref ref="cst-sust"/>.
        </p>
      </sect3>
      <sect3 id="ctr-subst-decl">
        <title>LEMMA: Substitution on Declarative Derivation
          [Extension to Lemma&nbsp;<xref ref="decl-sub"/>].</title>
        <p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <gamma/>
                    </canonical>
                    <canonical>
                      <store/>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <type/>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <aSubMap/>
              </btypes:TYPE>
              is some substitution such that
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap/>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </canonical>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then,
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE> 
        </p>
        <p>
          <leadin>Proof:</leadin> 
          Straightforward extension to 
          Lemma&nbsp;<xref ref="decl-sub"/>. 
        </p>
      </sect3>
      <sect3 id="ctr-subst-decl-cor">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="ctr-subst-decl"/>.</title>
        <p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <gamma/>
                    </canonical>
                    <canonical>
                      <store/>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <type/>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <aSubMap/>
              </btypes:TYPE>
              is some substitution such that
              <btypes:TYPE>
                <models name="consistent">
                  <assume/>
                  <Subst>
                    <aSubMap/>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </models>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then,
          <btypes:TYPE>
            <Exists>
              <aSubMap num="e"/>
            </Exists>
          </btypes:TYPE>
          such that:
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="e"/>
                      <aSubMap/>
                    </compose>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="e"/>
                      <aSubMap/>
                    </compose>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="e"/>
                      <aSubMap/>
                    </compose>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE> 
        </p>
        <p>
          <leadin>Proof:</leadin> 
          Straightforward extension to 
          Lemma&nbsp;<xref ref="ctr-subst-decl"/>.
          The extra substitution
          <btypes:TYPE>
            <aSubMap num="e"/>
          </btypes:TYPE>
          is necessary to solve any constraints introduced by the
          substitution 
          <btypes:TYPE>
            <aSubMap/>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="relevant-subst-only">
        <title>LEMMA: Elimination of Irrelevant Substitutions.</title>
        <p>
          If:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>               
            </p>
          </li>          
        </ol>
        <p>
          Then, 
          <btypes:TYPE>
            <Exists>
              <subeq>
                <aSubMap dash="'"/>
                <aSubMap/>
              </subeq>
            </Exists>
            <text content=" such that "/>
            <models name="sol">
              <assume>
                <aSubMap dash="'"/>
              </assume>
              <plus>
                <type/>
                <gamma/>
                <relevant>
                  <store/>
                  <aExpr/>
                </relevant>
              </plus>
            </models>
            <text content=" and "/>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap dash="'"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap dash="'"/>
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap dash="'"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof:</leadin> Follows from 
          Lemma&nbsp;<xref ref="solvable-weakening"/> and
          by observing the declarative type rules in
          Table&nbsp;<xref ref="decl_type_rules"/>.
        </p>
      </sect3>
      <sect3 id="eqi-subst-decl-ok">
        <title>LEMMA: Equivalent Substitutions 
          Preserve Declarative Derivation.</title>
        <p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="eqi">
                  <assume>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </assume>
                  <approx>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </approx>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="2"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap num="2"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="2"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>
        </p>
        <p>
          <leadin>Proof: </leadin>
          From Definition&nbsp;<xref ref="equiv-subst"/>, we have
          <btypes:TYPE>
            <eq>
              <Subst>
                <aSubMap num="1"/>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </Subst>
              <Subst>
                <aSubMap num="2"/>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </Subst>            
            </eq>
          </btypes:TYPE>. That is,
          <btypes:TYPE>
            <eq>
              <Subst>
                <aSubMap num="1"/>
                <type/>
              </Subst>
              <Subst>
                <aSubMap num="2"/>
                <type/>
              </Subst>
            </eq>
            <text content=" and "/>
            <eq>
              <Subst>
                <aSubMap num="1"/>
                <gamma/>
              </Subst>
              <Subst>
                <aSubMap num="2"/>
                <gamma/>
              </Subst>
            </eq>
            <text content=" and "/>
            <eq>
              <Subst>
                <aSubMap num="1"/>
                <store/>
              </Subst>
              <Subst>
                <aSubMap num="2"/>
                <store/>
              </Subst>
            </eq>
          </btypes:TYPE>.
          The result is now evident from assumption (2).
        </p>
      </sect3>
      <sect3 id="compat-subst-decl-ok">
        <title>LEMMA: Compatible Substitutions 
          Preserve Declarative Derivation.</title>
        <p>
          If
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <ceq>
                  <aSubMap num="s"/>
                  <aSubMap num="s" dash="'"/>
                </ceq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then,
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof: </leadin>
          From Definition&nbsp;<xref ref="sol-math"/>, we know that
          <btypes:TYPE>
            <eq>
              <aSubMap num="s"/>
              <compose>
                <aSubMap num="m"/>
                <aSubMap num="o"/>
              </compose>
            </eq>
          </btypes:TYPE>
          where
          <btypes:TYPE>
            <aSubMap num="m"/>
          </btypes:TYPE>
          contains substitutions to
          <btypes:TYPE>
            <pred name="MTVS">
              <plus>
                <type/>
                <gamma/>
                <store/>
              </plus>
            </pred>
          </btypes:TYPE>
          and
          <btypes:TYPE>
            <aSubMap num="o"/>
          </btypes:TYPE>
          is irrelevant to
          <btypes:TYPE>
            <canonical>
              <plus>
                <type/>
                <gamma/>
                <store/>
              </plus>
            </canonical>
          </btypes:TYPE>.
          From the definition of compatibility of substitutions,
          <btypes:TYPE>
            <aSubMap num="s" dash="'"/>
          </btypes:TYPE>
          must have compatible substitutions to <em>only</em> these
          type variables. The required result can be obtained by
          straightforward induction on the derivation of
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>
          </btypes:TYPE>.
        </p>
      </sect3>
      <sect3 id="compat-subst-decl-ok-cor1">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>.</title> 
        <p>
          If
        </p>
        <ol>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="s" dash="'"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>                
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then, 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="s" dash="'"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof: </leadin>
          Follows from 
          Lemma&nbsp;<xref ref="coequal-solve-OK"/> and
          Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>.          
        </p>
      </sect3>
      <sect3 id="compat-subst-decl-ok-cor2">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor1"/>.</title> 
        <p>
          If
        </p>
        <ol>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="e"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </plus>
                </models>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="e"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="e"/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>                          
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="e"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>                
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then, 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE>.
        </p>
        <p>
          <leadin>Proof: </leadin>
        </p>
        <ol>
          <li>
            <p>
              From assumption (3), the fact that 
              <btypes:TYPE>
                <subeq>
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                  <store/>
                </subeq>
              </btypes:TYPE>, and 
              Lemma&nbsp;<xref ref="solvable-weakening"/>, 
              we conclude that 
              <btypes:TYPE>
                <Exists>
                  <subeq>
                    <aSubMap num="s" dash="'"/>                    
                    <aSubMap num="s"/>
                  </subeq>
                </Exists>
                <text content=" such that "/>
                <models name="sol">
                  <assume>
                    <aSubMap num="s" dash="'"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </plus>
                </models>                
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              From assumption (2) and (3) and case (1) above, and               
              Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor1"/>, 
              we have          
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>.
            </p>
          </li> 
          <li>
            <p>
              From case (1), we can write:
              <btypes:TYPE>
                <eq>
                  <aSubMap num="s"/>
                  <compose>
                    <aSubMap num="o"/>
                    <aSubMap num="s" dash="'"/>                    
                  </compose>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              From assumption (3) and 
              Lemma&nbsp;<xref ref="sol-math-properties"/>, we have              
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="s"/>                      
                      <plus>
                        <gamma/>
                        <store/>
                        <type/>
                      </plus>
                    </Subst>
                  </normalize>                      
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>                      
                      <plus>
                        <gamma/>
                        <store/>
                        <type/>
                      </plus>
                    </Subst>                    
                  </canonical>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              Since we have:
              <btypes:TYPE>
                <subeq>
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                  <store/>                  
                </subeq>
              </btypes:TYPE>,              
              (and thus               
              <btypes:TYPE>
                <subeq>
                  <Subst>
                    <aSubMap num="s"/>                                          
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <store/>                  
                  </Subst>
                </subeq>
              </btypes:TYPE>),              
              from case (4) and
              Lemma&nbsp;<xref ref="solvable-weakening"/>, we obtain
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="s"/>                      
                      <plus>
                        <gamma/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <type/>
                      </plus>
                    </Subst>
                  </normalize>                      
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>                      
                      <plus>
                        <gamma/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <type/>
                      </plus>
                    </Subst>                    
                  </canonical>
                </eq>
              </btypes:TYPE>.
            </p>
          </li>
          <li>
            <p>
              Case (5) can be re-written as:
              <btypes:TYPE>
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="o"/>                      
                      <Subst>
                        <aSubMap num="s" dash="'"/>                      
                        <plus>
                          <gamma/>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                          <type/>
                        </plus>
                      </Subst>
                    </Subst>
                  </normalize>                      
                  <canonical>
                    <Subst>
                      <aSubMap num="o"/>                      
                      <Subst>
                        <aSubMap num="s" dash="'"/>                      
                        <plus>
                          <gamma/>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                          <type/>
                        </plus>
                      </Subst>
                    </Subst>                    
                  </canonical>
                </eq>
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              From cases (2), (6) and 
              Lemma&nbsp;<xref ref="ctr-subst-decl"/>, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="o"/>
                        <Subst>
                          <aSubMap num="s" dash="'"/>
                          <gamma/>
                        </Subst>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="o"/>
                        <Subst>
                          <aSubMap num="s" dash="'"/>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="o"/>
                        <Subst>
                          <aSubMap num="s" dash="'"/>
                          <type/>
                        </Subst>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>. 
              That is,
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>. 
            </p>
          </li>
          <li>
            <p>
              Since we have:
              <btypes:TYPE>
                <supeq>
                  <store/>                  
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </supeq>
              </btypes:TYPE>,              
              (and thus               
              <btypes:TYPE>
                <supeq>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <store/>                  
                  </Subst>
                  <Subst>
                    <aSubMap num="s"/>                                          
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </Subst>
                </supeq>
              </btypes:TYPE>),              
              from cases (4), (7), and
              Lemma&nbsp;<xref ref="T-Weakening-ext"/>, 
              we finally obtain:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="s"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>. 
            </p>
          </li>
        </ol>
      </sect3>
      <sect3 id="fixing-shallow-mutability">
        <title>LEMMA: Altering Shallow Mutability.</title>
        If 
        <p>
          <btypes:TYPE>
            <subeq>
              <set>
                <tvars name="thetas"/>
              </set>
              <ftvs>
                <type/>
              </ftvs>
            </subeq>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <type/>
            </models>
            <text content=", then "/>            
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <Csubst>
                <type/>
                <tvars name="thetas"/>
                <plural>
                  <floor>
                    <tvar name="thetas"/>
                  </floor>
                </plural>
              </Csubst>
            </models>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <Csubst>
                <type/>
                <tvars name="thetas"/> 
                <plural>
                  <ceil>
                    <tvar name="thetas"/>
                  </ceil>
                </plural>
              </Csubst>
            </models>
          </btypes:TYPE>.            
        </p>
        <p>
          <leadin>Proof:</leadin>
          Since a substitution is performed shallowly (up to the
          reference boundary), it cannot violate copy compatibility 
          (copy coercion) constraints. Since all type variables are
          still as general as before, and no new variables are used,
          <btypes:TYPE>
            <aSubMap/>
          </btypes:TYPE> is still a solution for all constraints in
          the modified type. Note that we can end up with types of the
          form  
          <btypes:TYPE>
            <floor>
              <ceil>
                <type/>
              </ceil>
            </floor>
          </btypes:TYPE>
          (or 
          <btypes:TYPE>
            <ceil>
              <floor>
                <type/>
              </floor>
            </ceil>
          </btypes:TYPE>), which is equivalent to
          <btypes:TYPE>
            <floor>
              <type/>
            </floor>
          </btypes:TYPE>
          (or 
          <btypes:TYPE>
            <ceil>
              <type/>
            </ceil>
          </btypes:TYPE>).
        </p>          
      </sect3>
      <sect3 id="fixing-shallow-mutability-cor1">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="fixing-shallow-mutability"/>.</title>
        If 
        <p>
          <btypes:TYPE>
            <subeq>
              <set>
                <tvars name="thetas"/>
              </set>
              <ftvs>
                <type/>
              </ftvs>
            </subeq>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <plus>              
                <solvable num="f"/>
                <type/>
                <solvable num="s"/>
              </plus>
            </models>
            <text content=", then "/>            
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <plus>
                <solvable num="f"/>
                <Csubst>
                  <type/>
                  <tvars name="thetas"/>
                  <plural>
                    <floor>
                      <tvar name="thetas"/>
                    </floor>
                  </plural>
                </Csubst>
                <solvable num="s"/>
              </plus>
            </models>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <plus>
                <solvable num="f"/>
                <Csubst>
                  <type/>
                  <tvars name="thetas"/> 
                  <plural>
                    <ceil>
                      <tvar name="thetas"/>
                    </ceil>
                  </plural>
                </Csubst>
                <solvable num="s"/>
              </plus>
            </models>
          </btypes:TYPE>.            
        </p>
        <p>
          <leadin>Proof:</leadin>
          Straightforward extension to 
          Lemma&nbsp;<xref ref="fixing-shallow-mutability-cor1"/>
        </p>          
      </sect3>
      <sect3 id="fixing-shallow-mutability-cor2">
        <title>LEMMA: Corollary to 
          Lemma&nbsp;<xref ref="fixing-shallow-mutability-cor1"/>.</title>
        If 
        <p>
          <btypes:TYPE>
            <subeq>
              <set>
                <tvars name="thetas"/>
              </set>
              <ftvs>
                <type/>
              </ftvs>
            </subeq>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>
              <Subst>
                <aSubMap/>
                <plus>              
                  <solvable num="f"/>
                  <type/>
                  <solvable num="s"/>
                </plus>
              </Subst>
            </models>
            <text content=", then "/>            
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>
              <Subst>
                <aSubMap/>                
                <plus>
                  <solvable num="f"/>
                  <Csubst>
                    <type/>
                    <tvars name="thetas"/>
                    <plural>
                      <floor>
                        <tvar name="thetas"/>
                      </floor>
                    </plural>
                  </Csubst>
                  <solvable num="s"/>
                </plus>
              </Subst>
            </models>
            <text content=" and "/>
            <models name="sol">
              <assume>
                <aSubMap num="s"/>
              </assume>
              <Subst>
                <aSubMap/>
                <plus>
                  <solvable num="f"/>
                  <Csubst>
                    <type/>
                    <tvars name="thetas"/> 
                    <plural>
                      <ceil>
                        <tvar name="thetas"/>
                      </ceil>
                    </plural>
                  </Csubst>
                  <solvable num="s"/>
                </plus>
              </Subst>
            </models>
          </btypes:TYPE>.            
        </p>
        <p>
          <leadin>Proof:</leadin>
          Straightforward extension to 
          Lemma&nbsp;<xref ref="fixing-shallow-mutability-cor1"/>
        </p>          
      </sect3>
      <sect3 id="valid-subst-decl-ok">
        <title>LEMMA: Valid Substitutions 
          Preserve Declarative Derivation.</title>
        <p>
          If
        </p>
        <ol>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="1"/>
                  </assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </models>                
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="1"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>            
            <p>
              <btypes:TYPE>
                <models name="sol">
                  <assume>
                    <aSubMap num="2"/>
                  </assume>
                  <Subst>
                    <aSubMap/>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </models>                
                <text content=" for some substitution "/>
                <aSubMap/>                
              </btypes:TYPE>
            </p>
          </li>          
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <inter>
                    <dom>
                      <aSubMap num="1"/>
                    </dom>
                    <dom>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                    </dom>
                  </inter>
                  <pred name="MTVS">
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </pred>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then, 
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE> 
        </p>
        <p>
          <leadin>Proof: </leadin>
        </p>
        <ol>
          <li>
            <p>
              From Lemma&nbsp;<xref ref="sol-subst-must-be-compat"/>, 
              assumption (1), (3), and (4), we conclude that
              <btypes:TYPE>
                <Exists>
                  <aSubMap num="1" dash="'"/>
                  <aSubMap num="0"/>
                </Exists>
              </btypes:TYPE>
              such that
            </p>
            <ol>
              <li>
                <p>
                  <btypes:TYPE>
                    <ceq>
                      <aSubMap num="1"/>
                      <aSubMap num="1" dash="'"/>
                    </ceq>
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  <btypes:TYPE>
                    <Sjudge name="eqi">
                      <assume>
                        <plus>
                          <type/>
                          <gamma/>
                          <store/>
                        </plus>
                      </assume>                  
                      <approx>
                        <compose>
                          <aSubMap num="2"/>
                          <aSubMap/>
                        </compose>                
                        <compose>
                          <aSubMap num="1" dash="'"/>
                          <aSubMap num="0"/>
                        </compose>
                      </approx>
                    </Sjudge>
                  </btypes:TYPE>
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              From assumption (1), (2), case (1.a) above, and
              Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              From assumption (3) and 
              Lemma&nbsp;<xref ref="sol-math-properties"/>, we have
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </canonical>
                </eq>             
              </btypes:TYPE>              
            </p>
          </li>
          <li>
            <p>
              From cases (3), (1.b), and 
              Lemma&nbsp;<xref ref="eqi-sol-properties"/>, we
              have
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <Subst>
                      <compose>
                        <aSubMap num="1" dash="'"/>
                        <aSubMap num="0"/>
                      </compose>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="1" dash="'"/>
                        <aSubMap num="0"/>
                      </compose>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </canonical>
                </eq>                   
              </btypes:TYPE>              
              That is,
              <btypes:TYPE>                
                <eq>
                  <normalize>
                    <Subst>
                      <aSubMap num="0"/>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <plus>
                          <type/>
                          <gamma/>
                          <store/>
                        </plus>
                      </Subst>
                    </Subst>
                  </normalize>
                  <canonical>
                    <Subst>
                      <aSubMap num="0"/>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <plus>
                          <type/>
                          <gamma/>
                          <store/>
                        </plus>
                      </Subst>
                    </Subst>
                  </canonical>
                </eq>                   
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              From cases (2), (4), and 
              Lemma&nbsp;<xref ref="ctr-subst-decl"/>, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap num="0"/>
                        <Subst>
                          <aSubMap num="1" dash="'"/>
                          <gamma/>
                        </Subst>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="0"/>
                        <Subst>
                          <aSubMap num="1" dash="'"/>
                          <store/>
                        </Subst>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <aSubMap num="0"/>
                        <Subst>
                          <aSubMap num="1" dash="'"/>
                          <type/>
                        </Subst>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>.
              That is,
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="1" dash="'"/>
                          <aSubMap num="0"/>
                        </compose>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="1" dash="'"/>
                          <aSubMap num="0"/>
                        </compose>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="1" dash="'"/>
                          <aSubMap num="0"/>
                        </compose>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              Finally, from cases (1.b), (4), and 
              Lemma&nbsp;<xref ref="eqi-subst-decl-ok"/>, we have:
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="2"/>
                          <aSubMap/>
                        </compose>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="2"/>
                          <aSubMap/>
                        </compose>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <Subst>
                        <compose>
                          <aSubMap num="2"/>
                          <aSubMap/>
                        </compose>
                        <type/>
                      </Subst>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>.              
            </p>
          </li>          
        </ol>
      </sect3>
      <sect3 id="eager-soundness">
        <title>THEOREM: Soundness of Eager Inference</title>
	<p>
          If:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <TIjudge>
                  <assume>
                    <gamma/>
                    <store/>
                    <tape/>
                  </assume>
                  <conclude>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </conclude>
                  <propagate>
                    <aSubMap num="u"/>
                    <tape dash="'"/>              
                  </propagate>
                </TIjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <plus>
                    <type/>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u"/>                  
                      <store/>
                    </Subst>
                  </plus>
                </Sjudge>
              </btypes:TYPE>.              
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <aSubMap num="su"/>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>                  
                  </compose>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then,
          <btypes:TYPE>
            <Sjudge>
              <assume>
                <canonical>
                  <Subst>
                    <aSubMap num="su"/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    +                    <aSubMap num="su"/>
                    <store/>
                  </Subst>
                </canonical>
              </assume>
              <tqExpr>
                <aExpr/>
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>
                    <type/>
                  </Subst>
                </canonical>
              </tqExpr>
            </Sjudge>	    
          </btypes:TYPE>.
        </p>
	<p>
	  <leadin>Proof: </leadin> 
          By induction on the derivation of 
          <btypes:TYPE>
            <TIjudge>
              <assume>
                <gamma/>
                <store/>
                <tape/>
              </assume>
              <conclude>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </conclude>
              <propagate>
                <aSubMap num="1"/>
                <tape dash="'"/>              
              </propagate>
            </TIjudge>
	  </btypes:TYPE>.
	  We proceed by case analysis on the last step
	  (again assuming &alpha;-reduction vacuously):
	</p>
	<ol>
	  <li>
	    <p>
	      Cases TI-UNIT, TI-TRUE. TI-FALSE, TI-ID, TI-HLOC,
              TI-SLOC are trivial. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Case TI-LAMBDA:               
	    </p>
	    <ol>
              <li>
                <p>
                  We know that:
                </p>
                <ol>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Hrules vspace="yes">
                          <tyRule>
                            <tyPre>
                              <TIjudge>
                                <assume>
                                  <extend>
                                    <gamma/>
                                    <mapping>
                                      <id/>
                                      <tvar name="alpha"/>
                                    </mapping>
                                  </extend>
                                  <store/>
                                  <roll>
                                    <tape/>
                                    <tvar name="alpha"/>
                                  </roll>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <aExpr num="i"/>
                                    <type num="r"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <aSubMap num="u"/>
                                  <tape dash="'"/>
                                </propagate>
                              </TIjudge>
                            </tyPre>
                            <tyConc>
                              <TIjudge>
                                <assume>
                                  <gamma/>
                                  <store/>
                                  <tape/>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <lambda> 
                                      <id/>
                                      <aExpr num="i"/>
                                    </lambda>
                                    <fn>
                                      <floor>
                                        <Subst>
                                          <aSubMap num="u"/>
                                          <tvar name="alpha"/>
                                        </Subst>
                                      </floor>
                                      <ceil>
                                        <type num="r"/>
                                      </ceil>
                                    </fn>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <compose>
                                    <aSubMap num="u"/>
                                  </compose>                    
                                  <tape dash="'"/>
                                </propagate>
                              </TIjudge>
                            </tyConc>
                          </tyRule>
                        </Hrules>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge name="sol">
                          <assume>
                            <aSubMap num="s"/>
                          </assume>
                          <plus>
                            <fn>
                              <floor>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <type num="r"/>
                              </ceil>
                            </fn>
                            <Subst>
                              <aSubMap num="u"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="u"/>
                              <store/>
                            </Subst>
                          </plus>
                        </Sjudge>                
                      </btypes:TYPE>
                    </p>
                  </li>
                </ol>
              </li>
	      <li>
		<p>
                  From induction hypothesis, we have:
                </p>
                <ol>
                  <li>
                    <p>
                      If
                      <btypes:TYPE>
                        <Sjudge name="sol">
                          <assume>
                            <aSubMap num="si"/>
                          </assume>
                          <plus>
                            <type num="r"/>
                            <Subst>
                              <aSubMap num="u"/>
                              <extend>
                                <gamma/>
                                <tqExpr>
                                  <id/>
                                  <tvar name="alpha"/>
                                </tqExpr>
                              </extend>
                            </Subst>
                            <Subst>
                              <aSubMap num="u"/>
                              <store/>
                            </Subst>
                          </plus>
                        </Sjudge>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      Then, 
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="si"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <extend>
                                  <gamma/>
                                  <tqExpr>
                                    <id/>
                                    <tvar name="alpha"/>
                                  </tqExpr>
                                </extend>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="si"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <store/>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="i"/>
                            <canonical>
                              <Subst>
                                <aSubMap num="si"/>
                                <type num="r"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>
                    </p>
                  </li>                  
                  <li>
                    <p>
                      That is,
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <aSubMap num="si"/>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <extend>
                                    <gamma/>
                                    <tqExpr>
                                      <id/>
                                      <tvar name="alpha"/>
                                    </tqExpr>
                                  </extend>
                                </Subst>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <aSubMap num="si"/>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <store/>
                                </Subst>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="i"/>
                            <canonical>
                              <Subst>
                                <aSubMap num="si"/>
                                <type num="r"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>
                    </p>
                  </li>
                </ol>
              </li>
              <li>                
                <p>
                  From case (2.b.i) above, and 
                  Definition&nbsp;<xref ref="sol-entities"/> 
                  rule S-GAMMA, we have:
                  <btypes:TYPE>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="si"/>
                      </assume>
                      <plus>
                        <type num="r"/>
                        <Subst>
                          <aSubMap num="u"/>
                          <gamma/>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <tvar name="alpha"/>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <store/>
                        </Subst>
                      </plus>
                    </Sjudge>
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  From case (2.c) above and 
                  Lemma&nbsp;<xref ref="sol-plus-commut"/>
                  (commutativity), we conclude that   
                  <btypes:TYPE>
                    <Exists>
                      <ceq>
                        <aSubMap num="si" dash="'"/>
                        <aSubMap num="si"/>
                      </ceq>
                    </Exists>
                    <text content=" such that "/>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="si" dash="'"/>
                      </assume>
                      <plus>
                        <type num="r"/>
                        <Subst>
                          <aSubMap num="u"/>
                          <tvar name="alpha"/>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <gamma/>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <store/>
                        </Subst>
                      </plus>
                    </Sjudge>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  From Definition&nbsp;<xref ref="sol-entities"/> 
                  rule S-MULTIPLE, we can write:
                  <btypes:TYPE>
                    <eq>
                      <aSubMap num="si" dash="'"/>
                      <compose>
                        <aSubMap num="f"/>
                        <aSubMap num="o"/>
                      </compose>
                    </eq>
                    <text content=" where "/>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="f"/>
                      </assume>
                      <plus>
                        <type num="r"/>
                        <Subst>
                          <aSubMap num="u"/>
                          <tvar name="alpha"/>
                        </Subst>
                      </plus>
                    </Sjudge>
                    <text content=" and "/>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="o"/>
                      </assume>
                      <Subst>
                        <aSubMap num="f"/>
                        <plus>
                          <Subst>
                            <aSubMap num="u"/>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <aSubMap num="u"/>
                            <store/>
                          </Subst>
                        </plus>
                      </Subst>
                    </Sjudge>                    
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  Given
                  <btypes:TYPE>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="f"/>
                      </assume>
                      <plus>
                        <type num="r"/>
                        <Subst>
                          <aSubMap num="u"/>
                          <tvar name="alpha"/>
                        </Subst>
                      </plus>
                    </Sjudge>
                  </btypes:TYPE>,
                  using the SOL-FN rule, we can conclude that
                  <btypes:TYPE>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="f"/>
                      </assume>
                      <fn>
                        <floor>                          
                          <Subst>
                            <aSubMap num="u"/>
                            <tvar name="alpha"/>
                          </Subst>
                        </floor>
                        <ceil>
                          <type num="r"/>
                        </ceil>
                      </fn>
                    </Sjudge>
                  </btypes:TYPE>.                  
                </p>
              </li>
              <li>
                <p>
                  Therefore, 
                  <btypes:TYPE>
                    <Sjudge name="sol">
                      <assume>
                        <aSubMap num="si" dash="'"/>
                      </assume>
                      <plus>                        
                        <fn>
                          <floor>                          
                            <Subst>
                              <aSubMap num="u"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </floor>
                          <ceil>
                            <type num="r"/>
                          </ceil>
                        </fn>
                        <Subst>
                          <aSubMap num="u"/>
                          <gamma/>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <store/>
                        </Subst>
                      </plus>
                    </Sjudge>
                    <text content=". That is, "/>
                    <eq>
                      <aSubMap num="si" dash="'"/>
                      <aSubMap num="s"/>
                    </eq>                      
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  From cases (d) and (g), we conclude that
                  <btypes:TYPE>
                    <ceq>
                      <aSubMap num="si"/>
                      <aSubMap num="s"/>
                    </ceq>                                          
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p> 
                  From case (2.b.i) and
                  Theorem&nbsp;<xref ref="TI-solve-correct"/>,
                  we have:
                  <btypes:TYPE>
                    <models name="sol">
                      <assume>
                        <aSubMap num="si"/>
                      </assume>
                      <plus>
                        <type num="r"/>
                        <Subst>
                          <aSubMap num="u"/>
                          <extend>
                            <gamma/>
                            <tqExpr>
                              <id/>
                              <tvar name="alpha"/>
                            </tqExpr>
                          </extend>
                        </Subst>
                        <Subst>
                          <aSubMap num="u"/>
                          <store/>
                        </Subst>
                      </plus>
                    </models>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  From cases (2.i), (2.b.iii), (2.h), and 
                  Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>, we
                  have:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <Subst>
                              <aSubMap num="u"/>
                              <extend>
                                <gamma/>
                                <tqExpr>
                                  <id/>
                                  <tvar name="alpha"/>
                                </tqExpr>
                              </extend>
                            </Subst>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <Subst>
                              <aSubMap num="u"/>
                              <store/>
                            </Subst>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="i"/>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  Since
                  <btypes:TYPE>
                    <eq>
                      <aSubMap num="su"/>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap num="u"/>                  
                      </compose>
                    </eq>
                  </btypes:TYPE>, we can write
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <extend>
                              <gamma/>
                              <tqExpr>
                                <id/>
                                <tvar name="alpha"/>
                              </tqExpr>
                            </extend>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <store/>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="i"/>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.
                  That is,
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <extend>
                            <Subst>
                              <aSubMap num="su"/>
                              <gamma/>
                            </Subst>
                            <tqExpr>
                              <id/>
                              <Subst>
                                <aSubMap num="su"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </tqExpr>
                          </extend>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <store/>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="i"/>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>. Or,
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <extend>
                          <canonical>                            
                            <Subst>
                              <aSubMap num="su"/>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <tqExpr>
                              <id/>
                              <Subst>
                                <aSubMap num="su"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </tqExpr>
                          </canonical>
                        </extend>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <store/>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="i"/>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                  From the T-LAMBDA rule, we have:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <store/>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <fn>
                          <minz>
                            <canonical>
                              <Subst>
                                <aSubMap num="su"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </canonical>
                          </minz>
                          <maxz>
                            <canonical>
                              <Subst>
                                <aSubMap num="s"/>
                                <type num="r"/>
                              </Subst>
                            </canonical>
                          </maxz>
                        </fn>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  By definition, 
                  <btypes:TYPE>
                    <eq>
                      <fn>
                        <minz>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </canonical>
                        </minz>
                        <maxz>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <type num="r"/>
                            </Subst>
                          </canonical>
                        </maxz>
                      </fn>
                      <fn>
                        <canonical>
                          <floor>
                            <Subst>
                              <aSubMap num="su"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </floor>
                        </canonical>
                        <canonical>
                          <ceil>
                            <Subst>
                              <aSubMap num="s"/>
                              <type num="r"/>
                            </Subst>
                          </ceil>
                        </canonical>
                      </fn>
                      <canonical>
                        <fn>
                          <floor>
                            <Subst>
                              <aSubMap num="su"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </floor>
                          <ceil>
                            <Subst>
                              <aSubMap num="s"/>
                              <type num="r"/>
                            </Subst>
                          </ceil>
                        </fn>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="s"/>
                          <fn>
                            <floor>
                              <Subst>
                                <aSubMap num="u"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </floor>
                            <ceil>
                              <type num="r"/>
                            </ceil>
                          </fn>
                        </Subst>                        
                      </canonical>
                    </eq>
                  </btypes:TYPE>
                </p>
              </li>
              <li>
                <p>
                  From cases (2.j) and (2.k) , we finally have:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <store/>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <canonical>
                          <Subst>
                            <aSubMap num="s"/>
                            <fn>
                              <floor>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <type num="r"/>
                              </ceil>
                            </fn>
                          </Subst>                        
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>
                </p>
              </li>
            </ol>
          </li>
	  <li>
	    <p>
	      Case TI-APP:
	    </p>
	    <ol>
              <li>
                <p>
                  We know that:
                </p>
                <ol>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Hrules vspace="yes">
                          <tyRule>
                            <tyPre>
                              <text content="[I]"/>
                              <TIjudge>
                                <assume>
                                  <gamma/>
                                  <store/>
                                  <roll>
                                    <tape/>
                                    <tvar name="alpha"/>
                                    <tvar name="beta"/>
                                    <tvar name="gamma"/>
                                    <tvar name="delta"/>
                                    <tvar name="epsiv"/>
                                  </roll>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <aExpr num="f"/>
                                    <type num="f"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <aSubMap num="uf"/>
                                  <tape dash="'"/>
                                </propagate>
                              </TIjudge>
                            </tyPre>
                            <tyPre>
                              <text content="[II]"/>
                              <TIjudge>
                                <assume>
                                  <Subst>
                                    <aSubMap num="uf"/>
                                    <gamma/>
                                  </Subst>
                                  <Subst>
                                    <aSubMap num="uf"/>
                                    <store/>
                                  </Subst>
                                  <tape dash="'"/>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <aExpr num="a"/>
                                    <type num="a"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <aSubMap num="ua"/>
                                  <tape dash="''"/>
                                </propagate>
                              </TIjudge>
                            </tyPre>
                            <tyPre>
                              <text content="[III]"/>
                              <UNIFY>
                                <Subst>
                                  <aSubMap num="ua"/>
                                  <type num="f"/>
                                </Subst>
                                <mbpair>
                                  <tvar name="beta"/>
                                  <fn>
                                    <floor>
                                      <tvar name="delta"/>
                                    </floor>
                                    <ceil>
                                      <tvar name="alpha"/>
                                    </ceil>
                                  </fn>
                                </mbpair>
                                <aSubMap num="vf"/>
                              </UNIFY>
                            </tyPre>
                            <tyPre>
                              <text content="[IV]"/>
                              <eq>
                                <tvars name="thetas"/>
                                <diff>
                                  <ftvs>
                                    <Subst>
                                      <aSubMap num="vf"/>
                                      <tvar name="alpha"/>
                                    </Subst>
                                  </ftvs>
                                  <ftvs>
                                    <Subst>
                                      <aSubMap num="vf"/>
                                      <tvar name="delta"/>
                                    </Subst>
                                  </ftvs>
                                </diff>
                              </eq>
                            </tyPre>
                            <tyPre>
                              <text content="[V]"/>
                              <eq>
                                <type num="rh"/>
                                <Csubst>
                                  <minz>
                                    <Subst>
                                      <aSubMap num="vf"/>
                                      <tvar name="alpha"/>
                                    </Subst>
                                  </minz>
                                  <tvars name="thetas"/>
                                  <plural>
                                    <floor>
                                      <tvar name="thetas"/>
                                    </floor>
                                  </plural>
                                </Csubst>
                              </eq>
                            </tyPre>
                            <tyPre>
                              <text content="[VI]"/>
                              <UNIFY>
                                <type num="a"/>
                                <mbpair>
                                  <tvar name="gamma"/>
                                  <floor>
                                    <Subst>
                                      <aSubMap num="vf"/>
                                      <tvar name="delta"/>
                                    </Subst>
                                  </floor>
                                </mbpair>
                                <aSubMap num="va"/>
                              </UNIFY>
                            </tyPre>
                            <tyPre>
                              <text content="[VII]"/>
                              <eq>
                                <type num="res"/>
                                <mbpair>
                                  <tvar name="epsiv"/>
                                  <Subst>
                                    <aSubMap num="va"/>			      
                                    <type num="rh"/>
                                  </Subst>
                                </mbpair>
                              </eq>
                            </tyPre>
                            <tyConc>
                              <TIjudge>
                                <assume>
                                  <gamma/>
                                  <store/>
                                  <tape/>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <apply>
                                      <aExpr num="f"/>
                                      <aExpr num="a"/>
                                    </apply>                 
                                    <type num="res"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <compose>
                                    <aSubMap num="va"/>
                                    <aSubMap num="vf"/>
                                    <aSubMap num="ua"/>
                                    <aSubMap num="uf"/>
                                  </compose>
                                  <tape dash="''"/>
                                </propagate>
                              </TIjudge>
                            </tyConc>
                          </tyRule>
                        </Hrules>
                      </btypes:TYPE>
                    </p>
                    <p>
                      Note that this inference rule is the same as the
                      one in Table&nbsp;<xref ref="hm_infer"/>, in
                      which all substitutions are written in every
                      step (without abbreviation), and some redundant
                      substitutions removed.                      
                    </p>
                  </li>
                  <li>                    
                    <p>
                      <btypes:TYPE>
                        <eq>
                          <aSubMap num="u"/>
                          <compose>
                            <aSubMap num="va"/>
                            <aSubMap num="vf"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                        </eq>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge name="sol">
                          <assume>
                            <aSubMap num="s"/>
                          </assume>
                          <plus>
                            <type num="res"/>
                            <Subst>
                              <aSubMap num="u"/>			                                    
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="u"/>			                                    
                              <store/>
                            </Subst>
                          </plus>
                        </Sjudge>                
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>                    
                    <p>
                      <btypes:TYPE>
                        <eq>
                          <aSubMap num="su"/>
                          <compose>
                            <aSubMap num="s"/>
                            <aSubMap num="u"/>
                          </compose>
                        </eq>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <eq>
                          <aExpr/>
                          <apply>
                            <aExpr num="f"/>
                            <aExpr num="a"/>
                          </apply>
                        </eq>
                      </btypes:TYPE>
                    </p>
                  </li>
                </ol>
              </li>
              <li>
		<p>
                  From induction hypothesis (wrt [I]), we have:
                </p>
                <ol>
                  <li>
                    <p>                      
                      If
                      <btypes:TYPE>
                        <Sjudge name="sol">
                          <assume>
                            <aSubMap num="sf"/>
                          </assume>
                          <plus>
                            <type num="f"/>
                            <Subst>
                              <aSubMap num="uf"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="uf"/>
                              <store/>
                            </Subst>
                          </plus>
                        </Sjudge>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      Then,
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="sf"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="sf"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <store/>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="f"/>
                            <canonical>
                              <Subst>
                                <aSubMap num="sf"/>
                                <type num="f"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>
                    </p>
                  </li>                  
                </ol>
              </li>
              <li>
		<p>
                  Similarly, from induction hypothesis (wrt [II]), 
                  we have:
                </p>
                <ol>
                  <li>
                    <p>                      
                      If
                      <btypes:TYPE>
                        <Sjudge name="sol">
                          <assume>
                            <aSubMap num="sa"/>
                          </assume>
                          <plus>
                            <type num="a"/>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <store/>
                            </Subst>
                          </plus>
                        </Sjudge>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      Then, 
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="sa"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="sa"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <store/>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="a"/>
                            <canonical>
                              <Subst>
                                <aSubMap num="sa"/>
                                <type num="a"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>
                    </p>
                  </li>                  
                </ol>
              </li>
              <li>
                <p>
                  From cases (3.b.i), (3.c.i) and
                  Theorem&nbsp;<xref ref="TI-solve-correct"/>, we have:
                </p> 
                <ol>
                  <li>
                    <p>                      
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="sf"/>
                          </assume>
                          <plus>
                            <type num="f"/>
                            <Subst>
                              <aSubMap num="uf"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="uf"/>
                              <store/>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>                      
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="sa"/>
                          </assume>
                          <plus>
                            <type num="a"/>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <store/>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From [I], [II], and
                      Lemma&nbsp;<xref ref="inf-subst-valid-add"/>, we
                      have:
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <collection>
                                  <aExpr num="f"/>
                                  <aExpr num="a"/>
                                </collection>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                            <type num="a"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      We know that 
                      <btypes:TYPE>
                        <eq>
                          <relevant>
                            <store/>
                            <collection>
                              <apply>
                                <aExpr num="f"/>
                                <aExpr num="a"/>
                              </apply>
                            </collection>
                          </relevant>
                          <relevant>
                            <store/>
                            <collection>
                              <aExpr num="f"/>
                              <aExpr num="a"/>
                            </collection>
                          </relevant>
                        </eq>
                      </btypes:TYPE>,
                      and thus from case (3.a.v),                       
                      <btypes:TYPE>
                        <eq>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                          <relevant>
                            <store/>
                            <collection>
                              <aExpr num="f"/>
                              <aExpr num="a"/>
                            </collection>
                          </relevant>
                        </eq>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.e.i) and (3.e.ii), we obtain:
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                            <type num="a"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      From case (3.e.iii) and
                      Lemma&nbsp;<xref ref="cst-implies-consistent"/>, 
                      we obtain:
                      <br/>
                      <btypes:TYPE>
                        <models name="consistent">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                            <type num="a"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                </ol>                
              </li>
              <li>
                <p>
                  From case (3.e.iv) and
                  Lemma&nbsp;<xref ref="sol-math-properties"/>, 
                  we conclude that 
                  <btypes:TYPE>
                    <Exists>
                      <aSubMap num="e"/>
                    </Exists>
                    <text content=" such that "/>
                    <models name="sol">
                      <assume>
                        <aSubMap num="e"/>
                      </assume>
                      <plus>
                        <Subst>
                          <compose>
                            <aSubMap num="ua"/>                      
                            <aSubMap num="uf"/>                      
                          </compose>
                          <gamma/>
                        </Subst>
                        <Subst>
                          <compose>
                            <aSubMap num="ua"/>                      
                            <aSubMap num="uf"/>                      
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                        <Subst>
                          <aSubMap num="ua"/>                      
                          <type num="f"/>
                        </Subst>
                        <type num="a"/>
                      </plus>
                    </models>
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <p>
                </p>
                <ol>
                  <li>
                    <p>
                      We know that 
                      <btypes:TYPE>
                        <subeq>                          
                          <relevant>
                            <store/>
                            <aExpr num="f"/>
                          </relevant>                          
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </subeq>
                      </btypes:TYPE>.
                      Therefore, from cases (3.e.iii), (3.f), and 
                      Lemma&nbsp;<xref ref="solvable-weakening"/>
                      (weakening), we have:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e"/>
                          </assume>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>.                      
                    </p>
                    <p>
                      That is, 
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e"/>
                          </assume>
                          <plus>
                            <Subst>                              
                              <aSubMap num="ua"/>                      
                              <Subst>                                                              
                                <aSubMap num="uf"/>                      
                                <gamma/>
                              </Subst>
                            </Subst>
                            <Subst>                              
                              <aSubMap num="ua"/>                      
                              <Subst>                                                              
                                <aSubMap num="uf"/>                      
                                <relevant>
                                  <store/>
                                  <aExpr num="f"/>
                                </relevant>
                              </Subst>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <Subst>                                                              
                                <aSubMap num="uf"/>                                                      
                                <type num="f"/>
                              </Subst>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>.                                            
                      Note that
                      <btypes:TYPE>
                        <eq>
                          <Subst>
                            <aSubMap num="uf"/>
                            <type num="f"/>
                          </Subst>
                          <type num="f"/>
                        </eq>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      From (3.b.i), (3.d.i), and
                      Lemma&nbsp;<xref ref="relevant-subst-only"/>, 
                      we can conclude that                       
                      <btypes:TYPE>
                        <Exists>
                          <aSubMap num="sf" dash="'"/>
                        </Exists>
                      </btypes:TYPE>
                      such that:
                    </p>
                    <ol>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <models name="sol">
                              <assume>
                                <aSubMap num="sf" dash="'"/>
                              </assume>
                              <plus>
                                <Subst>                                  
                                  <aSubMap num="uf"/>
                                  <gamma/>
                                </Subst>
                                <Subst>                                  
                                  <aSubMap num="uf"/>
                                  <relevant>
                                    <store/>
                                    <aExpr num="f"/>
                                  </relevant>
                                </Subst>
                                <Subst>
                                  <aSubMap num="uf"/>
                                  <type num="f"/>
                                </Subst>
                              </plus>
                            </models>	    
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <Sjudge>
                              <assume>
                                <canonical>
                                  <Subst>
                                    <aSubMap num="sf" dash="'"/>
                                    <Subst>                                  
                                      <aSubMap num="uf"/>
                                      <gamma/>
                                    </Subst>
                                  </Subst>
                                </canonical>
                                <canonical>
                                  <Subst>
                                    <aSubMap num="sf" dash="'"/>
                                    <Subst>                                  
                                      <aSubMap num="uf"/>
                                      <relevant>
                                        <store/>
                                        <aExpr num="f"/>
                                      </relevant>
                                    </Subst>
                                  </Subst>
                                </canonical>
                              </assume>
                              <tqExpr>
                                <aExpr num="f"/>
                                <canonical>
                                  <Subst>
                                    <aSubMap num="sf" dash="'"/>
                                    <Subst>
                                      <aSubMap num="uf"/>
                                      <type num="f"/>
                                    </Subst>
                                  </Subst>
                                </canonical>
                              </tqExpr>
                            </Sjudge>	    
                          </btypes:TYPE>.                      
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      It is clear that 
                      <btypes:TYPE>
                        <eq>
                          <inter>
                            <dom>
                              <aSubMap num="sf" dash="'"/>
                            </dom>
                            <dom>
                              <compose>
                                <aSubMap num="e"/>
                                <aSubMap num="ua"/>
                              </compose>
                            </dom>
                          </inter>
                          <pred name="MTVS">                            
                            <plus>
                              <Subst>                                  
                                <aSubMap num="uf"/>
                                <gamma/>
                              </Subst>
                              <Subst>                                  
                                <aSubMap num="uf"/>
                                <relevant>
                                  <store/>
                                  <aExpr num="f"/>
                                </relevant>
                              </Subst>
                              <Subst>
                                <aSubMap num="uf"/>
                                <type num="f"/>
                              </Subst>
                            </plus>
                          </pred>
                        </eq>
                      </btypes:TYPE>, because the derivation
                      [II] occurs in an environment that already
                      contains the substitutions 
                      <btypes:TYPE>
                        <aSubMap num="sf"/>
                      </btypes:TYPE> (and thus
                      <btypes:TYPE>                      
                        <aSubMap num="sf" dash="'"/>
                      </btypes:TYPE>), and it works on a 
                      different tape
                      <btypes:TYPE>
                        <tape dash="'"/>
                      </btypes:TYPE>, and thus uses fresh type
                      variables when new type variables are
                      introduced.                        
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  From cases (3.g.ii.A), (3.g.ii.B), (3.g.i),
                  (3.g.iii), and 
                  Lemma&nbsp;<xref ref="valid-subst-decl-ok"/>, 
                  we have:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                            </compose>
                            <Subst>                                  
                              <aSubMap num="uf"/>
                              <gamma/>
                            </Subst>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                            </compose>
                            <Subst>                                  
                              <aSubMap num="uf"/>
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="f"/>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                            </compose>
                            <Subst>
                              <aSubMap num="uf"/>
                              <type num="f"/>
                            </Subst>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.                      
                </p>
                <p>
                  That is,
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <relevant>
                              <store/>
                              <aExpr num="f"/>
                            </relevant>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="f"/>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <type num="f"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.                      
                </p>
              </li>
              <li>
                <p>
                  Since                  
                  <btypes:TYPE>
                    <supeq>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                      <relevant>
                        <store/>
                        <aExpr num="f"/>
                      </relevant>
                    </supeq>
                  </btypes:TYPE>, 
                  we have 
                  <btypes:TYPE>
                    <supeq>
                      <Subst>
                        <compose>
                          <aSubMap num="e"/>
                          <aSubMap num="ua"/>
                          <aSubMap num="uf"/>
                        </compose>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </Subst>
                      <Subst>
                        <compose>
                          <aSubMap num="e"/>
                          <aSubMap num="ua"/>
                          <aSubMap num="uf"/>
                        </compose>
                        <relevant>
                          <store/>
                          <aExpr num="f"/>
                        </relevant>
                      </Subst>
                    </supeq>
                  </btypes:TYPE>.
                  From case (f) and
                  Lemma&nbsp;<xref ref="sol-math-properties"/> and
                  Lemma&nbsp;<xref ref="solvable-weakening"/>,
                  we can obtain
                  <btypes:TYPE>
                    <eq>
                      <normalize>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <gamma/>
                        </Subst>
                      </normalize>
                      <canonical>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <gamma/>
                        </Subst>
                      </canonical>
                    </eq>
                    <text content=" and "/>
                    <eq>
                      <normalize>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                      </normalize>
                      <canonical>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                      </canonical>
                    </eq>
                  </btypes:TYPE>                      

                  Now, from case (h) and
                  Lemma&nbsp;<xref ref="T-Weakening-ext"/>, we have
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="f"/>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <type num="f"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.                      
                </p>
              </li>
              <li>
                <p>
                  Similarly, we have
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <aExpr num="a"/>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="e"/>
                              <aSubMap num="ua"/>
                              <aSubMap num="uf"/>
                            </compose>
                            <type num="a"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.                      
                </p>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      It is evident that 
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <mbpair>
                            <tvar name="beta"/>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </mbpair>
                        </models>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      Since
                      <btypes:TYPE>
                        <collection and="yes">
                          <tvar name="alpha"/>
                          <tvar name="beta"/>
                          <tvar name="delta"/>
                        </collection>
                      </btypes:TYPE>
                      are fresh type variables, we can write
                      (using case (3.e.iii)):
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                            <type num="a"/>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>                            
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Due to
                      Lemma&nbsp;<xref ref="sol-plus-commut"/> 
                      (commutativity) 
                      and case (3.k.ii), we  can write:
                      <br/>
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="ua"/>                      
                                <aSubMap num="uf"/>                      
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                            <type num="a"/>
                            <Subst>
                              <aSubMap num="ua"/>                      
                              <type num="f"/>
                            </Subst>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>                            
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      From case (3.k.iii), [III], and
                      Lemma&nbsp;<xref ref="unify-strong-consistent-cor"/>,
                      we have:
                      <br/>
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="vf"/>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="vf"/>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                            <type num="a"/>
                            <Subst>
                              <aSubMap num="vf"/>
                              <aSubMap num="ua"/>
                              <type num="f"/>
                            </Subst>
                            <Subst>
                              <aSubMap num="vf"/>
                              <mbpair>
                                <tvar name="beta"/>
                                <fn>
                                  <floor>
                                    <tvar name="delta"/>
                                  </floor>
                                  <ceil>
                                    <tvar name="alpha"/>
                                  </ceil>
                                </fn>
                              </mbpair>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                </ol>                
              </li>
              <li>
                <p>
                  Again, due to case (3.k.iv) and 
                  Lemma&nbsp;<xref ref="cst-implies-consistent"/>, and 
                  Lemma&nbsp;<xref ref="sol-math-properties"/>, we conclude
                  that 
                  <btypes:TYPE>
                    <Exists>
                      <aSubMap num="e" dash="'"/>
                    </Exists>
                    <text content=" such that "/>
                    <br/>
                    <models name="sol">
                      <assume>
                        <aSubMap num="e" dash="'"/>
                      </assume>
                      <plus>
                        <Subst>
                          <compose>
                            <aSubMap num="vf"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <gamma/>
                        </Subst>
                        <Subst>
                          <compose>
                            <aSubMap num="vf"/>
                            <aSubMap num="ua"/>
                            <aSubMap num="uf"/>
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                        <type num="a"/>
                        <Subst>
                          <compose>
                            <aSubMap num="vf"/>
                            <aSubMap num="ua"/>
                          </compose>
                          <type num="f"/>
                        </Subst>
                        <Subst>
                          <aSubMap num="vf"/>
                          <mbpair>
                            <tvar name="beta"/>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </mbpair>
                        </Subst>
                      </plus>
                    </models>
                  </btypes:TYPE>.
                </p>
                <p>
                  Similar to the argument in cases (g) through (j), we
                  obtain:                  
                </p>
                <ol>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="f"/>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <type num="f"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="a"/>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="'"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <type num="a"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  Since
                  <btypes:TYPE>
                    <eq>
                      <Subst>
                        <compose>
                          <aSubMap num="vf"/>
                          <aSubMap num="ua"/>
                          <aSubMap num="uf"/>
                        </compose>
                        <type num="a"/>
                      </Subst>
                      <type num="a"/>
                    </eq>
                    <text content=" and "/>
                    <eq>
                      <aSubMap num="u"/>
                      <compose>
                        <aSubMap num="va"/>
                        <aSubMap num="vf"/>
                        <aSubMap num="ua"/>
                        <aSubMap num="uf"/>
                      </compose>
                    </eq>                      
                  </btypes:TYPE>,
                  similar to cases (k) and (j) above, for the
                  unification performed in step [VI], we conclude that
                  <btypes:TYPE>
                    <Exists>
                      <aSubMap num="e" dash="''"/>
                    </Exists>
                  </btypes:TYPE>
                  such that:
                </p>
                <ol>
                  <li>
                    <p>
                      Let
                    </p>
                    <ol>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="1"/>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="2"/>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                  <aSubMap num="uf"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="3"/>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                </compose>
                                <type num="f"/>
                              </Subst>
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="4"/>
                              <Subst>
                                <aSubMap num="va"/>                              
                                <type num="a"/>
                              </Subst>
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="5"/>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                </compose>
                                <mbpair>
                                  <tvar name="beta"/>
                                  <fn>
                                    <floor>
                                      <tvar name="delta"/>
                                    </floor>
                                    <ceil>
                                      <tvar name="alpha"/>
                                    </ceil>
                                  </fn>
                                </mbpair>
                              </Subst>
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                      <li>
                        <p>
                          <btypes:TYPE>
                            <eq>
                              <solvable num="6"/>
                              <Subst>
                                <aSubMap num="va"/>
                                <mbpair>
                                  <tvar name="gamma"/>
                                  <floor>
                                    <Subst>
                                      <aSubMap num="vf"/>
                                      <tvar name="delta"/>
                                    </Subst>
                                  </floor>
                                </mbpair>
                              </Subst>                              
                            </eq>
                          </btypes:TYPE>
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <models name="cst">
                          <assume/>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <solvable num="3"/>
                            <solvable num="4"/>
                            <solvable num="5"/>
                            <solvable num="6"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <solvable num="3"/>
                            <solvable num="4"/>
                            <solvable num="5"/>
                            <solvable num="6"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="f"/>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <type num="f"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr num="a"/>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <type num="a"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From [III], we have:
                      <btypes:TYPE>
                        <UNIFY>
                          <Subst>
                            <aSubMap num="ua"/>
                            <type num="f"/>
                          </Subst>
                          <mbpair>
                            <tvar name="beta"/>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </mbpair>
                          <aSubMap num="vf"/>
                        </UNIFY>
                      </btypes:TYPE>                      
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.m.ii), (3.m.iii)  and                       
                      Lemma&nbsp;<xref ref="solvable-weakening"/>
                      (weakening), we have:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <Subst>
                            <plus>
                              <solvable num="3"/>
                              <solvable num="5"/>
                            </plus>
                          </Subst>
                        </models>
                      </btypes:TYPE>.
                      That is,
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <Subst>
                            <plus>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                  <aSubMap num="ua"/>
                                </compose>
                                <type num="f"/>
                              </Subst>
                              <Subst>
                                <compose>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                </compose>
                                <mbpair>
                                  <tvar name="beta"/>
                                  <fn>
                                    <floor>
                                      <tvar name="delta"/>
                                    </floor>
                                    <ceil>
                                      <tvar name="alpha"/>
                                    </ceil>
                                  </fn>
                                </mbpair>
                              </Subst>                          
                            </plus>
                          </Subst>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      The case (3.n.ii) can be re-written as: 
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <plus>
                            <Subst>
                              <compose>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                              </compose>
                              <Subst>
                                <aSubMap num="ua"/>
                                <type num="f"/>
                              </Subst>
                            </Subst>
                            <Subst>
                              <compose>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                              </compose>
                              <mbpair>
                                <tvar name="beta"/>
                                <fn>
                                  <floor>
                                    <tvar name="delta"/>
                                  </floor>
                                  <ceil>
                                    <tvar name="alpha"/>
                                  </ceil>
                                </fn>
                              </mbpair>
                            </Subst>                     
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.n.i), (3.n.iii) and 
                      Lemma&nbsp;<xref ref="unify-maybe-cor"/>, 
                      we have: 
                      <br/>
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                              </compose>
                              <Subst>
                                <aSubMap num="ua"/>
                                <type num="f"/>
                              </Subst>
                            </Subst>
                          </canonical>
                          <canonical>
                            <minz>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="va"/>
                                  <aSubMap num="vf"/>
                                </compose>
                                <fn>
                                  <floor>
                                    <tvar name="delta"/>
                                  </floor>
                                  <ceil>
                                    <tvar name="alpha"/>
                                  </ceil>
                                </fn>
                              </Subst>
                            </minz>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                    </p>
                    <p>
                      That is,
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                                <aSubMap num="ua"/>
                              </compose>                              
                              <type num="f"/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                              </compose>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      The case (3.n.iv) can be re-written as:
                      <br/>
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>                              
                              <type num="f"/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                                <aSubMap num="ua"/>
                                <aSubMap num="uf"/>
                              </compose>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>, since these substitutions have
                      no effect.
                    </p>
                  </li>
                  <li>
                    <p>
                      Due to case (3.a.ii), the above case (3.n.v) is
                      equivalent to 
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="u"/>
                              </compose>                              
                              <type num="f"/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="u"/>
                              </compose>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      The case (3.n.vi) is further equivalent to
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="u"/>
                              </compose>                              
                              <type num="f"/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <fn>
                              <floor>
                                <Subst>
                                  <compose>
                                    <aSubMap num="e" dash="''"/>
                                    <aSubMap num="u"/>
                                  </compose>                                  
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <Subst>
                                  <compose>
                                    <aSubMap num="e" dash="''"/>
                                    <aSubMap num="u"/>
                                  </compose>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </fn>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      Similarly, from the unification performed in
                      step [VI], we have: 
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="u"/>
                              </compose>
                              <type num="a"/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <floor>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>         
                                <tvar name="delta"/>
                              </Subst>
                            </floor>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.                                            
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From cases (3.m.iv) and (3.n.vii) we obtain:
                      <br/>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <Tsub>
                            <aExpr num="f"/>
                            <canonical>
                              <fn>
                                <floor>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="e" dash="''"/>
                                      <aSubMap num="u"/>
                                    </compose>                                  
                                    <tvar name="delta"/>
                                  </Subst>
                                </floor>
                                <ceil>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="e" dash="''"/>
                                      <aSubMap num="u"/>
                                    </compose>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </ceil>
                              </fn>
                            </canonical>
                          </Tsub>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.m.v) and (3.n.viii) we obtain:
                      <br/>
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="e" dash="''"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <Tsub>
                            <aExpr num="a"/>
                            <canonical>
                              <floor>
                                <Subst>
                                  <compose>
                                    <aSubMap num="e" dash="''"/>
                                    <aSubMap num="u"/>
                                  </compose>         
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                            </canonical>
                          </Tsub>
                        </Sjudge>	    
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From (3.m.ii) and (3.m.iii) and 
                      Lemma&nbsp;<xref ref="solvable-weakening"/>, 
                      we have
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <Subst>
                              <compose>
                                <aSubMap num="va"/>
                                <aSubMap num="vf"/>
                              </compose>
                              <tvar name="alpha"/>
                            </Subst>                            
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      The case (3.p.i) can be re-written as:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <Subst>
                            <aSubMap num="va"/>                            
                            <plus>
                              <solvable num="1"/>
                              <solvable num="2"/>
                              <Subst>
                                <aSubMap num="vf"/>
                                <tvar name="alpha"/>
                              </Subst>                            
                            </plus>
                          </Subst>
                        </models>
                      </btypes:TYPE>.                      
                      (Note: 
                      <btypes:TYPE>
                        <solvable num="1"/>
                        <text content=" and "/>
                        <solvable num="2"/>
                        <text content=" already contain "/>
                        <text content=" substitutions from "/>                        
                        <aSubMap num="va"/>                            
                      </btypes:TYPE>).
                    </p>
                  </li>
                  <li>
                    <p>
                      From [IV], we have
                      <btypes:TYPE>
                        <subeq>
                          <set>
                            <tvars name="thetas"/>
                          </set>
                          <ftvs>
                            <Subst>
                              <aSubMap num="vf"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </ftvs>
                        </subeq>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.p.ii), (3.p.iii) and
                      Lemma&nbsp;<xref ref="fixing-shallow-mutability-cor2"/>,
                      we have:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <Subst>
                            <aSubMap num="va"/>                            
                            <plus>
                              <solvable num="1"/>
                              <solvable num="2"/>
                              <Csubst>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                                <tvars name="thetas"/>
                                <plural>
                                  <floor>
                                    <tvar name="thetas"/>
                                  </floor>
                                </plural>
                              </Csubst>
                            </plus>
                          </Subst>                            
                        </models>
                      </btypes:TYPE>.
                      (Note: Here, we instantiated 
                      <btypes:TYPE>
                        <solvable num="s"/>
                      </btypes:TYPE> of
                      Lemma&nbsp;<xref ref="fixing-shallow-mutability-cor2"/>
                      to 
                      <btypes:TYPE>
                        <Empty/>
                      </btypes:TYPE>).                      
                    </p>
                  </li>
                  <li>
                    <p>
                      From (3.m.iv), it is evident that:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <Subst>
                              <aSubMap num="va"/>                                                            
                              <Csubst>
                                <minz>
                                  <Subst>
                                    <aSubMap num="vf"/>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </minz>
                                <tvars name="thetas"/>
                                <plural>
                                  <floor>
                                    <tvar name="thetas"/>
                                  </floor>
                                </plural>
                              </Csubst>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>. That is, 
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <Subst>
                              <aSubMap num="va"/>                                                            
                              <type num="rh"/>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>. 
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      Let 
                      <btypes:TYPE>
                        <eq>
                          <aSubMap num="E"/>
                          <compose>
                            <aSubMap num="e" dash="''"/>
                            <SubMap>
                              <tvar name="epsiv"/>
                              <Subst>
                                <aSubMap num="va"/>			      
                                <type num="rh"/>
                              </Subst>
                            </SubMap>
                          </compose>
                        </eq>
                        <text content=". A substitution for "/>
                        <tvar name="epsiv"/>
                        <text content=" with any type "/>
                        <ceq> 
                          <type/>                          
                          <Subst>
                            <aSubMap num="va"/>			      
                            <type num="rh"/>
                          </Subst>
                        </ceq>
                        <text content=" will actually work"/>
                        <text content=" in this case."/>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.p.v), (3.q.1) 
                      Lemma&nbsp;<xref ref="sol-math-properties"/>,
                      and 
                      Definition&nbsp;<xref ref="sol-math"/>,
                      we can easily obtain:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="E"/>
                          </assume>          
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <mbpair>
                              <tvar name="gamma"/>
                              <floor>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                            </mbpair>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                      That is,
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="E"/>
                          </assume>          
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <type num="ret"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      Similar to case (3.p.i), we obtain
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="e" dash="''"/>
                          </assume>
                          <Subst>
                            <aSubMap num="va"/>
                            <Subst>
                              <aSubMap num="vf"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </Subst>
                        </models>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      From case (3.r.i) and
                      Lemma&nbsp;<xref ref="sol-math-properties"/>,
                      we obtain:
                      <btypes:TYPE>
                        <eq>
                          <normalize>
                            <Subst>
                              <aSubMap num="e" dash="''"/>                          
                              <Subst>
                                <aSubMap num="va"/>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </Subst>
                            </Subst>
                          </normalize>
                          <canonical>
                            <Subst>
                              <aSubMap num="e" dash="''"/>                          
                              <Subst>
                                <aSubMap num="va"/>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </Subst>
                            </Subst>
                          </canonical>
                        </eq>
                      </btypes:TYPE>.
                      That is,
                      <btypes:TYPE>
                        <eq>
                          <normalize>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>                          
                                <aSubMap num="va"/>
                              </compose>
                              <Subst>
                                <aSubMap num="vf"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </Subst>
                          </normalize>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>                          
                                <aSubMap num="va"/>
                              </compose>
                              <Subst>
                                <aSubMap num="vf"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </Subst>
                          </canonical>
                        </eq>
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.r.ii), (3.p.iii) and
                      Lemma&nbsp;<xref ref="ctr-compat-properties"/>,
                      we obtain:
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>           
                              </compose>                                                 
                              <ceil>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="e" dash="''"/>
                                <aSubMap num="va"/>         
                              </compose>
                              <Csubst>
                                <minz>
                                  <Subst>
                                    <aSubMap num="vf"/>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </minz>
                                <tvars name="thetas"/>
                                <plural>
                                  <floor>
                                    <tvar name="thetas"/>
                                  </floor>
                                </plural>
                              </Csubst>
                            </Subst>                          
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      It is evident that
                      <btypes:TYPE>
                        <models name="eqi">
                          <assume>
                            <Subst>
                              <compose>
                                <aSubMap num="va"/>           
                                <aSubMap num="vf"/>
                              </compose>
                              <tvar name="alpha"/>
                            </Subst>
                          </assume>
                          <approx>
                            <aSubMap num="e" dash="''"/>
                            <aSubMap num="E"/>
                          </approx>
                        </models>
                        <text content=". Therefore, we can also say "/>
                        <models name="eqi">
                          <assume>
                            <Subst>
                              <aSubMap num="va"/>           
                              <ceil>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </Subst>
                          </assume>
                          <approx>
                            <aSubMap num="e" dash="''"/>
                            <aSubMap num="E"/>
                          </approx>
                        </models>
                        <text content=" and "/>
                        <models name="eqi">
                          <assume>
                            <Subst>
                              <aSubMap num="va"/>           
                              <Csubst>
                                <minz>
                                  <Subst>
                                    <aSubMap num="vf"/>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </minz>
                                <tvars name="thetas"/>
                                <plural>
                                  <floor>
                                    <tvar name="thetas"/>
                                  </floor>
                                </plural>
                              </Csubst>
                            </Subst>
                          </assume>
                          <approx>
                            <aSubMap num="e" dash="''"/>
                            <aSubMap num="E"/>
                          </approx>
                        </models>
                      </btypes:TYPE>.                      
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.r.iii) and (3.r.iv), we have:
                      <btypes:TYPE>
                        <Tsub>                          
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="E"/>
                                <aSubMap num="va"/>           
                              </compose>
                              <ceil>
                                <Subst>
                                  <aSubMap num="vf"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="E"/>
                                <aSubMap num="va"/>           
                              </compose>
                              <Csubst>
                                <minz>
                                  <Subst>
                                    <aSubMap num="vf"/>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </minz>
                                <tvars name="thetas"/>
                                <plural>
                                  <floor>
                                    <tvar name="thetas"/>
                                  </floor>
                                </plural>
                              </Csubst>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                      That is,
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <ceil>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="va"/>           
                                  <aSubMap num="vf"/>
                                </compose>
                                <tvar name="alpha"/>
                              </Subst>
                            </ceil>
                          </canonical>
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="E"/>
                                <aSubMap num="va"/>           
                              </compose>
                              <type num="rh"/>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                    </p>
                  </li>                  
                  <li>
                    <p>
                      From case (3.q.i), we know that
                      <btypes:TYPE>
                        <eq>
                          <canonical>
                            <Subst>
                              <aSubMap num="E"/>
                              <type num="res"/>
                            </Subst>
                          </canonical>                          
                          <canonical>
                            <Subst>
                              <compose>
                                <aSubMap num="E"/>
                                <aSubMap num="va"/>           
                              </compose>
                              <type num="rh"/>
                            </Subst>
                          </canonical>
                        </eq>
                      </btypes:TYPE>.
                      (We actually only need a compatibility result
                      here, in case we chose any other compatible type
                      in case (3.q.i)).
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.r.v) and (3.v.vi), we obtain
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <ceil>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="va"/>           
                                  <aSubMap num="vf"/>
                                </compose>
                                <tvar name="alpha"/>
                              </Subst>
                            </ceil>
                          </canonical>
                          <canonical>
                            <Subst>
                              <aSubMap num="E"/>
                              <type num="res"/>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      The case (3.r.vii) can be written as
                      <btypes:TYPE>
                        <Tsub>
                          <canonical>
                            <ceil>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <tvar name="alpha"/>
                              </Subst>
                            </ceil>
                          </canonical>
                          <canonical>
                            <Subst>
                              <aSubMap num="E"/>
                              <type num="res"/>
                            </Subst>
                          </canonical>
                        </Tsub>
                      </btypes:TYPE>, since the extra substitutions
                      have no effect.            
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From case (3.q.i), it is evident that
                      <btypes:TYPE>
                        <models name="eqi">
                          <assume>
                            <plus>
                              <solvable num="1"/>
                              <solvable num="2"/>
                              <fn>
                                <floor>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="e" dash="''"/>
                                      <aSubMap num="u"/>
                                    </compose>                                  
                                    <tvar name="delta"/>
                                  </Subst>
                                </floor>
                                <ceil>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="e" dash="''"/>
                                      <aSubMap num="u"/>
                                    </compose>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </ceil>
                              </fn>
                            </plus>
                          </assume>          
                          <approx>
                            <aSubMap num="E"/>
                            <aSubMap num="e" dash="''"/>
                          </approx>
                        </models>
                      </btypes:TYPE>.                  
                      Therefore, from case (3.o.i) and 
                      Lemma&nbsp;<xref ref="eqi-subst-decl-ok"/>, 
                      we have:
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <Tsub>
                            <aExpr num="f"/>
                            <canonical>
                              <fn>
                                <floor>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="E"/>
                                      <aSubMap num="u"/>
                                    </compose>                                  
                                    <tvar name="delta"/>
                                  </Subst>
                                </floor>
                                <ceil>
                                  <Subst>
                                    <compose>
                                      <aSubMap num="E"/>
                                      <aSubMap num="u"/>
                                    </compose>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </ceil>
                              </fn>
                            </canonical>
                          </Tsub>
                        </Sjudge>	    
                      </btypes:TYPE>.                                            
                    </p>
                  </li>
                  <li>
                    <p>
                      Similarly, we have:
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <relevant>
                                  <store/>
                                  <aExpr/>
                                </relevant>
                              </Subst>
                            </canonical>
                          </assume>
                          <Tsub>
                            <aExpr num="a"/>
                            <canonical>
                              <floor>
                                <Subst>
                                  <compose>
                                    <aSubMap num="E"/>
                                    <aSubMap num="u"/>
                                  </compose>         
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                            </canonical>
                          </Tsub>
                        </Sjudge>	    
                      </btypes:TYPE>.
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  Now, from cases (3.s.i), (3.s.ii), (3.r.viii) and
                  T-APP rule, we obtain:
                  <btypes:TYPE>
                    <Sjudge>
                      <assume>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="E"/>
                              <aSubMap num="u"/>
                            </compose>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <compose>
                              <aSubMap num="E"/>
                              <aSubMap num="u"/>
                            </compose>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                        </canonical>
                      </assume>
                      <tqExpr>
                        <apply>
                          <aExpr num="f"/>
                          <aExpr num="a"/>
                        </apply>
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="res"/>
                          </Subst>
                        </canonical>
                      </tqExpr>
                    </Sjudge>	    
                  </btypes:TYPE>.
                </p>
              </li>
              <li>
                <ol>
                  <li>
                    <p>
                      From case (3.q.ii) and
                      Lemma&nbsp;<xref ref="sol-plus-commut"/>
                      (commutativity), we obtain:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="E"/>
                          </assume>          
                          <plus>
                            <type num="ret"/>
                            <solvable num="1"/>
                            <solvable num="2"/>
                          </plus>
                        </models>
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      From case (3.a.iii) and 
                      Theorem&nbsp;<xref ref="TI-solve-correct"/>, 
                      we have:
                      <btypes:TYPE>
                        <models name="sol">
                          <assume>
                            <aSubMap num="s"/>
                          </assume>
                          <plus>
                            <type num="res"/>
                            <Subst>
                              <aSubMap num="u"/>			                                    
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="u"/>			                                    
                              <store/>
                            </Subst>
                          </plus>
                        </models>
                      </btypes:TYPE>
                    </p>
                  </li>
                  <li>
                    <p>
                      From cases (3.u.i), (t), (3.u.ii), and 
                      Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor2"/>,
                      we obtain:
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="s"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <compose>
                                  <aSubMap num="s"/>
                                  <aSubMap num="u"/>
                                </compose>
                                <store/>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <apply>
                              <aExpr num="f"/>
                              <aExpr num="a"/>
                            </apply>
                            <canonical>
                              <Subst>
                                <aSubMap num="s"/>
                                <type num="res"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.
                    </p>
                  </li>
                  <li>
                    <p>
                      Finally, from cases (3.a.iv) and (3.a.v), 
                      we obtain the desired result:
                      <btypes:TYPE>
                        <Sjudge>
                          <assume>
                            <canonical>
                              <Subst>
                                <aSubMap num="su"/>
                                <gamma/>
                              </Subst>
                            </canonical>
                            <canonical>
                              <Subst>
                                <aSubMap num="su"/>
                                <store/>
                              </Subst>
                            </canonical>
                          </assume>
                          <tqExpr>
                            <aExpr/>
                            <canonical>
                              <Subst>
                                <aSubMap num="s"/>
                                <type num="res"/>
                              </Subst>
                            </canonical>
                          </tqExpr>
                        </Sjudge>	    
                      </btypes:TYPE>.
                    </p>
                  </li>
                </ol>
              </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Cases TI-LET-&alpha;: Similar to case (4) (TI-APP),
	      except for the use of
              Lemma&nbsp;<xref ref="solve-sol-compat"/>.
	    </p>
	  </li>	
	  <li>
	    <p>
	      Cases TI-IF, TI-DUP, TI-DEREF, TI-SET,  
              TI-TQEXPR, TI-LET-&alpha;-TQ are similar.
	    </p>
	  </li>	
	</ol>
      </sect3>
      <sect3 id="eager-soundness-cor1">
        <title>LEMMA: Corollary&ndash;1 to Soundness of Eager Inference</title>
	<p>
          If:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <TIjudge>
                  <assume>
                    <gamma/>
                    <store/>
                    <tape/>
                  </assume>
                  <conclude>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </conclude>
                  <propagate>
                    <aSubMap num="u"/>
                    <tape dash="'"/>              
                  </propagate>
                </TIjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <corUp>
                    <type/>
                    <type dash="'"/>
                  </corUp>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="e"/>
                  </assume>
                  <Subst>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap num="u"/>
                    </compose>
                    <plus>
                      <gamma/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                    </plus>
                  </Subst>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <aSubMap/>
                  <compose>		
                    <aSubMap num="e"/>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then
          <btypes:TYPE>
	    <Sjudge>
	      <assume>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <gamma/>
                  </Subst>
                </canonical>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <store/>
                  </Subst>
                </canonical>
	      </assume>
	      <tqExpr>
		<aExpr/>
                <canonical>
                  <type dash="'"/>
                </canonical>
	      </tqExpr>
	    </Sjudge>	    
	  </btypes:TYPE>.
	</p>
	<p>
	  <leadin>Proof: </leadin>           
          Follows from 
          Theorem&nbsp;<xref ref="eager-soundness"/>
          Definition&nbsp;<xref ref="solvable-entities"/>,
          and Lemma&nbsp;<xref ref="inf-subst-valid"/>.
        </p>
      </sect3>
      <sect3 id="eager-soundness-cor2">
        <title>THEOREM: Corollary&ndash;2 to Soundness of Eager Inference</title>
	<p>
          If:
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <TIjudge>
                  <assume>
                    <gamma/>
                    <store/>
                    <tape/>
                  </assume>
                  <conclude>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </conclude>
                  <propagate>
                    <aSubMap num="u"/>
                    <tape dash="'"/>              
                  </propagate>
                </TIjudge>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge name="sol">
                  <assume>
                    <aSubMap num="s"/>
                  </assume>
                  <corUp>
                    <type/>
                    <type dash="'"/>
                  </corUp>
                </Sjudge>
              </btypes:TYPE>
            </p>
          </li>
        </ol>
        <p>
          Then
          <btypes:TYPE>
            <Exists>
              <aSubMap num="e"/>
            </Exists>
            <text content=" such that "/>
          </btypes:TYPE>
        </p>
        <ol>
          <li>
            <p>
              <btypes:TYPE>
                <eq>
                  <aSubMap/>
                  <compose>		
                    <aSubMap num="e"/>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                </eq>
              </btypes:TYPE>
            </p>
          </li>
          <li>
            <p>
              <btypes:TYPE>
                <Sjudge>
                  <assume>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </canonical>
                  </assume>
                  <tqExpr>
                    <aExpr/>
                    <canonical>
                      <type dash="'"/>
                    </canonical>
                  </tqExpr>
                </Sjudge>	    
              </btypes:TYPE>.
            </p>
          </li>
        </ol>
	<p>
	  <leadin>Proof: </leadin>           
          Follows from 
          Lemma&nbsp;<xref ref="eager-soundness-cor1"/>.
        </p>
      </sect3>
    </sect2>
  </sect1>
  </chapter>
  <chapter>
    <title>Implementation</title>
    
    <p>      
      The bootstrap compiler for BitC has been implemented in
      C++. Currently, the backend emits portable C code. The
      core of the compiler involves 28,686 lines of C++ code, of
      which implementation of type system accounts for about 6,894
      lines and the implementation of polymorphism accounts for 992
      lines.
    </p>
    <p>
      The bootstrap compiler for BitC implements polymorphism by
      brute-force polyinstantiation. This simplifies the
      implementation of overloading (type-classes) at the cost of
      requiring whole-program compilation. The algorithm is
      incremental, supporting use in an interactive environment&nbsp;<cite
      ref="sridhar2006polyinst"/>.  More sophisticated techniques for
      implementing polymorphism over unboxed types are explored in the
      literature&nbsp;<cites> <cite ref="leroy1992Unboxed"/> <cite
      ref="Harper1995PolymorphismTypeAnalysis"/> <cite
      ref="Shao1997Flexible"/> </cites>.  We view the current
      implementation as experimental, though it does have the
      practical advantage (important to us) that emitted types and
      code are directly inter-callable with C.
    </p>
    <p>
      There are several proposals for implementing polymorphism over
      unboxed types. For example, by using coercions&nbsp;<cite
	ref="leroy1992Unboxed"/> into a boxed representation when used
      in a polymorphic context, using dictionaries&nbsp;<cite
      ref="Harper1995PolymorphismTypeAnalysis"/> that is, passing extra type-parameters to
      functions, hybrid variations of the above&nbsp;<cite
      ref="Shao1997Flexible"/> or full polyinstantiation (C++ templates).
      Depending on the option we pick, there are different trade-offs
      with respect to the amount of RTTI support needed, separate
      compilation, efficiency, code size, <foreignphrase>etc</foreignphrase>.
    </p>    
  </chapter>
  <chapter>
    <title>Related Work</title>
        <p>
      Cyclone&nbsp;<cite ref="Jim2002Cyclone"/> supports first class
      polymorphism and polymorphic recursion for functions
      definitions. This approach is feasible in Cyclone, where there
      is a distinction between functions (code) and function pointers
      (data). In an expression language with inner functions, it is
      more intuitive to treat all first class values alike. Cyclone
      supports partial type reconstruction so that so that most types
      and instantiations of polymorphic types can be automatically
      inferred. Grossman provides a detailed account of using
      quantified types with imperative C style mutation and
      <progident>&amp;</progident> operator in Cyclone&nbsp;<cite
      ref="Grossman2006qtypes"/>. His formalization develops a general theory wherein
      any expression can be polymorphic, but requires explicit
      annotation for all polymorphic definitions and instantiations.
      Since C (and Cyclone) have no notion of immutability, both
      languages require explicit annotation of polymorphism. In
      contrast, we believe that the best way to integrate polymorphism
      into the systems programming paradigm is by automatic &mdash;
      albeit incomplete &mdash; inference. One contribution of our
      work (in comparison to&nbsp;<cite ref="Grossman2006qtypes"/>) is
      that we give a formal specification and proof of 
      correctness of the inference algorithm, not just the type
      system.
    </p>
    <p>
      Smith and Volpano have proposed an ML-style polymorphic type
      system for a dialect of C&nbsp;<cite ref="Smith1998polymorphicC"/>.
      Their system uses different binding constructs for polymorphic
      and mutable bindings &mdash; <progident>let</progident>,
      <progident>letvar</progident>, <progident>letarr</progident>.
      They impose the ML-like restriction that all first class
      references, <progident>var</progident>s and
      <progident>array</progident>s must be mutable, and function
      arguments and let-bound identifiers be immutable, because of
      which they do not have to deal with copy compatibility issues.
      Their language does not have structures and union types, and
      thus does not address complications due to parametrized types,
      and unboxed composite types with mixed unboxed mutable and
      immutable types. Our language, while being strictly more
      expressive, also provides a more natural expression of programs.
    </p>
    <p>
      A monadic model&nbsp;<cite ref="Launchbury1995stateinHaskell"/> of
      mutable state is used in pure functional languages like
      Haskell&nbsp;<cite ref="peytonjones2003haskellrevisedreport"/>.
      The main advantage of this approach is that the type system
      provides guarantees not only about the immutability of locations
      but also distinguishes side effecting computations from others.
      Therefore, this model is well suited for integration with
      theorem provers and deduction systems. However, this model is
      also considerably different from the normal programming idioms
      used by systems programmers. Hallgren
      <foreignphrase>et al.</foreignphrase> have recently proposed a
      monadic interface to low level hardware and formally specified
      certain behavioral properties about it&nbsp;<cite
	ref="hallgren2005principled"/>. They have also implemented a
      prototype operating systems in Haskell based on this system, and
      it would be interesting to see if this approach scales to a full
      implementation that provides real time guarantees. In BitC, we
      have considered providing syntactic constructs that guarantee
      side-effect free computation. For example we could have a
      defining form <progident>defpure</progident> that is similar to
      <progident>define</progident>, but allows purely applicative
      definitions only. This has the advantage of providing a
      separation of stateful computation from pure ones, as well as
      the simplicity of staying within the Hindley-Milner type system.
    </p>
    <p>
      Diatchki <foreignphrase>et al</foreignphrase> have proposed
      support for bit-level word types in Haskell&nbsp;<cite
      ref="Diatchki2005Representation"/>. Their solution could be
      extended to the full <progident>defrepr</progident> mechanism of
      BitC. Communication with the authors has revealed that there is
      a proposal for extending their prototype interpreter into a full
      implementation in the GHC compiler&nbsp;<cite
      ref="ghcManual"/>. The VFiasco project aims at formalizing the
      semantics of C++ and using it directly for verification of the
      Fiasco microkernel written in C++. They present formal semantics
      for some datatypes of C++ in&nbsp;<cite ref="hohmuth2005VFiasco"/>,
      but do not model C++ pointers, unions or mutability. 
    </p>
    <p>
      Cqual&nbsp;<cite ref="foster1999theory"/> provides a general
      framework for inference and use of type qualifiers. One of the
      applications presented in&nbsp;<cite ref="foster1999theory"/> is
      inference of (maximal) <progident>const</progident>
      qualifications for types in C programs, similar to mutability
      inference in BitC. However, their system does not deal with
      polymorphism or parametrized composite datatypes.
      SysObjC&nbsp;<cite ref="balogh2006sysobjc"/> extends the C
      programming language with object-like value types, but does
      address type safety in the face of polymorphism.
    </p>
    <p>
      C# is a safe, high-level language supports mutability and
      low-level representation, but does not support type inference.
      Spec#&nbsp;<cite ref="Barnett2004specsharp"/> is an extension of C#
      that also provides an integrated verification framework. Their
      framework is complementary to our system, and can benefit from
      BitC's mutability model&nbsp;<cite ref="specsharp2005releasenotes"/>.
    </p>
  </chapter>
  <chapter>
    <title>Conclusion</title>
    <p>
      In this paper, we have proposed a well-founded first-class
      mutability model. It is well founded in the sense that types are
      definitive about the mutability of all locations, and every
      location has one and only one type across all aliases. The model
      is first class in the sense that it supports unboxed objects and
      mutability of stack variables. This makes a language with this
      type system suitable for systems programming as well as for
      integration with a verification framework.
    </p>
    <p>
      There is a fundamental conflict of goals between the ability to
      infer principal types and to allow freedom of
      mutability-compatibility at copy boundaries. We have identified
      various trade-offs and some design choices in this regard, along
      with their pros and cons. We have proposed a solution to this
      problem that uses certain hinting mechanisms to infer types
      based on the ``natural'' flow of type information in an
      expression. We have also provided a formal framework and for out
      type system and proved it sound. The type system is implemented
      as part of the BitC language 
      compiler. Source code for the BitC compiler can be obtained from
      <progident>http://coyotos.org</progident>.
    </p>
  </chapter>
  <bibliography>    
    <bibentry label="ball2002ppabs">
      Thomas Ball, Todd Millstein, Sriram K. Rajamani
      ``Polymorphic predicate abstraction.''
      <doctitle>
	Microsoft Research Technical Report MSR_2001_10 
      </doctitle>
      June 2002.
    </bibentry>
    <bibentry label="ball2002debugging">
      Thomas Ball and Sriram K. Rajamani. ``The SLAM Project:
      Debugging System Software via Static Analysis.''
      <doctitle>Proc. 2002 ACM SIGPLAN-SIGACT Conference on Principles
      of Programming Languages</doctitle>, 2002.
    </bibentry>
    <bibentry label="balogh2006sysobjc">
      &Aacute;d&aacute;m Balogh and Zolt&aacute;n Cs&ouml;rnyei. ``SysObjC: C
      Extension for Development of Object-Oriented Operating
      Systems.'' <doctitle>Proc. Third ECOOP Workshop on Programming Languages
        and Operating Systems</doctitle>. San Jose, CA. October 2006.
    </bibentry>
    <bibentry label="Barnett2004specsharp"> 
      Mike Barnett, K. Rustan M. Leino, and Wolfram Schulte.  
      ``The Spec# programming system:  An overview.''
      <doctitle>
        CASSIS 2004, LNCS vol. 3362</doctitle>
      2004.
    </bibentry>
    <bibentry label="brewer2005thirty">
      E. Brewer, J. Condit, B. McCloskey, and F. Zhou. ``Thirty Years
      is Long Enough: Getting Beyond C.'' <doctitle>Proc. Tenth
      Workshop on Hot Topics in Operating System (HotOS X)</doctitle>,
      USENIX, 2005.
    </bibentry>
    <bibentry label="inria2004coq">
      The Coq Development Team
      ``The Coq Proof Assistant Reference Manual''
      <link href="http://coq.inria.fr/doc/main.html">
        <progident>http://coq.inria.fr/doc/main.html</progident>
      </link>
    </bibentry>
    <bibentry label="DeLine2001Vault">
      R. Deline and M. Fahndrich ``Enforcing high-level
      protocols in low-level software.''
      <doctitle>
        Proc. of the ACM Conference on Programming Language Design and
        Implementation 
      </doctitle>
      pp 59­69. 2001.
    </bibentry>
    <bibentry label="Diatchki2005Representation">
      Iavor S. Diatchki, Mark P. Jones, and Rebekah Leslie.
      ``High- level Views on Low-level Representations.''
      <doctitle>Proc. 10th ACM Conference on Functional
        Programming</doctitle> pp. 168&ndash;179.
      September 2005.
    </bibentry>
    <bibentry label="foster1999theory">
      Jeffrey S. Foster, Manuel F&auml;hndrich, and Alexander Aiken. ``A
      Theory of Type Qualifiers.'' <doctitle>Proc. SIGPLAN Conference
      on Programming Language Design and
      Implementation</doctitle> (PLDI'99). pp. 192&ndash;203. 1999.
    </bibentry>
    <bibentry label="ghcManual">
      The GHC Team
      ``The Glorious Glasgow Haskell Compilation System User's Guide,
      Version 6.6'' 
      <link
        href="http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html">
        <progident>http://www.haskell.org/ghc/docs/ latest/html/users_guide/index.html</progident>
      </link>
    </bibentry>
    <bibentry label="Grossman2006qtypes">
      D. Grossman, ``Quantified Types in an Imperative Language''
      <doctitle>ACM Transactions on Programming Languages and Systems
      </doctitle> 
      2006.
    </bibentry>
    <!-- <bibentry label="Grossman2003dissertation">
      D. Grossman ``Safe programming at the C level of abstraction.''
      <doctitle> Ph.D. dissertation. Cornell University
      </doctitle> 2003.
    </bibentry> -->
    <bibentry label="hallgren2005principled">
      T. Hallgren, M. P. Jones, R. Leslie, and A. Tolmach. ``A
      Principled Approach to Operating System Construction in
      Haskell.'' <doctitle>Proc. International Conference on
      Functional Programming (ICFP'05)</doctitle>, Sep. 2005. Tallinn,
      Estonia. pp. 116&ndash;128.
    </bibentry>
    <bibentry label="Harper1995PolymorphismTypeAnalysis">
      R. Harper and G. Morrisett. 
      ``Compiling polymorphism using intentional type analysis.'' 
      <doctitle>
        ACM Symp. on Principles of Programming Languages
      </doctitle>
      pp 130-141, January 1995
    </bibentry>
    <bibentry label="hohmuth2005VFiasco">
      Michael Hohmuth and Hendrik Tews
      ``The VFiasco approach for a verified operating system.''
      <progident>
	ECOOP Workshop on Programming Languages and Operating
	Systems 
      </progident>
      2005.
    </bibentry>
    <bibentry label="ISO1995Ada">
      ISO,
      <doctitle>International Standard ISO/IEC 8652:1995 (Information
      Technology &mdash; Programming
      Languages &mdash; Ada)</doctitle>
      International Standards Organization (ISO). 1995.
    </bibentry>
    <bibentry label="ISO1999ANSI-C">
      ISO,
      <doctitle>International Standard ISO/IEC 9899:1999 (Programming
      Languages - C)</doctitle>
      International Standards Organization (ISO). 1999.
    </bibentry>
    <bibentry label="Jim2002Cyclone">
      T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and
      Y. Wang  
      ``Cyclone: A safe dialect of C.'' 
      <doctitle>
        Proc. of USENIX Annual Technical Conference 
      </doctitle>
      pp 275­288, 2002. 
    </bibentry>
    <bibentry label="jones1995qualtypes">
      Mark P. Jones
      ``Qualified types: theory and practice.''
      <doctitle>
	Cambridge Distinguished Dissertations In Computer Science
      </doctitle>
      ISBN:0-521-47253-9, 1995
    </bibentry>
    <bibentry label="peytonjones2003haskellrevisedreport">
      Simon Peyton Jones (ed.). <doctitle>Haskell 98 Language and
	Libraries: The Revised report</doctitle>. Cambridge University
	Press. 2003.
    </bibentry>
    <bibentry label="Launchbury1995stateinHaskell">
      Launchbury, J. and Peyton Jones, S. L.
      ``State in Haskell.''
      <doctitle>
	LISP and Symbolic Computation 
      </doctitle>
      <b>8</b>, 4 (Dec.), pp 293-341, 1995. 
    </bibentry>
    <bibentry label="kaufmann00acl2">
      M. Kaufmann, J. S. Moore.
      ``Computer Aided Reasoning: An Approach''
      <doctitle>Kluwer Academic Publishers</doctitle>, 2000.
    </bibentry>
    <bibentry label="Kernighan1988C">
      Brian W. Kernighan and Dennis M. Ritchie. <doctitle>The C Programming
	Language</doctitle>. Prentice Hall, 1988
    </bibentry>
    <bibentry label="LeroyOcaml">
      Xavier Leroy,  
      ``The Objective Caml System Release 3.09, Documentation and
      User's Manual.''
      <link
        href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">
        <progident>http://caml.inria.fr/pub/docs/ manual-ocaml/index.html</progident>
      </link> 
    </bibentry>
    <bibentry label="leroy1992Unboxed">
      X. Leroy, ``Unboxed objects and polymorphic typing.''
      <doctitle> ACM SIGPLAN Symposium on Principles of 
        Programming Languages</doctitle>
      pages 177--188, January 1992.
      <b>8</b>(4):343--355, 1995.
    </bibentry>
    <bibentry label="Milner1978W">
      Robin Milner 
      ``A theory of type polymorphism in programming.''
      <doctitle>
        Journal of Computer and System Sciences
      </doctitle>
      pp 348-375, 1978.
    </bibentry>
    <bibentry label="milner97definition">
      Robin Milner, Mads Tofte, Robert Harper, and David
      MacQueen. <doctitle>The Definition of Standard ML -
      Revised</doctitle>
      The MIT Press, May 1997.
    </bibentry>
    <bibentry label="necula2002CCured">
      G. Necula, S. Mcpeak, and W. Weimer 
      ``CCured: Type-safe retrofitting of legacy code.''
      <doctitle>
        Proc. of Symposium on Principles of Programming Languages
      </doctitle> 
      pp 128­139, 2002.
    </bibentry>
    <bibentry label="Nipkow2002Isabelle">
      T. Nipkow, L. C. Paulson and M. Wenzel
      ``Isabelle/HOL &mdash; A Proof Assistant for Higher-Order
      Logic.''
      <doctitle>
        Springer LNCS series volume 2283
      </doctitle>2002.
    </bibentry>
    <bibentry label="Pfenning1999twelf">
      Frank Pfenning and Carsten Sch&uuml;rmann. ``System description:
      Twelf &mdash; a meta-logical framework for deductive systems.''
      <doctitle> Proc. of International Conference on Automated
        Deduction (CADE-16) 
      </doctitle> pp 202-206, Springer-Verlag LNAI 1632, 1999.
    </bibentry> 
    <bibentry label="pierce2002TypesBook">
      Benjamin C. Pierce
      ``Types and Programming Languages''
      <doctitle>
	The MIT Press, Massachusetts Institute of Technology
      </doctitle>
      ISBN 0-262-16209-1, 2002.      
    </bibentry>
    <bibentry label="Pierce1998local">
      Benjamin C. Pierce and David N. Turner. 
      ``Local Type Inference.''
      <doctitle>
        In Proc. of Symposium on Principles of Programming Languages 
      </doctitle> 
      pp 252-265, 1998.
    </bibentry>
    <bibentry label="Shao1997Flexible">
      Zhong Shao. ``Flexible representation analysis.''
      <doctitle>
        Proc. ACM SIGPLAN International conference on Functional programming
      </doctitle>
      pp 85 - 98, 1997.
    </bibentry>  
    <bibentry label="Smith1998polymorphicC">  	
      G. Smith and D. Volpano. 
      ``A sound polymorphic type system for a dialect of C.''
      <progident>
	Science of Computer Programming
      </progident>
      <b>32</b>(2--3):49--72, 1998. 
    </bibentry>
    <bibentry label="specsharp2005releasenotes"> 
      Spec# team
      ``Spec# 1.0.6404 for Microsoft Visual Studio 2005 Release
      Notes'' 
      <link
        href="http://research.microsoft.com/specsharp/1.0.6404/relnotes.htm">
        <progident>http://research.microsoft.com/specsharp /1.0.6404/relnotes.htm</progident>
      </link>
    </bibentry>
    <bibentry label="tschantz2005javari"> 
      Matthew S. Tschantz and Michael D. Ernst,     
      ``Javari: Adding reference immutability to Java''
      <doctitle>
	Object-Oriented Programming Systems, Languages, and
	Applications
      </doctitle>
      pp 211-230, October 2005.
    </bibentry>
    <bibentry label="wrightValRes1995">
      A. K. Wright, ``Simple Imperative Polymorphism'' 
      <doctitle> Lisp and Symbolic Computation</doctitle>
      8(4):343--355, 1995.
    </bibentry>
    <bibentry label="sridhar2006polyinst">
      Swaroop Sridhar ``Implementation of Polymorphism in BitC''
      <link
        href="http://coyotos.org/docs/bitc/polyinst.html">
        <progident>http://www.coyotos.org/ docs/bitc/polyinst.html</progident>
      </link>
    </bibentry>
    <bibentry label="sridhar2006plos">
      S. Sridhar and J. Shapiro. ``Type Inference for Unboxed Types
      and First Class Mutability'' <doctitle>Proc. 3rd ECOOP Workshop
      on Programming Languages and Operating Systems (PLOS
      2006)</doctitle> San Jose, CA. 2006.
    </bibentry>
    <bibentry label="shapiro2006coyotos">
      J. S. Shapiro, Eric Northup, M. Scott Doerrie, and Swaroop
      Sridhar.  <doctitle>Coyotos Microkernel
      Specification</doctitle>, 2006, available online at <link
      href="http://www.coyotos.org">www.coyotos.org</link>.
    </bibentry>
    <bibentry label="Harris2005HaskellonProcessor">
      Tim Harris, Simon Marlow and Simon Peyton Jones
      ``Haskell on a shared-memory multiprocessor''
      <doctitle>
        Proc. of the 2005 ACM SIGPLAN workshop on Haskell.
      </doctitle>
      pp 49-61, 2005.
    </bibentry>
    <bibentry label="Xi200dependentMut">
      H. XI
      ``Imperative programming with dependent types.''
      <doctitle>
        Proc. of IEEE Symposium on Logic in Computer Science
      </doctitle>
      pp 375­387, 2000.
    </bibentry>
    <bibentry label="shap1999fastcapsystem">
      J. S. Shapiro, J. M. Smith, and D. J. Farber. ``EROS, A Fast
      Capability System'' <doctitle>Proc. 17th ACM Symposium on Operating
	Systems Principles</doctitle>. Dec 1999. pp. 170&ndash;185. Kiawah
      Island Resort, SC, USA.
    </bibentry>
    <bibentry label="fahndrich2006language">
      M. F&auml;hndrich, M. Aiken, C. Hawblitzel, O. Hodson, G. Hunt,
      J. R. Lauris, and S. Levi. ``Language Support for Fast and
      Reliable Message-based Communication in Singularity OS.''
      <doctitle>Proc. EUROSYS 2006</doctitle>, Leuven Belgium. 2006
    </bibentry>
    <bibentry label="aiken2006deconstructing">
      M. Aiken, M. F&auml;hndrich, C. Hawblitzel, G. Hunt, and
      J. R. Lauris. ``Deconstructing Process Isolation.''
      <doctitle>Microsoft Technical Report
	MSR-TR-2006-43</doctitle>. Microsoft, Inc. 2006
    </bibentry>
    <bibentry label="DeLineVault">
      M. F&auml;hndrich and R. DeLine
      "Adoption and Focus: Practical Linear Types for Imperative
      Programming."
      <doctitle>
        Proc. of the ACM Conference on Programming Language Design and
        Implementation
      </doctitle>
      June 2002.
    </bibentry>
    <bibentry label="Schoeller2003eiffel">
      Bernd Schoeller. ``Strengthening
      Eiffel contracts using models.'' <doctitle> Hung Dang Van and
        Zhiming Liu, editors, Proceeding of the Workshop on Formal
        Aspects of Component Software FACS'03, </doctitle>
      September 2003.
    </bibentry>
    <bibentry label="Jacobs2006mtverify">
      Bart Jacobs, Jan Smans, Frank Piessens, Wolfram Schulte.
      ``A Simple Sequential Reasoning Approach for Sound Modular
      Verification of Mainstream Multithreaded Programs''
      <doctitle>
      Proc. of
      Multithreading in Hardware and Software:
      Formal Approaches to Design and Verification
      (TV 2006),
      </doctitle>
      Seattle, 2006.
    </bibentry>
    <bibentry label="SmithVolpanoPTVR1996">
      Geoffrey Smith and Dennis Volpano.
      ``Polymorphic typing of variables and references''
      <doctitle>
        ACM Transactions on Programming Languages and Systems
      </doctitle>
      Pages: 254 - 267, May 1996
    </bibentry>
    <bibentry label="peytonjones1993monads">
      Simon Peyton Jones and Philip Wadler
      ``Imperative functional programming.''
      <doctitle>
	Proc. ACM SIGPLAN Principles of Programming Languages.
      </doctitle>
      1993
    </bibentry>
    <bibentry label="wrightValRes1995">
      A. K. Wright, ``Simple Imperative Polymorphism'' 
      <doctitle> Lisp and Symbolic Computation</doctitle>
      8(4):343--355, 1995.
    </bibentry>
    <bibentry label="pierce2002TypesBook">
      Benjamin C. Pierce
      ``Types and Programming Languages''
      <doctitle>
	The MIT Press, Massachusetts Institute of Technology
      </doctitle>
      ISBN 0-262-16209-1, 2002.      
    </bibentry>
    <bibentry label="garrigueValRes2004">
      J. Garrigue, ``Relaxing the Value Restriction'' <doctitle>
        International Symposium on Functional and Logic
        Programming</doctitle> 2004.
    </bibentry>
    <bibentry label="Grossman2006qtypes">
      D. Grossman, ``Quantified Types in an Imperative Language''
      <doctitle>ACM Transactions on Programming Languages and Systems
      </doctitle> 
      2006.
    </bibentry>
    <bibentry label="Grossman2003dissertation">
      D. Grossman ``Safe programming at the C level of abstraction.''
      <doctitle> Ph.D. dissertation. Cornell University
      </doctitle> 2003.
    </bibentry>
    <bibentry label="shapBitcSpec2006">
      J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
      Specification'' 
      <link
        href="http://coyotos.org/docs/bitc/spec.html">
        <progident>http://coyotos.org/docs/bitc/spec.html</progident>
      </link>
    </bibentry>
    <bibentry label="sridharmutinfer2006">
      S. Sridhar, J. S. Shapiro ``Design of Type and Mutability
     Inference in BitC''
      <doctitle>Systems Research Laboratory Technical Report
        SRL2006-01</doctitle> Johns Hopkins University, 2006.
      <link
        href="http://www.coyotos.org/docs/bitc/mutinfer.html">
        <progident>http://www.coyotos.org/docs/bitc/mutinfer.html</progident> 
      </link>
    </bibentry>    
    <bibentry label="vaughanHM">
      Jeff Vaughan ``A proof of correctness for the Hindley-Milner
      type inference algorithm''
      <link
        href="http://www.seas.upenn.edu/~vaughan2/docs/hmproof.pdf">
        <progident>http://www.seas.upenn.edu/~vaughan2/docs/hmproof.pdf</progident> 
      </link>
    </bibentry>
  </bibliography>
</book>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->


<!--  LocalWords:  ptsz authorgroup firstname orgname sridharmutinfer bnf desc
 -->
<!--  LocalWords:  sLoc hLoc aVal aExpr lvalues lVal tqExpr bnfc dup opsem eval
 -->
<!--  LocalWords:  opState dyn sem Grossman qtypes levalOp evalOp RVAL aTS pred
 -->
<!--  LocalWords:  subst Csubst ceqOp maxzOp minzOp eq maxz neq minz metaCT ol
 -->
<!--  LocalWords:  covariant arg ret ceil Tsub TDjudge Hrules tyRule TW tyPre
 -->
<!--  LocalWords:  tyConc lval decl judgeOp Garriage's spEqOp notin spEq unin
 -->
<!--  LocalWords:  uninOp Sjudge dom mapsto rexec leadin leval supeq aSubMap Ph
 -->
<!--  LocalWords:  VSubstitution LSubstitution SubMap TEjudge UNF unf subeq ACM
 -->
<!--  LocalWords:  mbpair TIjudge vaughanHM Hindley Milner mdash epsiv corUp HL
 -->
<!--  LocalWords:  TypesBook corUpOp carrys epsi ASET SRL unkinded pagebreak SL
 -->
<!--  LocalWords:  Garriague's vspace CTX MTVs FTVs NTVs cst commut sust ok su
 -->
<!--  LocalWords:  canonicalized ndash si uf ua vf rh va sa subeqOp supeqOp eqi
 -->
 
<!--  LocalWords:  nceq
 -->

  
