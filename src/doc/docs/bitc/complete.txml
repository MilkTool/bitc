<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <article id="asplas" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo ptsz='default' latex.documentclass="llncs">
    <title>Sound and Complete Type Inference for a Systems Programming Language</title>
    <authorgroup>
      <author>
      	<firstname>Swaroop</firstname>
      	<surname>Sridhar</surname>
      	<email>swaroop@cs.jhu.edu</email>
      </author>
      <author>
      	<firstname>Jonathan</firstname>
        <othername>S.</othername>
      	<surname>Shapiro</surname>
      	<email>shap@eros-os.org</email>
      </author>
      <author>
      	<firstname>Scott</firstname>
        <othername>F.</othername>
      	<surname>Smith</surname>
      	<email>scott@cs.jhu.edu</email>
      </author>
      <affiliation>
	<address>
	  Department of Computer Science,
	  The Johns Hopkins University</address> 
      	<email>
	  swaroop@cs.jhu.edu, shap@cs.jhu.edu, scott@cs.jhu.edu
	</email>
      	<!-- <orgname>Department of Computer Science</orgname>
	<address>The Johns Hopkins University</address> 
	<address>3400 N. Charles Street, 224 NEB, 
	Baltimore, MD 21218</address> -->
      </affiliation>
    </authorgroup>
    <pubdate></pubdate>
    <!-- <categories>
    <category>dev/bitc</category>
  </categories> -->
    <categories>
      <category>bitc/formal</category>
    </categories>
    <synopsis>
      <p>
        A Theory of BitC mutability model and type inference.
	The HTML version of this paper is not
        able to represent all of the mathematical notation correctly.
      </p>
    </synopsis>
  </docinfo> 
  <abstract latex.incolumn="yes">
    <p>
      This paper introduces a new type system designed for
      safe systems programming. The type system features
      a new mutability model that combines unboxed types
      with a consistent typing of mutability. The type system is
      provably sound, supports polymorphism, and eliminates the need
      for alias analysis to determine the immutability of a location. 
      A sound and complete type inference algorithm for this system is
      presented.
    </p>
  </abstract>
  <sect1>
    <title>Introduction</title>
    <p>
      Recent advances in the theory and practice of programming
      languages have resulted in modern languages and tools that
      provide certain correctness guarantees regarding the execution
      of programs. However, these advances have not been effectively
      applied to the construction of <em>systems programs</em>, the
      core components of a computer system. One of the primary causes
      of this problem is the fact that existing languages do not
      simultaneously support modern language features &mdash; such as
      static type safety, type inference, higher order functions and
      polymorphism &mdash; as well as features
      that are critical to the correctness and performance of systems
      programs such as prescriptive data structure
      representation and mutability. In this paper, we endeavor to
      bridge this gap between modern language design and systems
      programming. We first discuss the support for these features in
      existing languages, identify the challenges in combining these
      feature sets and then describe our approach toward 
      solving this problem.  
    </p> 
    <p>
      <leadin>Representation Control</leadin> A systems programming
      language must be expressive enough to specify details of
      representation including boxed/unboxed data-structure layout and 
      stack/heap allocation.  For systems programs,
      this is both a correctness as well as a performance
      requirement. Systems programs interact with the hardware through
      data structures such as page tables whose representation is
      dictated by the hardware. Conformance to these representation
      specifications is necessary for correctness. 
      Languages like ML&nbsp;<cite ref="milner97definition"/>
      intentionally omit
      details of representation from the language definition, since
      this greatly simplifies the mathematical description of the
      language. Compilers like TIL&nbsp;<cite ref="Tarditi1996TIL"/> 
      implement unboxed representation as a discretionary
      optimization. However, in systems programs, statements about
      representation are 
      <em>prescriptive</em>, not <em>descriptive</em>.  
      Formal treatment of representation is required in 
      systems programming languages.
    </p>
    <p>
      Systems programs also rely on representation control
      for performance since it affects cache locality
      and paging behavior. This expressiveness is also crucial for
      interfacing with external C&nbsp;<cite ref="ISO1999ANSI-C"/> or
      assembly code and data. For 
      example, a careful implementation of the TCP/IP
      protocol stack in Standard ML incurred a substantial overhead of
      up to 10x increase in system load and a 40x slowdown in
      accessing external memory relative to the equivalent C
      implementation&nbsp;<cites>  
	<cite ref="Biagioni2001FoxNet"/>
	<cite ref="Derby1999Foxnet"/>
      </cites>.
      This shows that representation control is as important as, or even
      more important than, high level algorithms for the performance of
      systems tasks. 
    </p>
    <p>
      <leadin>Complete Mutability</leadin> One of the key features
      essential for systems programming is support for mutability. The
      support for mutability must be `complete' in the sense that any
      location &mdash; whether on the stack, heap, or within other
      unboxed structures &mdash; can be mutated. 
      Allocation of mutable cells on the stack boosts performance
      because (1) the top of the stack is typically accessible from
      the data cache (2) stack locations are directly addressable
      and therefore do not require the extra dereferencing involved in
      the case of heap locations (3) stack allocation does
      not involve  garbage collection overhead. This is particularly
      important for high confidence and/or embedded kernels as they
      cannot tolerate unpredictable variance in overhead caused by
      heap allocation and collection. ML-like languages require
      all mutable (<progident>ref</progident>) cells to reside on the
      heap. In pure languages like 
      Haskell&nbsp;<cite ref="peytonjones2003haskellrevisedreport"/>,
	the support for mutability is even more restrictive than ML. 
      These restricted models of mutability are
      insufficiently expressive from a systems programming perspective.
    </p>
    <p>
      <leadin>Consistent Mutability</leadin>
      The mutability support in a language is said to be
      `consistent' if the (im)mutability
      of every location  is invariant across all aliases over program
      execution. In this model, there is a sound notion of
      immutability of locations. This benefits tools that perform
      static analysis or model checking because conclusions drawn
      about the immutability of a location need never be
      conservative. It also increases the amount of optimization that
      a compiler can safely perform without complex alias
      analysis. Polymorphic type inference systems such as
      Hindley-Milner algorithm&nbsp;<cite ref="Milner1978W"/> also 
      rely on a sound notion of immutability. ML supports consistent
      mutability since types are definitive about the (im)mutability
      of every location. In contrast, C does not support this
      feature. For example, in C it is legal to write:   
      <br/>
      <progident>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	const bool *cp = ...;   
	bool *p = cp;
	*p = false;  // OK!
      </progident>
      <br/>
      The alleged ``constness'' of the location pointed to by
      <progident>cp</progident> is a local property (only) with
      respect to the alias <progident>cp</progident> and not a
      statement of true immutability of the target location.
      The analysis and optimization of critical
      systems programs can be improved by using a language 
      with a consistent mutability model. 
    </p>
    <p>
      <leadin>Type Inference and Polymorphism</leadin> Type
      inference achieves the advantages of static typing
      with a lower burden on the programmer, facilitating rapid
      prototyping and development. Polymorphic type inference 
      (c.f. ML or Haskell) combines the advantages of static type
      safety with much of the convenience provided by dynamically
      typed languages like Python&nbsp;<cite ref="pythonSpec"/>. 
      Automatic inference of polymorphism simplifies generic
      programming, and therefore increases the reuse and reliability
      of code. Safe languages like Java&nbsp;<cite ref="javaSpec"/>, 
      C#&nbsp;<cite ref="csharpSpec"/>, 
      or Vault&nbsp;<cite ref="DeLineMSRVault"/> do not support type
      inference. Cyclone&nbsp;<cite ref="Jim2002Cyclone"/> features
      partial type inference and supports polymorphism only for
      functions with explicit type annotations.
    </p>
    <p>
      The following table summarizes the support available in 
      existing languages for the above features and static
      type safety:
    </p>
    <xi:include href="include/complete/lang-comp.xmli"/>
    <br/>
    <br/>
    <p>
      In this paper, we present a new type system and formal
      foundations for a safe systems programming language that
      supports all of the above features.
    </p>
    <!-- <p>
      While several of the existing safe
      languages support two of the three features  &mdash; unboxed
      representation, mutability and polymorphic type inference
      &mdash; none combine all of them elegantly. 
      Further, none of the existing languages support a mutability
      model that is both complete and consistent.
      Therefore,
      systems programmers either continue to use languages such as
      Ada&nbsp;<cite ref="ISO1995Ada"/>, 
      C&nbsp;<cite ref="ISO1999ANSI-C"/>, and
      C++&nbsp;<cite ref="ISO1998C++"/>, or follow a ``two
      language'' discipline where they use a
      combination of safe and unsafe languages. For example, the
      SwitchWare&nbsp;<cite ref="Alexander98"/>
      active network architecture is largely written in
      Ocaml&nbsp;<cite ref="LeroyOcaml"/>, but 
      performance critical components such as SHA-1 hash computation
      are implemented in C.
  </p> -->
    <p>
      The combination of mutability and unboxed
      representation presents several challenges for type
      inference. Mutability is an attribute of the <em>location</em>
      storing a value and not the value itself. Therefore, two
      expressions across a copy boundary (ex: arguments copied at a
      function call) can differ in their
      mutability. We refer to this notion of mutability compatibility
      of types as <em>copy compatibility</em>. 
      Copy compatibility creates ramifications for
      syntax-directed type and mutability inference. Type
      inference is further complicated due to well known problems with
      the interaction of mutability and 
      polymorphism&nbsp;<cite ref="wrightValRes1995"/>. This has
      forced a second-class treatment of mutability in ML-like
      languages and a lack of inferred polymorphism in others.
    </p>
    <p>
      We present a sound and complete polymorphic type
      inference algorithm for a language that supports consistent and
      complete mutability. In order to overcome the challenges
      posed by copy compatibility, the underlying type system uses a
      system of constrained types that range over mutability and
      polymorphism. Safety of the type system as well as the soundness
      and completeness of the type inference algorithm have been
      proved.
    </p>
  </sect1>
  <sect1 id="informal">
    <title>Informal Overview</title>
    <btypes:TYPE>
      <vspace ptsz="-2ex"/>
    </btypes:TYPE>
    <p>
      In this section, we give an informal description of our type
      system and inference algorithm. 
      For purposes of presentation in this paper, we define
      <btypes:TYPE>
	<language/> </btypes:TYPE>, a core systems programming
      language calculus.
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> is a direct expression of lambda
      calculus with side effects, extended to be able to reflect the
      semantics of explicit representation. 
    </p>
    <xi:include href="include/complete/lang.xmli"/>
    <p>
      The type
      <btypes:TYPE>
	<ref>
	  <type/>
	</ref>
      </btypes:TYPE> represents a reference (pointer) type and 
      <btypes:TYPE>
	<mutable>
	  <ptype/>
	</mutable>
      </btypes:TYPE> represents a mutable type. 
      The expression
      <btypes:TYPE>
	<dup>
	  <aExpr/>
	</dup>
      </btypes:TYPE>,
      where 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>,
      returns a reference 
      of type
      <btypes:TYPE>
	<ref>
	  <type/>
	</ref>
      </btypes:TYPE> to a heap-allocated <em>copy</em>
      of the value of 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>. 
      The <progident>^</progident> operator is used to
      dereference heap cells.       
      Pairs <progident>(,)</progident>
      are <em>unboxed</em> structures whose
      constituent elements are contiguously allocated on the
      stack, or in their containing data-structure. 
      <btypes:TYPE>
	<fst>
	  <aExpr/>
	</fst>
	<text content=" and "/>
	<snd>
	  <aExpr/>
	</snd>
      </btypes:TYPE> perform selection from pairs.
      We define
      <btypes:TYPE>
	<eq>
	  <other>
	    <texttt content="1"/>
	  </other>
	  <texttt content="2"/>
	</eq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <other>
	    <texttt content="2"/>
	  </other>
	  <texttt content="1"/>
	</eq>
      </btypes:TYPE>.
      The <progident>let</progident> construct can be used for
      allocating (possibly mutable) stack variables and to create
      let-polymorphic bindings.
      <btypes:TYPE>
	<let optQual="yes">
	  <id/>
	  <aExpr/>
	</let>
      </btypes:TYPE>
      represents optional type qualification of let-bound variables.
    </p>
    <p>
      <leadin>The Mutability Model</leadin>
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> supports consistent, complete mutability.
      The mutability support is complete since the
      <progident>:=</progident> operator mutates both stack locations
      (let-bound locals, function parameters) and heap locations
      (<progident>dup</progident>-ed values). It can also perform
      in-place updates to individual fields of unboxed pairs.
      The mutability support is consistent since we impose the 
      ``one location, one type'' rule. For example, in the following
      expression,
      <br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <btypes:TYPE>
	<let>
	  <tqExpr>
	    <id name="cp"/>
	    <ref>
	      <bool/>
	    </ref>
	  </tqExpr>
	  <dup>
	    <true/>
	  </dup>
	  <let>
	    <tqExpr>
	      <id name="p"/>
	      <ref>
		<mutable>
		  <bool/>
		</mutable>
	      </ref>
	    </tqExpr>
	    <id name="cp"/>
	  </let>
	</let>
      </btypes:TYPE>
      &nbsp;&nbsp;
      <progident>
	(* Error *)
      </progident>
      <br/>
      <btypes:TYPE>
	<id name="cp"/>
      </btypes:TYPE> has the type reference to bool
      (<btypes:TYPE>
	<ref>
	  <bool/>
	</ref>
      </btypes:TYPE>), which is incompatible with that of 
      <btypes:TYPE>
	<id name="p"/>
      </btypes:TYPE>, reference to mutable-bool
      (<btypes:TYPE>
	<ref>
	  <mutable>
	    <bool/>
	  </mutable>
	</ref>
      </btypes:TYPE>).
      Unlike ML, <progident>:=</progident> does not dereference its target.  
      The expressions that can appear on the left of an assignment
      <progident>:=</progident> are restricted  to
      left expressions (defined by the above grammar).
      This not only preserves the programmer's mental model of the
      relationship between locations storage, but also ensures that
      compiler transformations are semantics preserving.
    </p>
    <p>
      <leadin>Copy Compatibility</leadin> 
      <btypes:TYPE> <language/> </btypes:TYPE> is a
      call-by-value language, and supports 
      copy compatibility, which permits locations across a
      copy boundary to differ in their mutability.
      For example, in the following expression: 
      <br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <btypes:TYPE>
	<let>
	  <id name="fnxn"/>
	  <lambda>
	    <id name="x"/>
	    <paren>
	      <assign>
		<id name="x"/>
		<false/>
	      </assign>
	    </paren>
	  </lambda>
	  <let>
	    <tqExpr>
	      <id name="y"/>
	      <bool/>
	    </tqExpr>
	    <true/>
	    <apply>
	      <id name="fnxn"/>
	      <id name="y"/>
	    </apply>
	  </let>
	</let>
      </btypes:TYPE>
      <br/>
      the type of
      <btypes:TYPE>
	<id name="fnxn"/>
      </btypes:TYPE> is
      <btypes:TYPE>
	<fn>
	  <paren>
	    <mutable>
	      <bool/>
	    </mutable>
	  </paren>
	  <unit/>
	</fn>
      </btypes:TYPE>, whereas that of the actual argument
      <btypes:TYPE>
	<id name="y"/>
      </btypes:TYPE> is
      <btypes:TYPE>
	<bool/>
      </btypes:TYPE>.
      Since 
      <btypes:TYPE>
	<id name="x"/>
      </btypes:TYPE> is a <em>copy</em> of 
      <btypes:TYPE>
	<id name="y"/>
      </btypes:TYPE> and occupies a different location, 
      this expression is type safe. 
      Thus, we write
      <btypes:TYPE>
	<ceq>
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	</ceq>
      </btypes:TYPE>, where &cong; indicates copy compatibility.
    </p>
    <p>
      Copy compatibility must not extend past a reference
      boundary in order to ensure that every location has a unique
      type. We define copy compatibility for 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> as:
    </p>    
    <font size="small">
      <btypes:TYPE>
	<Hrules initsep="2" colsep="3">
	  <tyRule>
	    <tyPre/>
	    <tyConc>
	      <ceq>                
		<type/>
		<type/>
	      </ceq>
	    </tyConc>                
	  </tyRule>   
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="2"/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>
		<type num="2"/>
		<type num="1"/>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="2"/>
	      </ceq>
	      <ceq>                
		<type num="2"/>
		<type num="3"/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>
		<type num="1"/>
		<type num="3"/>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type/>
		<ptype/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>                
		<type/>
		<mutable>
		  <ptype/>
		</mutable>
	      </ceq>
	    </tyConc>                
	  </tyRule>   
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="1" dash="'"/>
	      </ceq>
	      <ceq>
		<type num="2"/>
		<type num="2" dash="'"/>
	      </ceq>
	    </tyPre>
	    <tyConc>
	      <ceq>
		<pair>
		  <type num="1"/>
		  <type num="2"/>
		</pair>
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	</Hrules>
      </btypes:TYPE>
    </font>
    <br/>
    <p>
      Copy compatibility is allowed at all positions where a copy is
      performed: at argument passing, new
      variable binding, assignment, and basically in all expressions
      where a left-expression is not expected or returned.
      For example, the expression  
      <btypes:TYPE>
	<tqExpr>
	  <paren>
	    <tqExpr>
	      <id name="x"/>
	      <type/>
	    </tqExpr>
	  </paren>
	  <mutable>
	    <type/>
	  </mutable>
	</tqExpr>
      </btypes:TYPE> is ill typed, but 
      the branches of a conditional can have
      different but copy compatible types
      as in
      <btypes:TYPE>
	<if>
	  <true/>
	  <tqExpr>
	    <id name="a"/>
	    <type/>
	  </tqExpr>
	  <tqExpr>
	    <id name="b"/>
	    <mutable>
	      <type/>
	    </mutable>
	  </tqExpr>
	</if>
      </btypes:TYPE> .
    </p>
    <btypes:TYPE>
      <vspace ptsz="-4pt"/>
    </btypes:TYPE>
    <sect2 id="infer">
      <title>Type Inference</title>
      <btypes:TYPE>
	<vspace ptsz="-3pt"/>
      </btypes:TYPE>
      <p>
	We now consider the problem of designing a type inference
	algorithm for 
	<btypes:TYPE>
	  <language/>
	</btypes:TYPE>.
	Due to copy compatibility, it is no longer possible
	to infer a unique (simple) type for all expressions. 
	For example, in the expression
	<btypes:TYPE>
	  <let>
	    <id name="p"/>
	    <true/>
	  </let>
	</btypes:TYPE>, 
	we know that the type of the literal
	<btypes:TYPE>
	  <true/>
	</btypes:TYPE> is
	<btypes:TYPE>
	  <bool/>
	</btypes:TYPE>, but the type of
	<btypes:TYPE>
	  <id name="p"/>
	</btypes:TYPE>
	could either be
	<btypes:TYPE>
	  <bool/>
	</btypes:TYPE> or
	<btypes:TYPE>
	  <mutable>
	    <bool/>
	  </mutable>
	</btypes:TYPE>. 
	Therefore, unlike ML, we cannot use a 
	straightforward syntax-directed type inference algorithm
	in 
	<btypes:TYPE>
	  <language/>
	</btypes:TYPE>.
      </p>
      <p>
	It is natural to ask why mutability should be inferred at all.
	That is: why not require explicit annotation for all mutable
	values, and infer immutable types by default? Unfortunately,
	in a language with copy compatibility, this will result in a
	proliferation of type annotations. Constructor applications, 
	polymorphic type instantiations, accessor functions,
	<foreignphrase>etc.</foreignphrase> 
	will have to be explicitly annotated with their types. For
	example, if
	<btypes:TYPE> 
	  <id name="fst"/>
	</btypes:TYPE>
	is an accessor function that returns the first element of a
	pair, and  
	<btypes:TYPE> 
	  <id name="m"/>
	</btypes:TYPE>
	is a variable of type
	<btypes:TYPE> 
	  <mutable>
	    <bool/>
	  </mutable>
	</btypes:TYPE>, we will have to write: 
	<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<btypes:TYPE> 
	  <let>
	    <id name="xyz"/>
	    <tqExpr>
	      <dup>
		<apply>
		  <id name="fst"/>
		  <tqExpr nosp="yes">
		    <Pair>
		      <id name="m"/>
		      <false/>
		    </Pair>
		    <pair>
		      <mutable>
			<bool/>
		      </mutable>
		      <bool/>
		    </pair>
		  </tqExpr>
		</apply>
	      </dup>
	      <ref>
		<mutable>
		  <bool/>
		</mutable>
	      </ref>
	    </tqExpr>
	    <unspecified/>
	  </let>
	</btypes:TYPE>
	<br/>
	Therefore, if mutability is not inferred, it results in a
	substantial increase in the number of programmer annotations,
	and type inference becomes ineffective.
	It is desirable that the inference algorithm must
	automatically infer polymorphism (without any programmer
	annotations) as well, since this leads to better software
	engineering by maximizing code reuse.
      </p>
      <p>
	Therefore, the desirable characteristics of a type inference
	algorithm for   
	<btypes:TYPE>
	  <language/>
	</btypes:TYPE> are:
	<br/>
	(1) It must be sound, complete, and decidable without programmer
	    annotations. 
	<br/>
	(2) It must automatically infer both polymorphism and
	    mutability.
	<br/>
	(3) It must infer types that are intelligible to the programmer.
	That is, it must 
	<br/>
	&nbsp;&nbsp;&nbsp;
	avoid the main drawback of many inference
	systems with subtyping, where 
	<br/>
	&nbsp;&nbsp;&nbsp;
	the inferred principal type is presented as a set of 
	equations and inequations. 
      </p>
      <p>
	In order to address the above requirements, we propose a
	variant of the Hindley-Milner algorithm&nbsp;<cite
	  ref="Milner1978W"/>. This algorithm uses constrained types
	that range over mutability and polymorphism in order to infer
	principal types for       
	<btypes:TYPE>
	  <language/>
	</btypes:TYPE> programs.
      </p>
      <p>
	<leadin>Polymorphism Over Mutability</leadin>
	In order to infer principal types in a language with copy
	compatibility, we define the following constrained types that
	allow us to infer types with variable mutability.
	Let 
	<btypes:TYPE>
	  <TceqOp/>
	</btypes:TYPE> be a equivalence relation on types such that
	<btypes:TYPE>
	  <Tceq>
	    <ptype/>
	    <mutable>
	      <ptype/>
	    </mutable>
	  </Tceq>
	</btypes:TYPE>.
	Let 
	<btypes:TYPE>
	  <ctype>
	    <type/>
	    <operator symbol="eta"/>
	  </ctype>
	</btypes:TYPE> denote a constrained type where
	<btypes:TYPE>
	  <type/>
	</btypes:TYPE> is constrained by the set of (in)equations
	<btypes:TYPE>
	  <operator symbol="eta"/>
	</btypes:TYPE>. We write :
	<br/>
	<btypes:TYPE>
	  <equiv>
	    <mbTop>
	      <tvar/>
	      <ptype/>
	    </mbTop>
	    <ctype>
	      <tvar/>
	      <set>
		<Tceq>
		  <tvar/>
		  <ptype/>
		</Tceq>
	      </set>
	    </ctype>
	  </equiv>
	</btypes:TYPE>:
	any type equal to base type 
	<btypes:TYPE>
	  <ptype/>
	</btypes:TYPE> except for top level mutability.
	<br/>
	<btypes:TYPE>
	  <equiv>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	    <ctype>
	      <stype/>
	      <set>
		<ceq>
		  <stype/>
		  <ptype/>
		</ceq>
	      </set>
	    </ctype>
	  </equiv>
	</btypes:TYPE>:
	any type copy compatible with
	<btypes:TYPE>
	  <ptype/>
	</btypes:TYPE>, where
	<btypes:TYPE>
	  <eq>
	    <stype/>
	    <grouping>
	      <tvar/>
	      <text content=" or "/>
	      <mutable>
		<tvar/>
	      </mutable>
	    </grouping>
	  </eq>
	</btypes:TYPE>.
      </p>
      <p>
	Now, in the expression
	<btypes:TYPE>
	  <let>
	    <id name="p"/>
	    <true/>
	  </let>
	</btypes:TYPE>, 
	we can give
	<btypes:TYPE>
	  <id name="p"/>
	</btypes:TYPE>  the type
	<btypes:TYPE>
	  <mbFull>
	    <tvar/> 	  
	    <bool/>
	  </mbFull>
	</btypes:TYPE>.
	During inference, the type can later get resolved to either
	<btypes:TYPE>
	  <bool/>
	</btypes:TYPE> or
	<btypes:TYPE>
	  <mutable>
	    <bool/>
	  </mutable>
	</btypes:TYPE>.
	The forms 
	<btypes:TYPE>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</btypes:TYPE> and
	<btypes:TYPE>
	  <mbFull>
	    <stype/>
	    <ptype/>
	  </mbFull>
	</btypes:TYPE> respectively provide fine grained and coarse
	grained control over expressing types with 
	variable mutability. For example:
      </p>
      <font size="small">
	<table fullwidth="yes" latex.colspec="c|c|c">
	  <tbody>
	    <tr lineafter="yes">
	      <td><p>Type</p></td>
	      <td><p>Instances</p></td>
	      <td><p>Non-Instances</p></td>
	    </tr>
	    <!-- Row -->
	    <tr lineafter="yes">
	      <td>
		<p>
		  <btypes:TYPE>
		    <mbTop>
		      <tvar/>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mbTop>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <bool/>
		      <unit/>
		    </pair>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mutable>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mutable>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <mutable>
			<bool/>
		      </mutable>
		      <unit/>
		    </pair>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr>
	      <td>
		<p>
		  <btypes:TYPE>
		    <mbFull>
		      <tvar/>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mbFull>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <bool/>
		      <unit/>
		    </pair>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mutable>
		      <pair>
			<mutable>
			  <bool/>
			</mutable>
			<mutable>
			  <unit/>
			</mutable>
		      </pair>
		    </mutable>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <unit/>
		      <bool/>
		    </pair>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <tr lineafter="yes">
	      <td/>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <mutable>
			<bool/>
		      </mutable>
		      <unit/>
		    </pair>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mbTop>
		      <tvar name="beta"/>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mbTop>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td/>
	    </tr>
	    <!-- Row -->
	    <tr lineafter="yes">
	      <td>
		<p>
		  <btypes:TYPE>
		    <mbFull>
		      <mutable>
			<tvar/>
		      </mutable>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mbFull>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <mutable>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mutable>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mutable>
		      <pair>
			<bool/>
			<mutable>
			  <unit/>
			</mutable>
		      </pair>
		    </mutable>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <pair>
		      <bool/>
		      <unit/>
		    </pair>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mbTop>
		      <tvar name="beta"/>
		      <pair>
			<bool/>
			<unit/>
		      </pair>
		    </mbTop>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr lineafter="yes">
	      <td>
		<p>
		  <btypes:TYPE>
		    <mbFull>
		      <tvar/>
		      <ref>
			<bool/>
		      </ref>
		    </mbFull>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <ref>
		      <bool/>
		    </ref>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <mutable>
		      <ref>
			<bool/>
		      </ref>
		    </mutable>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE>
		    <ref>	
		      <mutable>
			<bool/>
		      </mutable>
		    </ref>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	  </tbody>
	</table>
      </font>
      <br/>
      <p>
	By embedding constraints within types, we obtain an elegant
	representation of constrained types that are self contained. 
	The programmer is just presented a type, rather than a type
	associated with a set of unsolved inequations.  
	<!-- For example, the expression
	<btypes:TYPE>
	  <lambda>
	    <id/>
	    <paren>
	      <assign>
		<deref>
		  <fst>
		    <id/>
		  </fst>
		</deref>
		<snd>
		  <id/>
		</snd>
	      </assign>
	    </paren>
	  </lambda>
	</btypes:TYPE>
	can be typed as
	<btypes:TYPE>
	  <fn>
	    <mbFull>
	      <tvar name="alpha"/>
	      <pair>
		<ref>
		  <mutable>
		    <tvar name="beta"/>
		  </mutable>
		</ref>
		<mbFull>
		  <tvar name="gamma"/>
		  <tvar name="beta"/>
		</mbFull>
	      </pair>
	    </mbFull>
	    <unit/>
	  </fn>
	</btypes:TYPE>, rather than
	<btypes:TYPE>
	  <ctype>
	    <fn>
	      <tvar name="alpha"/>
	      <unit/>
	    </fn>
	    <set>
	      <ceq>
		<tvar name="alpha"/>
		<pair>
		  <ref>
		    <mutable>
		      <tvar name="beta"/>
		    </mutable>
		  </ref>
		  <tvar name="gamma"/>
		</pair>
	      </ceq>
	      <ceq>
		<tvar name="gamma"/>
		<tvar name="beta"/>
	      </ceq>
	    </set>
	  </ctype>
	</btypes:TYPE>. -->
	Every type of the form
	<btypes:TYPE>
	  <mbFull>
	    <stype/>
	    <ptype/>
	  </mbFull>
	</btypes:TYPE> can be realized through a canonical
	representation using
	<btypes:TYPE>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</btypes:TYPE> types. 
	However, types of the form
	<btypes:TYPE>
	  <mbFull>
	    <stype/>
	    <ptype/>
	  </mbFull>
	</btypes:TYPE> are critical for type inference.
	For example, the type
	<btypes:TYPE>
	  <mbFull>
	    <tvar/>
	    <tvar name="beta"/>
	  </mbFull>
	</btypes:TYPE> represents a type that is compatible 
	with   
	<btypes:TYPE>
	  <tvar name="beta"/>
	</btypes:TYPE>, even if 
	<btypes:TYPE>
	  <tvar name="beta"/>
	</btypes:TYPE> later resolves to a more concrete (ex: pair)
	type.
      </p>
      <p>
	Since we allow copy compatibility at function argument and
	return positions, two function types are equal regardless of
	the shallow mutability of the argument and return types. 
	Therefore, we follow a convention of writing all function
	types with immutable types at copy compatible positions. The
	intuition here is that the type of a function must be
	described in the interface form, and must hide the
	``internal'' mutability information. For example, the function
	<btypes:TYPE> 
	  <lambda>
	    <id name="x"/>
	    <paren>
	      <assign>
		<id name="x"/>
		<true/>
	      </assign>
	    </paren>
	  </lambda>
	</btypes:TYPE>, has external type 
	<btypes:TYPE> 
	  <fn>
	    <bool/>
	    <unit/>
	  </fn>
	</btypes:TYPE> even though the internal type is
	<btypes:TYPE> 
	  <fn>
	    <mutable>
	      <bool/>
	    </mutable>
	    <unit/>
	  </fn>
	</btypes:TYPE>.
      </p>
      <p>
	<btypes:TYPE> 
	  <language/>
	</btypes:TYPE> is a let-polymorphic
	language. At a let boundary, we would like to quantify over
	variables that range over mutability, in order to achieve
	mutability polymorphism. The next sections discuss certain
	complications that arise during the inference of such types,
	present our solution to the problem.
      </p>
      <p>
	<leadin>Soundness implications</leadin>
	Like ML,
	<btypes:TYPE>
	  <language/>
	</btypes:TYPE> enforces the
	value restriction&nbsp;<cite ref="wrightValRes1995"/> to
	preserve soundness of polymorphic typing. This
	means that the type of 
	<btypes:TYPE>
	  <id/>
	</btypes:TYPE> 
	in 
	<btypes:TYPE>
	  <let>
	    <id/>
	    <aExpr num="1"/>
	    <aExpr num="2"/>
	  </let>
	</btypes:TYPE> can only be generalized if 
	<btypes:TYPE>
	  <aExpr num="1"/>
	</btypes:TYPE> is an <em>immutable</em> syntactic value.
	<!-- As is customary,
	values 
	<btypes:TYPE>
	<aVal/>
      </btypes:TYPE>, 
	Variables, and pairs of the above are considered syntactic
	values in
	<btypes:TYPE>
	<language/>
      </btypes:TYPE>. -->
	<!-- Due to the presence of unboxed mutability, we must add the
	immutable qualifier to the syntactic value clause. -->
	For example, in the expression
	<btypes:TYPE>
	  <let>
	    <id name="id"/>
	    <lambda>
	      <id/>
	      <id/>
	    </lambda>
	  </let>
	</btypes:TYPE>, the type of 
	<btypes:TYPE>
	  <id name="id"/>
	</btypes:TYPE> before generalization is
	<btypes:TYPE>
	  <mbFull>
	    <tvar name="beta"/>
	    <fn>
	      <tvar/>
	      <tvar/>
	    </fn>
	  </mbFull>
	</btypes:TYPE>. However, giving
	<btypes:TYPE>
	  <id name="id"/>
	</btypes:TYPE> the generalized type
	<btypes:TYPE>
	  <TS>
	    <grouping>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </grouping>
	    <mbFull>
	      <tvar name="beta"/>
	      <fn>
		<tvar/>
		<tvar/>
	      </fn>
	    </mbFull>
	  </TS>
	</btypes:TYPE> is unsound, since it permits
	expressions such as 
	<btypes:TYPE>
	  <let>
	    <id name="id"/>
	    <lambda>
	      <id/>
	      <id/>
	    </lambda>
	    <Pair>
	      <assign>
		<id name="id"/>
		<lambda>
		  <id/>
		  <true/>
		</lambda>
	      </assign>
	      <apply>
		<id name="id"/>
		<Unit/>
	      </apply>
	    </Pair>
	  </let>
	</btypes:TYPE> to type check.
	We can give
	<btypes:TYPE>
	  <id name="id"/>
	</btypes:TYPE> either the polymorphic type
	<btypes:TYPE>
	  <forall>
	    <tvar/>
	    <fn>
	      <tvar/>
	      <tvar/>
	    </fn>
	  </forall>
	</btypes:TYPE>, or the monomorphic type
	<btypes:TYPE>
	  <mbpair>
	    <tvar name="beta"/>
	    <fn>
	      <tvar/>
	      <tvar/>
	    </fn>
	  </mbpair>	  
	</btypes:TYPE>. However, neither is a principal type for
	<btypes:TYPE>
	  <id name="id"/>
	</btypes:TYPE>.
      </p>
      <p>
	<leadin>Overloading Polymorphism</leadin>
	Due to the above interaction of polymorphism and unboxed
	mutability, a traditional HM-style inference algorithm cannot 
	defer decisions about the mutability
	of types past their generalization. Therefore, current
	algorithms fix the mutability of types before generalization
	based on certain heuristics &mdash; thus sacrificing 
	completeness&nbsp;<cite ref="sridhar2006plos"/>. 
	In order to alleviate this problem, we use a new form of 
	constrained types that range over both mutability and
	polymorphism.
      </p>
      <p>
	We introduce constraints
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind/>
	    <type/>
	  </pcst>
	</btypes:TYPE> to enforce consistency restrictions on
	instantiations of generalized types.
	The constraint 
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind/>
	    <type/>
	  </pcst>
	</btypes:TYPE> requires that the identifier 
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> only be instantiated according to the kind
	<btypes:TYPE> 
	  <lKind/>
	</btypes:TYPE>, where
	<btypes:TYPE> 
	  <lKind/>
	</btypes:TYPE>&nbsp;=&nbsp;<btypes:TYPE> 
	  <lKind k="mono"/>
	</btypes:TYPE>&nbsp;or&nbsp;<btypes:TYPE> 
	  <lKind k="poly"/>
	</btypes:TYPE>. If 
	<btypes:TYPE> 
	  <eq>
	    <lKind/>
	    <lKind k="mono"/>
	  </eq>
	</btypes:TYPE>, the instantiation of 
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> must be monomorphic. That is, all uses of 
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> must instantiate
	<btypes:TYPE> 
	  <type/>
	</btypes:TYPE> to the same type
	<btypes:TYPE> 
	  <type dash="'"/>
	</btypes:TYPE>. Here, 
	<btypes:TYPE> 
	  <type dash="'"/>
	</btypes:TYPE> is permitted to be a mutable type. 
	If 
	<btypes:TYPE> 
	  <eq>
	    <lKind/>
	    <lKind k="poly"/>
	  </eq>
	</btypes:TYPE>, different uses of 
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> can instantiate 
	<btypes:TYPE> 
	  <type/>
	</btypes:TYPE> differently, but all such instantiations must be
	immutable.
	At the point of definition (<progident>let</progident>), if the
	exact instantiation kind of a variable is unknown, we add the
	constraint
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE>, where
	<btypes:TYPE> 
	  <lKind k="var"/>
	</btypes:TYPE> ranges over
	<btypes:TYPE> 
	  <lKind k="mono"/>
	</btypes:TYPE> and
	<btypes:TYPE> 
	  <lKind k="poly"/>
	</btypes:TYPE>. The correct instantiation kind is 
	determined later based on the uses of  
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE>, and consistency semantics are enforced
	accordingly. 
	The variable
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> in
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE> represents the program point
	(<progident>let</progident>) at which this constraint is
	generated. We assume that there are no name collisions 
	so that	every such  
	<btypes:TYPE> 
	  <id/>
	</btypes:TYPE> names a unique program point.
      </p>
      <p>
	In this approach, the definition of 
	<btypes:TYPE> 
	  <id name="id"/>
	</btypes:TYPE> will be given the principal constrained type:
	<br/>
	<btypes:TYPE> 
	  <space n="8"/>
	  <let>
	    <id name="id"/>
	    <lambda>
	      <id/>
	      <id/>
	    </lambda>
	    <aExpr/>
	  </let>
	  <space n="10"/>
	  <tqExpr>
	    <id name="id"/>
	    <btypes:TYPE>
	      <TS>
		<grouping>
		  <tvar name="alpha"/>
		  <tvar name="beta"/>
		</grouping>
		<ctype>
		  <mbFull>
		    <tvar name="beta"/>
		    <fn>
		      <tvar/>
		      <tvar/>
		    </fn>
		  </mbFull>
		  <set>
		    <pcst>
		      <id name="id"/>
		      <lKind k="var"/>
		      <mbFull>
			<tvar name="beta"/>
			<fn>
			  <tvar/>
			  <tvar/>
			</fn>
		      </mbFull>
		    </pcst>
		  </set>
		</ctype>
	      </TS>
	    </btypes:TYPE>
	  </tqExpr>
	</btypes:TYPE>
	<br/>
	Every time
	<btypes:TYPE> 
	  <id name="id"/>
	</btypes:TYPE> is instantiated to type
	<btypes:TYPE> 
	  <type dash="'"/>
	</btypes:TYPE> in
	<btypes:TYPE> 
	  <aExpr/>
	</btypes:TYPE>, the constraints
	<btypes:TYPE> 
	  <pcst>
	    <id name="id"/>
	    <lKind k="var"/>
	    <type dash="'"/>
	  </pcst>
	</btypes:TYPE> are collected.
	<btypes:TYPE> 
	  <aExpr/>
	</btypes:TYPE> is declared type correct only if the set of all
	instantiated constraints are consistent for some
	<btypes:TYPE> 
	  <lKind k="var"/>
	</btypes:TYPE>. Note that we do not quantify over
	<btypes:TYPE> 
	  <lKind k="var"/> 
	</btypes:TYPE>.
      </p> 
      <font size="small">
	<table fullwidth="yes" latex.colspec="c|c|c">
	  <tbody>
	    <tr lineafter="yes">
	      <td>
		<p>Example of
		  <btypes:TYPE> 
		    <aExpr/>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  Constraint set
		</p>
	      </td>
	      <td>
		<p>
		  Kind assignment
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <Pair>
		      <apply>
			<id name="id"/>
			<true/>
		      </apply>
		      <apply>
			<id name="id"/>
			<Unit/>
		      </apply>
		    </Pair>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <set>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<fn>
			  <bool/>
			  <bool/>
			</fn>
		      </pcst>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<fn>
			  <unit/>
			  <unit/>
			</fn>
		      </pcst>
		    </set>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <mapping>
		      <lKind k="var"/>
		      <lKind k="poly"/>
		    </mapping>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <assign>
		      <id name="id"/>
		      <lambda>
			<id/>
			<id/>
		      </lambda>
		    </assign>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <set>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<mutable>
			  <fn>
			    <tvar name="gamma"/>
			    <tvar name="gamma"/>
			  </fn>
			</mutable>
		      </pcst>
		    </set>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <mapping>
		      <lKind k="var"/>
		      <lKind k="mono"/>
		    </mapping>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <Pair>
		      <apply>
			<id name="id"/>
			<true/>
		      </apply>
		      <assign>
			<id name="id"/>
			<lambda>
			  <id/>
			  <Unit/>
			</lambda>
		      </assign>
		    </Pair>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <set>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<fn>
			  <bool/>
			  <bool/>
			</fn>
		      </pcst>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<mutable>
			  <fn>
			    <unit/>
			    <unit/>
			  </fn>
			</mutable>
		      </pcst>
		    </set>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <progident>Type Error</progident>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	    <tr lineafter="yes">
	      <td>
		<p>
		  <btypes:TYPE> 
		    <Pair>
		      <id name="id"/>
		      <id name="id"/>
		    </Pair>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <set>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<mbFull>
			  <tvar name="beta" num="1"/>
			  <fn>
			    <tvar name="alpha" num="1"/>
			    <tvar name="alpha" num="1"/>
			  </fn>
			</mbFull>
		      </pcst>
		      <pcst>
			<id name="id"/>
			<lKind k="var"/>
			<mbFull>
			  <tvar name="beta" num="2"/>
			  <fn>
			    <tvar name="alpha" num="2"/>
			    <tvar name="alpha" num="2"/>
			  </fn>
			</mbFull>
		      </pcst>
		    </set>
		  </btypes:TYPE>
		</p>
	      </td>
	      <td>
		<p>
		  <btypes:TYPE> 
		    <mapping>
		      <lKind k="var"/>
		      <grouping>
			<lKind k="mono"/>
			<text content=" or "/>
			<lKind k="poly"/>
		      </grouping>
		    </mapping>
		  </btypes:TYPE>
		</p>
	      </td>
	    </tr>
	    <!-- Row -->
	  </tbody>
	</table>
      </font>
      <br/>
      <br/>
      <p>
	The final case type checks with either kind, under the 
	type assignments 
	(<btypes:TYPE> 
	  <eq>
	    <tvar name="alpha" num="1"/>
	    <tvar name="alpha" num="2"/>
	  </eq>
	</btypes:TYPE>,
	<btypes:TYPE> 
	  <eq>
	    <tvar name="beta" num="1"/>
	    <tvar name="beta" num="2"/>
	  </eq>
	</btypes:TYPE>) if
	<btypes:TYPE> 
	  <mapping>
	    <lKind k="var"/>
	    <lKind k="mono"/>
	  </mapping>
	</btypes:TYPE> and
	(<btypes:TYPE> 
	  <eq>
	    <tvar name="beta" num="1"/>
	    <fn>
	      <tvar name="alpha" num="1"/>
	      <tvar name="alpha" num="1"/>
	    </fn>
	  </eq>
	</btypes:TYPE>,
	<btypes:TYPE> 
	  <eq>
	    <tvar name="beta" num="2"/>
	    <fn>
	      <tvar name="alpha" num="2"/>
	      <tvar name="alpha" num="2"/>
	    </fn>
	  </eq>
	</btypes:TYPE>) if
	<btypes:TYPE> 
	  <mapping>
	    <lKind k="var"/>
	    <lKind k="poly"/>
	  </mapping>
	</btypes:TYPE>.
	The intuition behind 
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE> constraints is to achieve a form of
	<em>overloading</em> over polymorphism and mutability.
	We can think of 
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE> as a 
	type class&nbsp;<cite ref="jones1995qualtypes"/> constraint that
	has exactly one possibly mutable instance
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="mono"/>
	    <type num="m"/>
	  </pcst>
	</btypes:TYPE>, and an infinite number of
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="poly"/>
	    <type num="p"/>
	  </pcst>
	</btypes:TYPE> instances where all types
	<btypes:TYPE> 
	  <types num="p"/>
	</btypes:TYPE> are immutable.
      </p>
      <p>
	In practice, once the correct kind of instantiation is
	inferred, the type scheme can be presented in a simplified
	form to the programmer. 
	For example, consider the expression
	<btypes:TYPE> 
	  <let>
	    <id name="f"/>
	    <lambda>
	      <id/>
	      <if>
		<deref>
		  <id/>
		</deref>
		<Unit/>
		<Unit/>
	      </if>
	    </lambda>
	    <Pair>
	      <apply>
		<id name="f"/>
		<id name="m"/>
	      </apply>
	      <apply>
		<id name="f"/>
		<id name="n"/>
	      </apply>
	    </Pair>
	  </let>
	</btypes:TYPE>, where
	<btypes:TYPE> 
	  <tqExpr>
	    <id name="m"/>
	    <ref>
	      <mutable>
		<bool/>
	      </mutable>
	    </ref>
	  </tqExpr>
	</btypes:TYPE> and
	<btypes:TYPE> 
	  <tqExpr>
	    <id name="n"/>
	    <ref>
	      <bool/>
	    </ref>
	  </tqExpr>
	</btypes:TYPE>.
	Here,
	<btypes:TYPE> 
	  <tqExpr>
	    <id name="f"/>
	    <TS>
	      <grouping>
		<tvar name="alpha"/>
		<tvar name="beta"/>
	      </grouping>
	      <mbFull>
		<tvar name="beta"/>
		<fn>
		  <ref>
		    <mbFull>
		      <tvar/>
		      <bool/>
		    </mbFull>
		  </ref>
		  <unit/>
		</fn>
	      </mbFull>
	      <set>
		<pcst>
		  <id name="f"/>
		  <lKind k="var"/>
		  <mbFull>
		    <tvar name="beta"/>
		    <fn>
		      <ref>
			<mbFull>
			  <tvar/>
			  <bool/>
			</mbFull>
		      </ref>
		      <unit/>
		    </fn>
		  </mbFull>
		</pcst>
	      </set>
	    </TS>
	  </tqExpr>
	</btypes:TYPE>. However, based on the polymorphic usage, we
	conclude that
	<btypes:TYPE> 
	  <mapping>
	    <lKind k="var"/>
	    <lKind k="poly"/>
	  </mapping>
	</btypes:TYPE>.
	We can now simplify the type scheme of 
	<btypes:TYPE> 
	  <id name="f"/>
	</btypes:TYPE> to obtain
	<btypes:TYPE> 
	  <tqExpr>
	    <id name="f"/>
	    <TS>
	      <tvar name="alpha"/>
	      <fn>
		<ref>
		  <mbFull>
		    <tvar/>
		    <bool/>
		  </mbFull>
		</ref>
		<unit/>
	      </fn>
	    </TS>
	  </tqExpr>
	</btypes:TYPE>.
	Since all function types are  immutable, the mutability of the
	argument type need not be fixed, thus preserving mutability
	polymorphism. 
	In order to ensure that type inference is modular, the
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE> constraints must not be exposed across a module
	boundary. For every top-level definition in a module, an
	arbitrary choice of
	<btypes:TYPE> 
	  <eq>
	    <lKind k="var"/>
	    <lKind k="mono"/>
	  </eq>
	</btypes:TYPE> or
	<btypes:TYPE> 
	  <eq>
	    <lKind k="var"/>
	    <lKind k="poly"/>
	  </eq>
	</btypes:TYPE> must be made for every surviving 
	<btypes:TYPE> 
	  <pcst>
	    <id/>
	    <lKind k="var"/>
	    <type/>
	  </pcst>
	</btypes:TYPE> constraint.
      </p>
      <p>
	In summary, we have used a system of constrained types to
	design a polymorphic type inference system that meets
	all of the design goals set at the beginning of this section. In
	the next section, we present a formal description of our type
	system and inference algorithm. 
      </p>
      <!-- <btypes:TYPE> 
      <let>
      <id name="map"/>
      <lambda>
      <id name="f"/>
      <lambda>
      <id name="x"/>
      <Pair>
      <apply>
      <id name="f"/>
      <fst>
      <id name="x"/>
    </fst>
    </apply>
      <apply>
      <id name="f"/>
      <fst>
      <id name="x"/>
    </fst>
    </apply>
    </Pair>
    </lambda>
    </lambda>
      <Pair>
      <map>
      <id name="id"/>
      <Pair>
      <true/>
      <false/>
    </Pair>
    </map>
      <map>
      <id name="id"/>
      <Pair>
      <Unit/>
      <Unit/>
    </Pair>
    </map>
    </Pair>
    </let>
    </btypes:TYPE> -->
    </sect2>
  </sect1>
  <sect1 id="formal">
    <title>Formal Description</title>
    <xi:include href="include/complete/grammar.xmli"/>
    <p>      
      In order to formalize the semantics of
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, we extend the calculus with stack and heap
      locations (Fig.&nbsp;<xref ref="grammar"/>). Heap locations are
      first class values, but stack 
      locations are not. Further, we annotate all 
      <progident>let</progident> expressions with a kind
      &mdash;
      <btypes:TYPE>
        <let kind="m"/>
      </btypes:TYPE>: monomorphic, possibly mutable
      definition, and
      <btypes:TYPE>
        <let kind="p"/>
      </btypes:TYPE>: polymorphic definitions.
      The two kinds of <progident>let</progident> expressions have
      different execution semantics. 
      We write
      <btypes:TYPE>
        <let kind="k"/>
      </btypes:TYPE> to range over the two kinds of
      <progident>let</progident>
      expressions.
      This distinction is
      similar to Smith and Volpano's Polymorphic-C&nbsp;<cite
        ref="Smith1998polymorphicC"/>. However, unlike 
      Polymorphic-C, let-kind is <em>meta syntax</em>, and is not a
      part of the input program.
      The correct kind of <progident>let</progident> is
      inferred from the static type information.
      We do not show the semantics for type-qualified expressions as
      they are trivial. 
    </p>
    <xi:include href="include/complete/opsem.xmli"/>
    <p>
      <leadin>Dynamic Semantics</leadin> The system state is
      represented by the triple
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      consisting of the stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE>, the heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, and the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> to be
      evaluated. Evaluation itself is a two place relation   
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      that denotes a single step of execution.
      Fig.&nbsp;<xref ref="dyn_sem_horz"/> shows the evaluation
      rules for our core language. We assume that the program is
      alpha-converted so that there are no name collisions due to
      inner bindings.  Following the theoretical
      development of&nbsp;<cite ref="Grossman2006qtypes"/>, we give
      separate execution semantics for left evaluation
      (execution of left expressions
      <btypes:TYPE>
	<lExp/>
      </btypes:TYPE> on the LHS of an assignment, denoted by
      <btypes:TYPE>
	<levalOp/>
      </btypes:TYPE>) and 
      right evaluation
      (<btypes:TYPE>
	<evalOp/>
      </btypes:TYPE>) respectively. 
    </p>
    <p>
      Since the E-Dup and E-^ rules work only on the heap, we can only
      capture references to heap cells. Stack locations cannot escape
      beyond their scope since E-Rval rule performs implicit value
      extraction from stack locations in rvalue contexts. State
      updates can be performed 
      either on the stack or on the heap&nbsp;(E-:=* rules). The stack
      is modeled as a pseudo-heap. 
      This enables us to abstract away details such as
      closure-construction and garbage collection while illustrating
      the core semantics, as they can later be reified
      independently.
    </p>
    <p>
      The execution semantics do not perform a copy operation in all
      cases where copy compatibility is permitted.
      For example, the E-If rule does not introduce a copy step in the
      branching expression. Since <progident>if</progident>-expressions
      are not lvalues, they cannot be the target of an assignment. 
      Therefore, the value that either branch evaluates to, can
      itself be used in all cases where a copy of that value can be.
    </p>
    <xi:include href="include/complete/operators.xmli"/>
    <p>
      <leadin>Static Semantics</leadin>
      Fig.&nbsp;<xref ref="operators"/> defines several operators and
      predicates on types that we use in this section.
      The operators
      <btypes:TYPE>
	<maxzTOp/>
      </btypes:TYPE>
      and
      <btypes:TYPE>
	<minzTOp/>
      </btypes:TYPE> respectively increase and decrease the shallow
      top-level mutability of a type.
      <btypes:TYPE>
	<maxzOp/>
      </btypes:TYPE>
      and
      <btypes:TYPE>
	<minzOp/>
      </btypes:TYPE> maximize / minimize the mutability
      of a type up to a reference or function boundary.
      <btypes:TYPE>
	<minzDOp/>
      </btypes:TYPE> removes all mutability in a type up to a function
      boundary.  
      We write
      <btypes:TYPE>
	<eq under="minzT">
	  <type num="1"/>
	  <type num="2"/>
	</eq>
      </btypes:TYPE> as shorthand for
      <btypes:TYPE>
	<eq>
	  <minzT>
	    <type num="1"/>
	  </minzT>
	  <minzT>
	    <type num="2"/>
	  </minzT>
	</eq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq under="minz">
	  <type num="1"/>
	  <type num="2"/>
	</eq>
      </btypes:TYPE> for
      <btypes:TYPE>
	<eq>
	  <minz>
	    <type num="1"/>
	  </minz>
	  <minz>
	    <type num="2"/>
	  </minz>
	</eq>
      </btypes:TYPE>.
      In our algebra of types, the mutable type constructor is
      idempotent  
      (<btypes:TYPE>
	<equiv>
	  <mutable>
	    <mutable>
	      <type/>
	    </mutable>
	  </mutable>
	  <mutable>
	    <type/>
	  </mutable>
	</equiv>
      </btypes:TYPE>).
      We also define the equivalences:
      <btypes:TYPE>
	<equiv>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	  <mbTop>
	    <tvar/>
	    <ptype dash="'"/>
	  </mbTop>
	</equiv>
      </btypes:TYPE>, where
      <btypes:TYPE>
	<eq under="minzT">
	  <ptype/>
	  <ptype dash="'"/>
	</eq>
      </btypes:TYPE>
      and
      <btypes:TYPE>
	<equiv>
	  <mbTop>
	    <stype/>
	    <ptype/>
	  </mbTop>
	  <mbTop>
	    <stype/>
	    <ptype dash="'"/>
	  </mbTop>
	</equiv>
      </btypes:TYPE>, where
      <btypes:TYPE>
	<eq under="minz">
	  <ptype/>
	  <ptype dash="'"/>
	</eq>
      </btypes:TYPE>.
      The predicates 
      <btypes:TYPE>
	<pred name="Immut"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<pred name="Mut"/>
      </btypes:TYPE> identify types that are observably immutable and
      mutable respectively. 
      The
      <btypes:TYPE>
	<concrete>
	  <type/>
	</concrete>
      </btypes:TYPE> predicate tests if the type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is concretizable by fixing variables that
      range over mutability.
    </p>
    <p>
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <type/>
	</Subst>
      </btypes:TYPE> denotes the application of a substitution 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> on
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> as defined in Fig.&nbsp;<xref ref="operators"/>.
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <aExpr/>
	</Subst>
      </btypes:TYPE>
      performs substitutions for 
      <btypes:TYPE>
	<lKind k="var"/>
      </btypes:TYPE> annotations in
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>.
      <btypes:TYPE>
	<spset>
	  <type/>
	</spset>
      </btypes:TYPE> 
      denotes the set of all constrained types and unconstrained
      type variables structurally present in 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>.
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <nothing/>
	</Subst>
      </btypes:TYPE> and
      <btypes:TYPE>
	<spset>
	  <nothing/>
	</spset>
      </btypes:TYPE>
      are extended to
      <btypes:TYPE>
	<collection and="yes">
	  <aTS/>
	  <gamma/>
	  <store/>
	  <set>
	    <types/>
	  </set>
	</collection>
      </btypes:TYPE> in the natural, capture-avoiding manner.
    </p>
    <font size="small">
    <p>
      <leadin>Definition 1 (Canonical Expressions).</leadin>
	<em>
      An expression 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> is said to be <em>canonical</em> if
      all <em><progident>let</progident></em> expressions in
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> are annotated with one of the 
      kinds
      <btypes:TYPE>
	<lKind k="mono"/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<lKind k="poly"/>
      </btypes:TYPE>.
	</em>
    </p>
      <p>
	<leadin>Definition 2 (Consistency of Constrained types).</leadin>
	<em>
	  Let 
	  <btypes:TYPE>
	    <pred name="mtv">
	      <types/>
	    </pred>
	  </btypes:TYPE>, 
	  <btypes:TYPE>
	    <pred name="Mtv">
	      <types/>
	    </pred>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <pred name="ntv">
	      <types/>
	    </pred>
	  </btypes:TYPE> be the set of all type variables appearing in 
	  <btypes:TYPE>
	    <set>
	      <types/>
	    </set>
	  </btypes:TYPE> constrained by
	  <btypes:TYPE>
	    <mbTop>
	      <tvar/>
	      <ptype/>
	    </mbTop>
	  </btypes:TYPE>, by
	  <btypes:TYPE>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	  </btypes:TYPE> and unconstrained
	  respectively. <!-- That is,
	  <btypes:TYPE>
	  <eq>
	  <pred name="mtv">
	  <types/>
	</pred>
	  <set>
	  <grouping>
	  <tvar/>
	  <ST/>
	  <in>
	  <mbTop>
	  <tvar/>
	  <ptype/>
	</mbTop>
	  <spset>
	  <types/>
	</spset>
	</in>
	</grouping>
	</set>
	</eq>
	</btypes:TYPE> and
	  <btypes:TYPE>
	  <eq>
	  <pred name="Mtv">
	  <types/>
	</pred>
	  <set>
	  <grouping>
	  <tvar/>
	  <ST/>
	  <in>
	  <mbFull>
	  <tvar/>
	  <ptype/>
	</mbFull>
	  <spset>
	  <types/>
	</spset>
	</in>
	  <text content=" or "/>
	  <in>
	  <mbFull>
	  <mutable>
	  <tvar/>
	</mutable>
	  <ptype/>
	</mbFull>
	  <spset>
	  <types/>
	</spset>
	</in>
	</grouping>
	</set>
	</eq>
	</btypes:TYPE>
	  and
	  <btypes:TYPE>
	  <eq>
	  <pred name="ntv">
	  <types/>
	</pred>
	  <set>
	  <grouping>
	  <tvar/>
	  <ST/>
	  <in>
	  <tvar/>
	  <spset>
	  <types/>
	</spset>
	</in>
	</grouping>
	</set>
	</eq>
	</btypes:TYPE>. -->
	  We say that the set of types
	  <btypes:TYPE>
	    <set>
	      <types/>
	    </set>
	  </btypes:TYPE> is consistent, 
	  written
	  <btypes:TYPE>
	    <CST>
	      <types/>
	    </CST>
	  </btypes:TYPE>, if:
	  (1) For all
	  <btypes:TYPE>
	    <subeq>
	      <set>
		<mbTop>
		  <tvar/>
		  <ptype/>
		</mbTop>
		<mbTop>
		  <tvar/>
		  <ptype dash="'"/>
		</mbTop>
	      </set>
	      <spset>
		<types/>
	      </spset>
	    </subeq>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq under="minzT">
	      <ptype/>
	      <ptype dash="'"/>
	    </eq>
	  </btypes:TYPE>.
	  <br/>
	  (2) For all
	  <btypes:TYPE>
	    <subeq>
	      <set>
		<mbFull>
		  <stype/>
		  <ptype/>
		</mbFull>
		<mbFull>
		  <stype dash="'"/>
		  <ptype dash="'"/>
		</mbFull>
	      </set>
	      <spset>
		<types/>
	      </spset>
	    </subeq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minzT">
	      <stype/>
	      <stype dash="'"/>
	    </eq>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq under="minz">
	      <ptype/>
	      <ptype dash="'"/>
	    </eq>
	  </btypes:TYPE>.
	  <br/>
	  (3)
	  <btypes:TYPE>
	    <pred name="mtv">
	      <types/>
	    </pred>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <pred name="Mtv">
	      <types/>
	    </pred>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <pred name="ntv">
	      <types/>
	    </pred>
	  </btypes:TYPE> 
	  are mutually exclusive.
	</em>
      </p>
      <p>
	<leadin>Definition 3 (Consistency of substitutions).</leadin>
	<em>
	  A substitution 
	  <btypes:TYPE>
	    <aSubMap/>
	  </btypes:TYPE>
	  is said to be consistent over a set of types
	  <btypes:TYPE>
	    <set>
	      <types/>
	    </set>
	  </btypes:TYPE>, written
	  <btypes:TYPE>
	    <Cst>
	      <aSubMap/>
	      <set>
		<types/>
	      </set>
	    </Cst>
	  </btypes:TYPE> if:
	  (1)
	  <btypes:TYPE>
	    <Cst>
	      <assume/>
	      <Subst>
		<aSubMap/>
		<spset>
		  <types/>
		</spset>
	      </Subst>
	    </Cst>
	  </btypes:TYPE>.
	  <br/>
	  (2) For all
	  <btypes:TYPE>
	    <in>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	      <spset>
		<types/>
	      </spset>
	    </in>
	  </btypes:TYPE>,
	  we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <tvar name="beta"/>
	    </eq>
	  </btypes:TYPE>,
	  or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <ptype dash="'"/>
	    </eq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <eq under="minzT">
	      <ptype dash="'"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	  <br/>
	  (3) For all
	  <btypes:TYPE>
	    <in>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	      <spset>
		<types/>
	      </spset>
	    </in>
	  </btypes:TYPE>,
	  we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <stype dash="'"/>
	    </eq>
	  </btypes:TYPE>,
	  or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <Ptype/>
	    </eq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <eq under="minz">
	      <Ptype/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Definition 4 (Consistency of &starf; constraints).</leadin>
	<em>
	  A set of &starf; constraints 
	  <btypes:TYPE>
	    <dCtset/>
	  </btypes:TYPE> is said to be consistent, written
	  <btypes:TYPE>
	    <models>
	      <assume/>
	      <dCtset/>
	    </models>
	  </btypes:TYPE> if:
	  (1) For all
	  <btypes:TYPE>
	    <in>
	      <pcst>
		<id name="x"/>
		<lKind k="poly"/>
		<type/>
	      </pcst>
	      <dCtset/>
	    </in>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <pred name="Immut">
	      <type/>
	    </pred>
	  </btypes:TYPE>.
	  <br/>
	  (2) For all
	  <btypes:TYPE>
	    <in>
	      <grouping>
		<pcst>
		  <id/>
		  <lKind k="mono"/>
		  <type num="1"/>
		</pcst>
		<text content=" ... "/>
		<pcst>
		  <id/>
		  <lKind k="mono"/>
		  <type num="n"/>
		</pcst>
	      </grouping>
	      <dCtset/>
	    </in>
	  </btypes:TYPE>, 
	  we have
	  <btypes:TYPE>
	    <eq>
	      <type num="1"/>
	      <text content=" ... "/>
	      <type num="n"/>
	    </eq>
	  </btypes:TYPE>.
	  <br/>
	  (3) For all
	  <btypes:TYPE>
	    <in>
	      <pcst>
		<id name="x"/>
		<lKind num="1"/>
		<type num="1"/>
	      </pcst>
	      <dCtset/>
	    </in>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <in>
	      <pcst>
		<id name="y"/>
		<lKind num="2"/>
		<type num="2"/>
	      </pcst>
	      <dCtset/>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <neq>
	      <lKind num="1"/>
	      <lKind num="2"/>
	    </neq>
	  </btypes:TYPE>
	  implies
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	</em>
      </p>
    </font>
    <xi:include href="include/complete/type.xmli"/>
    <p>    
      <leadin>Declarative Type Rules</leadin>
      Fig.&nbsp;<xref ref="decl_type_rules"/> presents a declarative
      definition of the type system of 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>.
      In this type system, copy compatibility is realized 
      through <em>copy coercion</em> 
      (<btypes:TYPE>
	<MsubOp/>
      </btypes:TYPE>)
      rules that are similar to subtyping rules
      (S-* rules in 
      Fig.&nbsp;<xref ref="decl_type_rules"/>).
      Since reference types 
      <btypes:TYPE>
	<ref>
	  <type/>
	</ref>
      </btypes:TYPE> are handled only by S-Refl,
      types cannot coerced beyond a reference
      boundary. Also, two function types are coercible only if they
      are structurally identical. 
      Here, the contravariance/covariance of argument/return types is
      unnecessary as we can follow a standard convention with
      respect to the mutability of argument/return types 
      at copy positions. The rules for typing expressions (T-* rules)
      introduce these coercions at all copy-compatible positions. 
    </p>
    <p>
      The type judgment  
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	  <dCtset/>
	</TDjudge>
      </btypes:TYPE> is understood as: given a binding environment 
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and store typing
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> subject to the set of &starf; constraints
      <btypes:TYPE>
	<dCtset/>
      </btypes:TYPE>. We write
      <btypes:TYPE>
	<Msub>
	  <aExpr/>                  
	  <type/>                  
	</Msub>
      </btypes:TYPE> as a shorthand for
      <btypes:TYPE>
	<tqExpr>
	  <aExpr/>                  
	  <type dash="'"/>                  
	</tqExpr>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Msub>
	  <type dash="'"/>
	  <type/>
	</Msub>
      </btypes:TYPE>, for some type
      <btypes:TYPE>
	<type dash="'"/>                  
      </btypes:TYPE>.
      The rule T-Lambda permits the interface type of a function be
      different from its internal type, as explained in
      Sec.&nbsp;<xref ref="infer"/>.
      The rule T-App introduces copy-coercions at argument and return
      positions of an application. T-Let-M rule types 
      <progident>let</progident> expressions monomorphically, 
      and thus requires a
      <btypes:TYPE>
	<let kind="m"/>
      </btypes:TYPE> annotation.
      In this case, the expression 
      <btypes:TYPE>
	<aExpr num="1"/>
      </btypes:TYPE> is permitted to be expansive (i.e. need not be a
      syntactic value 
      <btypes:TYPE>
	<vExp/>
      </btypes:TYPE>).
      The T-Let-MP rule types <progident>let</progident> expressions
      where the expression being bound is a syntactic value.
      It assigns 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> a constrained type scheme along with the 
      constraint
      <btypes:TYPE>
	<pcst>
	  <id/>
	  <lKind/>
	   <type/>
	</pcst>
      </btypes:TYPE>. The T-Id rule instantiates types and
      constraints. The instantiated constraints are collected over
      the entire derivation, so that we can enforce instantiation
      consistency.  
      <btypes:TYPE>
	<models name="new">
	  <assume/>
	  <tvars/>
	</models> 
      </btypes:TYPE> identifies fresh type variables.
    </p>
    <p>
      We prove the soundness of our type system by demonstrating
      subject reduction. Here, we prove that the type of an expression
      is preserved exactly by left-execution, which ensures that
      the type of a location does not change during the execution of a
      program. We also show that right execution preserves types
      except for shallow mutability. The result of a right execution
      can only be used in copy compatible positions, or as the target
      of a dereference. In the former case, preservation of shallow
      mutability is unnecessary, and in the later, the type
      within the reference is preserved exactly. 
    </p>
    <p>
      The interesting case is the safety of polymorphic
      <progident>let</progident> expressions. The 
      T-Let-MP rule does not require that the type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> being quantified over be immutable, but adds the 
      <btypes:TYPE>
	<pcst>
	  <id/>
	  <lKind/>
	  <type/>
	</pcst>
      </btypes:TYPE> constraint.
      Now, if we have a derivation
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	  <dCtset/>
	</TDjudge>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE>, then one of the two cases must follow.
      (1) If any instantiation of
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is mutable, then
      <btypes:TYPE>
	<eq>
	  <lKind/>
	  <lKind k="mono"/>
	</eq>
      </btypes:TYPE>.
      In this case, execution proceeds through the E-Let-M rule,
      which create a stack location for 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE>. Therefore, 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> is permitted to be the target of an
      assignment.
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE> guarantees that all instantiations of 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> are identical, which ensures that the type of
      a location cannot change.
      (2) 
      If 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is instantiated polymorphically, then
      <btypes:TYPE>
	<eq>
	  <lKind/>
	  <lKind k="poly"/>
	</eq>
      </btypes:TYPE>.
      Execution proceeds through the E-Let-P rule, which performs
      a value substitution. 
      Here,  
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE> guarantees that all instantiations are deeply
      immutable. Therefore, 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> cannot be directly used
      (in the forms
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<select>
	  <id/>
	  <path/>
	</select>
      </btypes:TYPE>) as the target of an assignment, which ensures
      that the value substitution cannot lead to a stuck state.
    </p> 
    <font size="small">
      <p>
	<leadin>Definition 5 (Consistent Type Derivation).</leadin>
	<em>
	  Let
	  <btypes:TYPE>
	    <spset>
	      <TDjudge D="yes">
		<aExpr/>
		<type/>
	      </TDjudge>
	    </spset>
	  </btypes:TYPE> denote the extension 
	  <btypes:TYPE>
	    <spset>
	      <nothing/>
	    </spset>
	  </btypes:TYPE> function to the set of all types used in the
	  derivation of
	  <btypes:TYPE>
	    <TDjudge D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>.
	  We say that
	  <btypes:TYPE>
	    <TDjudge D="yes" name="*">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE> 
	  is a consistent derivation if
	  <btypes:TYPE>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	      <dCtset dash="'"/>
	    </TDjudge>
	  </btypes:TYPE> for some
	  <btypes:TYPE>
	    <subeq>
	      <dCtset dash="'"/>
	      <dCtset/>
	    </subeq>
	  </btypes:TYPE>,
	  and
	  <btypes:TYPE>
	    <Cst>
	      <assume/>
	      <unin>
		<spset>
		  <dCtset/>
		</spset>
		<spset>
		  <TDjudge>
		    <aExpr/>
		    <type/>
		    <dCtset dash="'"/>
		  </TDjudge>
		</spset>
	      </unin>
	    </Cst>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Definition 6 (Stack and Heap Typing)</leadin>
	<em>
	  A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
	  <btypes:TYPE><stack/></btypes:TYPE> are said to be <em>well
	    typed</em> with respect to 
	  <btypes:TYPE><gamma/></btypes:TYPE>, 
	  <btypes:TYPE><store/></btypes:TYPE> and
	  <btypes:TYPE><dCtset/></btypes:TYPE>, written
	  <btypes:TYPE>
	    <TDjudge name="*" D="yes">
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </TDjudge>
	  </btypes:TYPE>, if:
	  <br/>
	  (1) 
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	  <br/>
	  (2) 
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="*" D="yes">
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge> 
	    <text content=" such that "/>
	    <eq under="minz">
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>
	  <br/>
	  (3) 
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="*" D="yes">
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <eq under="minz">
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>
	</em>
      </p>
      <p>
	<leadin>Definition 7 (Valid Lvalues).</leadin>
	<em>
	  We say that an lvalue
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE> is valid with respect to a stack
	  <btypes:TYPE>
	    <stack/>
	  </btypes:TYPE> and heap
	  <btypes:TYPE>
	    <heap/>
	  </btypes:TYPE>, written
	  <btypes:TYPE>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	  </btypes:TYPE> if for some
	  <btypes:TYPE>
	    <path/>
	  </btypes:TYPE>, either
	  (1)
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE> where
	  <btypes:TYPE>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	  </btypes:TYPE>; or
	  (2)
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE> where
	  <btypes:TYPE>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Lemma 1 (Progress).</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE>
	  is a closed canonical well typed expression,
	  that is, 
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE> for some
	  <btypes:TYPE>
	    <type/>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <store/>
	  </btypes:TYPE>, 
	  given any heap and stack such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>,
	  <br/>
	  (1) If 
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE> is a left expression
	  (<btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lExp/>
	    </eq>
	  </btypes:TYPE>), then
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE>
	  is either a valid lvalue (that is,
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lVal/>
	    </eq>
	  </btypes:TYPE> and
	  <br/>
	  <btypes:TYPE>
	    <space n="4"/>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	  </btypes:TYPE>) or else
	  <btypes:TYPE>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>.
	  <br/>
	  (2)
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE> is a value
	  <btypes:TYPE>
	    <aVal/>
	  </btypes:TYPE> or else
	  <btypes:TYPE>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Lemma 2 (Preservation).</leadin>
	<em>
	  For any canonical expression 
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE>,      
	  if
	  <btypes:TYPE>
	    <TDjudge D="yes" name="*">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>, 
	  <btypes:TYPE>
	    <TDjudge D="yes" name="*">
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </TDjudge>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <models>
	      <assume/>
	      <dCtset/>
	    </models>
	  </btypes:TYPE> then,
	  <br/>
	  (1) If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  <br/>
	  <btypes:TYPE>
	    <space n="4"/>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	  <br/>
	  (2) If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>,
	  <br/>
	  <btypes:TYPE>
	    <space n="4"/>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type dash="'"/>
	    </eq>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Definition 8 (Stuck State).</leadin>
	<em>
	  A system state
	  <btypes:TYPE>
	    <opState>
	      <stack/>
	      <heap/>
	      <aExpr/>
	    </opState>
	  </btypes:TYPE>
	  is said to be <em>stuck</em> if
	  <btypes:TYPE>
	    <neq>
	      <aExpr/>
	      <aVal/>
	    </neq>
	  </btypes:TYPE>
	  and there are no
	  <btypes:TYPE>
	    <stack dash="'"/>
	    <text content=", "/>
	    <heap dash="'"/>
	    <text content=", and "/>
	    <aExpr dash="'"/>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Theorem 1 (Type Soundness).</leadin>
	<em>
	  Let
	  <btypes:TYPE>
	    <evalOp many="yes"/>
	  </btypes:TYPE > denote the
	  reflexive-transitive-closure of
	  <btypes:TYPE>
	    <evalOp/>
	  </btypes:TYPE>.
	  For any canonical expression 
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE>, if
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	    <text content=","/>
	    <space n="2"/>
	  </btypes:TYPE> 
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	    <text content=","/>
	    <space n="2"/>
	  </btypes:TYPE> 
	  <btypes:TYPE>
	    <models>
	      <assume/>
	      <dCtset/>
	    </models>
	    <text content=", and "/>
	  </btypes:TYPE>
	  <btypes:TYPE>
	    <eval many="yes">
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>,
	  then
	  <btypes:TYPE>
	    <opState>
	      <stack dash="'"/>
	      <heap dash="'"/>
	      <aExpr dash="'"/>
	    </opState>
	  </btypes:TYPE> is not stuck.
	  That is, execution of a closed, canonical, well typed expression
	  cannot lead to a stuck state. 
	</em>
      </p>
    </font>
    <xi:include href="include/complete/infer.xmli"/>
    <xi:include href="include/complete/unify.xmli"/>
    <p>
      <leadin>Type Inference Algorithm</leadin>	
      Type inference is a program transformation that accepts a
      program in which <progident>let</progident> expressions are
      not annotated with their kinds, and returns the same program
      with <progident>let</progident> expressions annotated
      with their kinds and all expressions annotated with their
      types.
      The type inference algorithm is shown in
      Fig.&nbsp;<xref ref="hy_infer"/>.
      The inference judgment  
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> is understood as: given a binding environment 
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and store typing
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> subject to the constraints
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>. 
    </p>
    <p>
      The inference algorithm introduces constrained types of the form
      <btypes:TYPE>
	<mbFull>
	  <stype/>
	  <ptype/>
	</mbFull>
      </btypes:TYPE> at all copy compatible positions.
      For example, the I-App rule introduces copy compatibility for
      the function type itself, the argument and the return types.
      The I-Sel rule represents the pair type as
      <btypes:TYPE>
	<mbTop>
	  <tvar name="epsiv"/>
	  <pair>
	    <mbFull>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </mbFull>
	    <mbFull>
	      <tvar name="gamma"/>
	      <tvar name="delta"/>
	    </mbFull>
	  </pair>
	</mbTop>
      </btypes:TYPE>, which (1) permits top-level
      mutability of the pair type to be either mutable or immutable
      (2) ensures that the type of the selection is exactly same as
      the type of the field being selected
      (3) propagates full copy compatibility ``one level down.''  
    </p>
    <p>
      The unification algorithm is shown in 
      Fig.&nbsp;<xref ref="hy_unify"/>.
      The unification of a constraint set
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> either fails with an 
      error
      <btypes:TYPE>
	<error/>
      </btypes:TYPE>, or produces the pair
      <btypes:TYPE>
	<Pair>
	  <dCtset/>
	  <aSubMap/>
	</Pair>
      </btypes:TYPE>.
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> is a solution for all equality constraints 
      and some of the &starf; constraints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>.
      <btypes:TYPE>
	<dCtset/>
      </btypes:TYPE> is the set of &starf; constraints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> on which 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> has been applied.
      <btypes:TYPE>
	<uninOp excl="yes"/>
      </btypes:TYPE> represents disjoint union of sets.
    </p>
    <p>
      The U-Ct* rules perform unification of constrained
      types with other constrained or unconstrained types. First,
      immutable versions of the two types are unified to establish
      compatibility (through constraints involving 
      <btypes:TYPE>
	<eqOp under="minzT"/>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<eqOp under="minz"/>
      </btypes:TYPE>). Then, the constrained
      type is made to exactly equal the other type by unifying 
      its variable part with the other type.
      The key observation here is that the copy compatibility
      is a special restricted form of subtyping. Since the type of 
      the copy can be anywhere in the lattice of copy compatible 
      types, subtyping requirements are always
      with respect a local maxima (the most immutable compatible
      type). We exploit this behavior to design a simple unification
      algorithm that only uses equality constraints over constrained
      types.
    </p>
    <p>
      The U-Om1 ensures that all instantiations of monomorphic kind
      are the same. U-Op1 rule forces any concretizable
      instantiation of polymorphic kind to be immutable. 
      The U-Om2 rule infers monomorphic kind based on the mutability
      of the instantiated type, and U-Op2 infers polymorphic kind if
      a variable 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> is instantiated polymorphically to two types that
      do not inter-unify.
    </p>
    <font size="small">
      <p>
	<leadin>Definition 9 (Constraint Satisfaction).</leadin>
	<em>
	  The satisfaction of a constraint set
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE> by a substitution
	  <btypes:TYPE>
	    <aSubMap/>
	  </btypes:TYPE> is defined as follows.
	</em>
      </p>
      <font size="small">
	<btypes:TYPE>
	  <Hrules colsep="4">
	    <tyRule>
	      <tyPre>
		<grouping>
		  <Forall/>
		  <in>
		    <paren>
		      <eq>
			<type num="1"/>
			<type num="2"/>
		      </eq>
		    </paren>
		    <aCtset/>
		  </in>
		  <text content=", "/>
		  <eq>
		    <Subst>
		      <aSubMap/>
		      <type num="1"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="2"/>
		    </Subst>
		  </eq>
		</grouping>
		<grouping>
		  <Forall/>
		  <in>
		    <paren>
		      <eq>
			<lKind k="var"/>
			<lKind/>
		      </eq>
		    </paren>
		    <aCtset/>
		  </in>
		  <text content=", "/>
		  <eq>
		    <Subst>
		      <aSubMap/>
		      <lKind k="var"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <lKind/>
		    </Subst>
		  </eq>
		</grouping>
	      </tyPre>
	      <tyPre>
		<eq>
		  <dCtset/>
		  <set>
		    <grouping>
		      <Subst>
			<aSubMap/>
			<pcst>
			  <id/>
			  <lKind/>
			  <type/>
			</pcst>
		      </Subst>
		      <ST/>
		      <in>
			<pcst>
			  <id/>
			  <lKind/>
			  <type/>
			</pcst>
			<aCtset/>
		      </in>
		    </grouping>
		  </set>
		</eq>
	      </tyPre>
	      <tyConc>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </tyConc>
	    </tyRule>
	    <tyRule>
	      <tyPre>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </tyPre>
	      <tyPre>
		<models>
		  <assume/>
		  <dCtset/>
		</models>
	      </tyPre>
	      <tyConc>
		<Sjudge name="sat">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
      </font>
      <br/>
      <p>
	<leadin>Definition 10 (Notational Derivations).</leadin>
	<em>
	  We write:
	  <br/>
	  (1) 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Sjudge name="sol">
	      <aSubMap/>
	      <leadsto>
		<aCtset/>
		<dCtset/>
	      </leadsto>
	    </Sjudge>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Cst>
	      <assume>
		<aSubMap/>
	      </assume>
	      <set>
		<gamma/>
		<store/>
		<type/>
		<aCtset/>
	      </set>
	    </Cst>
	  </btypes:TYPE>
	  <br/>
	  (2)
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	</em>
      </p>
      <p>
	<leadin>Lemma 3 (Correctness of Unification).</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <eq>
	      <unf>
		<aCtset/>
	      </unf>
	      <Pair>
		<dCtset/>
		<aSubMap/>
	      </Pair>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Sjudge name="sol">
	      <aSubMap/>
	      <leadsto>
		<aCtset/>
		<dCtset/>
	      </leadsto>
	    </Sjudge>
	  </btypes:TYPE>
	</em>
      </p>
      <p>
	<leadin>Lemma 4 (Satisfiability of Unified Constraints).</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <eq>
	      <unf>
		<aCtset/>
	      </unf>
	      <Pair>
		<dCtset/>
		<aSubMap num="u"/>
	      </Pair>
	    </eq>
	  </btypes:TYPE>, then there exists a substitution
	  <btypes:TYPE>
	    <aSubMap num="s"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <Sjudge name="sat">
	      <compose>
		<aSubMap num="u"/>
		<aSubMap num="s"/>
	      </compose>
	      <leadsto>
		<aCtset/>
		<dCtset/>
	      </leadsto>
	    </Sjudge>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Lemma 5 (Principality of Unification).</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <eq>
	      <unf>
		<aCtset/>
	      </unf>
	      <Pair>
		<dCtset/>
		<aSubMap num="u"/>
	      </Pair>
	    </eq>
	  </btypes:TYPE>, where 
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE> is a set of constraints obtained from the type
	  inference algorithm, then, for all
	  <btypes:TYPE>
	    <aSubMap num="s"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <Sjudge name="sol">
	      <aSubMap num="s"/>
	      <leadsto>
		<aCtset/>
		<dCtset dash="'"/>
	      </leadsto>
	    </Sjudge>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <supeq>
	      <aSubMap num="s"/>
	      <aSubMap num="u"/>
	    </supeq>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Lemma 6 (Decidability of Unification).</leadin>
	<em>
	  The problem of computing a canonical derivation of
	  <btypes:TYPE>
	    <unf>
	      <aCtset/>
	    </unf>
	  </btypes:TYPE> for an arbitrary 
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE>,
	  where no two applications of U-Sym rule
	  happen consecutively is decidable.
	</em>
      </p>
      <p>
	<leadin>Theorem 2 (Soundness of Type Inference).</leadin>
	<em>
	  If 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE>, then
	  <br/>
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Lemma 7 (Type Checkability).</leadin>
	<em>
	  If 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <eq>
	      <unf>
		<aCtset/>
	      </unf>
	      <Pair>
		<dCtset/>
		<aSubMap/>
	      </Pair>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Exists/>
	    <aSubMap dash="'"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <models>
	      <assume/>
	      <Subst>
		<aSubMap dash="'"/>
		<dCtset/>
	      </Subst>
	    </models>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Subst>
	      <compose>
		<aSubMap/>
		<aSubMap dash="'"/>
	      </compose>
	      <aExpr/>
	    </Subst>
	  </btypes:TYPE> is canonical, and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<compose>
		  <aSubMap/>
		  <aSubMap dash="'"/>
		</compose>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</em>
      </p>
      <p>
	<leadin>Theorem 3 (Completeness of Type Inference).</leadin>
	<em>
	  If 
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, then there exists a
	  <btypes:TYPE>
	    <supeq>
	      <aSubMap dash="'"/>
	      <aSubMap/>
	    </supeq>
	  </btypes:TYPE> 
	  such that 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<aSubMap dash="'"/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE>.
	</em>
      </p>
    </font>
    <p>
      Proofs for safety of the type system and soundness and
      completeness of the inference algorithm can be
      found in&nbsp;<cite ref="sridhar2007formal"/>.
    </p>
  </sect1>
  <sect1 id="related">
    <title>Related Work</title>
    <p>
      Grossman&nbsp;<cite ref="Grossman2006qtypes"/> provides a theory
      of using quantified types with imperative C style mutation for
      Cyclone. However, his formalization requires explicit annotation
      for all polymorphic definitions and instantiations. In contrast,
      we believe that the best way to integrate polymorphism into the
      systems programming paradigm is by automatic inference. A
      further contribution of our work (in comparison to&nbsp;<cite
	ref="Grossman2006qtypes"/>) is that we 
      give a formal specification and proof of correctness of the
      inference algorithm, not just the type system.
      Cyclone&nbsp;<cite ref="Jim2002Cyclone"/> uses region analysis
      to provide safe support for the address
      <progident>&amp;</progident> operator. This technique is
      complementary to our work, and can be used to incorporate
      <progident>&amp;</progident> operator in 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>.
    </p>
    <p>
      C's <progident>const</progident> notion of immutability-by-alias
      offers localized checking of immutability properties, and
      encourages good programming practice by serving as documentation
      of programmers' intentions.  Other systems have proposed
      immutability-by-name&nbsp;<cite ref="DeLineMSRVault"/>,
      referential immutability&nbsp;<cites>
	<cite ref="shapiro1999EROS"/>
	<cite ref="tschantz2005javari"/>
      </cites>
      (transitive immutability-by-reference),
      <foreignphrase>etc.</foreignphrase> These techniques are
      orthogonal and complementary to the immutability-by-location
      property in <btypes:TYPE><language/></btypes:TYPE>. For
      example, we could have types like
      (<progident>const</progident>
      <btypes:TYPE>
	<mutable>
	  <type/>
	</mutable>
      </btypes:TYPE>) that can express
      both global and local usage properties of a location.
    </p>
    <p>
      A monadic model&nbsp;<cite ref="peytonjones1993monads"/>
      of mutability is used in pure functional languages like
      Haskell&nbsp;<cite ref="peytonjones2003haskellrevisedreport"/>.
      In this model, the type system distinguishes side-effecting
      computations from pure ones (and not just mutable locations
      from immutable ones). Even though this model is beneficial for
      integration with verification systems, it is considerably
      removed from the idioms needed by systems
      programmers. For example,  Hughes argues that there is no
      satisfactory way of creating and using global mutable variables
      using monads&nbsp;<cite ref="Hughes2004HaskellGlobals"/>. 
      There have been proposals for adding unboxed representation
      control to Haskell&nbsp;<cites>
	<cite ref="peytonjones1991unboxed"/>
	<cite ref="Diatchki2005Representation"/>
      </cites>. However, these systems are pure and therefore and do
      not consider the effects of mutability.
    </p>
    <p>
      Cqual&nbsp;<cite ref="foster2006Cqual"/> provides a framework
      of type qualifiers, which can be used to infer maximal
      <progident>const</progident> qualifications for C
      programs. However, CQual does not deal with polymorphism
      of types. In a monomorphic language, we can infer types and
      qualifiers independently. Adding polymorphism to CQual
      would introduce substantial challenges, particularly if
      polymorphism should be automatically inferred. The inference of
      types and qualifiers (mutability) becomes co-dependent: we need
      base types to infer qualifiers; but, we also need the qualifiers
      to infer base types due to the value
      restriction. 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> supports
      a polymorphic language and performs simultaneous
      inference of base types and mutability.
    </p>
  </sect1>
  <sect1 id="conclusion">
    <title>Conclusions</title>
    <p>
      In this paper, we have defined a language and type system 
      for systems programming which integrates all of unboxed
      representation, consistent complete mutability support, and
      polymorphism. The mutability model is expressive enough to 
      permit mutation of unboxed/stack locations, and at the same time
      guarantees that types are definitive about the mutability of
      every location across all aliases. 
    </p>
    <p>
      Complete support for mutability introduces challenges for type
      inference at copy boundaries. We have developed a novel algorithm
      that infers principal types using a system of constrained
      types. To our knowledge, this is the first sound and complete
      algorithm that infers both mutability and polymorphism in a
      systems programming language with copy compatibility.
    </p>
    <p>    
      The type inference algorithm is implemented as part of the
      BitC&nbsp;<cite ref="shapBitcSpec2006"/> language compiler.
      The core of the compiler involves 22,433 lines of C++ code, of
      which implementation of the type system accounts for about
      7,816 lines.
      The source code can be obtained from
      <link href="http://bitc-lang.org">
	<progident>http://bitc-lang.org</progident>.  
      </link>
    </p>
  </sect1>
  <!--   <sect1 id="acknowledgments" numbered="no"> -->
  <!--     <title>Acknowledgments</title> -->
  <!--     <p> -->
  <!--       <em>Undisclosed for anonymization.</em> -->
  <!--       Mark Jones was kind enough to educate us on type -->
  <!--       classes, which provided an essential basis for integrating these -->
  <!--       ideas. Foster, Iavor, Pari, bitc-dev... -->
  <!--     </p> -->
  <!--   </sect1> -->
  <bibliography>
    <font size="scriptsize">
      <!-- <bibentry label="Alexander98"> 
	 <key>Alexander98</key>
	D. S. Alexander, W. A. Arbaugh, M. W. Hicks, P. Kakkar,
	A. D. Keromytis, J. T. Moore, C. A. Gunder, S. M. Nettles,
	and J. M. Smith. 
	``The SwitchWare active network architecture''
	<doctitle>
	  IEEE Network
	</doctitle>
	May/June 1998.
      </bibentry> -->
      <bibentry label="Biagioni2001FoxNet"> 
	<!-- <key>Biagioni01</key> -->
	E. Biagioni, R. Harper, and P. Lee
	``A network protocol stack in Standard ML''
	<doctitle>
	  Higher Order and Symbolic Computation, Vol.14, No.4
	</doctitle>,
	2001.
      </bibentry>
      <bibentry label="DeLineMSRVault">
	<!-- <key>DeLine01</key> -->
	R. Deline and M. F&auml;hndrich,
	``VAULT: a programming language for reliable systems''
	<link href="http://research.microsoft.com/vault">
	  <progident>http://research.microsoft.com/vault</progident>
	</link>, 2001
      </bibentry>
      <bibentry label="Derby1999Foxnet">
	<!-- <key>Derby99</key> -->
	H. Derby,
	``The performance of FoxNet 2.0''
	<doctitle>
	  Technical Report CMU-CS-99-137
	</doctitle>
	School of Computer Science, Carnegie Mellon University, 
	June 1999. 
      </bibentry> 
      <bibentry label="csharpSpec"> 
	<!-- <key>ECMA06</key> -->
	ECMA International
	``Standard ECMA-334 C# Language Specification''
	<link href="http://www.ecma-international.org/publications/standards/Ecma-334.htm">
	  <progident>http://www.ecma-international.org/publications/standards/Ecma-334.htm</progident>
	</link><!--,2006.-->
      </bibentry>
      <bibentry label="foster2006Cqual">
	<!-- <key>Foster06</key> -->
	J. S. Foster, R. Johnson, J. Kodumal, and A. Aiken
	``Flow-Insensitive Type Qualifiers''
	<doctitle>
	  Trans. on Programming Languages and Systems. 
	</doctitle>
	28(6):1035-1087, Nov. 2006.  
      </bibentry>
      <bibentry label="Grossman2006qtypes">
	<!-- <key>Grossman06</key> -->
	D. Grossman, ``Quantified Types in an Imperative Language''
	<doctitle>ACM Transactions on Programming Languages and Systems
	</doctitle>, 
	2006.
      </bibentry>
      <bibentry label="Hughes2004HaskellGlobals">
	<!-- <key>Hughes04</key> -->
	J. Hughes 	 
	``Global variables in Haskell''
	<doctitle>
	  Journal of Functional Programming archive
	</doctitle>
	Volume 14,  Issue 5, Sept. 2004.
      </bibentry>
      <bibentry label="Diatchki2005Representation">
	<!-- <key>Diatchki05</key> -->
	I. S. Diatchki, M. P. Jones, and R. Leslie.
	``High- level Views on Low-level Representations.''
	<doctitle>Proc. ACM Int. Conference on Functional
	  Programming</doctitle> pp. 168&ndash;179, 
	2005.
      </bibentry>
    <!-- <bibentry label="ISO1995Ada">
	 <key>ISO95</key>
	International Std. Organization
	<doctitle>ISO/IEC 8652:1995 (Information
	  Technology &mdash; Prog.
	  Languages &mdash; Ada)</doctitle>, 1995.
      </bibentry> -->
    <!-- <bibentry label="ISO1998C++">
	 <key>ISO98</key>
	International Std. Organization
	<doctitle>ISO/IEC FDIS 14882:1998(E) (Prog.
	  Lang. - C++)</doctitle>, 1998.
      </bibentry> -->
      <bibentry label="ISO1999ANSI-C">
	<!-- <key>ISO99</key> -->
	International Std. Organization
	<doctitle>ISO/IEC 9899:1999 (Prog.
	  Languages - C)</doctitle>, 1999.
      </bibentry>
      <bibentry label="Jim2002Cyclone">
	<!-- <key>Jim02</key> -->
	T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and
	Y. Wang  
	``Cyclone: A safe dialect of C.'' 
	<doctitle>
	  Proc. of USENIX Annual Technical Conference 
	</doctitle>
	pp 275­288, 2002. 
      </bibentry>
      <bibentry label="jones1995qualtypes">
	<!-- <key>Jones95</key> -->
	M. P. Jones
	``Qualified types: theory and practice.''
	<doctitle>
	  Cambridge Distinguished Dissertations In Computer Science
	</doctitle>
	ISBN:0-521-47253-9, 1995
      </bibentry>
      <bibentry label="peytonjones1991unboxed">
	<!-- <key>Jones91</key> -->
	S. L. Peyton Jones and J. Launchbury
	``Unboxed values as first class citizens in a non-strict
	functional language.''
	<doctitle>
	  Functional Programming Languages and Computer Architecture
	</doctitle>,
	1991
      </bibentry>
      <bibentry label="peytonjones1993monads">
	<!-- <key>Jones93</key> -->
	S. L. Peyton Jones and P. Wadler
	``Imperative functional programming.''
	<doctitle>
	  Proc. ACM SIGPLAN Principles of Programming Languages.
	</doctitle>,
	1993
      </bibentry>  
      <bibentry label="peytonjones2003haskellrevisedreport">
	<!-- <key>Jones03</key> -->
	S. L. Peyton Jones (ed.). <doctitle>Haskell 98 Language and
	  Libraries: The Revised report</doctitle>. Cambridge University
	Press, 2003.
      </bibentry>
    <!-- <bibentry label="LeroyOcaml">
	 <key>Leroy05</key>
	Xavier Leroy,  
	``The Objective Caml System Release 3.09, Documentation and
	User's Manual.''
	<link
	  href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">
	  <progident>http://caml.inria.fr/pub/docs/ manual-ocaml/index.html</progident>
	</link> 
      </bibentry> -->
      <bibentry label="Milner1978W">
	<!-- <key>Milner78</key> -->
	R. Milner 
	``A theory of type polymorphism in programming.''
	<doctitle>
	  Journal of Computer and System Sciences
	</doctitle>
	pp 348-375, 1978.
      </bibentry>
      <bibentry label="milner97definition">
	<!-- <key>Milner97</key> -->
	R. Milner, M. Tofte, R. Harper, and D.MacQueen. 
	<doctitle>The Definition of Standard ML - Revised</doctitle>
	The MIT Press, May 1997.
      </bibentry>
      <!--     <bibentry label="necula2002CCured"> -->
      <!--       <key>Necula02</key> -->
      <!--       G. Necula, S. Mcpeak, and W. Weimer  -->
      <!--       ``CCured: Type-safe retrofitting of legacy code.'' -->
      <!--       <doctitle> -->
      <!--         Proc. of Symposium on Principles of Programming Languages -->
      <!--       </doctitle>  -->
      <!--       pp 128­139, 2002. -->
      <!--     </bibentry> -->
      <!--     <bibentry label="pierce2002TypesBook"> -->
      <!--       <key>Pierce02</key> -->
      <!--       B. C. Pierce -->
      <!--       ``Types and Programming Languages'' -->
      <!--       <doctitle> -->
      <!-- 	The MIT Press, Massachusetts Institute of Technology -->
      <!--       </doctitle> -->
      <!--       ISBN 0-262-16209-1, 2002.       -->
      <!--     </bibentry> -->
      <bibentry label="javaSpec">
	<!-- <key>Gosling05</key> -->
	J. Gosling, B. Joy, G. Steele, and G. Bracha
	``The Java Language Specification,'' Third Edition
	<link href="http://java.sun.com/docs/books/jls">
	  <progident>http://java.sun.com/docs/books/jls</progident>
	</link>
      </bibentry>
      <bibentry label="pythonSpec"> 
	<!-- <key>Rossum06</key> -->
	G. van Rossum, ``Python Reference Manual''
	F. L. Drake, Jr. (ed.)
	<link href="http://docs.python.org/ref/ref.html">
	  <progident>http://docs.python.org/ref/ref.html</progident>
	</link>, 2006.
      </bibentry>
      <bibentry label="shapiro1999EROS">
	<!-- <key>Shapiro99</key> -->
	J. S. Shapiro, J. M. Smith, and D. J. Farber. 
	``EROS: a fast capability system''
	<doctitle>
	  ACM Symposium on Operating Systems Principles
	</doctitle>,
	Dec. 1999.
      </bibentry>
      <bibentry label="shapBitcSpec2006">
	<!-- <key>U1</key> -->
	J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
	Specification''
	<link
	  href="http://bitc-lang.org/docs/bitc/spec.html">
	  <progident>http://www.bitc-lang.org/docs/bitc/spec.html</progident>
	</link>
      </bibentry>
      <bibentry label="Smith1998polymorphicC">
	<!-- <key>Smith98</key> -->
	G. Smith and D. Volpano. 
	``A sound polymorphic type system for a dialect of C.''
	<progident>
	  Science of Computer Programming
	</progident>
	<b>32</b>(2--3):49--72, 1998. 
      </bibentry>
      <bibentry label="sridhar2006plos">
	<!--  <key>Sridhar06</key> -->
	S. Sridhar and J. S. Shapiro. ``Type Inference for Unboxed Types
	and First Class Mutability'' 
	<doctitle>Proc. 3rd Workshop on Prog. Languages and
	  Operating Systems</doctitle>, 2006. 
      </bibentry>
      <bibentry label="sridhar2007formal">
	<!-- <key>Sridhar07</key> -->
	S. Sridhar, J. S. Shapiro and S. F. Smith
	``The BitC Type System and Inference Algorithm: Proofs of
	Soundness and Completeness''
	<link
	  href="http://bitc-lang.org/docs/bitc/c-formal.pdf">
	  <progident>http://www.bitc-lang.org/docs/bitc/c-formal.pdf</progident>
	</link><!-- , 2007 -->.
      </bibentry>
      <bibentry label="Tarditi1996TIL"> 
	<!-- <key>Tarditi96</key> -->
	D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and
	P. Lee. 
	``TIL: A type-directed optimizing compiler
	for ML''
	<doctitle>
	  Proc. ACM SIGPLAN PLDI
	</doctitle>, 1996. 
      </bibentry>
      <bibentry label="tschantz2005javari">
	<!-- <key>Tschantz05</key> -->
	M. S. Tschantz and M. D. Ernst,     
	``Javari: Adding reference immutability to Java''
	<doctitle>
	  Object-Oriented Programming Systems, Languages, and
	  Applications
	</doctitle>,
	Oct 2005.
      </bibentry>
      <bibentry label="wrightValRes1995">
	<!-- <key>Wright95</key> -->
	A. Wright, ``Simple Imperative Polymorphism'' 
	<doctitle> Lisp and Symbolic Comp.</doctitle>
	8(4):343-355, 1995.
      </bibentry>
    </font>
  </bibliography>
</article>

<!--       <btypes:TYPE> -->
<!-- 	<grammar notitle="yes"> -->
<!-- 	  <bnf2> -->
<!-- 	    <bnf desc="Identifiers"> -->
<!-- 	      <id/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<id name="y"/> -->
<!-- 		<id name="z"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Stack Locations"> -->
<!-- 	      <sLoc/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<sLoc num="1"/> -->
<!-- 		<sLoc num="2"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Heap Locations"> -->
<!-- 	      <hLoc/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<hLoc num="1"/> -->
<!-- 		<hLoc num="2"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2>	     -->
<!-- 	    <bnf desc="lvalues"> -->
<!-- 	      <lVal/> -->
<!-- 	      <alternatives> -->
<!-- 		<sLoc/> -->
<!-- 		<deref> -->
<!-- 		  <hLoc/> -->
<!-- 		</deref> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Values"> -->
<!-- 	      <aVal/> -->
<!-- 	      <alternatives> -->
<!-- 		<Unit/> -->
<!-- 		<true/> -->
<!-- 		<false/> -->
<!-- 		<hLoc/> -->
<!-- 		<lambda> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr/> -->
<!-- 		</lambda> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2 colspan="3"> -->
<!-- 	    <bnf desc="Expressions"> -->
<!-- 	      <aExpr/> -->
<!-- 	      <alternatives> -->
<!-- 		<aVal/> -->
<!-- 		<sLoc/> -->
<!-- 		<apply> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</apply> -->
<!-- 		<tqExpr> -->
<!-- 		  <aExpr/> -->
<!-- 		  <type/> -->
<!-- 		</tqExpr> -->
<!-- 		<assign> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</assign>  -->
<!-- 		<dup> -->
<!-- 		  <aExpr/> -->
<!-- 		</dup> -->
<!-- 		<deref> -->
<!-- 		  <aExpr/> -->
<!-- 		</deref> -->
<!-- 		<if> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</if> -->
<!-- 		<let kind="k"> -->
<!-- 		  <tqExpr optional="yes"> -->
<!-- 		    <id/> -->
<!-- 		    <type/> -->
<!-- 		  </tqExpr> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</let> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2 colspan="3"> -->
<!-- 	    <bnf desc="Let-kinds"> -->
<!-- 	      <symbol name="kappa"/> -->
<!-- 	      <alternatives> -->
<!-- 		<text content="-"/> -->
<!-- 		<symbol name="alpha"/> -->
<!-- 		<symbol name="psi"/> -->
<!-- 		<symbol name="forall"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	</grammar> -->
<!--       </btypes:TYPE> -->


<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->

<!--  LocalWords:  sysinfer twocolumn ptsz documentclass sigplanconf firstname
 -->
<!--  LocalWords:  authorgroup orgname mdash Coyotos shapiro coyotos ACL acl se
 -->
<!--  LocalWords:  kaufmann milner peytonjones haskellrevisedreport Kernighan
 -->
<!--  LocalWords:  CCured necula Condit cycloneManual Grossman qtypes Volpano
 -->
<!--  LocalWords:  SmithVolpanoPTVR const cpi cong ncong foreignphrase hoc mb
 -->
<!--  LocalWords:  sridharmutinfer boolPair sem dup bnf desc sLoc hLoc aVal ARG
 -->
<!--  LocalWords:  aExpr lvalues lVal tqExpr bnfc opsem opState eval levalOp et
 -->
<!--  LocalWords:  evalOp floatingtable fullwidth Hrules opRule RVAL opPre dom
 -->
<!--  LocalWords:  mapsto opConc leval notin subst Diatchki defrepr monad Cqual
 -->
<!--  LocalWords:  SysObjC balogh sysobjc IEC Aacute aacute Zolt ouml rnyei ACM
 -->
<!--  LocalWords:  Proc ECOOP Kluwer auml hndrich SIGPLAN PLDI ndash Sriram MLC
 -->
<!--  LocalWords:  Rajamani SIGACT McCloskey Zhou HotOS USENIX dependentMut th
 -->
<!--  LocalWords:  IEEE Verlag Mads Tofte MacQueen Iavor hallgren Tolmach ICFP
 -->
<!--  LocalWords:  Sep shap fastcapsystem Farber Kiawah Mcpeak Weimer Harren Ph
 -->
<!--  LocalWords:  Morrisett PolymorphismTypeAnalysis Symp Shao Zhong DeLine im
 -->
<!--  LocalWords:  Deline Fahndrich LeroyOcaml Caml fahndrich Hawblitzel Hodson
 -->
<!--  LocalWords:  Lauris EUROSYS Leuven aiken MSR sridhar PLOS Hindley uint gg
 -->
<!--  LocalWords:  Worshop Northup online bitfield Arith dereferencing mVal dyn
 -->
<!--  LocalWords:  bPtr polyinstantiated updatable rvalues lval TypEvalPred aTS
 -->
<!--  LocalWords:  pred Csubst Pari ocaml anonymization ML's twelf Nipkow inria
 -->
<!--  LocalWords:  coq ppabs dereferences HaskellonProcessor mtverify jones TCL
 -->
<!--  LocalWords:  qualtypes texttt mtd lang xmli horz maxzOp minzOp eq maxz na
 -->
<!--  LocalWords:  minz covariant arg ret ceil Tsub locsem decl specsharp CADE
 -->
<!--  LocalWords:  Monads Carsten LNAI Paulson Wenzel HOL LNCS Millstein eiffel
 -->
<!--  LocalWords:  DeLineVault Schoeller Bernd Zhiming Liu FACS Rustan Leino ve
 -->
<!--  LocalWords:  Schulte CASSIS specsharpreleasenotes Smans Piessens tschantz
 -->
<!--  LocalWords:  javari leadin isZthTrue Pfenning mVec mLst backend ShaoRep
 -->
<!--  LocalWords:  leroyUBobj harperPoly RTTI polyinst letvar letarr defpure ol
 -->
<!--  LocalWords:  GHC VFiasco hohmuth BitC's releasenotes uuml ghcManual Tews
 -->
<!--  LocalWords:  plos iuml analyses TDjudge judgeOp Sjudge unin supeq TIjudge
 -->
<!--  LocalWords:  aSubMap corUp corUpOp solvability rmann unifications revalOp
 -->
<!--  LocalWords:  reval epsiv TypesBook leroy polymorphicC Launchbury monads
 -->
<!--  LocalWords:  stateinHaskell Wadler ceqOp neq FirstName LastName liveness
 -->
<!--  LocalWords:  Tarditi javaSpec csharpSpec DeLineMSRVault schemeSpec thinsp
 -->
<!--  LocalWords:  pythonSpec runtime marshall unmarshall FoxNet TCP IP SubMap
 -->
<!--  LocalWords:  Biagioni Volpano's unkinded mbpair OTH Edoardo Larus Abadi
 -->
<!--  LocalWords:  amd Barha Steensgaard Wobber Zill Gilad Bracha ECMA Rossum
 -->
<!--  LocalWords:  Cheng tyRule tyPre tyConc isEntity REFL CQual xml DOCTYPE fn
 -->
<!--  LocalWords:  OSDoc xmlns btypes docinfo pubdate dev bitc BitC incolumn al
 -->
<!--  LocalWords:  unboxed nbsp shapBitcSpec mut compat SparkAdaBook SML OCaml
 -->
<!--  LocalWords:  progident Foxnet literallayout forall IntLit defstruct fst
 -->
<!--  LocalWords:  snd defunion cdr inlined Diatchi Sys Usr typ bool stateful
 -->
<!--  LocalWords:  xyz dereferenced deref constness ndx ident ul li lvalue tvar
 -->
<!--  LocalWords:  behaviour ceq sz accessor wrightValRes monomorphic tradeoffs
 -->
<!--  LocalWords:  ness vec lst abc deftypeclass definstance num href LHS RHS
 -->
<!--  LocalWords:  aCtset br subtyping iff contravariant tvars Xform Commut CMU
 -->
<!--  LocalWords:  polyinstantiation microkernel datatypes bibentry doctitle cp
 -->
<!--  LocalWords:  SparkAda Doerrie Swaroop Multithreaded Multithreading useF
 -->
<!--  LocalWords:  Kodumal fPtr polymorphically asplas llncs notitle copyList
 -->
<!--  LocalWords:  optionalElse dereference mutLst nospace listCopy bp textit
 -->
<!--  LocalWords:  allTrue rvalue reified HaskellGlobals SRL colspan benefacts
 -->
	
<!--  LocalWords:  ctype fnxn paren initsep colsep globals tbody valign td Loc
 -->
<!--  LocalWords:  Exprs TypeScheme Env Rval Oth cst Prog mutinfer de facto SHA
 -->
<!--  LocalWords:  scriptsize FDIS Keromytis Gunder SwitchWare inequations NEB
 -->
<!--  LocalWords:  Arbaugh Kakkar polymorphism TIL HM Refl contravariance co pp
 -->
<!--  LocalWords:  decidably Chekability Trans Int Std ISBN Comp Mf Sel Mct App
 -->
<!--  LocalWords:  monomorphically concretizable Checkability maxima MP Ct Om
 -->
<!--  LocalWords:  Op Sym
 -->
