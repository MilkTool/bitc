<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <article id="formal" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo ptsz='default' latex.otheroptions="nocopyrightspace" latex.documentclass="sigplanconf">
    <title>A Theory of Well-founded First Class Mutability</title>
    <subtitle>A Proof of Soundness for BitC Type System and
      Type Inference Algorithm</subtitle>
    <authorgroup>
      <author>
      	<firstname>Swaroop</firstname>
      	<surname>Sridhar</surname>
      	<email>swarop@cs.jhu.edu</email>
      </author>
      <author>
      	<firstname>Jonathan</firstname>
        <othername>S.</othername>
      	<surname>Shapiro</surname>
      	<email>shap@eros-os.org</email>
      </author>
      <author>
      	<firstname>Scott</firstname>
        <othername>F.</othername>
      	<surname>Smith</surname>
      	<email>scott@cs.jhu.edu</email>
      </author>
      <affiliation>
      	<orgname>Department of Computer Science</orgname>
      	<address>The Johns Hopkins University</address>
      	<address>3400 N.Charles Street. 224 NEB. Baltimore, MD 21218.</address>
      </affiliation>
    </authorgroup>
    <pubdate></pubdate>
    <!--     <copyright> -->
    <!--       <year>2006</year> -->
    <!--       <holder>Swaroop Sridhar</holder> -->
    <!--       <holder>Jonathan S. Shapiro</holder> -->
    <!--     </copyright> -->
    <!--   <categories> -->
    <!--     <category>dev/bitc</category> -->
    <!--   </categories> -->
    <synopsis>
      <p>
      </p>
    </synopsis>
  </docinfo>  
  <!--<abstract latex.incolumn="yes">
  <p>
    </p>
  </abstract> -->
  <!-- <toc/> -->
  <sect1 id="intro">
    <title>Introduction</title>
    <p>
      BitC is a systems programming language with first class support
      for unboxed types and mutability. Details about the language can
      be obtained from the <link
        href="http://coyotos.org/docs/bitc/spec.html"> BitC language
        specification</link> <cite ref="shapBitcSpec2006"/>. This
      document provides the formalization of the type system and type
      inference algorithm for a core calculus the BitC, along with the
      associated proofs.
    </p>
  </sect1>
  <sect1 id="language">
    <title>The Language <btypes:TYPE><language/></btypes:TYPE> </title>
    <p>
      We limit our presentation to a core calculus of BitC called 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> in the interest of brevity. 
    </p>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Identifiers">
          <id/>
          <alternatives etc="yes">
            <id name="y"/>
            <id name="z"/>
          </alternatives>
        </bnf>
        <bnf desc="Stack Locations"> 
          <sLoc/>
          <alternatives etc="yes">
            <sLoc num="1"/>
            <sLoc num="2"/>
          </alternatives>
        </bnf>
        <bnf desc="Heap Locations">
          <hLoc/>
          <alternatives etc="yes">
            <hLoc num="1"/>
            <hLoc num="2"/>
          </alternatives>
        </bnf>
        <bnf desc="Locations">
          <loc/>
          <alternatives>
            <sLoc/>
            <hLoc/>
          </alternatives>
        </bnf>
        <bnf desc="Values">
          <aVal/>
          <alternatives>
            <Unit/>
            <true/> 

            <false/>
            <hLoc/>
            <lambda>
              <id/>
              <aExpr/>
            </lambda>
          </alternatives>
        </bnf>
        <bnf desc="lvalues">
          <lVal/>
          <alternatives>
            <sLoc/>
            <deref>
              <hLoc/>
            </deref>
          </alternatives>
        </bnf>
        <bnf desc="Expressions">
          <aExpr/>
          <alternatives>
            <aVal/>
            <sLoc/>
            <apply>
              <aExpr/>
              <aExpr/>
            </apply>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
            <assign>
              <aExpr/>
              <aExpr/>
            </assign> 
          </alternatives>
        </bnf>
        <bnfc desc="">
          <alternatives>
            <dup>
              <aExpr/>
            </dup>
            <deref>
              <aExpr/>
            </deref>
          </alternatives>
        </bnfc>
        <bnfc desc="">
          <alternatives>
            <if>
              <aExpr/>
              <aExpr/>
              <aExpr/>
            </if>
          </alternatives>
        </bnfc>
        <bnfc desc="">
          <alternatives>
            <let kind="k">
              <tqExpr optional="yes">
                <id/>
                <type/>
              </tqExpr>
              <aExpr/>
              <aExpr/>
            </let>
          </alternatives>
        </bnfc>
        <bnf desc="Let-kinds">
          <lKind/>
          <alternatives>
            <text content="-"/>
            <lKind k="var"/>
            <lKind k="mono"/>
            <lKind k="poly"/>
          </alternatives>
        </bnf>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn><type/><type/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="ref / pointer">
          <alternatives>
            <ref><type/></ref>
          </alternatives> 
        </bnfc>
        <bnfc desc="Mutable type">
          <alternatives>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Type Scheme">
          <aTS/>
          <alternatives>
            <type/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      All the above syntactic forms can be parenthesized without
      change in meaning. The let-kind ``-'' is a placeholder for the
      unkinded (input) <progident>let</progident> form.
      A substitution is of Z for Y in X is written using the standard
      notation:
      <btypes:TYPE>
	<subst>
	  <text content="X"/>
	  <text content="Y"/>
	  <text content="Z"/>          
	</subst>
      </btypes:TYPE>.
    </p>
  </sect1>
  <sect1 id="opsem">
    <title>Dynamic Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
    <xi:include href="include/formal/opsem.xmli"/>
    <xi:include href="include/formal/decl.xmli"/>
    <xi:include href="include/formal/locsem.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Stack">
          <stack/>
          <alternatives>
            <Empty/>
            <extend>
              <stack/>
              <mapping>
                <sLoc/>
                <aVal/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Heap">
          <heap/>
          <alternatives>
            <Empty/>
            <extend>
              <heap/>
              <mapping>
                <hLoc/>
                <aVal/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      The Operational semantics rules are shown in Figure&nbsp;<xref
        ref="dyn_sem_horz"/>.
      The system state is represented by the triple 
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      consisting of the stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE>, the heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, and the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> to be
      evaluated. Evaluation itself is a two place relationship   
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      that denotes transformation in the system state due to a single
      step of execution.
      Figure&nbsp;<xref ref="dyn_sem_horz"/> shows the evaluation
      rules for our core language. We assume that the program is
      alpha-converted so that there are no name collisions due to
      inner bindings. Separate execution
      semantics are given for left and right execution (evaluation of
      expressions that appear on the LHS and RHS of an assignment 
      <btypes:TYPE>
	<assign>
	  <aExpr num="l"/>
	  <aExpr num="r"/>
	</assign>
      </btypes:TYPE>) denoted by 
      <btypes:TYPE><levalOp/></btypes:TYPE> and 
      <btypes:TYPE><evalOp/></btypes:TYPE> respectively. 
    </p>
  </sect1>
  <sect1 id="type_system">
    <title>Static Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Binding Environment">
          <gamma/>
          <alternatives>
            <Empty/>
            <extend>
              <gamma/>
              <mapping>
                <id/>
                <aTS/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Store Typing">
          <store/>
          <alternatives>
            <Empty/>
            <extend>
              <store/>
              <mapping>
                <loc/>
                <type/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Logical Relations">
          <LOGIC/>
          <alternatives>
            <TRUE/>
            <FALSE/>
            <AND>
              <LOGIC/>
              <LOGIC/>
            </AND>
            <OR>
              <LOGIC/>
              <LOGIC/>
            </OR>
          </alternatives>
        </bnf>
        <bnfc>
          <alternatives>              
            <NOT>
              <LOGIC/>
            </NOT>
            <pred name="Predicate">
              <plural>
                <LOGIC/>
              </plural>
            </pred>
          </alternatives>
        </bnfc>
        <bnf desc="Solvable Entities">
          <solvable/>
          <alternatives>
            <type/>
            <gamma/>
            <store/>
            <aExpr/>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      We represent mathematical properties as: 
      <btypes:TYPE>
	<models name="property">
	  <text content="assumption"/>
	  <text content="subject"/>
	</models>
      </btypes:TYPE>.
    </p>
    <p>
      Figure&nbsp;<xref ref="decl_rules"/> shows the declarative
      type rules, copy coercion rules and rules for type
      generalization. The location semantics (lvalue) rules 
      are shown in figure&nbsp;<xref ref="lval_rules"/>.
      The standard type judgment  
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> is understood as: given a binding environment 
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and store typing
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>.
      We write 
      <btypes:TYPE>
        <TDjudge sub="yes">
          <aExpr/>                  
          <type/>                  
        </TDjudge>
      </btypes:TYPE> as a shorthand for:
      <btypes:TYPE>
        <TDjudge>
          <aExpr/>                  
          <type dash="'"/>                  
        </TDjudge>
        <text content=", "/>
        <Tsub>
          <type dash="'"/>
          <type/>
        </Tsub>
      </btypes:TYPE>.
    </p>
    <definition id="aleq">      
      <title>Algebraic equivalences</title>
      <p>
        In our algebra of types, we define the following equivalence:
        <btypes:TYPE>
          <equiv>
            <mutable>
              <mutable>
                <type/>
              </mutable>
            </mutable>
            <mutable>
              <type/>
            </mutable>
          </equiv>
        </btypes:TYPE>.
        That is, the mutable type constructor is idempotent. 
      </p>
    </definition>
    <definition id="copy_sem">      
      <title>Copy Compatibility</title>
      <p> 
        We define the copy compatibility relationship 
        (<btypes:TYPE>
          <ceqOp/>
        </btypes:TYPE>) as follows:
      </p>
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre/>
            <tyConc>
              <ceq>                
                <type/>
                <type/>
              </ceq>
            </tyConc>                
          </tyRule>   
          <tyRule>
            <tyPre>
              <ceq>                
                <type/>
                <type dash="'"/>
              </ceq>	    
            </tyPre>
            <tyConc>
              <ceq>                
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </ceq>
            </tyConc>                
          </tyRule>   
          <tyRule>
            <tyPre>
              <ceq>                
                <type/>
                <type dash="'"/>
              </ceq>	    
            </tyPre>
            <tyConc>
              <ceq>
                <mutable>
                  <type/>
                </mutable>
                <type dash="'"/>
              </ceq>
            </tyConc>                
          </tyRule>   
        </Hrules>
      </btypes:TYPE>
    </definition>
    <p>
      In terms of the copy-coercion rules shown in
      Figure&nbsp;<xref ref="decl_rules"/>, we can define copy
      compatibility as: 
    </p>
    <example>
      <p>
        <btypes:TYPE>
          <equiv>
            <ceq>
              <type num="1"/>
              <type num="2"/>
            </ceq>
            <Tsub>
              <type num="1"/>
              <minz>
                <type num="2"/>
              </minz>
            </Tsub>
          </equiv>              
        </btypes:TYPE>
      </p>
    </example>
    <definition id="max_min">      
      <title>Max and Min Mutability</title>      
      <p> 
        The operators
        <btypes:TYPE><maxzOp/></btypes:TYPE> and
        <btypes:TYPE><minzOp/></btypes:TYPE> increase or
        decrease the mutability of a type, and are defined as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <eq>                
              <maxz>
                <mutable>
                  <type/>
                </mutable>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            <text content="  and  "/>
            <eq> 
              <maxz>
                <type/>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            `<text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
	    <br/>
            <eq>                
              <minz>
                <mutable>
                  <type/>
                </mutable>
              </minz>
              <type/>
            </eq>
            <text content="  and  "/>
            <eq> 
              <minz>
                <type/>
              </minz>
              <type/>
            </eq>
            <text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
          </btypes:TYPE> 
        </p>
      </example>
    </definition>
    <p>
      It is obvious that 
      <btypes:TYPE>
        <forall>
          <type/>
          <ceq> 
            <minz>
              <type/>
            </minz>
            <type/>
            <maxz>
              <type/>
            </maxz>
          </ceq>
        </forall>
        <text content=", and "/>
        <forall>
          <type/>
          <type dash="'"/>
          <iff>
            <ceq> 
              <type/>
              <type dash="'"/>
            </ceq>
            <eq>
              <minz>
                <type/>
              </minz>
              <minz>
                <type dash="'"/>
              </minz>
            </eq>
            <eq>
              <maxz>
                <type/>
              </maxz>
              <maxz>
                <type dash="'"/>
              </maxz>
            </eq>                
          </iff>
        </forall>          
        <text content="."/>
      </btypes:TYPE>
    </p>
    <definition id="structural_containment">
      <title>Structural Containment</title>
      <p>
        We define a structural containment relation 
        <btypes:TYPE>
          <in>
            <type/>
            <solvable/>
          </in>
        </btypes:TYPE> as follows.
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <type/>
        </btypes:TYPE> is structurally present as a part of 
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE>.
        <btypes:TYPE>
          <in>
            <type/>
            <aExpr/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <type/>
        </btypes:TYPE> is structurally present as a part of  
        <btypes:TYPE>
          <aExpr/>
        </btypes:TYPE>, as a type annotation.
        <btypes:TYPE>
          <in>
            <type/>
            <gamma/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <Exists>
            <in>
              <mapping>
                <id/>
                <type dash="'"/>
              </mapping>
              <gamma/>
            </in>
          </Exists>          
        </btypes:TYPE> such that 
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE>.
        <btypes:TYPE>
          <in>
            <type/>
            <store/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <Exists>
            <in>
              <mapping>
                <loc/>
                <type dash="'"/>
              </mapping>
              <gamma/>
            </in>
          </Exists>          
        </btypes:TYPE> such that 
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE>.
        We write
        <btypes:TYPE>
          <in>
            <type/>
            <solvables/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <in>
            <type/>
            <solvable/>
          </in>
        </btypes:TYPE>, for any
        <btypes:TYPE>
          <in>       
            <solvable/>
            <set>
              <solvables/>
            </set>
          </in>
        </btypes:TYPE>.
      </p>
    </definition>
    <definition id="ftvs">
      <title>Free Type Variables</title>
      <p>
        We denote the set of free type variables in a type
        <btypes:TYPE><type/></btypes:TYPE> as
        <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>. 
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <eq>
              <ftvs>
                <tvar name="alpha"/>
              </ftvs>
              <tvar name="alpha"/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <unit/>
              </ftvs>
              <empty/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <bool/>
              </ftvs>
              <empty/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <ref>
                  <type/>
                </ref>
              </ftvs>
              <ftvs>                  
                <type/>                  
              </ftvs>
            </eq>              
            <br/>
            <eq>
              <ftvs>
                <mutable>
                  <type/>
                </mutable>
              </ftvs>
              <ftvs>                  
                <type/>                  
              </ftvs>
            </eq>          
            <br/>
            <eq>
              <ftvs>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </ftvs>                                  
              <unin>
                <ftvs>
                  <type num="1"/>
                </ftvs>                    
                <ftvs>
                  <type num="2"/>
                </ftvs>                    
              </unin>                
            </eq>          
            <br/>
            <eq>
              <ftvs>
                <types num="i"/>
              </ftvs>
              <Unin>
                <ftvs>
                  <type num="i"/>
                </ftvs>
              </Unin>
            </eq>
            <br/>
            <eq>
              <ftvs>
                <aTS/>
              </ftvs>
              <unin>
                <ftvs>
                  <tvars name="alpha"/>
                </ftvs>
                <ftvs>
                  <type/>
                </ftvs>                  
              </unin>
            </eq>
            <text content=" where "/>
            <eq>
              <aTS/>
              <forall>
                <tvars name="alpha"/>
                <type/>
              </forall>
            </eq>              
            <br/>
            <eq>
              <ftvs>
                <gamma/>
              </ftvs>
              <Unin>
                <ftvs>
                  <aTS num="i"/>
                </ftvs>
              </Unin>                  
            </eq>
            <text content=" ; "/>
            <Forall/>
            <in>
              <mapping>
                <id/>
                <aTS num="i"/>
              </mapping>
              <gamma/>
            </in>
            <br/>
            <eq>
              <ftvs>
                <store/>
              </ftvs>
              <Unin>
                <ftvs>
                  <type num="i"/>
                </ftvs>
              </Unin>                  
            </eq> 
            <text content=" ; "/>
            <Forall/>
            <in>
              <mapping>
                <loc/>
                <type num="i"/>
              </mapping>
              <store/>
            </in>
            <br/>
            <eq>
              <ftvs>
                <aExpr/>
              </ftvs>
              <Unin>
                <ftvs>
                  <type num="i"/>
                </ftvs>
              </Unin>                  
            </eq> 
            <text content=" ; "/>
            <Forall/>
            <in>
              <type num="i"/>
              <aExpr/>
            </in>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <definition id="val_res">
      <title>Value Restriction</title>
      <p>
        We define some definitions used in the enforcement of value
        restriction in Figure&nbsp;<xref ref="decl_rules"/>.
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="Value">
              <aVal/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <id/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <hLoc/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <sLoc/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <dup>
                <aExpr/>
              </dup>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <deref>
                <aExpr/>
              </deref>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <eq>
              <grouping>
                <pred name="Value">
                  <if>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                    <aExpr num="3"/>
                  </if>
                </pred>
                <br/>
              </grouping>
              <AND>
                <pred name="Value">
                  <aExpr num="1"/>
                </pred>
                <pred name="Value">
                  <aExpr num="2"/>
                </pred>
                <pred name="Value">
                  <aExpr num="3"/>
                </pred>
              </AND>
            </eq>
            <br/>
            <fnxn name="Value">
              <let>
                <id/>
                <aExpr num="1"/>
                <aExpr num="2"/>
              </let>
              <AND>
                <pred name="Value">
                  <aExpr num="1"/>
                </pred>
                <pred name="Value">
                  <aExpr num="2"/>
                </pred>
              </AND>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <aExpr/>
              <FALSE/>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Expansive">
              <aExpr/>
              <NOT>
                <pred name="Value">
                  <aExpr/>
                </pred>
              </NOT>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Immut">
              <unit/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <bool/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <tvar name="alpha"/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <ref>
                <type/>
              </ref>                
              <pred name="Immut">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <forall>
                <tvars name="alpha"/>
                <type/>
              </forall>
              <pred name="Immut">                
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <type/>
              <FALSE/>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Mut">
              <type/>
              <NOT>
                <pred name="Immut">
                  <type/>
                </pred>
              </NOT>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <definition>
      <title>Stack and Heap Typing</title>
      <p>
        A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
        <btypes:TYPE><stack/></btypes:TYPE> are said to be
        <em>well typed</em> with respect to a binding context 
        <btypes:TYPE><gamma/></btypes:TYPE> and store typing
        <btypes:TYPE><store/></btypes:TYPE>, and written 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge>
          <text content=" if "/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <dom><store/></dom>
                <unin>
                  <dom><heap/></dom>
                  <dom><stack/></dom>
                </unin>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <forall>
                <in>
                  <hLoc/>
                  <dom><heap/></dom>
                </in>
              </forall>
              <text content=", "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <mapsto><heap/><hLoc/></mapsto>
                  <mapsto><store/><hLoc/></mapsto>
                </Tsub>
              </Sjudge>            
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <forall>
                <in>
                  <sLoc/>
                  <dom><stack/></dom>
                </in>
              </forall>
              <text content=", "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <mapsto><stack/><sLoc/></mapsto>
                  <mapsto><store/><sLoc/></mapsto>
                </Tsub>
              </Sjudge>            
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>      
    <lemma id="T-inversion">
      <title>Inversion of Typing Relation</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <Unit/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <unit/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <true/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <false/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <hLoc/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <lambda>
                  <id/>
                  <aExpr/>
                </lambda>
                <type/>
              </TDjudge>
              <text content=" then "/>
              <eq>
                <type/>
                <fn>
                  <type num="1" dash="'"/>
                  <type num="2" dash="'"/>
                </fn>
              </eq>
              <text content=" such that "/>
              <eq>
                <type num="1" dash="'"/>
                <minz>
                  <type num="1"/>
                </minz>
              </eq>
              <text content=", "/>
              <eq>
                <type num="2" dash="'"/>
                <maxz>
                  <type num="2"/>
                </maxz>
              </eq>
              <text content=", and, "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                        
                      <type num="1"/>                        
                    </mapping>
                  </extend>
                  <store/>
                </assume>                  
                <tqExpr>
                  <aExpr/>                    
                  <type num="2"/>                    
                </tqExpr>            
              </Sjudge>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li> 
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <deref>
                  <aExpr/>
                </deref>
                <type/>
              </TDjudge>
              <text content=" then "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <aExpr/>                      
                  <type dash="'"/>
                </Tsub>                    
              </Sjudge>                  
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>          
        <li>
          <p>
            Other cases are similar.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Immediate from the definition of typing relation.
      </p>
    </proof>
    <lemma id="T-sub-inversion">
      <title>Inversion of Copy Coercion</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <bool/>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content=" or "/>                
              <eq>
                <type/>
                <mutable>
                  <bool/>
                </mutable>
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <unit/>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <unit/>
              </eq>
              <text content=" or "/>                
              <eq>
                <type/>
                <mutable>
                  <bool/>
                </mutable>
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>                  
              </eq>
              <text content=" or "/>
              <eq>
                <type/>
                <mutable>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>     
                </mutable>             
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>                  
              </eq>
              <text content=" or "/>
              <eq>
                <type/>
                <mutable>
                  <ref>
                    <type dash="'"/>
                  </ref>                  
                </mutable>             
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <mutable>
                  <type dash="''"/>
                </mutable>
              </eq>
              <text content=" such that "/>                
              <Tsub>
                <type dash="''"/>
                <type dash="'"/>                  
              </Tsub>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </Tsub>
              <text content=" then "/>                
              <Tsub>
                <type/>
                <type dash="'"/>
              </Tsub>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the copy coercion derivation. 
      </p>
    </proof>
    <lemma id="T-canonical">
      <title>Canonical Forms</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
                <text content=" is a value, and "/>                
                <TDjudge sub="yes">
                  <aVal/>
                  <unit/>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <Unit/>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <bool/>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is either "/>
              <true/>
              <text content=" or "/>
              <false/>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <ref><type/></ref>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <hLoc/>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <fn><type num="1"/><type num="2"/></fn>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <lambda><id/><aExpr/></lambda>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of
        <btypes:TYPE>
          <TDjudge sub="yes">
            <aVal/>
            <type/>
          </TDjudge>
        </btypes:TYPE>.
      </p>
      <p>
        If 
        <btypes:TYPE>
          <TDjudge sub="yes">
            <aVal/>
            <bool/>
          </TDjudge>
        </btypes:TYPE>, 
        
        we have
        <btypes:TYPE>
          <TDjudge>
            <aVal/>
            <type/>
          </TDjudge>
          <text content=" and "/>
          <Tsub>
            <type/>
            <bool/>
          </Tsub>
        </btypes:TYPE> 
        
        by Inversion of copy coercion relation,
        <btypes:TYPE>
          <eq>
            <type/>
            <bool/>
          </eq>
          <text content=" or "/>
          <eq>
            <type/>
            <mutable>
              <bool/>
            </mutable>
          </eq>
        </btypes:TYPE>.
        
        If 
        <btypes:TYPE>
          <eq>
            <type/>
            <bool/>
          </eq>
        </btypes:TYPE>, it is clear that the final rule in the
        derivation must be T-True, or T-False, in which case the
        result is immediate. 

        The case  
        <btypes:TYPE>
          <eq>
            <type/>
            <mutable>
              <bool/>
            </mutable>
          </eq>
        </btypes:TYPE> cannot happen because there is no rule that
        derives a mutable type for a value, and we assume that the
        induction hypothesis 
        <btypes:TYPE>
          <TDjudge>
            <aVal/>
            <type/>
          </TDjudge>
        </btypes:TYPE> holds.
      </p>
      <p>
        Other cases of the lemma are similar.
      </p>
    </proof>
    <lemma id="T-progress">
      <title>Progress</title>
      <p>
        <btypes:TYPE>
          <text content="If "/>
          <aExpr/>
          <text content=" is a closed, well typed term, "/> 
          <text content="that is, "/> 
          <Sjudge>
            <assume>
              <Empty/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" for some "/> 
          <type/>
          <text content=" and "/> 
          <store/>
          <text content=", given any heap "/> 
          <heap/>
          <text content=" and stack "/> 
          <stack/>
          <text content=" such that "/> 
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=", "/>            
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content=" If "/>                
              <Sjudge name="lval">
                <assume/>
                <aExpr/>
              </Sjudge>
              <text content=", then "/>              
              <aExpr/>
              <text content=" is either a valid lvalue "/> 
              <lVal/>
              <text content=" (that is, "/>
              <eq>
                <lVal/>
                <sLoc/>
              </eq>
              <text content=", "/>
              <in>
                <sLoc/>
                <dom>
                  <stack/>
                </dom>
              </in>
              <text content=" or "/> 
              <eq>
                <lVal/>
                <deref>
                  <hLoc/>
                </deref>
              </eq>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <heap/>
                </dom>
              </in>
              <text content=") or else "/>
              <Exists>
                <aExpr dash="'"/>
                <stack dash="'"/>
                <heap dash="'"/>
              </Exists>
              <text content=" such that:"/>               
              <leval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </leval>
              <text content="."/>   
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>              
            <btypes:TYPE>
              <aExpr/>
              <text content=" is a value "/> 
              <aVal/>
              <text content=" or else "/> 
              <Exists>
                <aExpr dash="'"/>
                <stack dash="'"/>
                <heap dash="'"/>
              </Exists>
              <text content=" such that "/>               
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
            (Values) Result is immediate for right execution, and
            cannot happen for right execution
          </p>
        </li>
        <li>
          <p>
            Case T-Id: cannot happen, there is no execution rule for
            variables. 
          </p>
        </li>
        <li>
          <p>
            Case T-Sloc: Immediate for left execution. Right
            execution and can always continue with E-Rval rule as the
            stack is well typed 
            (<btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge> 
            </btypes:TYPE>).
          </p>
        </li>
        <li>
          <p>
            Case T-App: Only right execution is possible, no application is well
            typed as an lvalue. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <apply>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </apply>                  
              </eq>
              <text content=", "/>
              <Tsub>
                <aExpr num="1"/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>                  
              <text content=", and "/>
              <Tsub>
                <aExpr num="2"/>
                <type num="1"/>
              </Tsub>                
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
              <text content=" or "/>
              <aExpr num="2"/>
            </btypes:TYPE>
            is not a value, we can take E-App1# or
            E-App2#. Otherwise, when both 
            <btypes:TYPE>
              <aExpr num="1"/>
              <text content=" and "/>
              <aExpr num="2"/>
            </btypes:TYPE>
            are values, by canonical forms lemma, 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is of the form
            <btypes:TYPE>
              <lambda>
                <id/>
                <aExpr dash="'"/>
              </lambda>
            </btypes:TYPE>,
            and we can take the step E-App. 
          </p>
        </li>
        <li>
          <p>
            Case T-If: Similar to T-App, only right execution is
            permitted.
          </p>
        </li>
        <li>
          <p>
            Case T-Set: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <assign>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </assign>  
              </eq>
              <text content=", "/>
              <Tsub>
                <aExpr num="1"/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>                  
              <text content=", "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <mutable>
                  <type/>
                </mutable>
              </TDjudge>
              <text content=", "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type/>
              </TDjudge>
              <text content=", and "/>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            not an lvalue, since we have  
            <btypes:TYPE>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>
            </btypes:TYPE>
            we can take E-:=lhs# by induction hypothesis.
            Similarly, if 
            <btypes:TYPE>
              <aExpr num="2"/>
            </btypes:TYPE>
            is not a value, we can take E-:=rhs#.
            Finally, if
            <btypes:TYPE>
              <eq>
                <aExpr num="1"/>
                <lVal/>
              </eq>
              <text content=" and "/>
              <eq>
                <aExpr num="1"/>
                <aVal/>
              </eq>
            </btypes:TYPE>,
            we can take the step E-:=Stack or E-:=Heap as
            applicable. 
          </p>
        </li>
        <li>
          <p>
            Case T-Dup: Only right execution is
            permitted, and can take E-Dup# or E-Dup as
            applicable. 
          </p>
        </li>
        <li>
          <p>
            Case T-Deref: We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <deref>
                  <aExpr num="1"/>
                </deref>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>                  
                <ref>
                  <type/>
                </ref>                  
              </TDjudge>
            </btypes:TYPE>.
            Execution can take EL-^# or E-^# as
            applicable if  
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value.
            If 
            <btypes:TYPE>
              <Tsub>
                <aExpr num="1"/>
                <ref>
                  <type/>
                </ref>
              </Tsub>
            </btypes:TYPE>
            is a value, then, from the canonical forms lemma, 
            <btypes:TYPE>
              <eq>
                <aExpr num="1"/>
                <hLoc/>
              </eq>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
            </btypes:TYPE>.            
            Now, since this is an lvalue, we are done in the case of
            left execution. In the case of right execution, we can
            take step E-^ since the heap is well typed 
            (<btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge> 
            </btypes:TYPE>).
          </p>
        </li>
        <li>
          <p>
            Case T-Let-M: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="m">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=", "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=", "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=", and"/>
              <Sjudge name="loc">
                <assume/>
                <tqExpr>
                  <id/>
                  <aTS/>	
                </tqExpr>
              </Sjudge>
              <text content=", and"/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value, we can take E-Let#.
            Otherwise, we can take E-Let-M.              
          </p>
        </li>
        <li>
          <p>
            Case T-Let-P: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="m">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=", "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=", "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=", and"/>
              <Sjudge name="term">
                <assume/>
                <tqExpr>
                  <id/>
                  <aTS/>	
                </tqExpr>
              </Sjudge>
              <text content=", and"/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value, we can take E-Let#.
            Otherwise, can take E-Let-P.
          </p>
        </li>
        <li>
          <p>
            Case T-TqExpr and Case T-Let-M-Tq, T-Let-P-Tq are
            similar.  
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="T-Weakening">
      <title>Weakening</title>
      <p>
        We will write
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <GEN>
                <type/>
                <aTS/>
              </GEN>
            </tqExpr>
          </Sjudge>
          <text content=" as a shorthand for "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", and "/>            
          <Sjudge name="gen">
            <assume>
              <gamma/>
              <store/>
              <aExpr/>
            </assume>
            <GEN>
              <type/>
              <aTS/>
            </GEN>
          </Sjudge>
          <text content="."/>
        </btypes:TYPE>           
      </p>
      <ol>
        <li>          
          <p>
            If 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </Sjudge>                
            </btypes:TYPE>
            then,
          </p>
          <ol>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <gamma dash="'"/>
                    <gamma/>
                  </supeq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma dash="'"/>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <GEN>
                    <type/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
              <text content=", "/>
              <eq>
                <aTS/>
                <forall>
                  <tvars name="alpha"/>
                  <type/>
                </forall>
              </eq>
            </btypes:TYPE>
          </p>
          <ol>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <gamma dash="'"/>
                    <gamma/>
                  </supeq>                
                  <text content=" and "/>
                  <eq>
                    <inter>
                      <ftvs>
                        <gamma dash="'"/>
                      </ftvs>
                      <ftvs>
                        <tvars name="alpha"/>
                      </ftvs>
                    </inter>
                    <Empty/>
                  </eq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma dash="'"/>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <GEN>
                        <type/>
                        <aTS/>
                      </GEN>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" and "/>
                  <eq>
                    <inter>
                      <ftvs>
                        <store dash="'"/>
                      </ftvs>
                      <ftvs>
                        <tvars name="alpha"/>
                      </ftvs>
                    </inter>
                    <Empty/>
                  </eq>               
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <GEN>
                        <type/>
                        <aTS/>
                      </GEN>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Straightforward induction on the typing derivation.
      </p>
    </proof>
    <lemma id="T-VSubstitution">
      <title>Value Substitution</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <aTS/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", "/>            
          <pred name="Immut">
            <aTS/>
          </pred>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aVal/>
              <type num="v"/>
            </tqExpr>
          </Sjudge>
          <text content=", and "/>
          <Sjudge name="gen">
            <assume>
              <gamma/>
              <store/>
              <aExpr/>
            </assume>
            <GEN>
              <type num="v"/>
              <aTS/>
            </GEN>
          </Sjudge>
          <text content=" then "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <subst>
                <aExpr/>
                <id/>
                <aVal/>
              </subst>
              <type/>
            </tqExpr>
          </Sjudge>            
        </btypes:TYPE>          
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation of
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <aTS/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>.
        We proceed by case analysis on the final step of the
        derivation. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Id: We have 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <id name="y"/>
              </eq>
              <text content=" where "/>
              <in>
                <id name="y"/>
                <extend>
                  <gamma/>
                  <id/>
                  <aTS/>
                </extend>
              </in>
            </btypes:TYPE>.
          </p>
          <p>
            There are two sub cases to consider. If 
            <btypes:TYPE>
              <eq>
                <id name="x"/>
                <id name="y"/>
              </eq>
            </btypes:TYPE>,
            then, 
            <btypes:TYPE>
              <eq>
                <subst>
                  <id name="y"/>
                  <id name="x"/>
                  <aVal/>
                </subst>
                <aVal/>                
              </eq>
            </btypes:TYPE>,
            and the result type 
            <btypes:TYPE>
              <type/>
            </btypes:TYPE> is an instantiation of the type scheme 
            <btypes:TYPE>
              <aTS/>
            </btypes:TYPE>.
            One of the assumptions of the lemma states that
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aVal/>
                  <GEN>
                    <type num="v"/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>. That is, 
            <btypes:TYPE>
              <spEq>
                <type/>
                <aTS/>
              </spEq>
            </btypes:TYPE>, and we can infer any more-specific type
            (and in particular the type being instantiated at the
            T-Id rule) instead for this substitution of the
            expression    
            <btypes:TYPE>
              <aVal/>
            </btypes:TYPE>.
            Therefore, we have
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <aExpr/>
                    <id/>
                    <aVal/>
                  </subst>
                  <type/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.
          </p>
          <p>
            If 
            <btypes:TYPE>
              <neq>
                <id name="x"/>
                <id name="y"/>
              </neq>
            </btypes:TYPE>, then 
            <btypes:TYPE>
              <eq>
                <subst>
                  <id name="y"/>
                  <id name="x"/>
                  <aVal/>
                </subst>
                <id name="y"/>
              </eq>
            </btypes:TYPE>,
            and the result is immediate.
          </p>
        </li>
        <li>
          <p>
            Case T-Lambda: We have 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <lambda>
                  <id name="y"/>
                  <aExpr dash="'"/>
                </lambda>
              </eq>
              <text content=", and "/>
              <eq>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </eq>
              
              <text content=", and "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id/>
                      <aTS/>
                    </tqExpr>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr dash="'"/>
                  <type num="2"/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.              
          </p>
          <p>
            We can assume that
            <btypes:TYPE>
              <neq>
                <id/>
                <id name="y"/>
              </neq>
            </btypes:TYPE>.
            Since it is clear that the type
            <btypes:TYPE>
              <type num="1"/>
            </btypes:TYPE>
            of 
            <btypes:TYPE>
              <id name="y"/>
            </btypes:TYPE>
            can either use variables already in               
            <btypes:TYPE>
              <gamma/>
            </btypes:TYPE>
            or fresh type variables, we know that 
            <btypes:TYPE>
              <eq>
                <inter>
                  <ftvs>
                    <extend>
                      <gamma/>
                      <tqExpr>
                        <id name="y"/>
                        <type num="1"/>
                      </tqExpr>
                    </extend>
                  </ftvs>
                  <ftvs>
                    <aTS/>
                  </ftvs>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
            Thus, by weakening lemma, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <aVal/>
                  <GEN>
                    <type num="v"/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>
            , and, by induction hypothesis, 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <aExpr dash="'"/>
                    <id/>
                    <aVal/>
                  </subst>
                  <type num="2"/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.
            Finally, by the T-Lambda rule, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <lambda>
                    <id num="y"/>
                    <paren>
                      <subst>
                        <aExpr dash="'"/>
                        <id/>                      
                        <aVal/>
                      </subst>
                    </paren>
                  </lambda>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>, and thus
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <lambda>
                      <id num="y"/>
                      <aExpr dash="'"/>
                    </lambda>                    
                    <id/>                      
                    <aVal/>                  
                  </subst>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>, which is the desired result.
          </p>
        </li>
        <li>
          <p>
            T-Set case is similar, except that the substitution
            cannot happen on the LHS of an assignment, since we do
            not perform substitution of mutable values. 
          </p>
        </li>
        <li>
          <p>
            Other cases are similar.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="T-LSubstitution">
      <title>Location Substitution</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <type num="0"/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", and for some "/>
          <supeq>
            <store dash="'"/>
            <store/>
          </supeq>
          <text content=", "/>
          <tqExpr>
            <mapsto>
              <store/>
              <sLoc/>
              <type num="0"/>
            </mapsto>
          </tqExpr>
          <text content=", then "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store dash="'"/>
            </assume>
            <tqExpr>
              <subst>
                <aExpr/>
                <id/>
                <sLoc/>
              </subst>
              <type/>
            </tqExpr>
          </Sjudge>            
        </btypes:TYPE>.          
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation of
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <type/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, similar to lemma <xref
          ref="T-VSubstitution"/>.
      </p>
    </proof>
    <lemma id="T-sh-safety">
      <title>Stack and Heap Assignment</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <extend>
                    <heap/>
                    <mapping>
                      <hLoc/>
                      <aVal/>
                    </mapping>
                  </extend>
                  <stack/>
                </plus>
              </Sjudge>
              <text content=", and "/>
              <Tsub>
                <mapsto>
                  <store/>
                  <hLoc/>
                </mapsto>
                <type/>
              </Tsub>
              <text content=", and "/>
              <TDjudge>
                <aVal dash="'"/>
                <type/>
              </TDjudge>
              <text content=", then, "/>               
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <extend>
                    <heap/>
                    <mapping>
                      <hLoc/>
                      <aVal dash="'"/>
                    </mapping>
                  </extend>
                  <stack/>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="Similarly, if "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <extend>
                    <stack/>
                    <mapping>
                      <sLoc/>
                      <aVal/>
                    </mapping>
                  </extend>
                </plus>
              </Sjudge>
              <text content=" and  "/>
              <Tsub>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
                <type/>
              </Tsub>
              <text content=", and "/>
              <TDjudge>
                <aVal dash="'"/>
                <type/>
              </TDjudge>
              <text content=", then, "/>                 
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <extend>
                    <stack/>
                    <mapping>
                      <sLoc/>
                      <aVal dash="'"/>
                    </mapping>
                  </extend>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Immediate from the definition of stack and heap typing.
      </p>
    </proof>
    <lemma id="T-preservation">
      <title>Preservation</title>
      <p>
        <btypes:TYPE>          
          <text content="If "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=" then, "/>    
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <leval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </leval>
              <text content=", then, there exists a "/>
              <supeq>
                <store dash="'"/>
                <store/>
              </supeq>
              <text content=" such that "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <tqExpr>
                  <aExpr dash="'"/>
                  <type/>
                </tqExpr>                    
              </Sjudge>
              <text content=" and "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <plus>
                  <heap dash="'"/>
                  <stack dash="'"/>
                </plus>
              </Sjudge>
              <text content="."/>
            </btypes:TYPE>              
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>          
              <text content="If "/>
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
              <text content=", there exists a "/>
              <supeq>
                <store dash="'"/>
                <store/>
              </supeq>                
              <text content=" such that "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <Tsub>
                  <aExpr dash="'"/>
                  <type dash="'"/>
                </Tsub>                    
              </Sjudge>
              <text content=",  "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <plus>
                  <heap dash="'"/>
                  <stack dash="'"/>
                </plus>
              </Sjudge>
              <text content=" and "/>
              <eq>
                <minz>
                  <type/>
                </minz>
                <minz>
                  <type dash="'"/>
                </minz>
              </eq>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>. We proceed by the case analysis of the final
        step. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot
            happen. 
          </p>
        </li>
        <li>
          <p>
            Case T-Sloc: Only right execution is applicable. 
            We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <sLoc/>
              </eq>
              <text content=" and "/>
              <tqExpr>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
                <type/>
              </tqExpr>
            </btypes:TYPE>.
            The only applicable step is E-Rval, and we have
            <btypes:TYPE>
              <eq>
                <aExpr dash="'"/>
                <mapsto>
                  <stack/>
                  <sLoc/>
                </mapsto>
              </eq>
            </btypes:TYPE>.
            From the definition of stack typing, we have:
            <btypes:TYPE>
              <Tsub>
                <mapsto>
                  <stack/>
                  <sLoc/>
                </mapsto>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
              </Tsub>
            </btypes:TYPE>              
            and thus 
            <btypes:TYPE>
              <Tsub>
                <aExpr dash="'"/>
                <type/>
              </Tsub>
            </btypes:TYPE>              
            which implies
            <btypes:TYPE>              
              <eq>
                <minz>
                  <type/>
                </minz>
                <minz>
                  <type dash="'"/>
                </minz>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Case T-App:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <apply>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </apply>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <fn>
                  <type num="2"/>
                  <type num="0"/>
                </fn>
              </TDjudge>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type num="2"/>
              </TDjudge>
              <text content=", and "/>
              <Tsub>
                <type num="0"/>
                <type/>
              </Tsub>
              <text content=", and "/>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
              <text content = " where "/>
              <eq>
                <type num="2"/>
                <minz>
                  <type num="2" dash="'"/>
                </minz>
              </eq>                
              <eq>
                <type num="0"/>
                <maxz>
                  <type num="0" dash="'"/>
                </maxz>
              </eq>
              <text content=" and "/>
            </btypes:TYPE>.
          </p>
          <p>              
            This cannot happen for left execution. 
            For right execution, we proceed by further case
            analysis of the applicable execution rules for
            <btypes:TYPE>
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
            </btypes:TYPE>.
          </p>
          <ol>
            <li>
              <p>
                Case E-App1#:
                We have:
                <btypes:TYPE>
                  <eval>
                    <opState>
                      <stack/>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                  <text content=" and "/>
                  <eq>
                    <aExpr dash="'"/>
                    <apply>
                      <aExpr num="1" dash="'"/>
                      <aExpr num="2"/>
                    </apply>
                  </eq>
                </btypes:TYPE>.
                By induction hypothesis, we have:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <Tsub>
                      <aExpr num="1" dash="'"/>
                      <fn>
                        <type num="2"/>
                        <type num="0"/>
                      </fn>     
                    </Tsub>                 
                  </Sjudge>                    
                  <text content=" for some "/>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                </btypes:TYPE>.
                One of the assumptions of the T-App rule states that 
                <btypes:TYPE>                    
                  <TDjudge sub="yes">
                    <aExpr num="2"/>
                    <type num="2"/>
                  </TDjudge>
                </btypes:TYPE>, and by weakening lemma, we have, 
                <btypes:TYPE>                    
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <Tsub>
                      <aExpr num="2"/>
                      <type num="2"/>
                    </Tsub>
                  </Sjudge>
                </btypes:TYPE>. Finally, by the T-App rule, we
                conclude that
                <btypes:TYPE>                    
                  <tqExpr>
                    <paren>
                      <apply>
                        <aExpr num="1" dash="'"/>                        
                        <aExpr num="2"/>
                      </apply>
                    </paren>
                    <type/>
                  </tqExpr>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                Case E-App2#: Similar to the previous
                sub-case. 
              </p>
            </li>
            <li>
              <p>
                Case E-App: We have:
                <btypes:TYPE>
                  <eq>
                    <aExpr num="1"/>
                    <lambda>
                      <id/>
                      <aExpr num="0"/>
                    </lambda>
                  </eq>
                  <text content=" and "/>
                  <eq>
                    <aExpr num="2"/>
                    <aVal/>
                  </eq>
                  <text content=" and "/>
                  <text content=" and "/>
                  <eq>
                    <aExpr dash="'"/>
                    <subst>
                      <aExpr num="0"/>
                      <id/>
                      <sLoc/>
                    </subst>
                  </eq>
                  <text content=" and "/>
                  <eval>
                    <opState>
                      <extend>
                        <stack/>
                        <mapping>
                          <sLoc/>
                          <aVal/>
                        </mapping>
                      </extend>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                </btypes:TYPE>.
              </p>
              <p>
                By the inversion lemma for 
                <btypes:TYPE>
                  <lambda>
                    <id/>
                    <aExpr num="0"/>
                  </lambda>
                </btypes:TYPE> we have
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <gamma>
                          <id/>
                          <type num="2" dash="'"/>
                        </gamma>
                        <store/>
                      </extend>
                    </assume>
                    <tqExpr>
                      <aExpr num="0"/>
                      <type num="0" dash="'"/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
              <p>
                Further from location substitution lemma, we have 
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <subst>
                        <aExpr num="0"/>
                        <id/>
                        <sLoc/>
                      </subst>
                      <type num="0" dash="'"/>
                    </tqExpr>
                  </Sjudge>
                  <text content=" where "/>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" and "/>
                  <tqExpr>
                    <mapsto>
                      <store/>
                      <sLoc/>
                    </mapsto>
                    <type num="2" dash="'"/>
                  </tqExpr>
                </btypes:TYPE>.
              </p>
              <p>
                Thus, we have 
                <btypes:TYPE>
                  <Tsub>
                    <type num="0"/>
                    <type num="0" dash="'"/>
                  </Tsub>
                  <text content=" and "/>
                  <Tsub>
                    <type num="0"/>
                    <type/>
                  </Tsub>
                </btypes:TYPE>.
                Therefore, it is clear that
                <btypes:TYPE>
                  <eq>
                    <minz>
                      <type num="0" dash="'"/>
                    </minz>
                    <minz>
                      <type/>
                    </minz>
                  </eq>
                </btypes:TYPE>.                  
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Case T-Set:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <assign>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </assign>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <mutable>
                  <type/>
                </mutable>
              </TDjudge>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type/>
              </TDjudge>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>                
            </btypes:TYPE>
          </p>
          <p>
            If the step taken is E-:=#lhs or E-:=#rhs,
            the result follows from the induction hypothesis and
            T-Set rule (as in the case of T-App).               
            If the step taken is E-:=Stack or E-:=Heap, the
            result follows from the stack and heap assignment lemma.
          </p>
        </li>
        <li>
          <p>
            Case T-Deref: We have: 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <deref>
                  <aExpr dash="'"/>
                </deref>
              </eq>
              <text content=" and "/>
              <TDjudge sub="yes">
                <aExpr dash="'"/>                  
                <ref>
                  <type/>
                </ref>                  
              </TDjudge>
            </btypes:TYPE>.
            If the step taken is EL-^# or E-^#,
            the result follows from induction hypothesis and T-Deref
            rule. 
            If the step taken is E-^ (right execution only) 
            <btypes:TYPE>
              <aExpr dash="'"/>                  
            </btypes:TYPE> is a value, and from canonical forms
            lemma, we know that 
            <btypes:TYPE>
              <eq>
                <aExpr dash="'"/>                  
                <hLoc/>
              </eq>
              <text content=" and "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
            </btypes:TYPE>
            and the result follows from the fact that
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Case T-Let-P: Right execution only. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="p">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=" and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>                
                <type num="1"/>                
              </TDjudge>
              <text content=" and "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=" and "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=" and "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            There are two sub-cases to consider:
          </p>
          <ol>
            <li>
              <p>
                If we take step E-Let#,                   
                <btypes:TYPE>
                  <eval>
                    <opState>
                      <stack/>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                </btypes:TYPE>
                and 
                <btypes:TYPE>
                  <eq>
                    <aExpr dash="'"/>
                    <paren>
                      <let kind="p">
                        <id/>
                        <aExpr num="1" dash="'"/>
                        <aExpr num="2"/>
                      </let>
                    </paren>
                  </eq>
                  <text content=". If "/>                    
                  <eq>
                    <aExpr/>
                    <aVal/>
                  </eq>
                </btypes:TYPE>
                It is clear that 
                <btypes:TYPE>
                  <pred name="Value">
                    <aExpr num="1"/>
                  </pred>
                </btypes:TYPE> implies
                <btypes:TYPE>
                  <pred name="Value">
                    <aExpr num="1" dash="'"/>
                  </pred>
                </btypes:TYPE>.                     
                Now, the result follows
                from the induction hypothesis and the E-Let-P rule.
              </p>
            </li>
            <li>
              <p>
                If we take the step E-Let-P, 
                <btypes:TYPE>
                  <eq>
                    <aExpr/>
                    <paren>
                      <let kind="p">
                        <id/>
                        <aVal/>
                        <aExpr num="2"/>
                      </let>
                    </paren>
                  </eq>
                </btypes:TYPE>
                Since 
                <btypes:TYPE>
                  <tqExpr>
                    <id/>
                    <aTS/>
                  </tqExpr>
                </btypes:TYPE>
                has a polymorphic type, 
                (that is,
                <btypes:TYPE>
                  <eq>
                    <aTS/>
                    <forall>
                      <tvars name="alpha"/>
                      <type name="s"/>
                    </forall>
                  </eq>
                </btypes:TYPE>)
                we know that
                <btypes:TYPE>
                  <pred name="Immut">
                    <type/>
                  </pred>
                </btypes:TYPE>.
                Also, from canonical forms lemma, all values have
                an immutable type. Therefore, 
                <btypes:TYPE>
                  <eq>
                    <type/>
                    <type num="1"/>
                  </eq>
                </btypes:TYPE>. Now, the result follows from
                value substitution lemma. 
              </p>
            </li>
          </ol>            
        </li>
        <li>
          <p>
            Case T-Let-M: Similar to T-Let-P, except that we should
            always use the GEN-EXPANSIVE rule during generalization,
            and use the location substitution lemma instead of 
            the value substitution lemma
          </p>
        </li>
        <li>
          <p>
            Cases T-If, T-Dup, T-TqExpr, and T-Let-M-Tq T-Let-P-Tq are
            similar.  
          </p>
        </li>
      </ol>
    </proof>
    <definition id="stuck_state">
      <title>Stuck State</title>
      <p>
        A system state 
        <btypes:TYPE>
          <opState>
            <stack/>
            <heap/>
            <aExpr/>
          </opState>
        </btypes:TYPE>
        is said to be <term>stuck</term> if
        <btypes:TYPE>
          <neq>
            <aExpr/>
            <aVal/>
          </neq>
        </btypes:TYPE>
        and there are no 
        <btypes:TYPE>
          <stack dash="'"/>
          <text content=", "/>
          <heap dash="'"/>
          <text content=", and "/>
          <aExpr dash="'"/>
        </btypes:TYPE>   
        such that 
        <btypes:TYPE>
          <eval>
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
          </eval>
        </btypes:TYPE>.
      </p>
    </definition>      
    <theorem id="T-soundness">
      <title>Type Soundness</title>
      <p>
        If 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <Empty/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=" and "/>
          <eval many="yes">
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
          </eval>
          <text content=" then "/>
          <opState>
            <stack dash="'"/>
            <heap dash="'"/>
            <aExpr dash="'"/>
          </opState>
          <text content=" is not stuck."/>            
        </btypes:TYPE>
        That is, execution of a well typed expression cannot lead to
        a stuck state. Here, 
        <btypes:TYPE>
          <evalOp many="yes"/>
        </btypes:TYPE > represents the 
        reflexive-transitive-closure of 
        <btypes:TYPE>
          <evalOp/>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        By straightforward induction on the length of   
        <btypes:TYPE>
          <evalOp many="yes"/>
        </btypes:TYPE>. If 
        <btypes:TYPE>
          <eq>
            <aExpr/>
            <aVal/>
          </eq>
        </btypes:TYPE>, proof is immediate. Otherwise, from 
        Lemma&nbsp;<xref ref="T-progress"/> (Progress),
        we know that we can take at least one step forward. Further,
        from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation),
        we know that a (left/right) execution of a well
        typed expression in with respect to a well typed stack and heap
        will always result in another well typed expression, stack
        and heap. Proof now follows from induction hypothesis.  
      </p>
    </proof>
  </sect1>
  <sect1 id="eq-infer">
    <title>Equational Type Inference</title> 
    <xi:include href="include/formal/eq-infer.xmli"/>
    <xi:include href="include/formal/eq-unify.xmli"/>
    <xi:include href="include/formal/eq-helper.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><type/><type/></fn>                  
          </alternatives>
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><type/></ref>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Constr. Type">
          <aCtype/>
          <alternatives>
            <type/>
            <ctype>
              <type/>
              <aCtset/>
            </ctype>
          </alternatives>
        </bnf>
        <bnf desc="Type Scheme">          
          <aTS/>
          <alternatives>
            <aCtype/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
        <bnf desc="Constraints">
          <constraint/>
          <alternatives>
            <eq>
              <type/>
              <type/>
            </eq>
            <ceq>
              <type/>
              <type/> 
            </ceq>
            <Tsub>
              <type/>
              <type/> 
            </Tsub>
            <Pcst>
              <lKind/>
              <type/>
              <type/>
            </Pcst>
          </alternatives>
        </bnf>
        <bnf desc="Constraint Sets">
          <aCtset/>
          <alternatives>
            <Empty/>
            <set>
              <plural>
                <constraint/>
              </plural>
            </set>
            <unin>
              <aCtset/>
              <aCtset/>
            </unin>
          </alternatives>            
        </bnf>
        <bnf desc="Substitutions">            
          <aSubMap/>            
          <alternatives>
            <EmptySubst/>
            <SubMap>
              <tvar name="alpha"/>
              <type/>
            </SubMap>
            <SubMap>
              <lKind k="var"/>
              <lKind/>
            </SubMap>
            <compose>
              <aSubMap/>
              <aSubMap/>
            </compose>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      The application of a substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> on X is written as
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <text content="X"/>
	</Subst>
      </btypes:TYPE>. 
      As a matter of notational convenience, we write:
      <btypes:TYPE>
        <aSubMap num="a.b"/> 
      </btypes:TYPE> to mean
      <btypes:TYPE>
        <compose>
          <aSubMap num="a"/> 
          <aSubMap num="b"/> 
        </compose>
      </btypes:TYPE>. Note that
      <btypes:TYPE>
        <eq>
          <Subst>
            <aSubMap num="a.b"/> 
            <text content="x"/>
          </Subst>
          <Subst>
            <compose>
              <aSubMap num="a"/> 
              <aSubMap num="b"/> 
            </compose>
            <text content="x"/>
          </Subst>
          <Subst>
            <aSubMap num="a"/> 
            <Subst>
              <aSubMap num="b"/>                 
              <text content="x"/>
            </Subst>
          </Subst>
          <Subst>
            <aSubMap num="b"/>                 
            <Subst>
              <aSubMap num="a"/> 
              <text content="x"/>
            </Subst>
          </Subst>
        </eq>
      </btypes:TYPE>.        
    </p>
    <definition id="meta">      
      <title>Meta Constructors</title>      
      <p>
        <btypes:TYPE>
          <floor>
            <type/>
          </floor>
        </btypes:TYPE>
        and 
        <btypes:TYPE>
          <ceil>
            <type/>
          </ceil>
        </btypes:TYPE>
        are "meta-constructors" which (respectively) minimize and
        maximize the mutability of a type, but are interpreted
        lazily. The meta-constructors are idempotent. 
      </p>
    </definition>
    Note that in our type system, we have restricted meta types to be
    syntactically present only as part of function types.
    <definition id="pcst">      
      <title>Meta Polymorphic Constraints</title>      
      <p>
        The constraint 
        <btypes:TYPE>
          <Pcst>
            <lKind/>
            <type/>
            <type dash="'"/>
          </Pcst>
        </btypes:TYPE> is used to express types that are polymorphic
        <em>over</em> polymorphism and mutability. 
        The type 
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE> can only be a specialization of 
        <btypes:TYPE>
          <type/>
        </btypes:TYPE>, obtained through some substitution.        
        A Substitution over the polymorphic constraint is defined as:
        <btypes:TYPE>
          <eq>
            <Subst>
              <aSubMap/>
              <Pcst>
                <lKind/>
                <type/>
                <type dash="'"/>
              </Pcst>
            </Subst>
            <Pcst>
              <Subst>
                <aSubMap/>                
                <lKind/>
              </Subst>
              <type/>              
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </Pcst>
          </eq>
        </btypes:TYPE>.
        A substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE> satisfies the set of constraints
        <btypes:TYPE>
          <set>
            <Pcst>
              <lKind k="var"/>
              <type/>
              <type num="1"/>
            </Pcst>
            <unspecified/>
            <Pcst>
              <lKind k="var"/>
              <type/>
              <type num="n"/>
            </Pcst>
          </set>
        </btypes:TYPE> if and only if:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <lKind k="var"/>
                </Subst>
                <lKind k="mono"/>
              </eq>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <type num="1"/>
                </Subst>
                <unspecified/>
                <Subst>
                  <aSubMap/>
                  <type num="n"/>
                </Subst>
              </eq>
            </btypes:TYPE>, or
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <lKind k="var"/>
                </Subst>
                <lKind k="poly"/>
              </eq>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <collection>
                <pred name="Immut">
                  <Subst>
                    <aSubMap/>
                    <type num="1"/>
                  </Subst>
                </pred>
                <unspecified/>
                <pred name="Immut">
                  <Subst>
                    <aSubMap/>
                    <type num="n"/>
                  </Subst>
                </pred>
              </collection>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <definition id="define_infer">
      <title>Type Inference</title> 
      <p>
        Type inference is a program
        transformation that accepts a program in which
        <progident>let</progident> expressions are not annotated
        with their kinds, and returns the same programs in which
        <progident>let</progident> expressions are annotated with
        their kinds and all expressions are annotated with their
        types.
      </p>
    </definition>
    <p>
      The equational type inference algorithm is as shown in
      Figure&nbsp;<xref ref="eq_infer"/>. 
      The inference judgment 
      <btypes:TYPE>
	<TEjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
          <constrain>
            <aCtset/>
          </constrain>
	</TEjudge>
      </btypes:TYPE>
      should be understood as: given the binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
      <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
      <btypes:TYPE><type/></btypes:TYPE> for the expression 
      <btypes:TYPE><aExpr/></btypes:TYPE> under the constraints
      <btypes:TYPE><aCtset/></btypes:TYPE>. 
      The Unification algorithm is given in 
      figure&nbsp;<xref ref="eq_unify"/> with some auxiliary
      definitions and translations defined in 
      figure&nbsp;<xref ref="eq_helper"/>. 
      The unification algorithm takes in a set of constraints
      <btypes:TYPE><aCtset/></btypes:TYPE> and either fails with an
      error <btypes:TYPE><error/></btypes:TYPE>, or succeeds to 
      result in a pair consisting of residual constraints
      <btypes:TYPE><aCtset/></btypes:TYPE> 
      (which should only contain constraints of the form:
      <btypes:TYPE>
        <!-- a <= t  -->
        <Tsub>
          <tvar name="alpha"/>
          <type/>
        </Tsub>
        <text content=","/>
        <space/>
        <!-- t <= a  -->
        <Tsub>
          <type/>
          <tvar name="alpha"/>
        </Tsub>
        <text content=", "/>
        <space/>
        <!-- however, both of the cases a <= t and t <= a
        cannot occur since it can be reduced -->
        <!-- P(k, t1, t2)  -->
        <Pcst>
          <lKind k="var"/>
          <type/>
          <type dash="'"/>
        </Pcst>
        <text content=", and"/>
        <space/>
        <Pcst>
          <lKind k="poly"/>
          <type num="g"/>
          <type num="i"/>
        </Pcst>
        <text content=", where"/>
        <space/>
        <pred name="Immut">
          <type num="i"/>
        </pred>
        <text content=", and"/>
        <space/>
        <neq>
          <pred name="dtv">
            <type num="i"/>
          </pred>
          <Empty/>
        </neq>
        <text content="."/>            
      </btypes:TYPE>)
      and a list of
      substitutions <btypes:TYPE><aSubMap/></btypes:TYPE> for the
      constraints solved in this pass.
    </p>
    <definition id="stvs-eq">
      <title>Shallow Type Variables</title>
      <p>
        The set of type variables embedded in a type up to a 
        reference/function boundary. 
      </p>
      <p>
        <btypes:TYPE>
          <fnxn name="stv">
            <tvar name="alpha"/>
            <set>
              <tvar name="alpha"/>
            </set>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <unit/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <bool/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <fn>
              <type/>
              <type dash="'"/>
            </fn>
            <Empty/>
          </fnxn>          
          <br/>
          <fnxn name="stv">
            <ref>
              <type/>
            </ref>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <mutable>
              <type/>
            </mutable>
            <pred name="stv">
              <type/>
            </pred>
          </fnxn>
          <br/>
        </btypes:TYPE>
      </p>
    </definition>    
    <definition id="dtvs-eq">
      <title>Deep Type Variables</title>
      <p>
        The set of type variables embedded in a type up to a 
        function boundary. 
      </p>
      <p>        
        <btypes:TYPE>
          <fnxn name="dtv">
            <tvar name="alpha"/>
            <set>
              <tvar name="alpha"/>
            </set>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <unit/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <bool/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <fn>
              <type/>
              <type dash="'"/>
            </fn>
            <Empty/>
          </fnxn>          
          <br/>
          <fnxn name="dtv">
            <mutable>
              <type/>
            </mutable>
            <pred name="dtv">
              <type/>
            </pred>		
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <ref>
              <type/>
            </ref>
            <pred name="dtv">
              <type/>
            </pred>		
          </fnxn>
        </btypes:TYPE>
      </p>
    </definition>    
    <theorem id="eq-unify-correct">
      <title>Correctness of Unification</title>
      <p>
        If:
        <btypes:TYPE>
          <eq>
            <unf>
              <aCtset/>
            </unf>
            <Pair>
              <aCtset dash="'"/>
              <aSubMap/>
            </Pair>
          </eq>
          <text content=", then"/>
          <Exists>
            <aSubMap num="s"/>
          </Exists>          
          <text content=" such that "/>
          <models name="sat"> 
            <assume>
              <aSubMap num="s"/>
            </assume>
            <aCtset dash="'"/>
          </models>
        </btypes:TYPE>
      </p>
    </theorem>
    <theorem id="eq-unify-decidable">
      <title>Decidability of Unification</title>
      <p>
        The unification algorithm
        <btypes:TYPE>
          <unf>
            <aCtset/>
          </unf>
          <text content=" computes to some "/>
          <Pair>
            <aCtset dash="'"/>
            <aSubMap/>
          </Pair>
          <text content=" or fails with "/>
          <error/>
          <text content=" decidably in a finite number of steps."/>
        </btypes:TYPE>
      </p>
    </theorem>
    <theorem id="eq-infer-sound">
      <title>Soundness of Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TEjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <constrain>
              <aCtset/>
            </constrain>
          </TEjudge>
          <text content=" and "/>
          <eq>
            <unf>
              <aCtset/>
            </unf>
            <Pair>
              <aCtset num="u"/>
              <aSubMap num="u"/>
            </Pair>
          </eq>
          <text content=", then "/>
          <Forall>
            <aSubMap num="s"/>
          </Forall>
          <text content=" such that "/>
          <models name="sat"> 
            <assume>
              <aSubMap num="s"/>
            </assume>
            <aCtset num="u"/>
          </models>
          <text content=", "/>  
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>                
                  <aExpr/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>                                  
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	                
        </btypes:TYPE>.
      </p>
    </theorem>
    <theorem id="eq-infer-complete">
      <title>Completeness of Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>	                          
          <text content=" then "/>
          <Exists>
            <aSubMap/>
          </Exists>
          <text content=" such that "/>
          <TEjudge>
            <assume>
              <gamma dash="'"/>
              <store dash="'"/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type dash="'"/>
              </tqExpr>
            </conclude>
            <constrain>
              <aCtset/>
            </constrain>
          </TEjudge>
          <text content=", "/>
          <models name="sat"> 
            <assume>
              <aSubMap/>
            </assume>
            <aCtset/>
          </models>
          <text content=", "/>
          <eq>
            <gamma/>
            <canonical>
              <Subst>
                <aSubMap/>
                <gamma dash="'"/>
              </Subst>
            </canonical>
          </eq>
          <text content=", "/>
          <eq>
            <store/>
            <canonical>
              <Subst>
                <aSubMap/>
                <store dash="'"/>
              </Subst>
            </canonical>
          </eq>
          <text content=" and "/>
          <eq>
            <type/>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </eq>
        </btypes:TYPE>.
      </p>
    </theorem>
  </sect1>
  <sect1 id="infer">
    <title>Heuristic Type Inference</title> 
    <xi:include href="include/formal/hm-infer.xmli"/>
    <xi:include href="include/formal/hm-unify.xmli"/>
    <xi:include href="include/formal/hm-solve.xmli"/>
    <xi:include href="include/formal/hm-inter.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><type/><type/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><type/></ref>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnfc desc="Maybe Type">
          <alternatives>
            <mbpair>
              <type/>
              <type dash="'"/>
            </mbpair>              
          </alternatives>
        </bnfc>
        <bnf desc="Unct. Types">
          <sType/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><sType/><sType/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><sType/></ref>
            <mutable><sType/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Type Scheme">
          <aTS/>
          <alternatives>
            <type/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <definition>
      <title>Constraint Set Closure</title>
      <p>
        A closure operation
        <btypes:TYPE>
          <pred name="close">
            <aCtset/> 
          </pred>
        </btypes:TYPE>
        on a constraint set 
        <btypes:TYPE>
          <aCtset/> 
        </btypes:TYPE> produces an equivalent set
        of atomic constraints by using the copy coercion rules defined
        in Figure&nbsp;<xref ref="decl_rules"/> (note that this
        conversion is total); and by explicitely adding all transitive
        relationships.
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <fn>
                        <type num="1"/>
                        <type num="2"/>
                      </fn>
                      <fn>
                        <type num="1" dash="'"/>
                        <type num="2" dash="'"/>
                      </fn>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type num="1"/>
                        <type num="1" dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type num="2"/>
                        <type num="2" dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type num="1" dash="'"/>
                        <type num="1"/>
                      </Tsub>
                      <Tsub>
                        <type num="2" dash="'"/>
                        <type num="2"/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <ref>
                        <type/>
                      </ref>
                      <ref>
                        <type dash="'"/>
                      </ref>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type/>
                        <type dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type dash="'"/>
                        <type/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <mutable>
                        <type/>
                      </mutable>
                      <mutable>
                        <type dash="'"/>
                      </mutable>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type/>
                        <type dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type dash="'"/>
                        <type/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <grouping>
                  <pred name="close">
                    <unin>
                      <set>
                        <Tsub>
                          <type num="1"/>
                          <type num="2"/>
                        </Tsub>
                        <Tsub>
                          <type num="2"/>
                          <type num="3"/>
                        </Tsub>
                      </set>
                      <aCtset/>
                    </unin>
                  </pred>
                  <space/>
                  <textit content="where"/>
                  <space/>
                  <notin>
                    <Tsub>
                      <type num="1"/>
                      <type num="3"/>
                    </Tsub>
                    <aCtset/>
                  </notin>
                  <br/>
                </grouping>
                <pred name="close">
                  <unin>
                    <set>
                      <Tsub>
                        <type num="1"/>
                        <type num="2"/>
                      </Tsub>
                      <Tsub>
                        <type num="2"/>
                        <type num="3"/>
                      </Tsub>
                      <Tsub>
                        <type num="1"/>
                        <type num="3"/>
                      </Tsub>
                    </set>                      
                    <aCtset/>
                  </unin>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <grouping>
                  <pred name="close">
                    <aCtset/>
                  </pred>
                  <space/>
                  <textit content="where none of the above cases "/>
                  <textit content="are applicable"/>
                  <space/>
                </grouping>
                <aCtset/>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <definition>
      <title>Normalization of Constraint Sets</title>
      <p>
        The normalization function
        <btypes:TYPE>
          <normalize>
            <aCtset/>
          </normalize>
        </btypes:TYPE> is used to obtain a normalized form of a
        constraint set 
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE> by re-writing it only in terms of closed
        subtype constraints.
      </p>
      <p>
        <btypes:TYPE>
          <eq>              
            <normalize>
              <aCtset/>
            </normalize>
            <pred name="close">
              <aCtset dash="'"/>
            </pred>
          </eq>
        </btypes:TYPE>
        where
        <btypes:TYPE>
          <aCtset dash="'"/>
        </btypes:TYPE>
        is obtained from
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE> using the normalizing translations:
      </p>
      <ul>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <eq>
                    <type num="1"/>
                    <type num="2"/>
                  </eq>
                </DBrac>
                <DBrac>
                  <collection>
                    <Tsub>
                      <type num="1"/>
                      <type num="2"/>
                    </Tsub>
                    <Tsub>
                      <type num="2"/>
                      <type num="1"/>
                    </Tsub>	      
                  </collection>
                </DBrac>
              </leadsto>	
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <ceq>
                    <type num="1"/>
                    <type num="2"/>
                  </ceq>
                </DBrac>
                <DBrac>
                  <collection>
                    <Tsub>
                      <type num="1"/>
                      <tvar name="alpha"/>
                    </Tsub>	      
                    <Tsub>
                      <type num="2"/>
                      <tvar name="alpha"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>,
            where
            <btypes:TYPE>
              <models name="new">
                <assume/>
                <tvar name="alpha"/>
              </models>
            </btypes:TYPE>.            
          </p>
        </li>
      </ul>
    </definition>
    <definition id="sat">
      <title>Constraint Satisfiability</title>
      <p>
        A Substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>
        satisfies a constraint set
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE>, written
        <btypes:TYPE>
          <models name="sat">
            <aSubMap/>
            <aCtset/>
          </models>
        </btypes:TYPE>
        iff
        <btypes:TYPE>
          <normalize>
            <aCtset/>
          </normalize>
        </btypes:TYPE>
        consists only of tautologies (trivially).
      </p>
    </definition>    
    <definition id="ext-ftvs">
      <title>FTVs (Extension)</title>
      <p>
        We need to enhance the definition of FTV as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <unspecified/>
            <br/>
            <eq>
              <ftvs>
                <mbpair>
                  <type num="1"/>
                  <type num="2"/>
                </mbpair>
              </ftvs>
              <unin>
                <ftvs>
                  <type num="1"/>
                </ftvs>
                <ftvs>
                  <inner>
                    <type num="2"/>
                  </inner>
                </ftvs>
              </unin>
            </eq>
            <br/>
            <eq>
              <ftvs>
                <solvables/>
              </ftvs>
              <Unin>
                <ftvs>
                  <solvable/>
                </ftvs>
              </Unin>
            </eq>
          </btypes:TYPE>.
        </p>
      </example>
    </definition>
    <definition id="MTVs">
      <title>MTVs</title>
      <p>
        The function 
        <btypes:TYPE>
          <fnxn name="mtv">
            <solvable/>
            <tvars name="alpha"/>
          </fnxn>
        </btypes:TYPE> is defined to be the set of all type variables
        within the solvable entity 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>. That is, it returns the set of all
        type-variables 
        <btypes:TYPE>
          <tvars name="alpha"/>
        </btypes:TYPE> where  
        <btypes:TYPE>
          <tvar name="alpha"/>
        </btypes:TYPE> occurs within a maybe type as 
        <btypes:TYPE>
          <mbpair>
            <tvar name="alpha"/>
            <type num="h"/>
          </mbpair>            
        </btypes:TYPE>.
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="mtv">
              <tvar name="alpha"/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <unit/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <bool/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <mbpair>
                <tvar name="alpha"/>
                <type num="h"/>
              </mbpair>                            
              <unin>
                <tvar name="alpha"/>
                <pred name="mtv">
                  <type num="h"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <mbpair>
                <type/>
                <type num="h"/>
              </mbpair>                            
              <pred name="mtv">
                <type/>
              </pred>
            </fnxn>
            <text content=" where "/>
            <neq>
              <type/>
              <tvar name="alpha"/>
            </neq>
            <br/>
            <fnxn name="mtv">
              <ref>
                <type/>
              </ref>                            
              <pred name="mtv">
                <type/>
              </pred>
            </fnxn>              
            <br/>
            <fnxn name="mtv">
              <mutable>
                <type/>
              </mutable>                            
              <pred name="mtv">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>                            
              <unin>
                <pred name="mtv">
                  <type num="1"/>
                </pred>
                <pred name="mtv">
                  <type num="2"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <gamma/>
              <grouping>
                <Unin>
                  <pred name="mtv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <id num="i"/>
                      <type num="i"/>
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <store/>
              <grouping>
                <Unin>
                  <pred name="mtv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <loc num="i"/>
                      <type num="i"/>
                    </mapping>
                    <store/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <aExpr/>
              <grouping>
                <Unin>
                  <pred name="mtv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <type num="i"/>
                    <aExpr/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="mtv">
              <solvables/>
              <Unin>
                <pred name="mtv">
                  <solvable/>
                </pred>
              </Unin>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>              
    </definition>
    <definition id="NTVs">
      <title>NTVs</title>
      <p>
        The set of unconstrained variables is defined as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="ntv">
              <tvar name="alpha"/>
              <set>
                <tvar name="alpha"/>
              </set>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <unit/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <bool/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <mbpair>
                <tvar name="alpha"/>
                <type num="h"/>
              </mbpair>                            
              <pred name="ntv">
                <type num="h"/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <mbpair>
                <type/>
                <type num="h"/>
              </mbpair>                            
              <pred name="ntv">
                <type/>
              </pred>
            </fnxn>
            <text content=" where "/>
            <neq>
              <type/>
              <tvar name="alpha"/>
            </neq>
            <br/>
            <fnxn name="ntv">
              <ref>
                <type/>
              </ref>                            
              <pred name="ntv">
                <type/>
              </pred>
            </fnxn>              
            <br/>
            <fnxn name="ntv">
              <mutable>
                <type/>
              </mutable>                            
              <pred name="ntv">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>                            
              <unin>
                <pred name="ntv">
                  <type num="1"/>
                </pred>
                <pred name="ntv">
                  <type num="2"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <gamma/>
              <grouping>
                <Unin>
                  <pred name="ntv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <id num="i"/>
                      <type num="i"/>
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <store/>
              <grouping>
                <Unin>
                  <pred name="ntv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <loc num="i"/>
                      <type num="i"/>
                    </mapping>
                    <store/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <aExpr/>
              <grouping>
                <Unin>
                  <pred name="ntv">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <type num="i"/>
                    <aExpr/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="ntv">
              <solvables/>
              <Unin>
                <pred name="ntv">
                  <solvable/>
                </pred>
              </Unin>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>              
    </definition>
    <definition id="TVs">
      <title>TVs</title>
      <p>
        The set of all type variables in a solvable entity is given
        by TV() function, defined as follows:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="tv">
              <solvable/>
              <unin>
                <pred name="mtv">
                  <solvable/>
                </pred>
                <pred name="ntv">
                  <solvable/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="tv">
              <solvables/>
              <Unin>
                <pred name="tv">
                  <solvable/>
                </pred>
              </Unin>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <p>
      Note that this
      function is different from FTV(), defined in 
      Definition&nbsp;<xref ref="ext-ftvs"/>. 
    </p>
    <definition id="ca">
      <title>Consistency and Acyclicity</title> 
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Exists>
                  <aSubMap/>
                </Exists>
                <text content=" such that "/>
                <models name="sat">
                  <aSubMap/>
                  <aCtset/>
                </models>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="cst">
                <assume/>
                <aCtset/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <SubMap>
                  <tvar name="alpha"/>
                  <type/>
                </SubMap>
                <text content=" and "/>
                <SubMap>
                  <tvar name="beta"/>
                  <type dash="'"/>
                </SubMap>
                <text content=" in "/>
                <aSubMap/>
                <text content=", "/>
                <eq>
                  <tvar name="alpha"/>
                  <tvar name="beta"/>
                </eq>
                <text content=" implies "/>
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>          
              </grouping>
            </tyPre>
            <tyConc>
              <models name="cst">
                <assume/>
                <aSubMap/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <grouping>
                    <Tsub>
                      <tvar name="alpha"/>
                      <type/>
                    </Tsub>
                    <text content=" or "/>
                    <Tsub>
                      <tvar name="alpha"/>
                      <type/>
                    </Tsub>
                  </grouping>
                  <normalize>
                    <aCtset/>
                  </normalize>
                </in>                
                <text content=", "/>
                <OR>
                  <paren>
                    <eq>
                      <type/>
                      <tvar name="alpha"/>
                    </eq>
                  </paren>
                  <paren>
                    <eq>
                      <type/>
                      <mutable>
                        <tvar name="alpha"/>
                      </mutable>
                    </eq>
                  </paren>
                  <paren>
                    <notin>
                      <tvar name="alpha"/>
                      <type/>
                    </notin>
                  </paren>
                </OR>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="acy">
                <assume/>
                <aCtset/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type/>
                  </SubMap>
                  <pred name="TransClose">
                    <aSubMap/>
                  </pred>
                </in>
                <text content=", "/>
                <notin>
                  <tvar name="alpha"/>
                  <type/>
                </notin>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="acy">
                <assume/>
                <aSubMap/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <models name="cst">   
                <assume/>
                <aCtset/>
              </models>  	    
              <models name="acy">   
                <assume/>
                <aCtset/>
              </models>  	    	    
            </tyPre>
            <tyConc> 
              <models name="ca">   
                <assume/>
                <aCtset/>
              </models>  
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <models name="cst">   
                <assume/>
                <aSubMap/>
              </models>  	    
              <models name="acy">   
                <assume/>
                <aSubMap/>
              </models>  	    	    
            </tyPre>
            <tyConc> 
              <models name="ca">   
                <assume/>
                <aSubMap/>
              </models>  
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>
    </definition>      
    <definition id="ctr_extract">
      <title>Constraint Set Extraction</title>
      <btypes:TYPE>
        <Hrules vspace="yes">
          <tyRule>
            <tyPre/>
            <tyConc>
              <eq>
                <spset>
                  <Empty/>
                </spset>
                <Empty/>
              </eq>
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <eq>
                    <id name="i"/>
                    <text content="1 ... n"/>
                  </eq>
                </Forall>
                <space/>
                <eq>
                  <spset>
                    <solvable num="i"/>
                  </spset>
                  <aCtset num="i"/>
                </eq>
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <solvable num="1"/>
                  <unspecified/>
                  <solvable num="n"/>
                </spset>
                <Unin>
                  <aCtset num="i"/>
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <eq>
                <spset>
                  <solvable num="1"/>
                </spset>
                <aCtset num="1"/>
              </eq>
              <eq>
                <spset>
                  <solvable num="2"/>
                </spset>
                <aCtset num="2"/>
              </eq>
            </tyPre>
            <tyConc>
              <eq>
                <unin>
                  <spset>
                    <solvable num="1"/> 
                  </spset>
                  <spset>
                    <solvable num="2"/>
                  </spset>
                </unin>
                <unin>
                  <aCtset num="1"/>
                  <aCtset num="2"/>
                </unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <mbpair>
                    <type num="i"/>                
                    <type num="i" dash="'"/>
                  </mbpair>
                  <type/>
                </in>
                <text content=","/>
                <space/>
                <eq>
                  <aCtset num="i"/>
                  <set>
                    <ceq>
                      <type num="i"/>
                      <inner>
                        <type num="i" dash="'"/>
                      </inner>
                    </ceq>
                  </set>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <type/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <type num="i"/>                
                  <aExpr/> 
                </in>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <aExpr/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <in>
                    <mapping>
                      <id/>
                      <type num="i"/>                
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <gamma/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>               
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <in>
                    <mapping>
                      <loc/>
                      <type num="i"/>                
                    </mapping>
                    <store/>
                  </in>
                </Forall>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <store/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>       
        </Hrules>
      </btypes:TYPE>        
    </definition>
    <definition id="maybe-consistent">
      <title>Consistency of Maybe types</title>
      <p>
        We identify the following consistency property on maybe types.
      </p>
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <tvar name="alpha"/>
                  <type/>
                  <type dash="'"/>
                </Forall>
                <text content=" such that "/>
                <in>
                  <mbpair>
                    <type/>
                    <type dash="'"/>
                  </mbpair>
                  <solvables/>
                </in>
                <text content=", "/>
                <eq>
                  <type/>
                  <tvar name="alpha"/>
                </eq>
                <text content=" or "/>
                <ceq>
                  <type/>
                  <inner>
                    <type dash="'"/>
                  </inner>
                </ceq>
              </grouping>
            </tyPre>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <grouping>
                    <mbpair>
                      <tvar name="alpha"/>
                      <type/>
                    </mbpair>
                    <text content=" and "/>
                    <mbpair>
                      <tvar name="alpha"/>
                      <type dash="'"/>
                    </mbpair>
                  </grouping>
                  <solvables/>
                </in>
                <text content=", "/>
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>
              </grouping>              
              <eq>
                <inter>
                  <pred name="mtv">
                    <solvables/>
                  </pred>
                  <pred name="ntv">
                    <solvables/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </tyPre>
            <tyConc>
              <CST>
                <solvables/>
              </CST>
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>
    </definition>
    <definition id="normalized-ctr-types">
      <title>Canonical forms of Solvable Entities</title>
      <p>
        For any 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <models name="sat">
            <EmptySubst/>
            <spset>
              <solvable/>
            </spset>
          </models>
        </btypes:TYPE>,
        we write 
        <btypes:TYPE>
          <canonical>
            <solvable/>
          </canonical>
        </btypes:TYPE> to represent the equivalent entity
        in which (1) all meta-constructors in are fully interpreted,
        and (2) the (tautological) constraints embedded within 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE> are removed to obtain an equivalent
        unconstrained entity.
      </p>
    </definition>    
    <p>
      For example, if
      <btypes:TYPE>
        <eq>
          <type/>
          <mbpair>
            <mutable>
              <bool/>
            </mutable>
            <bool/>
          </mbpair>
        </eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
        <eq>
          <canonical>
            <type/>
          </canonical>
          <mutable>
            <bool/>
          </mutable>
        </eq>
      </btypes:TYPE>, and if
      <btypes:TYPE>
        <eq>
          <gamma/>
          <mapping>
            <id/>
            <floor>
              <mutable>
                <unit/>
              </mutable>
            </floor>
          </mapping>
        </eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
        <eq>
          <canonical>
            <gamma/>
          </canonical>
          <mapping>
            <id/>
            <unit/>
          </mapping>
        </eq>
      </btypes:TYPE>. 
      That is, canonicalization obtains entities that are within the
      language and type system defined in 
      section&nbsp;<xref ref="language"/>.
    </p>
    <definition id="shorthand">
      <title>Notational Shorthands</title>
      <p>
        We use the following shorthand translations as a notational
        convenience. Shorthand&nbsp;(<xref ref="decl_shorthand"/>) was already defined
        and used in section&nbsp;<xref ref="type_system"/>
      </p>
      <ol>
        <li id="decl_shorthand">
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge sub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge>
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Tsub>
                      <type/>
                      <type dash="'"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge name="j" sub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge name="j">
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Tsub>
                      <type/>
                      <type dash="'"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge name="j" Msub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge name="j">
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Msub>
                      <type/>
                      <type dash="'"/>
                    </Msub>
                  </collection>
                </DBrac>
              </leadsto>            
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TIjudge>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </TIjudge>
                </DBrac>
                <DBrac>            
                  <TIjudge>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>            
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <EmptySubst/>
                    </propagate>
                  </TIjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>          
                  <TIjudge>
                    <precond>
                      <aSubMap num="0"/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <aSubMap/>
                    </propagate>
                  </TIjudge>
                </DBrac>
                <DBrac>          
                  <TIjudge>
                    <assume>
                      <Subst>
                        <aSubMap num="0"/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap num="0"/>
                        <store/>
                      </Subst>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <Subst>
                          <aSubMap num="0"/>
                          <aExpr/>
                        </Subst>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <aSubMap/>
                    </propagate>
                  </TIjudge>
                </DBrac>
              </leadsto>   
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>              
              <leadsto>
                <DBrac>  
                  <judge>
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </DBrac>
                <DBrac>          
                  <Sjudge>
                    <assume>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </assume>
                    <tqExpr>
                      <Subst>
                        <aSubMap/>
                        <aExpr/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>              
              <leadsto>
                <DBrac>  
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </DBrac>
                <DBrac>          
                  <Sjudge name="j">
                    <assume>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </assume>
                    <tqExpr>
                      <Subst>
                        <aSubMap/>
                        <aExpr/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>          
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <aExpr/>
                    <type/>
                  </Djudge>
                </DBrac>
                <DBrac>          
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac> 
                  <set>
                    <aSubMap/>
                    <spset>
                      <unspecified/>
                    </spset>
                  </set>
                </DBrac>
                <DBrac>          
                  <Subst>                
                    <aSubMap/>
                    <grouping>
                      <set>
                        <unspecified/>
                      </set>
                    </grouping>
                  </Subst>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac> 
                  <Subst>
                    <aSubMap/>
                    <spset>
                      <unspecified/>
                    </spset>
                  </Subst>
                </DBrac>
                <DBrac>          
                  <Subst>                
                    <aSubMap/>
                    <grouping>
                      <spset>
                        <unspecified/>
                      </spset>
                    </grouping>
                  </Subst>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <p>
      The type inference algorithm is as shown in
      Figure&nbsp;<xref ref="hm_infer"/>. 
      The inference judgment 
      <btypes:TYPE>
	<TIjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/> <type/>
	    </tqExpr>
	  </conclude>
	  <propagate>
	    <aSubMap/>
	  </propagate>
	</TIjudge>
      </btypes:TYPE>
      should be understood as: given the binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
      <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
      <btypes:TYPE><type/></btypes:TYPE> for the expression 
      <btypes:TYPE><aExpr/></btypes:TYPE>.
      <btypes:TYPE><aSubMap/></btypes:TYPE> is list of substitutions 
      obtained by unifications performed during inference, and must be
      propagated to further derivations. 
      The judgment
      <btypes:TYPE>
	<models name="new">
	  <assume/>
	  <tvars name="alpha"/>
	</models>
      </btypes:TYPE> identifies new type variables. 
    </p>
    <p>
      Unification rules are as shown in 
      Figure&nbsp;<xref ref="hm_unify"/>.
      The unification judgment
      <btypes:TYPE>
	<UNIFY>
	  <type num="1"/>                  
	  <type num="2"/>
	  <aSubMap/>
	</UNIFY>
      </btypes:TYPE>
      is understood as: 
      <btypes:TYPE>
	<type num="1"/>                  
      </btypes:TYPE>
      unifies with
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      under the substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE>. 
    </p>
    <p>
      A constraint solver for solving copy compatibility constraints at 
      let-boundaries is 
      defined in Figure&nbsp;<xref ref="hm_solve"/>.          
      The judgment 
      <btypes:TYPE>
	<Sjudge name="solve">
	  <assume>
	    <aSubMap/>
	    <id/>
	    <aExpr/>
	  </assume>
	  <corUp>
	    <type num="1"/>
	    <type num="2"/>
	  </corUp>
	</Sjudge>
      </btypes:TYPE>
      should be read as: the (possibly) constrained type 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE>
      for the identifier
      <btypes:TYPE>
	<id/>
      </btypes:TYPE>
      (possibly) used in the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      is transformed to the unconstrained type
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      by solving all the copy compatibility constraints.
    </p>
    <p>
      We prove the soundness of the inference system, through an
      intermediate declarative system defined in 
      Figure&nbsp;<xref ref="hm_inter_rules"/>
    </p>
    <lemma id="Tsub-implies-Msub">
      <title><btypes:TYPE><TsubOp/></btypes:TYPE> 
        implies <btypes:TYPE><MsubOp/></btypes:TYPE></title>
      <p>
        If
        <btypes:TYPE>
          <Tsub>
            <type/>
            <type dash="'"/>
          </Tsub>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Evident from the definition of 
        <btypes:TYPE><MsubOp/></btypes:TYPE> in 
        Figure&nbsp;<xref ref="hm_inter_rules"/>.
        Both
        <btypes:TYPE><TsubOp/></btypes:TYPE> and
        <btypes:TYPE><MsubOp/></btypes:TYPE> are partial functions on
        types, but 
        <btypes:TYPE><MsubOp/></btypes:TYPE> clearly covers all
        cases that 
        <btypes:TYPE><TsubOp/></btypes:TYPE> relates.
      </p>
    </proof>
    <lemma id="Msub-begets-Tsub">
      <title><btypes:TYPE><MsubOp/></btypes:TYPE> 
        begets <btypes:TYPE><TsubOp/></btypes:TYPE></title> 
      <p>
        If
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Exists>
            <aSubMap/>
          </Exists>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <Tsub>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </Tsub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By construction of 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>. One possible solution is        
        <btypes:TYPE>
          <eq>
            <aSubMap/>
            <grouping>
              <Forall>
                <in>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type num="h"/>
                  </mbpair>
                  <type/> 
                </in>
              </Forall>
              <textit content=","/>
              <space/>
              <SubMap>
                <tvar name="alpha"/>
                <inner>
                  <type num="h"/>
                </inner>
              </SubMap>
            </grouping>
          </eq>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="Msub-consistent">
      <title>Consistency of <btypes:TYPE><MsubOp/></btypes:TYPE></title> 
      <p>
        If
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE> and
        <btypes:TYPE>
          <CST>
            <type/>
            <type dash="'"/>
          </CST>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Forall>
            <aSubMap/>
          </Forall>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <spset>
              <type/>
            </spset>
          </models>              
        </btypes:TYPE>, we have        
        <btypes:TYPE>
          <Tsub>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </Tsub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By straightforward induction over the derivation of 
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>, with case analysis over the 
        definition of <btypes:TYPE><MsubOp/></btypes:TYPE> in
        Figure&nbsp;<xref ref="hm_inter_rules"/>.
        A normalizing derivation with no redundant applications of
        reflexive and transitive rules must be considered.
      </p>
    </proof>
    <lemma id="weakening-sat-cst">
      <title>Weakening of Satisfiability and Consistency</title>
      <p>
        Weakening of properties over solvable entities:
      </p>
      <ol>
        <li>
          <p>
            If 
            <btypes:TYPE>	    
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>
                <aCtset/>
              </models>
            </btypes:TYPE> and
            <btypes:TYPE>	    
              <subeq>
                <aCtset dash="'"/>
                <aCtset/>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>
                <aCtset dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p> 
            If 
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <aCtset/>
              </models>
            </btypes:TYPE> and
            <btypes:TYPE>	    
              <subeq>
                <aCtset dash="'"/>
                <aCtset/>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <aCtset dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>	    
              <CST>
                <solvables num="n"/>
              </CST>
            </btypes:TYPE>, and            
            <btypes:TYPE>	
              <subeq>
                <set>
                  <solvables num="m"/>
                </set>
                <set>
                  <solvables num="n"/>
                </set>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <CST>
                <solvables num="m"/>
              </CST>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>
              <CST>
                <solvables/>
              </CST>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <spset>
                  <solvables/>
                </spset>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Evident from 
        <btypes:TYPE>
          <defn tag="sat"/>
        </btypes:TYPE>,
        <btypes:TYPE>
          <defn tag="ca"/>
        </btypes:TYPE>, and
        <btypes:TYPE>
          <defn tag="maybe-consistent"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="cst-implies-sat">
      <title>Consistency Implies Satisfiability</title>
      <p>
        If 
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <aCtset/>
          </models>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Exists>
            <aSubMap/>
          </Exists>
        </btypes:TYPE> such that
        <btypes:TYPE>
          <models name="sat">
            <aSubMap/>
            <aCtset/>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By inversion of the constraint consistency relationship in 
        <btypes:TYPE>
          <defn tag="ca"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="sat-implies-ct">
      <title>Satisfied constraints are consistent</title>
      <p>
        If 
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <spset>
              <solvables/>
            </spset>
          </models>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Cst>
            <assume/>
            <Subst>
              <aSubMap/>
              <set>
                <solvables/>
              </set>
            </Subst>
          </Cst>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Due to assumption&nbsp;(3), since 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE> satisfies all constraints in 
        <btypes:TYPE>
          <solvables/>
        </btypes:TYPE>,  we must have
        <btypes:TYPE>
          <eq>
            <pred name="mtv">
              <Subst>
                <aSubMap/>
                <solvables/>
              </Subst>
            </pred>
            <Empty/>
          </eq>
        </btypes:TYPE>. That is, there exists no 
        <btypes:TYPE>
          <in>
            <mbpair>
              <tvar name="alpha"/>
              <type/>
            </mbpair>
            <Subst>
              <aSubMap/>
              <solvables/>
            </Subst>
          </in>
        </btypes:TYPE>.
        Further, we must also have
        <btypes:TYPE>
          <Forall/>
          <in>
            <mbpair>
              <type/>
              <type dash="'"/>
            </mbpair>
            <Subst>
              <aSubMap/>
              <solvables/>
            </Subst>
          </in>
          <text content=", "/>
          <ceq>
            <type/>
            <inner>
              <type dash="'"/>
            </inner>
          </ceq>
        </btypes:TYPE>.
        Now, from  
        <btypes:TYPE>
          <defn tag="maybe-consistent"/>
        </btypes:TYPE>, we obtain
        <btypes:TYPE>
          <Cst>
            <assume/>
            <Subst>
              <aSubMap/>
              <set>
                <solvables/>
              </set>
            </Subst>
          </Cst>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="decl-sub">
      <title>Substitution on Declarative Derivation</title>
      <p>
        <btypes:TYPE>	    
          <text content="If "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" then "/>
          <judge>
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Straightforward induction on the
        derivation of 
        <btypes:TYPE>	    
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, except for the fact that we should use
        appropriate &alpha;-renaming on generalized variables 
        <btypes:TYPE>	    
          <forall>
            <in>
              <aTS/>
              <gamma/>
            </in>
          </forall>
        </btypes:TYPE>, so that generalized variables do not get
        substituted. 	  
      </p>
    </proof>
    <lemma id="int-consistent">
      <title>Consistency of Intermediate Derivation</title>
      <p>
        If 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>,
        then
        <btypes:TYPE>
          <CST>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </CST>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Evident from the definition of the intermediate type system in 
        figure&nbsp;<xref ref="hm_inter_rules"/> (each rule
        explicitly includes a consistency constraint), and
        <btypes:TYPE>	    
          <lem tag="weakening-sat-cst"/>
        </btypes:TYPE> (weakening).
      </p>
    </proof>
    <lemma id="subst_cst">
      <title>Substitution Consistency of Maybe types</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                <solvables num="n"/>
              </CST>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>	
              <subeq>
                <set>
                  <solvables num="m"/>
                </set>
                <set>                  
                  <solvables num="n"/>
                </set>
              </subeq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <aSubMap/>
            </btypes:TYPE> is a substitution such that
            <btypes:TYPE>
              <Cst>
                <assume/>
                <set>
                  <Subst>
                    <aSubMap/>
                    <solvables num="m"/>
                  </Subst>
                </set>
              </Cst>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <inter>
                  <dom>
                    <aSubMap/>
                  </dom>
                  <pred name="tv">
                    <solvables num="n"/>
                  </pred>
                </inter>
                <pred name="tv">
                  <solvables num="m"/>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Cst>
            <assume/>
            <Subst>
              <aSubMap/>
              <set>
                <solvables num="n"/>
              </set>
            </Subst>
          </Cst>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <ol>
        <li>
          <p>
            Due to assumption&nbsp;(1), and
            <btypes:TYPE>
              <defn tag="maybe-consistent"/>
            </btypes:TYPE>, we have
          </p>
          <ol>
            <li>
              <p>
                <btypes:TYPE>
                  <Forall>
                    <tvar name="alpha"/>
                    <type/>
                    <type dash="'"/>
                  </Forall>
                  <text content=" such that "/>
                  <in>
                    <mbpair>
                      <type/>
                      <type dash="'"/>
                    </mbpair>
                    <solvables num="n"/>
                  </in>
                  <text content=", "/>
                  <eq>
                    <type/>
                    <tvar name="alpha"/>
                  </eq>
                  <text content=" or "/>
                  <ceq>
                    <type/>
                    <inner>
                      <type dash="'"/>
                    </inner>
                  </ceq>
                </btypes:TYPE>
              </p>
            </li>
            <li>
              <p>
                <btypes:TYPE>
                  <Forall/>
                  <in>
                    <grouping>
                      <mbpair>
                        <tvar name="alpha"/>
                        <type/>
                      </mbpair>
                      <text content=" and "/>
                      <mbpair>
                        <tvar name="alpha"/>
                        <type dash="'"/>
                      </mbpair>
                    </grouping>
                    <solvables num="n"/>
                  </in>
                  <text content=", "/>
                  <eq>
                    <type/>
                    <type dash="'"/>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
            <li>
              <p>
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <pred name="mtv">
                        <solvables num="n"/>
                      </pred>
                      <pred name="ntv">
                        <solvables num="n"/>
                      </pred>
                    </inter>
                    <Empty/>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Due to assumption&nbsp;(3), 
            <btypes:TYPE>
              <defn tag="maybe-consistent"/>
            </btypes:TYPE>, we have
          </p>          
          <ol>
            <li>
              <p>
                <btypes:TYPE>
                  <Forall>
                    <tvar name="alpha"/>
                    <type/>
                    <type dash="'"/>
                  </Forall>
                  <text content=" such that "/>
                  <in>
                    <mbpair>
                      <type/>
                      <type dash="'"/>
                    </mbpair>
                    <Subst>
                      <aSubMap/>
                      <solvables num="m"/>
                    </Subst>
                  </in>
                  <text content=", "/>
                  <eq>
                    <type/>
                    <tvar name="alpha"/>
                  </eq>
                  <text content=" or "/>
                  <ceq>
                    <type/>
                    <inner>
                      <type dash="'"/>
                    </inner>
                  </ceq>
                </btypes:TYPE>
              </p>
            </li>
            <li>
              <p>
                <btypes:TYPE>
                  <Forall/>
                  <in>
                    <grouping>
                      <mbpair>
                        <tvar name="alpha"/>
                        <type/>
                      </mbpair>
                      <text content=" and "/>
                      <mbpair>
                        <tvar name="alpha"/>
                        <type dash="'"/>
                      </mbpair>
                    </grouping>
                    <Subst>
                      <aSubMap/>
                      <solvables num="m"/>
                    </Subst>
                  </in>
                  <text content=", "/>
                  <eq>
                    <type/>
                    <type dash="'"/>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
            <li>
              <p>
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <pred name="mtv">
                        <Subst>
                          <aSubMap/>
                          <solvables num="m"/>
                        </Subst>
                      </pred>
                      <pred name="ntv">
                        <Subst>
                          <aSubMap/>
                          <solvables num="m"/>
                        </Subst>
                      </pred>
                    </inter>
                    <Empty/>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Due to assumption&nbsp;(4), we can write
            <btypes:TYPE>
              <eq>
                <aSubMap/>
                <compose>
                  <aSubMap num="1"/>                  
                  <aSubMap num="2"/>
                  <aSubMap num="3"/>
                </compose>
              </eq>
            </btypes:TYPE> such that 
            <btypes:TYPE>
              <eq>
                <dom>
                  <aSubMap num="1"/>
                </dom>
                <pred name="mtv">
                  <solvables num="m"/>
                </pred>
              </eq>
            </btypes:TYPE>, 
            <btypes:TYPE>
              <eq>
                <dom>
                  <aSubMap num="2"/>
                </dom>
                <pred name="ntv">
                  <solvables num="m"/>
                </pred>
              </eq>
            </btypes:TYPE>, and 
            <btypes:TYPE>
              <eq>
                <inter>
                  <dom>
                    <aSubMap num="3"/>
                  </dom>
                  <pred name="tv">
                    <solvables num="n"/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From cases&nbsp;(2.a, 2.b, 2.c, 1.a, and 3), we can
            conclude that 
            <btypes:TYPE>
              <Forall>
                <tvar name="alpha"/>
                <type/>
                <type dash="'"/>
              </Forall>
              <text content=" such that "/>
              <in>
                <mbpair>
                  <type/>
                  <type dash="'"/>
                </mbpair>
                <Subst>
                  <aSubMap/>
                  <solvables num="n"/>
                </Subst>
              </in>
              <text content=", "/>
              <eq>
                <type/>
                <tvar name="alpha"/>
              </eq>
              <text content=" or "/>
              <ceq>
                <type/>
                <inner>
                  <type dash="'"/>
                </inner>
              </ceq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            From cases&nbsp;(2.b, 1.b, and 3), we conclude that
            <btypes:TYPE>
              <Forall/>
              <in>
                <grouping>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type/>
                  </mbpair>
                  <text content=" and "/>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type dash="'"/>
                  </mbpair>
                </grouping>
                <Subst>
                  <aSubMap/>
                  <solvables num="n"/>
                </Subst>
              </in>
              <text content=", "/>
              <eq>
                <type/>
                <type dash="'"/>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From cases&nbsp;(2.c, 1.c, and 3), we conclude that
            <btypes:TYPE>
              <eq>
                <inter>
                  <pred name="mtv">
                    <Subst>
                      <aSubMap/>
                      <solvables num="n"/>
                    </Subst>
                  </pred>
                  <pred name="ntv">
                    <Subst>
                      <aSubMap/>
                      <solvables num="n"/>
                    </Subst>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            From cases&nbsp;(4, 5, 6) and 
            <btypes:TYPE>
              <defn tag="maybe-consistent"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap/>
                  <set>
                    <solvables num="n"/>
                  </set>
                </Subst>
              </Cst>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="partial_solutions">
      <title>Partial solutions</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                  <solvables num="n"/>
                </CST>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>	
              <subeq>
                <set>
                  <solvables num="m"/>
                </set>
                <set>                  
                  <solvables num="n"/>
                </set>
              </subeq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap num="m"/>
                </assume>
                <spset>
                  <solvables num="m"/>
                </spset>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <inter>
                  <dom>
                    <aSubMap num="m"/>
                  </dom>
                  <pred name="tv">
                    <solvables num="n"/>
                  </pred>
                </inter>
                <pred name="tv">
                  <solvables num="m"/>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap num="m"/>
                  <set>
                    <solvables num="n"/>
                  </set>
                </Subst>
              </Cst>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Exists>
                <aSubMap num="n"/>
              </Exists>
            </btypes:TYPE>
            such that
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap num="n"/>
                </assume>
                <Subst>
                  <aSubMap num="m"/>
                  <spset>
                    <solvables num="n"/>
                  </spset>
                </Subst>
              </models>
            </btypes:TYPE>, and
            <btypes:TYPE>
              <eq>
                <Subst>
                  <scomp>
                    <aSubMap num="n"/>
                    <aSubMap num="m"/>
                  </scomp>
                  <set>
                    <solvables num="m"/>
                  </set>
                </Subst>
                <Subst>
                  <aSubMap num="m"/>
                  <set>
                    <solvables num="m"/>
                  </set>
                </Subst>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <ol>
        <li>          
          <p>
            From assumption&nbsp;(3) and 
            <btypes:TYPE>
              <lem tag="sat-implies-ct"/>
            </btypes:TYPE>, we conclude that
            <btypes:TYPE>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap num="m"/>
                  <set>
                    <solvables num="m"/>
                  </set>
                </Subst>
              </Cst>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From assumptions&nbsp;(1 and 2),
            case&nbsp;(1), assumptions&nbsp;(4) and
            <btypes:TYPE>
              <lem tag="subst_cst"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap num="m"/>
                  <set>
                    <solvables num="n"/>
                  </set>
                </Subst>
              </Cst>
            </btypes:TYPE>, the required conclusion&nbsp;(1).
          </p>
        </li>
        <li>
          <p>
            Conclusion&nbsp;(2) can be proved by construction of
            <btypes:TYPE>
              <aSubMap num="n"/>
            </btypes:TYPE>. One possibility is
            <btypes:TYPE>
              <eq>
                <aSubMap num="n"/>
                <SubMap>
                  <tvar name="alpha"/>
                  <inner>
                    <type/>
                  </inner>
                </SubMap>
              </eq>
              <text content=", "/>
              <Forall>
                <in>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type/>
                  </mbpair>
                  <Subst>
                    <aSubMap num="m"/>
                    <solvables num="n"/>
                  </Subst>
                </in>
              </Forall>
            </btypes:TYPE>.
          </p>
          <ol>
            <li>
              <p>
                Clearly, 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap num="n"/>
                    </assume>
                    <Subst>
                      <aSubMap num="m"/>
                      <spset>
                        <solvables num="n"/>
                      </spset>
                    </Subst>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                We know that 
                <btypes:TYPE>
                  <eq>
                    <dom>
                      <aSubMap/>
                    </dom>
                    <pred name="mtv">
                      <Subst>
                        <aSubMap num="m"/>
                        <spset>
                          <solvables num="n"/>
                        </spset>
                      </Subst>
                    </pred>
                  </eq>
                </btypes:TYPE>. 
              </p>
            </li>
            <li>
              <p>
                Due to assumption&nbsp;(3), we must have 
                <btypes:TYPE>
                  <eq>
                    <pred name="mtv">
                      <Subst>
                        <aSubMap num="m"/>
                        <solvables num="m"/>
                      </Subst>
                    </pred>
                    <Empty/>
                  </eq>
                </btypes:TYPE>. 
              </p>
            </li>
            <li>
              <p>
                By construction, 
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <dom>
                        <aSubMap/>
                      </dom>
                      <pred name="ntv">
                        <Subst>
                          <aSubMap num="m"/>
                          <spset>
                            <solvables num="n"/>
                          </spset>
                        </Subst>
                      </pred>
                    </inter>
                    <Empty/>
                  </eq>
                </btypes:TYPE>, and consequently, 
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <dom>
                        <aSubMap/>
                      </dom>
                      <pred name="ntv">
                        <Subst>
                          <aSubMap num="m"/>
                          <spset>
                            <solvables num="m"/>
                          </spset>
                        </Subst>
                      </pred>
                    </inter>
                    <Empty/>
                  </eq>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                From cases (3.c and 3.d), we conclude that 
                <btypes:TYPE>
                  <eq>
                    <Subst>
                      <scomp>
                        <aSubMap num="n"/>
                        <aSubMap num="m"/>
                      </scomp>
                      <set>
                        <solvables num="m"/>
                      </set>
                    </Subst>
                    <Subst>
                      <aSubMap num="m"/>
                      <set>
                        <solvables num="m"/>
                      </set>
                    </Subst>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </proof>
    <lemma id="ct_additive">
      <title>Additivity of Consistent Entities</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                <solvables/>
                <solvables num="m"/>
              </CST>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                <solvables/>
                <solvables num="n"/>
              </CST>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <inter>
                  <pred name="tv">
                    <solvables num="m"/>
                  </pred>
                  <pred name="tv">
                    <solvables num="n"/>
                  </pred>
                </inter>
                <pred name="tv">
                  <solvables/>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <CST>
            <solvables/>
            <solvables num="m"/>
            <solvables num="n"/>
          </CST>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <ol>
        <li>
          <p> 
            <btypes:TYPE>
              <Forall>
                <in>
                  <mbpair>
                    <type/>
                    <type dash="'"/>
                  </mbpair>
                  <grouping>
                    <solvables/>
                    <text content=", "/>
                    <solvables num="m"/>
                    <text content=", or "/>
                    <solvables num="n"/>
                  </grouping>
                </in>
              </Forall>
            </btypes:TYPE>,
            if
            <btypes:TYPE>
              <neq>
                <type/>
                <tvar name="alpha"/>
              </neq>
            </btypes:TYPE>
            for some
            <btypes:TYPE>
              <tvar name="alpha"/>
            </btypes:TYPE>, then
            from assumptions&nbsp;(1 and 2),
            we must have
            <btypes:TYPE>
              <ceq>
                <type/>
                <inner>
                  <type dash="'"/>
                </inner>
              </ceq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Forall>
                <in>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type num="i"/>
                  </mbpair>
                  <grouping>
                    <solvables num="m"/>
                    <text content=", and "/>
                    <solvables num="n"/>
                  </grouping>
                </in>
              </Forall>
            </btypes:TYPE>,
            from assumptions&nbsp;(1, 2, and 3), and
            <btypes:TYPE>
              <defn tag="maybe-consistent"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <Exists>
                <in>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type num="0"/>
                  </mbpair>
                  <solvables/>
                </in>
              </Exists>
            </btypes:TYPE>, such that
            <btypes:TYPE>
              <eq>
                <types num="i"/>
                <type num="0"/>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Due to assumption&nbsp;(1), we must have
            <btypes:TYPE>
              <eq>
                <inter>
                  <pred name="mtv">
                    <solvables/>
                    <solvables num="m"/>
                  </pred>
                  <pred name="ntv">
                    <solvables/>
                    <solvables num="m"/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
            Due to assumption&nbsp;(2), we must have
            <btypes:TYPE>
              <eq>
                <inter>
                  <pred name="mtv">
                    <solvables/>
                    <solvables num="n"/>
                  </pred>
                  <pred name="ntv">
                    <solvables/>
                    <solvables num="n"/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
            This, along with assumption&nbsp;(3) gives us
            <btypes:TYPE>
              <eq>
                <inter>
                  <pred name="mtv">
                    <solvables/>
                    <solvables num="m"/>
                    <solvables num="n"/>
                  </pred>
                  <pred name="ntv">
                    <solvables/>
                    <solvables num="m"/>
                    <solvables num="n"/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From cases&nbsp;(1, 2, and 3), and 
            <btypes:TYPE>
              <defn tag="maybe-consistent"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <CST>
                <solvables/>
                <solvables num="m"/>
                <solvables num="n"/>
              </CST>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </proof>
    <theorem id="intermediate-sound">
      <title>Soundness of Intermediate System</title>
      <p>
        If:
      </p>
      <ol>
        <li id="inter-sound__a_derive">
          <p>
            <btypes:TYPE>
              <TDjudge name="j">
                <aExpr/>
                <type/>
              </TDjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li id="inter-sound__a_solve">
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>                
                <spset>
                  <gamma/>
                  <store/>
                  <aExpr/>
                  <type/>
                </spset>
              </models>
            </btypes:TYPE>.              
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Djudge>            
            <aSubMap/>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </Djudge>
        </btypes:TYPE>.        
      </p>
    </theorem>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>
        We proceed by case analysis on the last step,
        assuming &alpha;-reduction vacuously.        
      </p>
      <ol>
        <li id="ints_bases">
          <p>
            Cases J-Unit, J-True. J-False, J-Id, J-Hloc,
            J-Sloc are trivial. 
          </p>
        </li>
        <li id="ints_lam">
          <p>
            Case J-Lambda:               
          </p>
          <ol>
            <li id="ints_l1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="ints_l1_1">
                  <btypes:TYPE>                    
                    <Hrules vspace="yes">                      
                      <tyRule>
                        <tyPre>
                          <Sjudge name="j">
                            <assume>
                              <extend>
                                <gamma/>
                                <mapping>
                                  <id/>
                                  <type num="1"/>
                                </mapping>
                              </extend>
                              <store/>
                            </assume>
                            <tqExpr>
                              <aExpr/>
                              <type num="2"/>
                            </tqExpr>
                          </Sjudge>
                        </tyPre>
                        <tyPre>
                          <CST>
                            <gamma/>
                            <store/>	
                            <aExpr/>
                            <type num="1"/>	      
                            <type num="2"/>
                          </CST>
                        </tyPre>
                        <tyConc>
                          <TDjudge name="j">
                            <lambda>
                              <id/>
                              <aExpr/>
                            </lambda>
                            <fn M="yes">		
                              <type num="1"/>
                              <type num="2"/>
                            </fn>
                          </TDjudge>
                        </tyConc>
                      </tyRule>
                    </Hrules>
                  </btypes:TYPE>
                </li>
                <li id="ints_l1_2">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap/>
                        </assume>
                        <spset>
                          <gamma/>
                          <store/>
                          <lambda>
                            <id/>
                            <aExpr num="i"/>
                          </lambda>
                          <fn M="yes">
                            <type num="1"/>
                            <type num="2"/>
                          </fn>
                        </spset>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
              <p>
                and we need to show that
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <type num="1"/>
                      <type num="2"/>
                    </fn>                    
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="inst_l2">
              <p>
                It is evident (from the syntactic structure) that                 
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <lambda>
                        <id/>
                        <aExpr num="i"/>
                      </lambda>
                    </spset>
                    <spset>
                      <aExpr num="i"/>
                    </spset>
                  </eq>
                </btypes:TYPE>
                and
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <fn M="yes">
                        <type num="1"/>
                        <type num="2"/>
                      </fn>
                    </spset>
                    <spset>
                      <type num="1"/>
                      <type num="2"/>
                    </spset>
                  </eq>
                </btypes:TYPE>. Therefore, we can re-write
                case (2.a.ii) as
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <gamma/>
                      <store/>
                      <aExpr num="i"/>
                      <type num="1"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>.
                Similarly, since
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <gamma/>
                      <type num="1"/>
                    </spset>
                    <spset>
                      <paren>
                        <extend>
                          <gamma/>
                          <mapping>
                            <id/>
                            <type num="1"/>
                          </mapping>
                        </extend>
                      </paren>
                    </spset>
                  </eq>
                </btypes:TYPE>, we can write
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l3">
              <p>
                Since we have
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>, and 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>,                
                from induction hypothesis, we obtain 
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <type num="1"/>
                      </mapping>
                    </extend>                    
                    <store/>
                    <aExpr num="i"/>
                    <type num="2"/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l4">
              <p>
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <type num="1"/>
                      </mapping>
                    </extend>                    
                    <store/>
                    <aExpr num="i"/>
                    <type num="2"/>
                  </Djudge>
                </btypes:TYPE> is a shorthand for 
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <extend>
                            <gamma/>
                            <mapping>
                              <id/>
                              <type num="1"/>
                            </mapping>
                          </extend>                    
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>, which can be re-written as
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <mapping>
                          <id/>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="1"/>
                            </Subst>
                          </canonical>
                        </mapping>
                      </extend>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>
              </p>
            </li>
            <li id="ints_l5">
              <p>
                From case (2.d) and T-Lambda rule in
                figure&nbsp;<xref ref="decl_rules"/>, we obtain
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <lambda>
                        <id/>
                        <canonical>                          
                          <Subst>
                            <aSubMap/>
                            <aExpr num="i"/>
                          </Subst>
                        </canonical>
                      </lambda>
                      <fn>
                        <minz>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="1"/>
                            </Subst>
                          </canonical>
                        </minz>
                        <maxz>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="2"/>
                            </Subst>
                          </canonical>
                        </maxz>
                      </fn>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="insts_l6">
              <p>
                From 
                <btypes:TYPE>
                  <defn tag="normalized-ctr-types"/>
                </btypes:TYPE> and
                <btypes:TYPE>
                  <defn tag="meta"/>
                </btypes:TYPE>, it is clear that
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <floor>
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                      </floor>
                    </canonical>                    
                    <minz>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                      </canonical>
                    </minz>
                  </eq>
                </btypes:TYPE>, and
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <ceil>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </ceil>
                    </canonical>
                    <maxz>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </maxz>
                  </eq>
                </btypes:TYPE>.
                Therefore, we can write
                <btypes:TYPE>
                  <eq br="yes">
                    <fn>
                      <minz>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <type num="1"/>
                          </Subst>
                        </canonical>
                      </minz>
                      <maxz>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <type num="2"/>
                          </Subst>
                        </canonical>
                      </maxz>
                    </fn>
                    <fn>
                      <canonical>
                        <floor>
                          <Subst>
                            <aSubMap/>
                            <type num="1"/>
                          </Subst>
                        </floor>
                      </canonical>
                      <canonical>
                        <ceil>
                          <Subst>
                            <aSubMap/>
                            <type num="2"/>
                          </Subst>
                        </ceil>
                      </canonical>
                    </fn>
                    <canonical>
                      <fn M="yes">
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </fn>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <fn M="yes">
                          <type num="1"/>
                          <type num="2"/>
                        </fn>
                      </Subst>                        
                    </canonical>
                  </eq>
                </btypes:TYPE>.
                It is further evident that
                <btypes:TYPE>
                  <eq>
                    <lambda>
                      <id/>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                    </lambda>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                      </Subst>
                    </canonical>
                  </eq>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l7">
              <p>
                Substituting the equivalencies in case (2.f) into case
                (2.e), we obtain:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>                          
                        <Subst>
                          <aSubMap/>                          
                          <lambda>
                            <id/>
                            <aExpr num="i"/>
                          </lambda>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <fn>
                            <floor>
                              <type num="1"/>
                            </floor>
                            <ceil>
                              <type num="2"/>
                            </ceil>
                          </fn>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
                That is,
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <type num="1"/>
                      <type num="2"/>
                    </fn>                    
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li id="ints_app">
          <p>
            Case J-App:
          </p>
          <ol>
            <li id="ints_a1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="ints_a1_1">
                  <p>
                    <btypes:TYPE>
                      <Hrules vspace="yes">                      
                        <tyRule>
                          <tyPre>
                            <grouping>
                              <text content="(A)"/>
                              <space/>
                              <space/>
                              <space/>
                              <TDjudge name="j">
                                <aExpr num="1"/> <type num="1"/>
                              </TDjudge>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="(B)"/>
                              <space/>
                              <space/>
                              <space/>
                              <Msub>
                                <type num="1"/>
                                <fn M="yes">
                                  <type num="a"/>
                                  <type num="r"/>
                                </fn>
                              </Msub>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="(C)"/>
                              <space/>
                              <space/>
                              <space/>
                              <TDjudge name="j">
                                <aExpr num="2"/>
                                <type num="2"/>
                              </TDjudge>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="(D)"/>
                              <space/>
                              <space/>
                              <space/>
                              <Msub>
                                <type num="2"/>
                                <inner>
                                  <type num="a"/>
                                </inner>
                              </Msub>
                            </grouping> 
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="(E)"/>
                              <space/>
                              <space/>
                              <space/>
                              <Msub>
                                <type num="r"/>
                                <inner>
                                  <type/>
                                </inner>
                              </Msub>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="(F)"/>
                              <space/>
                              <space/>
                              <space/>
                              <CST>
                                <gamma/>
                                <store/>
                                <aExpr num="1"/>
                                <aExpr num="2"/>
                                <type/>
                                <type num="1"/>
                                <type num="2"/>
                                <fn M="yes">
                                  <type num="a"/>
                                  <type num="r"/>
                                </fn>
                              </CST>
                            </grouping>
                          </tyPre>
                          <tyConc>
                            <TDjudge name="j">
                              <apply>
                                <aExpr num="1"/>
                                <aExpr num="2"/>
                              </apply>
                              <type/>
                            </TDjudge>
                          </tyConc>
                        </tyRule>
                      </Hrules>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="ints_a1_2">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap/>
                        </assume>                
                        <spset>
                          <gamma/>
                          <store/>
                          <apply>
                            <aExpr num="1"/>
                            <aExpr num="2"/>
                          </apply>
                          <type/>
                        </spset>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
              <p>
                We need to show that 
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <apply>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </apply>
                    <type/>
                  </Djudge>
                </btypes:TYPE>.
              </p>                
            </li>
            <li id="ints_a2">
              <p>
                From case&nbsp;(3.a.ii), we obtain 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>                
                    <spset>
                      <gamma/>
                      <store/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                      <type/>
                    </spset>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a3">
              <ol>
                <li id="ints_a3_1">
                  <p>
                    From case&nbsp;(3.a.i.F), we
                    have 
                    <btypes:TYPE>
                      <CST>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                        <type/>
                        <type num="1"/>
                        <type num="2"/>
                        <fn M="yes">
                          <type num="a"/>
                          <type num="r"/>
                        </fn>
                      </CST>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li id="ints_a3_2">
                  <p>
                    Clearly, 
                    <btypes:TYPE>
                      <subeq>
                        <set>
                          <gamma/>
                          <store/>
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                          <type/>
                        </set>
                        <set>
                          <gamma/>
                          <store/>
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                          <type/>
                          <type num="1"/>
                          <type num="2"/>
                          <fn M="yes">
                            <type num="a"/>
                            <type num="r"/>
                          </fn>
                        </set>
                      </subeq>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li id="ints_a3_3">
                  <p>
                    From case&nbsp;(3.b), we have
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap/>
                        </assume>                
                        <spset>
                          <gamma/>
                          <store/>
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                          <type/>
                        </spset>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li id="ints_a3_4">
                  <p>
                    We can assume that 
                    <btypes:TYPE>
                      <eq>
                        <inter>
                          <dom>
                            <aSubMap/>
                          </dom>
                          <pred name="tvs">
                            <set>
                              <gamma/>
                              <store/>
                              <aExpr num="1"/>
                              <aExpr num="2"/>
                              <type/>
                              <type num="1"/>
                              <type num="2"/>
                              <fn M="yes">
                                <type num="a"/>
                                <type num="r"/>
                              </fn>
                            </set>
                          </pred>
                        </inter>
                        <pred name="tvs">
                          <set>
                            <gamma/>
                            <store/>
                            <aExpr num="1"/>
                            <aExpr num="2"/>
                            <type/>
                          </set>
                        </pred>
                      </eq>
                    </btypes:TYPE>, because this property can be
                    obtained by suitable &alpha;-renaming using fresh
                    type variables. The only common type variables
                    that need to be common to both the derivations are
                    those present in 
                    <btypes:TYPE>
                      <gamma/>
                      <text content=" or "/>
                      <store/>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li id="ints_a3_5">
                  <p>
                    Now, from cases&nbsp;(3.c.i, 3.c.ii, 3.c.iii and
                    3.c.iv) and 
                    <btypes:TYPE>
                      <lem tag="partial_solutions"/>
                    </btypes:TYPE>, we conclude that 
                    <btypes:TYPE>
                      <Exists>
                        <aSubMap dash="''"/>
                      </Exists>
                    </btypes:TYPE>
                    such that if
                    <btypes:TYPE>
                      <eq>
                        <aSubMap dash="'"/>
                        <compose>
                          <aSubMap dash="''"/>
                          <aSubMap/>
                        </compose>
                      </eq>
                    </btypes:TYPE>, we have
                  </p>
                  <ol>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <models name="sat">
                            <assume>
                              <aSubMap dash="''"/>
                            </assume>
                            <Subst>
                              <aSubMap/>
                              <spset>
                                <gamma/>
                                <store/>
                                <aExpr num="1"/>
                                <aExpr num="2"/>
                                <type/>
                                <type num="1"/>
                                <type num="2"/>
                                <fn M="yes">
                                  <type num="a"/>
                                  <type num="r"/>
                                </fn>
                              </spset>
                            </Subst>
                          </models>
                        </btypes:TYPE>, and therefore,<br/>
                        <btypes:TYPE>
                          <models name="sat">
                            <assume>
                              <aSubMap dash="'"/>
                            </assume>
                            <spset>
                              <gamma/>
                              <store/>
                              <aExpr num="1"/>
                              <aExpr num="2"/>
                              <type/>
                              <type num="1"/>
                              <type num="2"/>
                              <fn M="yes">
                                <type num="a"/>
                                <type num="r"/>
                              </fn>
                            </spset>
                          </models>
                        </btypes:TYPE>.
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <Subst>
                              <aSubMap dash="'"/>
                              <set>
                                <gamma/>
                                <store/>
                                <aExpr num="1"/>
                                <aExpr num="2"/>
                                <type/>
                              </set>
                            </Subst>
                            <Subst>
                              <aSubMap/>
                              <set>
                                <gamma/>
                                <store/>
                                <aExpr num="1"/>
                                <aExpr num="2"/>
                                <type/>
                              </set>
                            </Subst>
                          </eq>
                        </btypes:TYPE>.
                      </p>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li id="ints_a4">
              <p>
                From case&nbsp;(3.c.v.A) and 
                <btypes:TYPE>	    
                  <lem tag="weakening-sat-cst"/>
                </btypes:TYPE> (weakening), we obtain
              </p>
              <ol>
                <li>
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap dash="'"/>
                        </assume>
                        <spset>
                          <gamma/>
                          <store/>
                          <aExpr num="1"/>
                          <type num="1"/>
                        </spset>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap dash="'"/>
                        </assume>
                        <spset>
                          <gamma/>
                          <store/>
                          <aExpr num="2"/>
                          <type num="2"/>
                        </spset>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
            </li>
            <li id="ints_a5">
              <p>
                From case&nbsp;(3.d.i), and 
                induction hypothesis with respect to 
                case&nbsp;(3.a.i.A), we conclude that
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap dash="'"/>
                    <gamma/>
                    <store/>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a6">
              <p>
                From case&nbsp;(3.d.ii), and 
                induction hypothesis with respect to 
                case&nbsp;(3.a.i.C), we conclude that
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap dash="'"/>
                    <gamma/>
                    <store/>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a7">
              <p>
                From cases&nbsp;(3.a.i.F and 3.c.v.A), and  
                <btypes:TYPE>	    
                  <lem tag="weakening-sat-cst"/>
                </btypes:TYPE> (weakening), we obtain
                <btypes:TYPE>
                  <CST>
                    <type num="1"/>
                    <fn M="yes">
                      <type num="a"/>
                      <type num="r"/>
                    </fn>
                  </CST>
                </btypes:TYPE> and
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap dash="'"/>
                    </assume>
                    <spset>
                      <type num="1"/>
                      <fn M="yes">
                        <type num="a"/>
                        <type num="r"/>
                      </fn>
                    </spset>
                  </models>
                </btypes:TYPE>. Now, from
                case&nbsp;(3.a.i.B) and
                <btypes:TYPE>	    
                  <lem tag="Msub-consistent"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>	  
                  <Tsub>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <type num="1"/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <fn M="yes">
                          <type num="a"/>
                          <type num="r"/>
                        </fn>
                      </Subst>
                    </canonical>
                  </Tsub>
                </btypes:TYPE>. That is,
                <btypes:TYPE>	  
                  <Tsub>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <type num="1"/>
                      </Subst>
                    </canonical>
                    <fn>
                      <minz>
                        <canonical>
                          <Subst>
                            <aSubMap dash="'"/>
                            <type num="a"/>
                          </Subst>
                        </canonical>
                      </minz>
                      <maxz>
                        <canonical>
                          <Subst>
                            <aSubMap dash="'"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </maxz>
                    </fn>
                  </Tsub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a8">
              <p>
                Similarly, for case (3.a.i.D), we obtain
                <btypes:TYPE>	    
                  <Tsub>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                                        
                        <type num="2"/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <inner>
                          <type num="a"/>
                        </inner>
                      </Subst>
                    </canonical>
                  </Tsub>
                </btypes:TYPE>.
                Given case&nbsp;(3.c.v.A), 
                <btypes:TYPE>	    
                  <ceq>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                                        
                        <type num="2"/>
                      </Subst>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <inner>
                          <type num="a"/>
                        </inner>
                      </Subst>
                    </canonical>
                  </ceq>
                </btypes:TYPE>. For any two types 
                <btypes:TYPE>	    
                  <type dash="'"/>
                  <text content=" and "/>
                  <type dash="''"/>
                </btypes:TYPE> such that
                <btypes:TYPE>	    
                  <ceq>
                    <type dash="'"/>
                    <type dash="''"/>
                  </ceq>
                </btypes:TYPE>, we have 
                <btypes:TYPE>	    
                  <Tsub>
                    <type dash="'"/>
                    <minz>
                      <type dash="'"/>
                    </minz>
                  </Tsub>
                </btypes:TYPE>, and
                <btypes:TYPE>	    
                  <Tsub>
                    <type dash="''"/>
                    <minz>
                      <type dash="'"/>
                    </minz>
                  </Tsub>
                </btypes:TYPE>.
                Therefore, we conclude that 
                <btypes:TYPE>	    
                  <Tsub>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                    
                        <inner>
                          <type num="a"/>
                        </inner>
                      </Subst>
                    </canonical>
                    <minz>
                      <canonical>
                        <Subst>
                          <aSubMap dash="'"/>
                          <type num="a"/>
                        </Subst>
                      </canonical>
                    </minz>
                  </Tsub>
                </btypes:TYPE>.
                We can now write
                <btypes:TYPE>	    
                  <Tsub>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                                        
                        <type num="2"/>
                      </Subst>
                    </canonical>
                    <minz>
                      <canonical>
                        <Subst>
                          <aSubMap dash="'"/>
                          <type num="a"/>
                        </Subst>
                      </canonical>
                    </minz>
                  </Tsub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a9">
              <p>
                Similar to case&nbsp;(h), from case (3.a.i.E), we
                obtain
                <btypes:TYPE>	    
                  <Tsub>
                    <maxz>
                      <canonical>
                        <Subst>
                          <aSubMap dash="'"/>                    
                          <inner>
                            <type num="r"/>
                          </inner>
                        </Subst>
                      </canonical>
                    </maxz>
                    <canonical>
                      <Subst>
                        <aSubMap dash="'"/>                                        
                        <type/>
                      </Subst>
                    </canonical>
                  </Tsub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a10">
              <p>
                From cases&nbsp;(3.e, 3.f, 3.g, 3.h, and 3.i) and the
                T-App rule in figure&nbsp;<xref ref="decl_rules"/>, we
                obtain,
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap dash="'"/>
                    <gamma/>
                    <store/>
                    <apply>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </apply>
                    <type/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a11">
              <p>
                From cases&nbsp;(3.j, and 3.c.v.B), we finally conclude that
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <apply>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </apply>
                    <type/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li id="ints_rest">
          <p>
            Cases J-If, J-Dup, J-Deref, J-Set,  
            J-Tqexpr, J-Let-M[Tq], and J-Let-P[Tq] are similar.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="int-subst">
      <title>Substitution on Intermediate Derivation</title>
      <p>
         <btypes:TYPE>	    
          <text content="If "/>
          <Sjudge name="j">
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>          
          <aSubMap/>
          <text content=" is a substitution such that "/>
          <Cst>
            <assume/>
            <Subst>
              <aSubMap/>              
              <set>
                <gamma/>
                <store/>
                <aExpr/>
                <type/>
              </set>
            </Subst>
          </Cst>
          <text content=", then "/>
          <judge name="j">
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>	
    </lemma>
    <proof>
      <p>
        Straightforward induction on the
        derivation of 
        <btypes:TYPE>	    
          <Sjudge name="j">
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, similar to 
        <btypes:TYPE>	    
          <lem tag="decl-sub"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <theorem id="TI-unify-correct">
      <title>Correctness of Unification</title>
      <p>
        <btypes:TYPE>
          <text content="If "/>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>              
            <aSubMap/>
          </UNIFY>
          <text content=", then:"/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Msub>
                <Subst>
                  <aSubMap/>
                  <type num="1"/>
                </Subst>
                <Subst>
                  <aSubMap/>
                  <type num="2"/>              
                </Subst>
              </Msub>
              <text content=" and "/>
              <Msub>
                <Subst>
                  <aSubMap/>
                  <type num="2"/>              
                </Subst>
                <Subst>
                  <aSubMap/>
                  <type num="1"/>
                </Subst>
              </Msub>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ca">   
                <assume/>
                <spset>
                  <type num="1"/>
                </spset>
              </models>
              <text content=", and"/>
              <models name="ca">
                <assume/>
                <spset>
                  <type num="2"/>
                </spset>
              </models>
              <text content=" implies "/>
              <models name="ca">   
                <assume/>
                <Subst>
                  <aSubMap/>
                  <spset>
                    <type num="1"/>
                    <type num="2"/>
                  </spset>
                </Subst>
              </models>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </theorem>
    <proof>
      <p>
        By straightforward induction on the derivation of 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>              
            <aSubMap/>
          </UNIFY>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="unify-consistent">
      <title>Consistency of Unified Types</title>
      <p>
        <btypes:TYPE>
          <text content="If "/>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>              
            <aSubMap/>
          </UNIFY>
          <text content=", then:"/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                <solvables/>
                <type num="1"/>
                <type num="2"/>
              </CST>
              <text content=" implies "/>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap/>
                  <set>
                    <solvables/>
                    <type num="1"/>
                    <type num="2"/>
                  </set>
                </Subst>
              </Cst>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <CST>
                <solvables/>
                <type num="1"/>
              </CST>
              <text content=", and"/>
              <CST>
                <solvables/>
                <type num="2"/>
              </CST>
              <text content=" implies "/>
              <Cst>
                <assume/>
                <Subst>
                  <aSubMap/>
                  <set>
                    <solvables/>
                    <type num="1"/>
                    <type num="2"/>
                  </set>
                </Subst>
              </Cst>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By straightforward induction on the derivation of 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>              
            <aSubMap/>
          </UNIFY>
        </btypes:TYPE>.
      </p>
    </proof>
    <theorem id="TI-solve-correct">
      <title>Correctness of the Constraint Solver</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="s">
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
        </btypes:TYPE>,
        then 
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <spset>
              <type/>
            </spset>
          </models>              
        </btypes:TYPE> and
        <btypes:TYPE>
          <eq>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <type dash="'"/>
            </canonical>
          </eq>
        </btypes:TYPE>
      </p>
    </theorem>
    <proof>
      <p>
        By straightforward induction on the derivation of 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
        </btypes:TYPE>, noting that the solver infers
        compatible types at steps Sol-Ct-Var and that the Sol-Ct-Const
        explicitely checks for compatibility.
      </p>
    </proof>
    <lemma id="TI-SOLVE-correct">
      <title>Corollary to Correctness of the Constraint Solver</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="solve">
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
        </btypes:TYPE>,
        then 
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <spset>
              <type/>
            </spset>
          </models>              
        </btypes:TYPE> and
        <btypes:TYPE>
          <eq>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <type dash="'"/>
            </canonical>
          </eq>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        Follows from 
        <btypes:TYPE>
          <thm tag="TI-solve-correct"/>
        </btypes:TYPE> and the definition of
        <btypes:TYPE>
          <Sjudge name="solve"/>
        </btypes:TYPE>
        figure&nbsp;<xref ref="hm_solve"/>.
      </p>
    </proof>
    <theorem id="TI-solve-total">
      <title>Totality of the Constraint Solver</title>
      <p>
        If          
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <spset>
              <type/>
            </spset>
          </models>
          <text content=" then "/>
          <Exists/>
          <aSubMap/>
          <text content=" and "/>
          <type dash="'"/>
          <text content=" such that "/>
          <Sjudge name="s">
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        Evident from the definition of the solver in 
        figure&nbsp;<xref ref="hm_solve"/>.
      </p>
    </proof>
    <theorem id="unique-solve-solutions">
      <title>Uniqueness of Solutions Produced by the Solver</title> 
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="s">
            <assume>
              <aSubMap dash="'"/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
          <text content=" and "/>
          <Sjudge name="s">
            <assume>
              <aSubMap dash="''"/>
            </assume>
            <corUp>
              <type/>
              <type dash="''"/>
            </corUp>
          </Sjudge>
          <text content=", then "/>
          <eq>
            <aSubMap dash="'"/>
            <aSubMap dash="''"/>
          </eq>
          <text content=" and "/>
          <eq>
            <type dash="'"/>
            <type dash="''"/>
          </eq>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        Evident from the definition of the solver in 
        figure&nbsp;<xref ref="hm_solve"/>.
      </p>
    </proof>
    <theorem id="TI-unify-decidable">
      <title>Decidability of Unification</title>
      <p>
        If
        <btypes:TYPE>
          <models name="acy">
            <assume/>
            <spset>
              <type num="1"/>
            </spset>
          </models>
          <text content=" and "/>
          <models name="acy">
            <assume/>
            <spset>
              <type num="2"/>
            </spset>
          </models>
        </btypes:TYPE>, then,        
        a normalizing derivation of 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>
            <aSubMap/>
          </UNIFY>
        </btypes:TYPE>
        where no two uses of U-Commut occur consecutively is
        decidable. 
      </p>
    </theorem>
    <proof>
      <p>
        The unifier and constraint solver builds a solution tree by
        always invoking itself types having <em>smaller</em> shapes of
        types (after eliminating redundant uses of the U-Commut rule).
        Since types are of bounded size and acyclic, and since
        unification itself does not produce any cycles
        (Theorem&nbsp;<xref ref="TI-unify-correct"/>), these
        derivations must be bounded. 
      </p>
    </proof>
    <theorem id="TI-solve-decidable">
      <title>Decidability of the Constraint Solver</title>
      <p>
        If
        <btypes:TYPE>
          <models name="acy">
            <assume/>
            <spset>
              <type/>
            </spset>
          </models>
        </btypes:TYPE>, then,
        the derivation of
        <btypes:TYPE>
          <Sjudge name="s">
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
          <text content=" is decidable."/>
        </btypes:TYPE>
      </p>
    </theorem>
    <proof>
      <p>
        Similar to Theorem&nbsp;<xref ref="TI-unify-decidable"/>. 
      </p>
    </proof>
    <lemma id="structural_isomorphism">
      <title>Structural Isomorphism</title>
      <p>
        If 
        <btypes:TYPE>
          <Msub>
            <type num="1"/>
            <type num="2"/>              
          </Msub>
          <text content=" and "/>
          <Msub>
            <type num="2"/>              
            <type num="1"/>
          </Msub>
        </btypes:TYPE>, then for any substitution
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>, we have
        <btypes:TYPE>
          <Msub>
            <Subst>
              <aSubMap/>
              <type num="1"/>
            </Subst>
            <Subst>
              <aSubMap/>
              <type num="2"/>              
            </Subst>
          </Msub>
          <text content=" and "/>
          <Msub>
            <Subst>
              <aSubMap/>
              <type num="2"/>              
            </Subst>
            <Subst>
              <aSubMap/>
              <type num="1"/>
            </Subst>
          </Msub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Since we have both
        <btypes:TYPE>
          <Msub>
            <type num="1"/>
            <type num="2"/>
          </Msub>
          <text content=" and "/>
          <Msub>
            <type num="2"/>
            <type num="1"/>
          </Msub>
        </btypes:TYPE>,
        the two types 
        <btypes:TYPE>
          <type num="1"/>
          <text content=" and "/>
          <type num="2"/>
        </btypes:TYPE> must be structurally equivalent expect for the
        fact that one of the types can be of the form
        <btypes:TYPE>
          <mbpair>
            <type/>
            <type dash="'"/>
          </mbpair>
        </btypes:TYPE>, and the other of the form
        <btypes:TYPE>
          <type/>
        </btypes:TYPE>. The conclusion is thus evident.
      </p>
    </proof>
    <lemma id="heuristic-inference-consistent">
      <title>Consistency of Heuristic Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
            </propagate>
          </TIjudge>
        </btypes:TYPE> and
        <btypes:TYPE>
          <CST>
            <gamma/>
            <store/>
          </CST>
        </btypes:TYPE>
        then,
        <btypes:TYPE>
          <Cst>
            <assume/>
            <Subst>
              <aSubMap/>
              <set>
                <gamma/>
                <store/>
                <aExpr/>
                <type/>
              </set>
            </Subst>
          </Cst>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>, noting that (1) all maybe types are introduced
        through new type variables, (2) the two parts of a maybe type
        are never separated once constructed (3) all substitutions
        produced during inference are obtained from the unifier or the
        solver, which preserve consistency according to 
        <btypes:TYPE>
          <thm tag="TI-unify-correct"/>
        </btypes:TYPE> (property&nbsp;3), and
        <btypes:TYPE>
          <thm tag="TI-solve-correct"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="hm-tvar-effects">
      <title>Type Variable Propagation</title>
      <p>
        If:
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr num="1"/>
                <type num="1"/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="1"/>
            </propagate>
          </TIjudge>
        </btypes:TYPE> and
        <btypes:TYPE>
          <TIjudge>
            <precond>
              <aSubMap num="1"/>
            </precond>              
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr num="2"/>
                <type num="2"/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="2"/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <eq>
            <inter>
              <pred name="tv">
                <Subst>
                  <scomp>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </scomp>
                  <collection>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </collection>
                </Subst>
              </pred>
              <pred name="tv">
                <Subst>
                  <scomp>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </scomp>
                  <collection>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </collection>
                </Subst>
              </pred>
            </inter>
            <pred name="tv">
              <Subst>
                <scomp>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </scomp>
                <collection>
                  <gamma/>
                  <store/>
                </collection>
              </Subst>
            </pred>
          </eq>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By straightforward induction on the derivation of 
        <btypes:TYPE>
          <TIjudge>
            <precond>
              <aSubMap num="1"/>
            </precond>              
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr num="2"/>
                <type num="2"/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="2"/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>. 
        This derivation happens in an environment that already
        contains the substitutions obtained from the first
        derivation:
        <btypes:TYPE>
          <aSubMap num="1"/>
        </btypes:TYPE>. 
        All of the cases in the second derivation either
        use (1) primitive types that do not alter the type variables
        involved, (2) types (and thus type variables) from 
        <btypes:TYPE>
          <Subst>
            <aSubMap num="1"/>
            <gamma/>
          </Subst>
          <text content=" or "/>
          <Subst>
            <aSubMap num="1"/>
            <store/>
          </Subst>
        </btypes:TYPE>, or (3) new type variables.
        Therefore, it is evident that, if
        <btypes:TYPE>
          <eq>
            <set>
              <tvars name="alpha"/>
            </set>
            <Unin>
              <pred name="tv">
                <type/>
              </pred>
            </Unin>
          </eq>
          <text content=", "/>
          <Forall>
            <in>
              <type/>
              <range>
                <aSubMap num="2"/>
              </range>
            </in>
          </Forall>            
        </btypes:TYPE>, we have
        <btypes:TYPE>
          <eq>
            <inter>
              <paren>
                <unin>
                  <dom>
                    <aSubMap num="2"/>
                  </dom>
                  <set>
                    <tvars name="alpha"/>
                  </set>
                  <pred name="tv">
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                      <collection>
                        <aExpr num="2"/>
                        <type num="2"/>
                      </collection>
                    </Subst>
                  </pred>
                </unin>
              </paren>
              <pred name="tv">
                <Subst>
                  <aSubMap num="1"/>
                  <collection>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </collection>
                </Subst>
              </pred>
            </inter>
            <pred name="tv">
              <Subst>
                <aSubMap num="1"/>
                <collection>
                  <gamma/>
                  <store/>
                </collection>
              </Subst>
            </pred>
          </eq>
        </btypes:TYPE>.
        From this, we can conclude that
        <btypes:TYPE>
          <eq>
            <inter>
              <pred name="tv">
                <Subst>
                  <scomp>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </scomp>
                  <collection>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </collection>
                </Subst>
              </pred>
              <pred name="tv">
                <Subst>
                  <scomp>
                    <aSubMap num="1"/>
                    <aSubMap num="2"/>
                  </scomp>
                  <collection>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </collection>
                </Subst>
              </pred>
            </inter>
            <pred name="tv">
              <Subst>
                <scomp>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </scomp>
                <collection>
                  <gamma/>
                  <store/>
                </collection>
              </Subst>
            </pred>
          </eq>
        </btypes:TYPE>.
      </p>
      <p>
        <em>Note:</em> 
        For the sake of simplicity, type variables present as type
        qualifications that are unbound in the environment are treated
        as fresh type variables. For example, the expression
        <btypes:TYPE>
          <if>
            <true/>
            <tqExpr>
              <aExpr num="a"/> 
              <tvar name="alpha"/>
            </tqExpr>
            <tqExpr>
              <aExpr num="2"/>
              <tvar name="alpha"/>
            </tqExpr>
          </if>
        </btypes:TYPE>, where
        <btypes:TYPE>
          <notin>
            <tvar name="alpha"/>
            <pred name="tv">
              <gamma/>
              <store/>
            </pred>
          </notin>
        </btypes:TYPE> is equivalent to 
        <btypes:TYPE>
          <if>
            <true/>
            <tqExpr>
              <aExpr num="a"/> 
              <tvar name="beta"/>
            </tqExpr>
            <tqExpr>
              <aExpr num="2"/>
              <tvar name="gamma"/>
            </tqExpr>
          </if>
        </btypes:TYPE>, where
        <btypes:TYPE>
          <models name="new">
            <assume/>
            <grouping>
              <tvar name="beta"/>
              <tvar name="gamma"/>
            </grouping>
          </models>
        </btypes:TYPE>.
        This formulation obviates the need for tracking type variable
        scopes in the environment. If necessary, any alternate
        behaviour can be obtained by introducing dummy bindings (ex:
        through an lambda expression that encompasses all expressions
        that must be in scope of a type variable). 
      </p>
    </proof>
    <theorem id="heuristic-inference-sound">
      <title>Soundness of Heuristic Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
            </propagate>
          </TIjudge>
        </btypes:TYPE> and
        <btypes:TYPE>
          <CST>
            <gamma/>
            <store/>
          </CST>
        </btypes:TYPE>
        then,
        <btypes:TYPE>
          <judge name="j">
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>.
        We proceed by case analysis on the last step,
        assuming &alpha;-reduction vacuously.
      </p>
      <ol>
        <li id="hms_base">
          <p>
            Cases I-Unit, I-True. I-False, I-Id, I-Hloc,
            I-Sloc are trivial. 
          </p>
        </li>
        <li id="hms_lambda">
          <p>
            Case I-Lambda:               
          </p>
          <ol>
            <li id="hms_l1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="hms_l1_1">
                  <btypes:TYPE>
                    <Hrules>
                      <tyRule>
                        <tyPre>
                          <grouping>
                            <text content="(A)"/>
                            <space/>
                            <space/>
                            <space/>
                            <TIjudge>
                              <assume>
                                <extend>
                                  <gamma/>
                                  <mapping>
                                    <id/>
                                    <tvar name="alpha"/>
                                  </mapping>
                                </extend>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <aExpr num="i"/>
                                  <type/>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <aSubMap/>
                              </propagate>
                            </TIjudge>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(B)"/>
                            <space/>
                            <space/>
                            <space/>
                            <models name="new">
                              <assume/>
                              <tvar name="alpha"/>
                            </models>
                          </grouping>
                        </tyPre>
                        <tyConc>
                          <TIjudge>
                            <assume>
                              <gamma/>
                              <store/>
                            </assume>
                            <conclude>
                              <tqExpr>
                                <lambda> 
                                  <id/>
                                  <aExpr num="i"/>
                                </lambda>
                                <fn M="yes">		    
                                  <Subst>
                                    <aSubMap/>
                                    <tvar name="alpha"/>
                                  </Subst>		    		    
                                  <type/>		    
                                </fn>
                              </tqExpr>
                            </conclude>
                            <propagate>		
                              <aSubMap/>		
                            </propagate>
                          </TIjudge>
                        </tyConc>
                      </tyRule>
                    </Hrules>
                  </btypes:TYPE>
                </li>
                <li id="hms_l1_2">
                  <p>
                    <btypes:TYPE>
                      <CST>
                        <gamma/>
                        <store/>
                      </CST>
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
              <p>
                We need to show that
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <fn M="yes">		    
                          <Subst>
                            <aSubMap/>
                            <tvar name="alpha"/>
                          </Subst>		    		    
                          <type/>		    
                        </fn>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_l2">
              <p>
                From case&nbsp;(2.a.ii), conclusion of
                case&nbsp;(2.a.i) and 
                <btypes:TYPE>
                  <lem tag="heuristic-inference-consistent"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap/>
                      <set>
                        <gamma/>
                        <store/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <fn M="yes">		    
                          <Subst>
                            <aSubMap/>
                            <tvar name="alpha"/>
                          </Subst>		    		    
                          <type/>		    
                        </fn>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>. This can be re-written as
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap/>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="i"/>
                        <tvar name="alpha"/>
                        <type/>		    
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_l3">
              <p>
                From cases&nbsp;(2.a.ii and 2.a.i.B), we can write
                <btypes:TYPE>
                  <CST>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <tvar name="alpha"/>
                      </mapping>
                    </extend>
                    <store/>
                  </CST>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_l4">
              <p>
                From cases&nbsp;(2.a.i.A and 2.c), from induction
                hypothesis, we conclude that
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <tvar name="alpha"/>
                        </mapping>
                      </extend>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr num="i"/>
                        <type/>		    
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_l5">
              <p>
                From cases&nbsp;(2.d and 2.b), and the J-Lambda rule
                in figure&nbsp;<xref ref="hm_inter_rules"/>, we obtain
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <fn M="yes">		    
                          <tvar name="alpha"/>
                          <type/>		    
                        </fn>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
                This can be equivalently stated as:
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                        <fn M="yes">		    
                          <Subst>
                            <aSubMap/>
                            <tvar name="alpha"/>
                          </Subst>		    		    
                          <type/>		    
                        </fn>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol> <!-- Lambda case ends here -->
        </li>
        <li id="hms_app">
          <p>
            Case I-App:
          </p>
          <ol>
            <li id="hms_a1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="hms_a1_1">
                  <btypes:TYPE>
                    <Hrules>
                      <tyRule>
                        <tyPre>
                          <grouping>
                            <text content="(A)"/>
                            <space/>
                            <space/>
                            <space/>
                            <TIjudge>
                              <assume>
                                <gamma/>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <aExpr num="1"/>
                                  <type num="1"/>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <aSubMap num="1"/>
                              </propagate>
                            </TIjudge>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(B)"/>
                            <space/>
                            <space/>
                            <space/>
                            <TIjudge>
                              <precond>
                                <aSubMap num="1"/>
                              </precond>
                              <assume>
                                <gamma/>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <aExpr num="2"/>
                                  <type num="2"/>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <aSubMap num="2"/>
                              </propagate>
                            </TIjudge>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(C)"/>
                            <space/>
                            <space/>
                            <space/>
                            <UNIFY>
                              <Subst>
                                <aSubMap num="2"/>
                                <type num="1"/>
                              </Subst>
                              <mbpair>
                                <tvar name="beta"/>
                                <fn M="yes">
                                  <tvar name="delta"/>
                                  <tvar name="alpha"/>
                                </fn>
                              </mbpair>
                              <aSubMap num="f"/>
                            </UNIFY>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(D)"/>
                            <space/>
                            <space/>
                            <space/>
                            <UNIFY>
                              <type num="2"/>	      
                              <mbpair>
                                <tvar name="gamma"/>		
                                <minz>
                                  <Subst>
                                    <aSubMap num="f"/>
                                    <tvar name="delta"/>
                                  </Subst>
                                </minz>
                              </mbpair>
                              <aSubMap num="a"/>
                            </UNIFY>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(E)"/>
                            <space/>
                            <space/>
                            <space/>
                            <eq>
                              <type/>
                              <mbpair>
                                <tvar name="epsiv"/>
                                <minz>
                                  <Subst>
                                    <scomp>
                                      <aSubMap num="a"/>
                                      <aSubMap num="f"/>
                                    </scomp>
                                    <tvar name="alpha"/>
                                  </Subst>
                                </minz>
                              </mbpair>
                            </eq>
                          </grouping>
                        </tyPre>
                        <tyPre>
                          <grouping>
                            <text content="(F)"/>
                            <space/>
                            <space/>
                            <space/>
                            <models name="new">
                              <assume/>
                              <grouping>
                                <tvar name="alpha"/>
                                <tvar name="beta"/>
                                <tvar name="gamma"/>
                                <tvar name="delta"/>
                                <tvar name="epsiv"/>
                              </grouping>
                            </models>
                          </grouping>
                        </tyPre>
                        <tyConc>
                          <TIjudge>
                            <assume>
                              <gamma/>
                              <store/>
                            </assume>
                            <conclude>
                              <tqExpr>
                                <apply>
                                  <aExpr num="1"/>
                                  <aExpr num="2"/>
                                </apply>                 
                                <type/>
                              </tqExpr>
                            </conclude>
                            <propagate>
                              <scomp>
                                <aSubMap num="1"/>
                                <aSubMap num="2"/>
                                <aSubMap num="f"/>
                                <aSubMap num="a"/>
                              </scomp>
                            </propagate>
                          </TIjudge>
                        </tyConc>
                      </tyRule>
                    </Hrules>
                  </btypes:TYPE>
                </li>
                <li id="hms_a1_2">
                  <p>
                    <btypes:TYPE>
                      <CST>
                        <gamma/>
                        <store/>
                      </CST>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="hms_a1_3">
                  <p>
                    <btypes:TYPE>
                      <eq>
                        <aSubMap/>
                        <scomp>
                          <aSubMap num="1"/>
                          <aSubMap num="2"/>
                          <aSubMap num="f"/>
                          <aSubMap num="a"/>
                        </scomp>
                      </eq>                        
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
              <p>
                We need to show that
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <apply>
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                        </apply>                 
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a2">
              <p>
                From cases&nbsp;(3.a.i.A and 3.a.ii) and induction
                hypothesis, we can write, 
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap num="1"/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr num="1"/>
                        <type num="1"/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a3">
              <p>
                From cases&nbsp;(3.a.ii and 3.b) and
                <btypes:TYPE>
                  <lem tag="heuristic-inference-consistent"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap num="1"/>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a4">
              <p>
                From case&nbsp;(3.c) and
                <btypes:TYPE>
                  <lem tag="weakening-sat-cst"/>
                </btypes:TYPE> (weakening), we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap num="1"/>
                      <set>
                        <gamma/>
                        <store/>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>. Using this result along with
                case&nbsp;(3.a.i.B) and induction hypothesis, we obtain
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr num="2"/>
                        <type num="2"/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a5">
              <p>
                From case&nbsp;(3.d) and 
                <btypes:TYPE>
                  <lem tag="int-consistent"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap num="2"/>
                      <Subst>
                        <aSubMap num="1"/>
                        <set>
                          <gamma/>
                          <store/>
                          <aExpr num="2"/>
                          <type num="2"/>
                        </set>
                      </Subst>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a6">
              <p>
                From cases&nbsp;(3.b and 3.e), and
                <btypes:TYPE>
                  <lem tag="int-subst"/>
                </btypes:TYPE>, we obtain
                 <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr num="1"/>
                        <type num="1"/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a7">
              <p>
                From case&nbsp;(3.f) and
                <btypes:TYPE>
                  <lem tag="int-consistent"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a8">
              <p>
                From cases&nbsp;(3.a.i.A and 3.a.i.B), and
                <btypes:TYPE>
                  <lem tag="hm-tvar-effects"/>
                </btypes:TYPE>, we obtain:
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <pred name="tv">
                        <Subst>
                          <scomp>
                            <aSubMap num="1"/>
                            <aSubMap num="2"/>
                          </scomp>
                          <collection>
                            <aExpr num="1"/>
                            <type num="1"/>
                          </collection>
                        </Subst>
                      </pred>
                      <pred name="tv">
                        <Subst>
                          <scomp>
                            <aSubMap num="1"/>
                            <aSubMap num="2"/>
                          </scomp>
                          <collection>
                            <aExpr num="2"/>
                            <type num="2"/>
                          </collection>
                        </Subst>
                      </pred>
                    </inter>
                    <pred name="tv">
                      <Subst>
                        <scomp>
                          <aSubMap num="1"/>
                          <aSubMap num="2"/>
                        </scomp>
                        <collection>
                          <gamma/>
                          <store/>
                        </collection>
                      </Subst>
                    </pred>
                  </eq>
                </btypes:TYPE>.
                This can be written as:
                <btypes:TYPE>
                  <eq>
                    <inter>
                      <pred name="tv">
                        <Subst>
                          <scomp>
                            <aSubMap num="1"/>
                            <aSubMap num="2"/>
                          </scomp>
                          <collection>
                            <gamma/>
                            <store/>
                            <aExpr num="1"/>
                            <type num="1"/>
                          </collection>
                        </Subst>
                      </pred>
                      <pred name="tv">
                        <Subst>
                          <scomp>
                            <aSubMap num="1"/>
                            <aSubMap num="2"/>
                          </scomp>
                          <collection>
                            <gamma/>
                            <store/>
                            <aExpr num="2"/>
                            <type num="2"/>
                          </collection>
                        </Subst>
                      </pred>
                    </inter>
                    <pred name="tv">
                      <Subst>
                        <scomp>
                          <aSubMap num="1"/>
                          <aSubMap num="2"/>
                        </scomp>
                        <collection>
                          <gamma/>
                          <store/>
                        </collection>
                      </Subst>
                    </pred>
                  </eq>
                </btypes:TYPE>.                
              </p>
            </li>
            <li id="hms_a9">
              <p>
                From cases&nbsp;(3.g, 3.e, and 3.h), we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a10">
              <p>
                It is evident that 
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                      </scomp>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                        <mbpair>
                          <tvar name="beta"/>
                          <fn M="yes">
                            <tvar name="delta"/>
                            <tvar name="alpha"/>
                          </fn>
                        </mbpair>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>, since 
                <btypes:TYPE>
                  <tvar name="beta"/>
                  <text content=", "/>
                  <tvar name="gamma"/>
                  <text content=", and "/>
                  <tvar name="delta"/>
                </btypes:TYPE> are new type variables 
                (from case&nbsp;(3.a.i.F)).
              </p>
            </li>
            <li id="hms_a11">
              <p>
                From cases&nbsp;(3.a.i.C, and 3.j) and 
                <btypes:TYPE>
                  <lem tag="unify-consistent"/>
                </btypes:TYPE>-conclusion&nbsp;(1), we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                        <mbpair>
                          <tvar name="beta"/>
                          <fn M="yes">
                            <tvar name="delta"/>
                            <tvar name="alpha"/>
                          </fn>
                        </mbpair>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a12">
              <p>
                From case&nbsp;(3.a.i.C), and 
                <btypes:TYPE>
                  <thm tag="TI-unify-correct"/>
                </btypes:TYPE>-conclusion(1), we have 
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <scomp>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <type num="1"/>
                    </Subst>
                    <Subst>
                      <aSubMap num="f"/>
                      <mbpair>
                        <tvar name="beta"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </mbpair>
                    </Subst>
                  </Msub>
                  <text content=" and "/>
                  <Msub>
                    <Subst>
                      <aSubMap num="f"/>
                      <mbpair>
                        <tvar name="beta"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </mbpair>
                    </Subst>
                    <Subst>
                      <scomp>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <type num="1"/>
                    </Subst>
                  </Msub>
                </btypes:TYPE>. This can be equivalently written as
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <type num="1"/>
                    </Subst>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <mbpair>
                        <tvar name="beta"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </mbpair>
                    </Subst>
                  </Msub>
                  <text content=" and "/>
                  <Msub>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <mbpair>
                        <tvar name="beta"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </mbpair>
                    </Subst>
                    <Subst>
                      <scomp>
                        <aSubMap num="1"/>
                        <aSubMap num="2"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <type num="1"/>
                    </Subst>
                  </Msub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a13">
              <p>
                From case (3.a.iii), we know that
                <btypes:TYPE>
                  <eq>
                    <aSubMap/>
                    <scomp>
                      <aSubMap num="1"/>
                      <aSubMap num="2"/>
                      <aSubMap num="f"/>
                      <aSubMap num="a"/>
                    </scomp>
                  </eq>
                </btypes:TYPE>.
                Similar to cases&nbsp;(3.j, 3.k, and 3.l), from
                case&nbsp;(3.a.i.D) we obtain:
              </p>
              <ol>
                <li>
                  <p>
                    <btypes:TYPE>
                      <Cst>
                        <assume/>
                        <Subst>
                          <aSubMap/>
                          <set>
                            <gamma/>
                            <store/>
                            <aExpr num="1"/>
                            <type num="1"/>
                            <aExpr num="2"/>
                            <type num="2"/>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn M="yes">
                                <tvar name="delta"/>
                                <tvar name="alpha"/>
                              </fn>
                            </mbpair>
                            <mbpair>
                              <tvar name="gamma"/>		
                              <minz>
                                <Subst>
                                  <aSubMap num="f"/>
                                  <tvar name="delta"/>
                                </Subst>
                              </minz>
                            </mbpair>
                          </set>
                        </Subst>
                      </Cst>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    <btypes:TYPE>
                      <Msub>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>	      
                        </Subst>
                        <Subst>
                          <aSubMap/>
                          <mbpair>
                            <tvar name="gamma"/>		
                            <minz>
                              <Subst>
                                <aSubMap num="f"/>
                                <tvar name="delta"/>
                              </Subst>
                            </minz>
                          </mbpair>
                        </Subst>
                      </Msub>
                      <text content=" and "/>
                      <Msub>
                        <Subst>
                          <aSubMap/>
                          <mbpair>
                            <tvar name="gamma"/>		
                            <minz>
                              <Subst>
                                <aSubMap num="f"/>
                                <tvar name="delta"/>
                              </Subst>
                            </minz>
                          </mbpair>
                        </Subst>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>	      
                        </Subst>
                      </Msub>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li id="hms_a14"> 
              <ol>
                <li>
                  <p>
                    From case&nbsp;(3.m.i), and
                    <btypes:TYPE>
                      <lem tag="weakening-sat-cst"/>
                    </btypes:TYPE> (weakening-conclusion&nbsp;(3)),
                    we obtain
                    <btypes:TYPE>
                      <Cst>
                        <assume/>
                        <Subst>
                          <aSubMap/>
                          <set>
                            <gamma/>
                            <store/>
                            <aExpr num="1"/>
                            <type num="1"/>
                          </set>
                        </Subst>
                      </Cst>
                    </btypes:TYPE>
                    From this, case&nbsp;(3.b), and
                    <btypes:TYPE>
                      <lem tag="int-subst"/>
                    </btypes:TYPE>, we obtain
                    <btypes:TYPE>
                      <judge name="j">
                        <precond>
                          <aSubMap/>
                        </precond>
                        <assume>
                          <gamma/>
                          <store/>
                        </assume>
                        <conclude>
                          <tqExpr>
                            <aExpr num="1"/>
                            <type num="1"/>
                          </tqExpr>
                        </conclude>
                      </judge>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Similarly, from case&nbsp;(3.d), and
                    <btypes:TYPE>
                      <lem tag="int-subst"/>
                    </btypes:TYPE>, we obtain
                    <btypes:TYPE>
                      <judge name="j">
                        <precond>
                          <aSubMap/>
                        </precond>
                        <assume>
                          <gamma/>
                          <store/>
                        </assume>
                        <conclude>
                          <tqExpr>
                            <aExpr num="2"/>
                            <type num="2"/>
                          </tqExpr>
                        </conclude>
                      </judge>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li id="hms_a15">
              <p>
                From case&nbsp;(3.m.i), and
                <btypes:TYPE>
                  <lem tag="weakening-sat-cst"/>
                </btypes:TYPE> (weakening-conclusion&nbsp;(3)),
                we obtain
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap/>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                        <mbpair>
                          <tvar name="beta"/>
                          <fn M="yes">
                            <tvar name="delta"/>
                            <tvar name="alpha"/>
                          </fn>
                        </mbpair>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>. From this, it is evident that
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap/>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
                Now, from cases&nbsp;(3.m.1 and 3.a.i.E), since 
                <btypes:TYPE>
                  <tvar name="epsiv"/>
                </btypes:TYPE> is a new type variable, and
                <btypes:TYPE>
                  <eq>
                    <Subst>
                      <scomp>
                        <aSubMap num="a"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <tvar name="alpha"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <tvar name="alpha"/>
                    </Subst>
                  </eq>
                </btypes:TYPE>, and 
                <btypes:TYPE>
                  <in>
                    <Subst>
                      <aSubMap/>
                      <tvar name="alpha"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <fn M="yes">
                        <tvar name="delta"/>
                        <tvar name="alpha"/>
                      </fn>
                    </Subst>                    
                  </in>
                </btypes:TYPE>, we conclude that
                <btypes:TYPE>
                  <Cst>
                    <assume/>
                    <Subst>
                      <aSubMap/>
                      <set>
                        <gamma/>
                        <store/>
                        <aExpr num="1"/>
                        <type num="1"/>
                        <aExpr num="2"/>
                        <type num="2"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                        <type/>
                      </set>
                    </Subst>
                  </Cst>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a16">
              <p>
                From case&nbsp;(3.l) and 
                 <btypes:TYPE>
                  <lem tag="structural_isomorphism"/>
                </btypes:TYPE>, we obtain (as one of the conclusions):
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="1"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <mbpair>
                        <tvar name="beta"/>
                        <fn M="yes">
                          <tvar name="delta"/>
                          <tvar name="alpha"/>
                        </fn>
                      </mbpair>
                    </Subst>
                  </Msub>
                </btypes:TYPE>, from which we can conclude that
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="1"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <fn M="yes">
                        <tvar name="delta"/>
                        <tvar name="alpha"/>
                      </fn>
                    </Subst>
                  </Msub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a17">
              <p>
                From case&nbsp;(3.m.ii), we have 
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="2"/>	      
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <mbpair>
                        <tvar name="gamma"/>		
                        <minz>
                          <Subst>
                            <aSubMap num="f"/>
                            <tvar name="delta"/>
                          </Subst>
                        </minz>
                      </mbpair>
                    </Subst>
                  </Msub>
                </btypes:TYPE>, from which, we can conclude that
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="2"/>	      
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <minz>
                        <Subst>
                          <aSubMap num="f"/>
                          <tvar name="delta"/>
                        </Subst>
                      </minz>
                    </Subst>
                  </Msub>
                </btypes:TYPE>, and therefore
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="2"/>	      
                    </Subst>
                    <minz>
                      <Subst>
                        <aSubMap/>
                        <tvar name="delta"/>
                      </Subst>
                    </minz>
                  </Msub>
                </btypes:TYPE>, and thus
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <type num="2"/>	      
                    </Subst>
                    <inner>
                      <Subst>
                        <aSubMap/>
                        <tvar name="delta"/>
                      </Subst>
                    </inner>
                  </Msub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a18">
              <p>
                For any type 
                <btypes:TYPE>
                  <type dash="'"/>
                </btypes:TYPE>, it is evident from the definition of 
                <btypes:TYPE>
                  <inner>
                    <type dash="'"/>
                  </inner>
                </btypes:TYPE> in
                figure&nbsp;<xref ref="hm_infer"/> that
                <btypes:TYPE>
                  <Msub>
                    <minz>
                      <type dash="'"/>
                    </minz>
                    <inner>
                      <type dash="'"/>
                    </inner>
                  </Msub>
                </btypes:TYPE>. Therefore,
                <btypes:TYPE>
                  <Msub>
                    <minz>
                      <Subst>
                        <aSubMap/>
                        <tvar name="alpha"/>
                      </Subst>
                    </minz>
                    <inner>
                      <Subst>
                        <aSubMap/>
                        <tvar name="alpha"/>
                      </Subst>
                    </inner>
                  </Msub>
                </btypes:TYPE>. From this, it is evident that
                <btypes:TYPE>
                  <Msub>
                    <mbpair>
                      <tvar name="gamma"/>
                      <minz>
                        <Subst>
                          <aSubMap/>
                          <tvar name="alpha"/>
                        </Subst>
                      </minz>
                    </mbpair>
                    <inner>
                      <Subst>
                        <aSubMap/>
                        <tvar name="alpha"/>
                      </Subst>
                    </inner>
                  </Msub>
                </btypes:TYPE>.
                Now, from case&nbsp;(3.a.i.E), (since
                <btypes:TYPE>
                  <eq>
                    <Subst>
                      <scomp>
                        <aSubMap num="a"/>
                        <aSubMap num="f"/>
                      </scomp>
                      <tvar name="alpha"/>
                    </Subst>
                    <Subst>
                      <aSubMap/>
                      <tvar name="alpha"/>
                    </Subst>
                  </eq>
                </btypes:TYPE>, and
                <btypes:TYPE>
                  <eq>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                    <type/>
                  </eq>
                </btypes:TYPE>), we can write
                <btypes:TYPE>
                  <Msub>
                    <Subst>
                      <aSubMap/>
                      <tvar name="alpha"/>
                    </Subst>
                    <inner>
                      <Subst>
                        <aSubMap/>
                        <type/>	      
                      </Subst>
                    </inner>
                  </Msub>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="hms_a19">
              <p>
                Now, from cases&nbsp;(3.n.i, 3.p, 3.n.ii, 3.q, 3.r,
                and 3.o) and the J-App rule in 
                figure&nbsp;<xref ref="hm_inter_rules"/>, we obtain
                <btypes:TYPE>
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <apply>
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                        </apply>                 
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li> <!-- App case ends here -->
        <li id="hms_rest">
          <p>
            Cases I-If, I-Dup, I-Deref, I-Set,  
            I-Tqexpr, I-Let[Tq] are similar.
          </p>
        </li>
      </ol>
    </proof>
  </sect1>
  <nocite ref="sridhar2006plos"/>
  <bibliography>
    <bibentry label="shapBitcSpec2006">
      <key>Shapiro06</key>
      J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
      Specification''
      <link
      href="http://bitc-lang.org/docs/bitc/spec.html">
      <progident>http://www.bitc-lang.org/docs/bitc/spec.html</progident>
      </link>
    </bibentry>
    <bibentry label="sridhar2006plos">
      <key>Sridhar06</key>
       S. Sridhar and J. Shapiro. ``Type Inference for Unboxed Types
       and First Class Mutability'' <doctitle>Proc. 3rd ECOOP Workshop
       on Programming Languages and Operating Systems (PLOS
       2006)</doctitle> San Jose, CA. 2006.
    </bibentry>
  </bibliography>
 
</article>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->


<!--  LocalWords:  ptsz authorgroup firstname orgname sridharmutinfer bnf desc
 -->
<!--  LocalWords:  sLoc hLoc aVal aExpr lvalues lVal tqExpr bnfc dup opsem eval
 -->
<!--  LocalWords:  opState dyn sem Grossman qtypes levalOp evalOp RVAL aTS pred
 -->
<!--  LocalWords:  subst Csubst ceqOp maxzOp minzOp eq maxz neq minz metaCT ol
 -->
<!--  LocalWords:  covariant arg ret ceil Tsub TDjudge Hrules tyRule TW tyPre
 -->
<!--  LocalWords:  tyConc lval decl judgeOp Garriage's spEqOp notin spEq unin
 -->
<!--  LocalWords:  uninOp Sjudge dom mapsto rexec leadin leval supeq aSubMap Ph
 -->
<!--  LocalWords:  VSubstitution LSubstitution SubMap TEjudge UNF unf subeq ACM
 -->
<!--  LocalWords:  mbpair TIjudge vaughanHM Hindley Milner mdash epsiv corUp HL
 -->
<!--  LocalWords:  TypesBook corUpOp carrys epsi ASET SRL unkinded pagebreak SL
 -->
<!--  LocalWords:  Garriague's vspace CTX MTVs FTVs NTVs cst commut sust ok su
 -->
<!--  LocalWords:  canonicalized ndash si uf ua vf rh va sa subeqOp supeqOp eqi
 -->
 
<!--  LocalWords:  nceq documentclass sigplanconf FirstName LastName notitle ih
 -->

<!--  LocalWords:  horz idemp Acyclicity otheroptions nocopyrightspace FTV NTV
 -->
<!--  LocalWords:  explicitely tvs asm mtvs lem nosp req defn scomp subnum sep
 -->
<!--  LocalWords:  fnize cong sm ecomp subEq BitC Swaroop Sridhar dev bitc LHS
 -->


<!--  LocalWords:  unboxed RHS lvalue Hloc Sloc Rval lhs rhs Deref Tq iff wrt
 -->
<!--  LocalWords:  canonicalization unifications Tqexpr Tvar Oth Composability
 -->
<!--  LocalWords:  Doerrie Proc ECOOP PLOS
 -->
