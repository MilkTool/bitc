<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <article id="formal" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo ptsz='default' latex.otheroptions="nocopyrightspace" latex.documentclass="sigplanconf">
    <title>A Theory of Well-founded First Class Mutability</title>
    <subtitle>A Proof of Soundness for BitC Type System and
      Type Inference Algorithm</subtitle>
    <authorgroup>
      <author>
      	<firstname>Swaroop</firstname>
      	<surname>Sridhar</surname>
      	<email>swarop@cs.jhu.edu</email>
      </author>
      <author>
      	<firstname>Jonathan</firstname>
        <othername>S.</othername>
      	<surname>Shapiro</surname>
      	<email>shap@eros-os.org</email>
      </author>
      <author>
      	<firstname>Scott</firstname>
        <othername>F.</othername>
      	<surname>Smith</surname>
      	<email>scott@cs.jhu.edu</email>
      </author>
      <affiliation>
      	<orgname>Department of Computer Science</orgname>
      	<address>The Johns Hopkins Uinversity</address>
      	<address>3400 N.Charles Street. 224 NEB. Balimore, MD 21218.</address>
      </affiliation>
    </authorgroup>
    <pubdate></pubdate>
    <!--     <copyright> -->
    <!--       <year>2006</year> -->
    <!--       <holder>Swaroop Sridhar</holder> -->
    <!--       <holder>Jonathan S. Shapiro</holder> -->
    <!--     </copyright> -->
    <!--   <categories> -->
    <!--     <category>dev/bitc</category> -->
    <!--   </categories> -->
    <synopsis>
      <p>
      </p>
    </synopsis>
  </docinfo>  
  <!--<abstract latex.incolumn="yes">
  <p>
    </p>
  </abstract> -->
  <!-- <toc/> -->
  <sect1 id="intro">
    <title>Introduction</title>
    <p>
      BitC is a systems programming language with first class support
      for unboxed types and mutability. Details about the language can
      be obtained from the <link
        href="http://coyotos.org/docs/bitc/spec.html"> BitC language
        specification</link> <cite ref="shapBitcSpec2006"/>. This
      document provides the formalization of the type system and type
      inference algorithm for a core calculus the BitC, along with the
      associated proofs.
    </p>
  </sect1>
  <sect1 id="language">
    <title>The Language <btypes:TYPE><language/></btypes:TYPE> </title>
    <p>
      We limit our presentation to a core calculus of BitC called 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> in the interest of brevity. 
    </p>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Identifiers">
          <id/>
          <alternatives etc="yes">
            <id name="y"/>
            <id name="z"/>
          </alternatives>
        </bnf>
        <bnf desc="Stack Locations"> 
          <sLoc/>
          <alternatives etc="yes">
            <sLoc num="1"/>
            <sLoc num="2"/>
          </alternatives>
        </bnf>
        <bnf desc="Heap Locations">
          <hLoc/>
          <alternatives etc="yes">
            <hLoc num="1"/>
            <hLoc num="2"/>
          </alternatives>
        </bnf>
        <bnf desc="Locations">
          <loc/>
          <alternatives>
            <sLoc/>
            <hLoc/>
          </alternatives>
        </bnf>
        <bnf desc="Values">
          <aVal/>
          <alternatives>
            <Unit/>
            <true/> 

            <false/>
            <hLoc/>
            <lambda>
              <id/>
              <aExpr/>
            </lambda>
          </alternatives>
        </bnf>
        <bnf desc="lvalues">
          <lVal/>
          <alternatives>
            <sLoc/>
            <deref>
              <hLoc/>
            </deref>
          </alternatives>
        </bnf>
        <bnf desc="Expressions">
          <aExpr/>
          <alternatives>
            <aVal/>
            <sLoc/>
            <apply>
              <aExpr/>
              <aExpr/>
            </apply>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
            <assign>
              <aExpr/>
              <aExpr/>
            </assign> 
          </alternatives>
        </bnf>
        <bnfc desc="">
          <alternatives>
            <dup>
              <aExpr/>
            </dup>
            <deref>
              <aExpr/>
            </deref>
          </alternatives>
        </bnfc>
        <bnfc desc="">
          <alternatives>
            <if>
              <aExpr/>
              <aExpr/>
              <aExpr/>
            </if>
          </alternatives>
        </bnfc>
        <bnfc desc="">
          <alternatives>
            <let kind="k">
              <tqExpr optional="yes">
                <id/>
                <type/>
              </tqExpr>
              <aExpr/>
              <aExpr/>
            </let>
          </alternatives>
        </bnfc>
        <bnf desc="Let-kinds">
          <lKind/>
          <alternatives>
            <text content="-"/>
            <lKind k="var"/>
            <lKind k="mono"/>
            <lKind k="poly"/>
          </alternatives>
        </bnf>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn><type/><type/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="ref / pointer">
          <alternatives>
            <ref><type/></ref>
          </alternatives> 
        </bnfc>
        <bnfc desc="Mutable type">
          <alternatives>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Type Scheme">
          <aTS/>
          <alternatives>
            <type/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      All the above syntactic forms can be parenthesized without
      change in meaning. The let-kind ``-'' is a placeholder for the
      unkinded (input) <progident>let</progident> form.
      A substitution is of Z for Y in X is written using the standard
      notation:
      <btypes:TYPE>
	<subst>
	  <text content="X"/>
	  <text content="Y"/>
	  <text content="Z"/>          
	</subst>
      </btypes:TYPE>.
    </p>
  </sect1>
  <sect1 id="opsem">
    <title>Dynamic Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
    <xi:include href="include/formal/opsem.xmli"/>
    <xi:include href="include/formal/decl.xmli"/>
    <xi:include href="include/formal/locsem.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Stack">
          <stack/>
          <alternatives>
            <Empty/>
            <extend>
              <stack/>
              <mapping>
                <sLoc/>
                <aVal/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Heap">
          <heap/>
          <alternatives>
            <Empty/>
            <extend>
              <heap/>
              <mapping>
                <hLoc/>
                <aVal/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      The Operational semantics rules are shown in Figure&nbsp;<xref
        ref="dyn_sem_horz"/>.
      The system state is represented by the triple 
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      consisting of the stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE>, the heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, and the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> to be
      evaluated. Evaluation itself is a two place relationship   
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      that denotes transformation in the system state due to a single
      step of execution.
      Figure&nbsp;<xref ref="dyn_sem_horz"/> shows the evaluation
      rules for our core language. We assume that the program is
      alpha-converted so that there are no name collisions due to
      inner bindings. Separate execution
      semantics are given for left and right execution (evaluation of
      expressions that appear on the LHS and RHS of an assignment 
      <btypes:TYPE>
	<assign>
	  <aExpr num="l"/>
	  <aExpr num="r"/>
	</assign>
      </btypes:TYPE>) denoted by 
      <btypes:TYPE><levalOp/></btypes:TYPE> and 
      <btypes:TYPE><evalOp/></btypes:TYPE> respectively. 
    </p>
  </sect1>
  <sect1 id="type_system">
    <title>Static Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Binding Environment">
          <gamma/>
          <alternatives>
            <Empty/>
            <extend>
              <gamma/>
              <mapping>
                <id/>
                <aTS/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Store Typing">
          <store/>
          <alternatives>
            <Empty/>
            <extend>
              <store/>
              <mapping>
                <loc/>
                <type/>
              </mapping>
            </extend>
          </alternatives>
        </bnf>
        <bnf desc="Logical Relations">
          <LOGIC/>
          <alternatives>
            <TRUE/>
            <FALSE/>
            <AND>
              <LOGIC/>
              <LOGIC/>
            </AND>
            <OR>
              <LOGIC/>
              <LOGIC/>
            </OR>
          </alternatives>
        </bnf>
        <bnfc>
          <alternatives>              
            <NOT>
              <LOGIC/>
            </NOT>
            <pred name="Predicate">
              <plural>
                <LOGIC/>
              </plural>
            </pred>
          </alternatives>
        </bnfc>
      </grammar>
    </btypes:TYPE>
    <p>
      We represent mathematical properties as: 
      <btypes:TYPE>
	<models name="property">
	  <text content="assumption"/>
	  <text content="subject"/>
	</models>
      </btypes:TYPE>.
    </p>
    <p>
      Figure&nbsp;<xref ref="decl_rules"/> shows the declarative
      type rules, copy coercion rules and rules for type
      generalization. The location semantics (lvalue) rules 
      are shown in figure&nbsp;<xref ref="lval_rules"/>.
      The standard type judgment  
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> is understood as: given a binding environment 
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and store typing
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>.
      We write 
      <btypes:TYPE>
        <TDjudge sub="yes">
          <aExpr/>                  
          <type/>                  
        </TDjudge>
      </btypes:TYPE> as a shorthand for:
      <btypes:TYPE>
        <TDjudge>
          <aExpr/>                  
          <type dash="'"/>                  
        </TDjudge>
        <text content=", "/>
        <Tsub>
          <type dash="'"/>
          <type/>
        </Tsub>
      </btypes:TYPE>.
    </p>
    <definition id="aleq">      
      <title>Algebraic equivalences</title>
      <p>
        In our algebra of types, we define the following equivalence:
        <btypes:TYPE>
          <equiv>
            <mutable>
              <mutable>
                <type/>
              </mutable>
            </mutable>
            <mutable>
              <type/>
            </mutable>
          </equiv>
        </btypes:TYPE>.
        That is, the mutable type constructor is idempotent. 
      </p>
    </definition>
    <definition id="copy_sem">      
      <title>Copy Compatibility</title>
      <p> 
        We deifne the copy compatibility relationship 
        (<btypes:TYPE>
          <ceqOp/>
        </btypes:TYPE>) as follows:
      </p>
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre/>
            <tyConc>
              <ceq>                
                <type/>
                <type/>
              </ceq>
            </tyConc>                
          </tyRule>   
          <tyRule>
            <tyPre>
              <ceq>                
                <type/>
                <type dash="'"/>
              </ceq>	    
            </tyPre>
            <tyConc>
              <ceq>                
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </ceq>
            </tyConc>                
          </tyRule>   
          <tyRule>
            <tyPre>
              <ceq>                
                <type/>
                <type dash="'"/>
              </ceq>	    
            </tyPre>
            <tyConc>
              <ceq>
                <mutable>
                  <type/>
                </mutable>
                <type dash="'"/>
              </ceq>
            </tyConc>                
          </tyRule>   
        </Hrules>
      </btypes:TYPE>
    </definition>
    <p>
      In terms of the copy-coercion rules shown in
      Figure&nbsp;<xref ref="decl_rules"/>, we can define copy
      compatibility as: 
    </p>
    <example>
      <p>
        <btypes:TYPE>
          <equiv>
            <ceq>
              <type num="1"/>
              <type num="2"/>
            </ceq>
            <Tsub>
              <type num="1"/>
              <minz>
                <type num="2"/>
              </minz>
            </Tsub>
          </equiv>              
        </btypes:TYPE>
      </p>
    </example>
    <definition id="max_min">      
      <title>Max and Min Mutability</title>      
      <p> 
        The operators
        <btypes:TYPE><maxzOp/></btypes:TYPE> and
        <btypes:TYPE><minzOp/></btypes:TYPE> increase or
        decrease the mutability of a type, and are defined as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <eq>                
              <maxz>
                <mutable>
                  <type/>
                </mutable>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            <text content="  and  "/>
            <eq> 
              <maxz>
                <type/>
              </maxz>
              <mutable>
                <type/>
              </mutable>
            </eq>
            `<text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
	    <br/>
            <eq>                
              <minz>
                <mutable>
                  <type/>
                </mutable>
              </minz>
              <type/>
            </eq>
            <text content="  and  "/>
            <eq> 
              <minz>
                <type/>
              </minz>
              <type/>
            </eq>
            <text content=", where "/>
            <neq>                
              <type/>
              <mutable>
                <type dash="'"/>
              </mutable>
            </neq>
          </btypes:TYPE> 
        </p>
      </example>
    </definition>
    <p>
      It is obvious that 
      <btypes:TYPE>
        <forall>
          <type/>
          <ceq> 
            <minz>
              <type/>
            </minz>
            <type/>
            <maxz>
              <type/>
            </maxz>
          </ceq>
        </forall>
        <text content=", and "/>
        <forall>
          <type/>
          <type dash="'"/>
          <iff>
            <ceq> 
              <type/>
              <type dash="'"/>
            </ceq>
            <eq>
              <minz>
                <type/>
              </minz>
              <minz>
                <type dash="'"/>
              </minz>
            </eq>
            <eq>
              <maxz>
                <type/>
              </maxz>
              <maxz>
                <type dash="'"/>
              </maxz>
            </eq>                
          </iff>
        </forall>          
        <text content="."/>
      </btypes:TYPE>
    </p>
    <definition id="ftvs">
      <title>Free Type Variables</title>
      <p>
        We denote the set of free type variables in a type
        <btypes:TYPE><type/></btypes:TYPE> as
        <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>. 
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <eq>
              <ftvs>
                <tvar name="alpha"/>
              </ftvs>
              <tvar name="alpha"/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <unit/>
              </ftvs>
              <empty/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <bool/>
              </ftvs>
              <empty/>                
            </eq>
            <br/>
            <eq>
              <ftvs>
                <ref>
                  <type/>
                </ref>
              </ftvs>
              <ftvs>                  
                <type/>                  
              </ftvs>
            </eq>              
            <br/>
            <eq>
              <ftvs>
                <mutable>
                  <type/>
                </mutable>
              </ftvs>
              <ftvs>                  
                <type/>                  
              </ftvs>
            </eq>          
            <br/>
            <eq>
              <ftvs>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </ftvs>                                  
              <unin>
                <ftvs>
                  <type num="1"/>
                </ftvs>                    
                <ftvs>
                  <type num="2"/>
                </ftvs>                    
              </unin>                
            </eq>          
            <br/>
            <eq>
              <ftvs>
                <types num="i"/>
              </ftvs>
              <Unin>
                <ftvs>
                  <type num="i"/>
                </ftvs>
              </Unin>
            </eq>
            <br/>
            <eq>
              <ftvs>
                <aTS/>
              </ftvs>
              <unin>
                <ftvs>
                  <tvars name="alpha"/>
                </ftvs>
                <ftvs>
                  <type/>
                </ftvs>                  
              </unin>
            </eq>
            <text content=" where "/>
            <eq>
              <aTS/>
              <forall>
                <tvars name="alpha"/>
                <type/>
              </forall>
            </eq>              
            <br/>
            <eq>
              <ftvs>
                <gamma/>
              </ftvs>
              <Unin>
                <ftvs>
                  <aTS num="i"/>
                </ftvs>
              </Unin>                  
            </eq>
            <text content=" ; "/>
            <Forall/>
            <in>
              <mapping>
                <id/>
                <aTS num="i"/>
              </mapping>
              <gamma/>
            </in>
            <br/>
            <eq>
              <ftvs>
                <store/>
              </ftvs>
              <Unin>
                <ftvs>
                  <type num="i"/>
                </ftvs>
              </Unin>                  
            </eq> 
            <text content=" ; "/>
            <Forall/>
            <in>
              <mapping>
                <loc/>
                <type num="i"/>
              </mapping>
              <store/>
            </in>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <definition id="val_res">
      <title>Value Restriction</title>
      <p>
        We define some definitions used in the enforcement of value
        restriction in Figure&nbsp;<xref ref="decl_rules"/>.
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="Value">
              <aVal/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <id/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <hLoc/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <sLoc/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <dup>
                <aExpr/>
              </dup>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <deref>
                <aExpr/>
              </deref>
              <pred name="Value">
                <aExpr/>
              </pred>
            </fnxn>
            <br/>
            <eq>
              <grouping>
                <pred name="Value">
                  <if>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                    <aExpr num="3"/>
                  </if>
                </pred>
                <br/>
              </grouping>
              <AND>
                <pred name="Value">
                  <aExpr num="1"/>
                </pred>
                <pred name="Value">
                  <aExpr num="2"/>
                </pred>
                <pred name="Value">
                  <aExpr num="3"/>
                </pred>
              </AND>
            </eq>
            <br/>
            <fnxn name="Value">
              <let>
                <id/>
                <aExpr num="1"/>
                <aExpr num="2"/>
              </let>
              <AND>
                <pred name="Value">
                  <aExpr num="1"/>
                </pred>
                <pred name="Value">
                  <aExpr num="2"/>
                </pred>
              </AND>
            </fnxn>
            <br/>
            <fnxn name="Value">
              <aExpr/>
              <FALSE/>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Expansive">
              <aExpr/>
              <NOT>
                <pred name="Value">
                  <aExpr/>
                </pred>
              </NOT>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Immut">
              <unit/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <bool/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <tvar name="alpha"/>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>
              <TRUE/>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <ref>
                <type/>
              </ref>                
              <pred name="Immut">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <forall>
                <tvars name="alpha"/>
                <type/>
              </forall>
              <pred name="Immut">                
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="Immut">
              <type/>
              <FALSE/>
            </fnxn>
            <br/>
            <br/>
            <fnxn name="Mut">
              <type/>
              <NOT>
                <pred name="Immut">
                  <type/>
                </pred>
              </NOT>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <definition>
      <title>Stack and Heap Typing</title>
      <p>
        A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
        <btypes:TYPE><stack/></btypes:TYPE> are said to be
        <em>well typed</em> with respect to a binding context 
        <btypes:TYPE><gamma/></btypes:TYPE> and store typing
        <btypes:TYPE><store/></btypes:TYPE>, and written 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge>
          <text content=" if "/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <dom><store/></dom>
                <unin>
                  <dom><heap/></dom>
                  <dom><stack/></dom>
                </unin>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <forall>
                <in>
                  <hLoc/>
                  <dom><heap/></dom>
                </in>
              </forall>
              <text content=", "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <mapsto><heap/><hLoc/></mapsto>
                  <mapsto><store/><hLoc/></mapsto>
                </Tsub>
              </Sjudge>            
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <forall>
                <in>
                  <sLoc/>
                  <dom><stack/></dom>
                </in>
              </forall>
              <text content=", "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <mapsto><stack/><sLoc/></mapsto>
                  <mapsto><store/><sLoc/></mapsto>
                </Tsub>
              </Sjudge>            
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>      
    <lemma id="T-inversion">
      <title>Inversion of Typing Relation</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <Unit/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <unit/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <true/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <false/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <hLoc/>
                <type/>
              </TDjudge>
              <text content=" then "/>                
              <eq>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>
              </eq>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <lambda>
                  <id/>
                  <aExpr/>
                </lambda>
                <type/>
              </TDjudge>
              <text content=" then "/>
              <eq>
                <type/>
                <fn>
                  <type num="1" dash="'"/>
                  <type num="2" dash="'"/>
                </fn>
              </eq>
              <text content=" such that "/>
              <eq>
                <type num="1" dash="'"/>
                <minz>
                  <type num="1"/>
                </minz>
              </eq>
              <text content=", "/>
              <eq>
                <type num="2" dash="'"/>
                <maxz>
                  <type num="2"/>
                </maxz>
              </eq>
              <text content=", and, "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                        
                      <type num="1"/>                        
                    </mapping>
                  </extend>
                  <store/>
                </assume>                  
                <tqExpr>
                  <aExpr/>                    
                  <type num="2"/>                    
                </tqExpr>            
              </Sjudge>
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li> 
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <TDjudge>
                <deref>
                  <aExpr/>
                </deref>
                <type/>
              </TDjudge>
              <text content=" then "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <Tsub>
                  <aExpr/>                      
                  <type dash="'"/>
                </Tsub>                    
              </Sjudge>                  
              <text content="."/>                
            </btypes:TYPE>
          </p>
        </li>          
        <li>
          <p>
            Other cases are similar.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Immediate from the definition of typing relation.
      </p>
    </proof>
    <lemma id="T-sub-inversion">
      <title>Inversion of Copy Coercion</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <bool/>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <bool/>
              </eq>
              <text content=" or "/>                
              <eq>
                <type/>
                <mutable>
                  <bool/>
                </mutable>
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <unit/>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <unit/>
              </eq>
              <text content=" or "/>                
              <eq>
                <type/>
                <mutable>
                  <bool/>
                </mutable>
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>                  
              </eq>
              <text content=" or "/>
              <eq>
                <type/>
                <mutable>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>     
                </mutable>             
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <ref>
                  <type dash="'"/>
                </ref>                  
              </eq>
              <text content=" or "/>
              <eq>
                <type/>
                <mutable>
                  <ref>
                    <type dash="'"/>
                  </ref>                  
                </mutable>             
              </eq>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </Tsub>
              <text content=" then "/>                
              <eq>
                <type/>
                <mutable>
                  <type dash="''"/>
                </mutable>
              </eq>
              <text content=" such that "/>                
              <Tsub>
                <type dash="''"/>
                <type dash="'"/>                  
              </Tsub>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/> 
              <Tsub>
                <type/>
                <mutable>
                  <type dash="'"/>
                </mutable>
              </Tsub>
              <text content=" then "/>                
              <Tsub>
                <type/>
                <type dash="'"/>
              </Tsub>
              <text content="."/>                                
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the copy coercion derivation. 
      </p>
    </proof>
    <lemma id="T-canonical">
      <title>Canonical Forms</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
                <text content=" is a value, and "/>                
                <TDjudge sub="yes">
                  <aVal/>
                  <unit/>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <Unit/>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <bool/>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is either "/>
              <true/>
              <text content=" or "/>
              <false/>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <ref><type/></ref>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <hLoc/>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <aVal/>
              <text content=" is a value, and "/>
              <TDjudge sub="yes">
                <aVal/>
                <fn><type num="1"/><type num="2"/></fn>
              </TDjudge>
              <text content=", then, "/>
              <aVal/>
              <text content=" is "/>
              <lambda><id/><aExpr/></lambda>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of
        <btypes:TYPE>
          <TDjudge sub="yes">
            <aVal/>
            <type/>
          </TDjudge>
        </btypes:TYPE>.
      </p>
      <p>
        If 
        <btypes:TYPE>
          <TDjudge sub="yes">
            <aVal/>
            <bool/>
          </TDjudge>
        </btypes:TYPE>, 
        
        we have
        <btypes:TYPE>
          <TDjudge>
            <aVal/>
            <type/>
          </TDjudge>
          <text content=" and "/>
          <Tsub>
            <type/>
            <bool/>
          </Tsub>
        </btypes:TYPE> 
        
        by Inversion of copy coercion relation,
        <btypes:TYPE>
          <eq>
            <type/>
            <bool/>
          </eq>
          <text content=" or "/>
          <eq>
            <type/>
            <mutable>
              <bool/>
            </mutable>
          </eq>
        </btypes:TYPE>.
        
        If 
        <btypes:TYPE>
          <eq>
            <type/>
            <bool/>
          </eq>
        </btypes:TYPE>, it is clear that the final rule in the
        derivation must be T-True, or T-False, in which case the
        result is immediate. 

        The case  
        <btypes:TYPE>
          <eq>
            <type/>
            <mutable>
              <bool/>
            </mutable>
          </eq>
        </btypes:TYPE> cannot happen because there is no rule that
        derives a mutable type for a value, and we assume that the
        induction hypothesis 
        <btypes:TYPE>
          <TDjudge>
            <aVal/>
            <type/>
          </TDjudge>
        </btypes:TYPE> holds.
      </p>
      <p>
        Other cases of the lemma are similar.
      </p>
    </proof>
    <lemma id="T-progress">
      <title>Progress</title>
      <p>
        <btypes:TYPE>
          <text content="If "/>
          <aExpr/>
          <text content=" is a closed, well typed term, "/> 
          <text content="that is, "/> 
          <Sjudge>
            <assume>
              <Empty/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" for some "/> 
          <type/>
          <text content=" and "/> 
          <store/>
          <text content=", given any heap "/> 
          <heap/>
          <text content=" and stack "/> 
          <stack/>
          <text content=" such that "/> 
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=", "/>            
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content=" If "/>                
              <Sjudge name="lval">
                <assume/>
                <aExpr/>
              </Sjudge>
              <text content=", then "/>              
              <aExpr/>
              <text content=" is either a valid lvalue "/> 
              <lVal/>
              <text content=" (that is, "/>
              <eq>
                <lVal/>
                <sLoc/>
              </eq>
              <text content=", "/>
              <in>
                <sLoc/>
                <dom>
                  <stack/>
                </dom>
              </in>
              <text content=" or "/> 
              <eq>
                <lVal/>
                <deref>
                  <hLoc/>
                </deref>
              </eq>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <heap/>
                </dom>
              </in>
              <text content=") or else "/>
              <Exists>
                <aExpr dash="'"/>
                <stack dash="'"/>
                <heap dash="'"/>
              </Exists>
              <text content=" such that:"/>               
              <leval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </leval>
              <text content="."/>   
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>              
            <btypes:TYPE>
              <aExpr/>
              <text content=" is a value "/> 
              <aVal/>
              <text content=" or else "/> 
              <Exists>
                <aExpr dash="'"/>
                <stack dash="'"/>
                <heap dash="'"/>
              </Exists>
              <text content=" such that "/>               
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
            (Values) Result is immediate for right execution, and
            cannot happen for right execution
          </p>
        </li>
        <li>
          <p>
            Case T-Id: cannot happen, there is no execution rule for
            variables. 
          </p>
        </li>
        <li>
          <p>
            Case T-Sloc: Immediate for left execution. Right
            execution and can always continue with E-Rval rule as the
            stack is well typed 
            (<btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge> 
            </btypes:TYPE>).
          </p>
        </li>
        <li>
          <p>
            Case T-App: Only right execution is possible, no application is well
            typed as an lvalue. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <apply>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </apply>                  
              </eq>
              <text content=", "/>
              <Tsub>
                <aExpr num="1"/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>                  
              <text content=", and "/>
              <Tsub>
                <aExpr num="2"/>
                <type num="1"/>
              </Tsub>                
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
              <text content=" or "/>
              <aExpr num="2"/>
            </btypes:TYPE>
            is not a value, we can take E-App1# or
            E-App2#. Otherwise, when both 
            <btypes:TYPE>
              <aExpr num="1"/>
              <text content=" and "/>
              <aExpr num="2"/>
            </btypes:TYPE>
            are values, by canonical forms lemma, 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is of the form
            <btypes:TYPE>
              <lambda>
                <id/>
                <aExpr dash="'"/>
              </lambda>
            </btypes:TYPE>,
            and we can take the step E-App. 
          </p>
        </li>
        <li>
          <p>
            Case T-If: Similar to T-App, only right execution is
            permitted.
          </p>
        </li>
        <li>
          <p>
            Case T-Set: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <assign>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </assign>  
              </eq>
              <text content=", "/>
              <Tsub>
                <aExpr num="1"/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </Tsub>                  
              <text content=", "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <mutable>
                  <type/>
                </mutable>
              </TDjudge>
              <text content=", "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type/>
              </TDjudge>
              <text content=", and "/>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            not an lvalue, since we have  
            <btypes:TYPE>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>
            </btypes:TYPE>
            we can take E-:=lhs# by induction hypothesis.
            Similarly, if 
            <btypes:TYPE>
              <aExpr num="2"/>
            </btypes:TYPE>
            is not a value, we can take E-:=rhs#.
            Finally, if
            <btypes:TYPE>
              <eq>
                <aExpr num="1"/>
                <lVal/>
              </eq>
              <text content=" and "/>
              <eq>
                <aExpr num="1"/>
                <aVal/>
              </eq>
            </btypes:TYPE>,
            we can take the step E-:=Stack or E-:=Heap as
            applicable. 
          </p>
        </li>
        <li>
          <p>
            Case T-Dup: Only right execution is
            permitted, and can take E-Dup# or E-Dup as
            applicable. 
          </p>
        </li>
        <li>
          <p>
            Case T-Deref: We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <deref>
                  <aExpr num="1"/>
                </deref>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>                  
                <ref>
                  <type/>
                </ref>                  
              </TDjudge>
            </btypes:TYPE>.
            Execution can take EL-^# or E-^# as
            applicable if  
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value.
            If 
            <btypes:TYPE>
              <Tsub>
                <aExpr num="1"/>
                <ref>
                  <type/>
                </ref>
              </Tsub>
            </btypes:TYPE>
            is a value, then, from the canonical forms lemma, 
            <btypes:TYPE>
              <eq>
                <aExpr num="1"/>
                <hLoc/>
              </eq>
              <text content=", "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
            </btypes:TYPE>.            
            Now, since this is an lvalue, we are done in the case of
            left execution. In the case of right execution, we can
            take step E-^ since the heap is well typed 
            (<btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge> 
            </btypes:TYPE>).
          </p>
        </li>
        <li>
          <p>
            Case T-Let-M: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="m">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=", "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=", "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=", and"/>
              <Sjudge name="loc">
                <assume/>
                <tqExpr>
                  <id/>
                  <aTS/>	
                </tqExpr>
              </Sjudge>
              <text content=", and"/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value, we can take E-Let#.
            Otherwise, we can take E-Let-M.              
          </p>
        </li>
        <li>
          <p>
            Case T-Let-P: Only right execution is applicable. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="m">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=", "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=", "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=", and"/>
              <Sjudge name="term">
                <assume/>
                <tqExpr>
                  <id/>
                  <aTS/>	
                </tqExpr>
              </Sjudge>
              <text content=", and"/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            If 
            <btypes:TYPE>
              <aExpr num="1"/>
            </btypes:TYPE>
            is not a value, we can take E-Let#.
            Otherwise, can take E-Let-P.
          </p>
        </li>
        <li>
          <p>
            Case T-TqExpr and Case T-Let-M-Tq, T-Let-P-Tq are
            similar.  
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="T-Weakening">
      <title>Weakening</title>
      <p>
        We will write
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <GEN>
                <type/>
                <aTS/>
              </GEN>
            </tqExpr>
          </Sjudge>
          <text content=" as a shorthand for "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", and "/>            
          <Sjudge name="gen">
            <assume>
              <gamma/>
              <store/>
              <aExpr/>
            </assume>
            <GEN>
              <type/>
              <aTS/>
            </GEN>
          </Sjudge>
          <text content="."/>
        </btypes:TYPE>           
      </p>
      <ol>
        <li>          
          <p>
            If 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <type/>
                </tqExpr>
              </Sjudge>                
            </btypes:TYPE>
            then,
          </p>
          <ol>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <gamma dash="'"/>
                    <gamma/>
                  </supeq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma dash="'"/>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <type/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <GEN>
                    <type/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
              <text content=", "/>
              <eq>
                <aTS/>
                <forall>
                  <tvars name="alpha"/>
                  <type/>
                </forall>
              </eq>
            </btypes:TYPE>
          </p>
          <ol>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <gamma dash="'"/>
                    <gamma/>
                  </supeq>                
                  <text content=" and "/>
                  <eq>
                    <inter>
                      <ftvs>
                        <gamma dash="'"/>
                      </ftvs>
                      <ftvs>
                        <tvars name="alpha"/>
                      </ftvs>
                    </inter>
                    <Empty/>
                  </eq>
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma dash="'"/>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <GEN>
                        <type/>
                        <aTS/>
                      </GEN>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" and "/>
                  <eq>
                    <inter>
                      <ftvs>
                        <store dash="'"/>
                      </ftvs>
                      <ftvs>
                        <tvars name="alpha"/>
                      </ftvs>
                    </inter>
                    <Empty/>
                  </eq>               
                  <text content=" then "/>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <aExpr/>
                      <GEN>
                        <type/>
                        <aTS/>
                      </GEN>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Straightforward induction on the typing derivation.
      </p>
    </proof>
    <lemma id="T-VSubstitution">
      <title>Value Substitution</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <aTS/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", "/>            
          <pred name="Immut">
            <aTS/>
          </pred>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aVal/>
              <type num="v"/>
            </tqExpr>
          </Sjudge>
          <text content=", and "/>
          <Sjudge name="gen">
            <assume>
              <gamma/>
              <store/>
              <aExpr/>
            </assume>
            <GEN>
              <type num="v"/>
              <aTS/>
            </GEN>
          </Sjudge>
          <text content=" then "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <subst>
                <aExpr/>
                <id/>
                <aVal/>
              </subst>
              <type/>
            </tqExpr>
          </Sjudge>            
        </btypes:TYPE>          
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation of
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <aTS/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>.
        We proceed by case analysis on the final step of the
        derivation. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Id: We have 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <id name="y"/>
              </eq>
              <text content=" where "/>
              <in>
                <id name="y"/>
                <extend>
                  <gamma/>
                  <id/>
                  <aTS/>
                </extend>
              </in>
            </btypes:TYPE>.
          </p>
          <p>
            There are two sub cases to consider. If 
            <btypes:TYPE>
              <eq>
                <id name="x"/>
                <id name="y"/>
              </eq>
            </btypes:TYPE>,
            then, 
            <btypes:TYPE>
              <eq>
                <subst>
                  <id name="y"/>
                  <id name="x"/>
                  <aVal/>
                </subst>
                <aVal/>                
              </eq>
            </btypes:TYPE>,
            and the result type 
            <btypes:TYPE>
              <type/>
            </btypes:TYPE> is an instantiation of the type scheme 
            <btypes:TYPE>
              <aTS/>
            </btypes:TYPE>.
            One of the assumptions of the lemma states that
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <aVal/>
                  <GEN>
                    <type num="v"/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>. That is, 
            <btypes:TYPE>
              <spEq>
                <type/>
                <aTS/>
              </spEq>
            </btypes:TYPE>, and we can infer any more-specific type
            (and in particular the type being instantiated at the
            T-Id rule) instead for this substitution of the
            expression    
            <btypes:TYPE>
              <aVal/>
            </btypes:TYPE>.
            Therefore, we have
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <aExpr/>
                    <id/>
                    <aVal/>
                  </subst>
                  <type/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.
          </p>
          <p>
            If 
            <btypes:TYPE>
              <neq>
                <id name="x"/>
                <id name="y"/>
              </neq>
            </btypes:TYPE>, then 
            <btypes:TYPE>
              <eq>
                <subst>
                  <id name="y"/>
                  <id name="x"/>
                  <aVal/>
                </subst>
                <id name="y"/>
              </eq>
            </btypes:TYPE>,
            and the result is immediate.
          </p>
        </li>
        <li>
          <p>
            Case T-Lambda: We have 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <lambda>
                  <id name="y"/>
                  <aExpr dash="'"/>
                </lambda>
              </eq>
              <text content=", and "/>
              <eq>
                <type/>
                <fn>
                  <type num="1"/>
                  <type num="2"/>
                </fn>
              </eq>
              
              <text content=", and "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id/>
                      <aTS/>
                    </tqExpr>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <aExpr dash="'"/>
                  <type num="2"/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.              
          </p>
          <p>
            We can assume that
            <btypes:TYPE>
              <neq>
                <id/>
                <id name="y"/>
              </neq>
            </btypes:TYPE>.
            Since it is clear that the type
            <btypes:TYPE>
              <type num="1"/>
            </btypes:TYPE>
            of 
            <btypes:TYPE>
              <id name="y"/>
            </btypes:TYPE>
            can either use variables already in               
            <btypes:TYPE>
              <gamma/>
            </btypes:TYPE>
            or fresh type variables, we know that 
            <btypes:TYPE>
              <eq>
                <inter>
                  <ftvs>
                    <extend>
                      <gamma/>
                      <tqExpr>
                        <id name="y"/>
                        <type num="1"/>
                      </tqExpr>
                    </extend>
                  </ftvs>
                  <ftvs>
                    <aTS/>
                  </ftvs>
                </inter>
                <Empty/>
              </eq>
            </btypes:TYPE>.
            Thus, by weakening lemma, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <aVal/>
                  <GEN>
                    <type num="v"/>
                    <aTS/>
                  </GEN>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>
            , and, by induction hypothesis, 
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <tqExpr>
                      <id name="y"/>
                      <type num="1"/>
                    </tqExpr>
                  </extend>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <aExpr dash="'"/>
                    <id/>
                    <aVal/>
                  </subst>
                  <type num="2"/>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>.
            Finally, by the T-Lambda rule, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <lambda>
                    <id num="y"/>
                    <paren>
                      <subst>
                        <aExpr dash="'"/>
                        <id/>                      
                        <aVal/>
                      </subst>
                    </paren>
                  </lambda>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>, and thus
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <tqExpr>
                  <subst>
                    <lambda>
                      <id num="y"/>
                      <aExpr dash="'"/>
                    </lambda>                    
                    <id/>                      
                    <aVal/>                  
                  </subst>
                  <fn>
                    <type num="1"/>
                    <type num="2"/>
                  </fn>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>, which is the desired result.
          </p>
        </li>
        <li>
          <p>
            T-Set case is similar, except that the substitution
            cannot happen on the LHS of an assignment, since we do
            not perform substitution of mutable values. 
          </p>
        </li>
        <li>
          <p>
            Other cases are similar.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="T-LSubstitution">
      <title>Location Substitution</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <type num="0"/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=", and for some "/>
          <supeq>
            <store dash="'"/>
            <store/>
          </supeq>
          <text content=", "/>
          <tqExpr>
            <mapsto>
              <store/>
              <sLoc/>
              <type num="0"/>
            </mapsto>
          </tqExpr>
          <text content=", then "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store dash="'"/>
            </assume>
            <tqExpr>
              <subst>
                <aExpr/>
                <id/>
                <sLoc/>
              </subst>
              <type/>
            </tqExpr>
          </Sjudge>            
        </btypes:TYPE>.          
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the typing derivation of
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <extend>
                <gamma/>
                <tqExpr>
                  <id/>
                  <type/>
                </tqExpr>
              </extend>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, similar to lemma <xref
          ref="T-VSubstitution"/>.
      </p>
    </proof>
    <lemma id="T-sh-safety">
      <title>Stack and Heap Assignment</title>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <extend>
                    <heap/>
                    <mapping>
                      <hLoc/>
                      <aVal/>
                    </mapping>
                  </extend>
                  <stack/>
                </plus>
              </Sjudge>
              <text content=", and "/>
              <Tsub>
                <mapsto>
                  <store/>
                  <hLoc/>
                </mapsto>
                <type/>
              </Tsub>
              <text content=", and "/>
              <TDjudge>
                <aVal dash="'"/>
                <type/>
              </TDjudge>
              <text content=", then, "/>               
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <extend>
                    <heap/>
                    <mapping>
                      <hLoc/>
                      <aVal dash="'"/>
                    </mapping>
                  </extend>
                  <stack/>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="Similarly, if "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <extend>
                    <stack/>
                    <mapping>
                      <sLoc/>
                      <aVal/>
                    </mapping>
                  </extend>
                </plus>
              </Sjudge>
              <text content=" and  "/>
              <Tsub>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
                <type/>
              </Tsub>
              <text content=", and "/>
              <TDjudge>
                <aVal dash="'"/>
                <type/>
              </TDjudge>
              <text content=", then, "/>                 
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <extend>
                    <stack/>
                    <mapping>
                      <sLoc/>
                      <aVal dash="'"/>
                    </mapping>
                  </extend>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Immediate from the definition of stack and heap typing.
      </p>
    </proof>
    <lemma id="T-preservation">
      <title>Preservation</title>
      <p>
        <btypes:TYPE>          
          <text content="If "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=" then, "/>    
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <leval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </leval>
              <text content=", then, there exists a "/>
              <supeq>
                <store dash="'"/>
                <store/>
              </supeq>
              <text content=" such that "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <tqExpr>
                  <aExpr dash="'"/>
                  <type/>
                </tqExpr>                    
              </Sjudge>
              <text content=" and "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <plus>
                  <heap dash="'"/>
                  <stack dash="'"/>
                </plus>
              </Sjudge>
              <text content="."/>
            </btypes:TYPE>              
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>          
              <text content="If "/>
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
              <text content=", there exists a "/>
              <supeq>
                <store dash="'"/>
                <store/>
              </supeq>                
              <text content=" such that "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <Tsub>
                  <aExpr dash="'"/>
                  <type dash="'"/>
                </Tsub>                    
              </Sjudge>
              <text content=",  "/>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store dash="'"/>
                </assume>
                <plus>
                  <heap dash="'"/>
                  <stack dash="'"/>
                </plus>
              </Sjudge>
              <text content=" and "/>
              <eq>
                <minz>
                  <type/>
                </minz>
                <minz>
                  <type dash="'"/>
                </minz>
              </eq>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>. We proceed by the case analysis of the final
        step. 
      </p>
      <ol>
        <li>
          <p>
            Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot
            happen. 
          </p>
        </li>
        <li>
          <p>
            Case T-Sloc: Only right execution is applicable. 
            We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <sLoc/>
              </eq>
              <text content=" and "/>
              <tqExpr>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
                <type/>
              </tqExpr>
            </btypes:TYPE>.
            The only applicable step is E-Rval, and we have
            <btypes:TYPE>
              <eq>
                <aExpr dash="'"/>
                <mapsto>
                  <stack/>
                  <sLoc/>
                </mapsto>
              </eq>
            </btypes:TYPE>.
            From the definition of stack typing, we have:
            <btypes:TYPE>
              <Tsub>
                <mapsto>
                  <stack/>
                  <sLoc/>
                </mapsto>
                <mapsto>
                  <store/>
                  <sLoc/>
                </mapsto>
              </Tsub>
            </btypes:TYPE>              
            and thus 
            <btypes:TYPE>
              <Tsub>
                <aExpr dash="'"/>
                <type/>
              </Tsub>
            </btypes:TYPE>              
            which implies
            <btypes:TYPE>              
              <eq>
                <minz>
                  <type/>
                </minz>
                <minz>
                  <type dash="'"/>
                </minz>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Case T-App:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <apply>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </apply>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <fn>
                  <type num="2"/>
                  <type num="0"/>
                </fn>
              </TDjudge>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type num="2"/>
              </TDjudge>
              <text content=", and "/>
              <Tsub>
                <type num="0"/>
                <type/>
              </Tsub>
              <text content=", and "/>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
              <text content = " where "/>
              <eq>
                <type num="2"/>
                <minz>
                  <type num="2" dash="'"/>
                </minz>
              </eq>                
              <eq>
                <type num="0"/>
                <maxz>
                  <type num="0" dash="'"/>
                </maxz>
              </eq>
              <text content=" and "/>
            </btypes:TYPE>.
          </p>
          <p>              
            This cannot happen for left execution. 
            For right execution, we proceed by further case
            analysis of the applicable execution rules for
            <btypes:TYPE>
              <eval>
                <opState>
                  <stack/>
                  <heap/>
                  <aExpr/>
                </opState>
                <opState>
                  <stack dash="'"/>
                  <heap dash="'"/>
                  <aExpr dash="'"/>
                </opState>
              </eval>
            </btypes:TYPE>.
          </p>
          <ol>
            <li>
              <p>
                Case E-App1#:
                We have:
                <btypes:TYPE>
                  <eval>
                    <opState>
                      <stack/>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                  <text content=" and "/>
                  <eq>
                    <aExpr dash="'"/>
                    <apply>
                      <aExpr num="1" dash="'"/>
                      <aExpr num="2"/>
                    </apply>
                  </eq>
                </btypes:TYPE>.
                By induction hypothesis, we have:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <Tsub>
                      <aExpr num="1" dash="'"/>
                      <fn>
                        <type num="2"/>
                        <type num="0"/>
                      </fn>     
                    </Tsub>                 
                  </Sjudge>                    
                  <text content=" for some "/>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                </btypes:TYPE>.
                One of the assumptions of the T-App rule states that 
                <btypes:TYPE>                    
                  <TDjudge sub="yes">
                    <aExpr num="2"/>
                    <type num="2"/>
                  </TDjudge>
                </btypes:TYPE>, and by weakening lemma, we have, 
                <btypes:TYPE>                    
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <Tsub>
                      <aExpr num="2"/>
                      <type num="2"/>
                    </Tsub>
                  </Sjudge>
                </btypes:TYPE>. Finally, by the T-App rule, we
                conclude that
                <btypes:TYPE>                    
                  <tqExpr>
                    <paren>
                      <apply>
                        <aExpr num="1" dash="'"/>                        
                        <aExpr num="2"/>
                      </apply>
                    </paren>
                    <type/>
                  </tqExpr>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                Case E-App2#: Similar to the previous
                sub-case. 
              </p>
            </li>
            <li>
              <p>
                Case E-App: We have:
                <btypes:TYPE>
                  <eq>
                    <aExpr num="1"/>
                    <lambda>
                      <id/>
                      <aExpr num="0"/>
                    </lambda>
                  </eq>
                  <text content=" and "/>
                  <eq>
                    <aExpr num="2"/>
                    <aVal/>
                  </eq>
                  <text content=" and "/>
                  <text content=" and "/>
                  <eq>
                    <aExpr dash="'"/>
                    <subst>
                      <aExpr num="0"/>
                      <id/>
                      <sLoc/>
                    </subst>
                  </eq>
                  <text content=" and "/>
                  <eval>
                    <opState>
                      <extend>
                        <stack/>
                        <mapping>
                          <sLoc/>
                          <aVal/>
                        </mapping>
                      </extend>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                </btypes:TYPE>.
              </p>
              <p>
                By the inversion lemma for 
                <btypes:TYPE>
                  <lambda>
                    <id/>
                    <aExpr num="0"/>
                  </lambda>
                </btypes:TYPE> we have
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <gamma>
                          <id/>
                          <type num="2" dash="'"/>
                        </gamma>
                        <store/>
                      </extend>
                    </assume>
                    <tqExpr>
                      <aExpr num="0"/>
                      <type num="0" dash="'"/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
              <p>
                Further from location substitution lemma, we have 
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <gamma/>
                      <store dash="'"/>
                    </assume>
                    <tqExpr>
                      <subst>
                        <aExpr num="0"/>
                        <id/>
                        <sLoc/>
                      </subst>
                      <type num="0" dash="'"/>
                    </tqExpr>
                  </Sjudge>
                  <text content=" where "/>
                  <supeq>
                    <store dash="'"/>
                    <store/>
                  </supeq>
                  <text content=" and "/>
                  <tqExpr>
                    <mapsto>
                      <store/>
                      <sLoc/>
                    </mapsto>
                    <type num="2" dash="'"/>
                  </tqExpr>
                </btypes:TYPE>.
              </p>
              <p>
                Thus, we have 
                <btypes:TYPE>
                  <Tsub>
                    <type num="0"/>
                    <type num="0" dash="'"/>
                  </Tsub>
                  <text content=" and "/>
                  <Tsub>
                    <type num="0"/>
                    <type/>
                  </Tsub>
                </btypes:TYPE>.
                Therefore, it is clear that
                <btypes:TYPE>
                  <eq>
                    <minz>
                      <type num="0" dash="'"/>
                    </minz>
                    <minz>
                      <type/>
                    </minz>
                  </eq>
                </btypes:TYPE>.                  
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Case T-Set:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <assign>
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </assign>
              </eq>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>
                <mutable>
                  <type/>
                </mutable>
              </TDjudge>
              <text content=", and "/>
              <TDjudge sub="yes">
                <aExpr num="2"/>
                <type/>
              </TDjudge>
              <Sjudge name="lval">
                <assume/>                  
                <aExpr num="1"/>                  
              </Sjudge>                
            </btypes:TYPE>
          </p>
          <p>
            If the step taken is E-:=#lhs or E-:=#rhs,
            the result follows from the induction hypothesis and
            T-Set rule (as in the case of T-App).               
            If the step taken is E-:=Stack or E-:=Heap, the
            result follows from the stack and heap assignment lemma.
          </p>
        </li>
        <li>
          <p>
            Case T-Deref: We have: 
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <deref>
                  <aExpr dash="'"/>
                </deref>
              </eq>
              <text content=" and "/>
              <TDjudge sub="yes">
                <aExpr dash="'"/>                  
                <ref>
                  <type/>
                </ref>                  
              </TDjudge>
            </btypes:TYPE>.
            If the step taken is EL-^# or E-^#,
            the result follows from induction hypothesis and T-Deref
            rule. 
            If the step taken is E-^ (right execution only) 
            <btypes:TYPE>
              <aExpr dash="'"/>                  
            </btypes:TYPE> is a value, and from canonical forms
            lemma, we know that 
            <btypes:TYPE>
              <eq>
                <aExpr dash="'"/>                  
                <hLoc/>
              </eq>
              <text content=" and "/>
              <in>
                <hLoc/>
                <dom>
                  <store/>
                </dom>
              </in>
            </btypes:TYPE>
            and the result follows from the fact that
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <plus>
                  <heap/>
                  <stack/>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Case T-Let-P: Right execution only. We have:
            <btypes:TYPE>
              <eq>
                <aExpr/>
                <paren>
                  <let kind="p">
                    <id/>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </let>
                </paren>
              </eq>
              <text content=" and "/>
              <TDjudge sub="yes">
                <aExpr num="1"/>                
                <type num="1"/>                
              </TDjudge>
              <text content=" and "/>
              <Tsub>
                <type/>
                <type num="1"/>
              </Tsub>
              <text content=" and "/>
              <Sjudge name="gen">
                <assume>
                  <gamma/>
                  <store/>
                  <aExpr num="1"/>
                </assume>                
                <GEN>
                  <type/>
                  <aTS/>
                </GEN>
              </Sjudge>      
              <text content=" and "/>
              <Sjudge>
                <assume>
                  <extend>
                    <gamma/>
                    <mapping>
                      <id/>                      
                      <aTS/>
                    </mapping>
                  </extend>
                  <store/>
                </assume>                
                <tqExpr>
                  <aExpr num="2"/>
                  <type num="2"/>
                </tqExpr>                
              </Sjudge>
            </btypes:TYPE>.
            There are two sub-cases to consider:
          </p>
          <ol>
            <li>
              <p>
                If we take step E-Let#,                   
                <btypes:TYPE>
                  <eval>
                    <opState>
                      <stack/>
                      <heap/>
                      <aExpr num="1"/>
                    </opState>
                    <opState>
                      <stack dash="'"/>
                      <heap dash="'"/>
                      <aExpr num="1" dash="'"/>
                    </opState>
                  </eval>
                </btypes:TYPE>
                and 
                <btypes:TYPE>
                  <eq>
                    <aExpr dash="'"/>
                    <paren>
                      <let kind="p">
                        <id/>
                        <aExpr num="1" dash="'"/>
                        <aExpr num="2"/>
                      </let>
                    </paren>
                  </eq>
                  <text content=". If "/>                    
                  <eq>
                    <aExpr/>
                    <aVal/>
                  </eq>
                </btypes:TYPE>
                It is clear that 
                <btypes:TYPE>
                  <pred name="Value">
                    <aExpr num="1"/>
                  </pred>
                </btypes:TYPE> implies
                <btypes:TYPE>
                  <pred name="Value">
                    <aExpr num="1" dash="'"/>
                  </pred>
                </btypes:TYPE>.                     
                Now, the result follows
                from the induction hypothesis and the E-Let-P rule.
              </p>
            </li>
            <li>
              <p>
                If we take the step E-Let-P, 
                <btypes:TYPE>
                  <eq>
                    <aExpr/>
                    <paren>
                      <let kind="p">
                        <id/>
                        <aVal/>
                        <aExpr num="2"/>
                      </let>
                    </paren>
                  </eq>
                </btypes:TYPE>
                Since 
                <btypes:TYPE>
                  <tqExpr>
                    <id/>
                    <aTS/>
                  </tqExpr>
                </btypes:TYPE>
                has a polymorphic type, 
                (that is,
                <btypes:TYPE>
                  <eq>
                    <aTS/>
                    <forall>
                      <tvars name="alpha"/>
                      <type name="s"/>
                    </forall>
                  </eq>
                </btypes:TYPE>)
                we know that
                <btypes:TYPE>
                  <pred name="Immut">
                    <type/>
                  </pred>
                </btypes:TYPE>.
                Also, from canonical forms lemma, all values have
                an immutable type. Therefore, 
                <btypes:TYPE>
                  <eq>
                    <type/>
                    <type num="1"/>
                  </eq>
                </btypes:TYPE>. Now, the result follows from
                value substitution lemma. 
              </p>
            </li>
          </ol>            
        </li>
        <li>
          <p>
            Case T-Let-M: Similar to T-Let-P, except that we should
            always use the GEN-EXPANSIVE rule during generalization,
            and use the location substitution lemma instead of 
            the value substitution lemma
          </p>
        </li>
        <li>
          <p>
            Cases T-If, T-Dup, T-TqExpr, and T-Let-M-Tq T-Let-P-Tq are
            similar.  
          </p>
        </li>
      </ol>
    </proof>
    <definition id="stuck_state">
      <title>Stuck State</title>
      <p>
        A system state 
        <btypes:TYPE>
          <opState>
            <stack/>
            <heap/>
            <aExpr/>
          </opState>
        </btypes:TYPE>
        is said to be <term>stuck</term> if
        <btypes:TYPE>
          <neq>
            <aExpr/>
            <aVal/>
          </neq>
        </btypes:TYPE>
        and there are no 
        <btypes:TYPE>
          <stack dash="'"/>
          <text content=", "/>
          <heap dash="'"/>
          <text content=", and "/>
          <aExpr dash="'"/>
        </btypes:TYPE>   
        such that 
        <btypes:TYPE>
          <eval>
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
          </eval>
        </btypes:TYPE>.
      </p>
    </definition>      
    <theorem id="T-soundness">
      <title>Type Soundness</title>
      <p>
        If 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <Empty/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <plus>
              <heap/>
              <stack/>
            </plus>
          </Sjudge> 
          <text content=" and "/>
          <eval many="yes">
            <opState>
              <stack/>
              <heap/>
              <aExpr/>
            </opState>
            <opState>
              <stack dash="'"/>
              <heap dash="'"/>
              <aExpr dash="'"/>
            </opState>
          </eval>
          <text content=" then "/>
          <opState>
            <stack dash="'"/>
            <heap dash="'"/>
            <aExpr dash="'"/>
          </opState>
          <text content=" is not stuck."/>            
        </btypes:TYPE>
        That is, execution of a well typed expression cannot lead to
        a stuck state. Here, 
        <btypes:TYPE>
          <evalOp many="yes"/>
        </btypes:TYPE > represents the 
        reflexive-transitive-closure of 
        <btypes:TYPE>
          <evalOp/>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        By straightforward induction on the length of   
        <btypes:TYPE>
          <evalOp many="yes"/>
        </btypes:TYPE>. If 
        <btypes:TYPE>
          <eq>
            <aExpr/>
            <aVal/>
          </eq>
        </btypes:TYPE>, proof is immediate. Otherwise, from 
        Lemma&nbsp;<xref ref="T-progress"/> (Progress),
        we know that we can take at least one step forward. Further,
        from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation),
        we know that a (left/right) execution of a well
        typed expression in with respect to a well typed stack and heap
        will always result in another well typed expression, stack
        and heap. Proof now follows from induction hypothesis.  
      </p>
    </proof>
  </sect1>
  <sect1 id="eq-infer">
    <title>Equational Type Inference</title> 
    <xi:include href="include/formal/eq-infer.xmli"/>
    <xi:include href="include/formal/eq-unify.xmli"/>
    <xi:include href="include/formal/eq-helper.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><type/><type/></fn>                  
          </alternatives>
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><type/></ref>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Constr. Type">
          <aCtype/>
          <alternatives>
            <type/>
            <ctype>
              <type/>
              <aCtset/>
            </ctype>
          </alternatives>
        </bnf>
        <bnf desc="Type Scheme">          
          <aTS/>
          <alternatives>
            <aCtype/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
        <bnf desc="Constraints">
          <constraint/>
          <alternatives>
            <eq>
              <type/>
              <type/>
            </eq>
            <ceq>
              <type/>
              <type/> 
            </ceq>
            <Tsub>
              <type/>
              <type/> 
            </Tsub>
            <Pcst>
              <lKind/>
              <type/>
              <type/>
            </Pcst>
          </alternatives>
        </bnf>
        <bnf desc="Constraint Sets">
          <aCtset/>
          <alternatives>
            <Empty/>
            <set>
              <plural>
                <constraint/>
              </plural>
            </set>
            <unin>
              <aCtset/>
              <aCtset/>
            </unin>
          </alternatives>            
        </bnf>
        <bnf desc="Substitutions">            
          <aSubMap/>            
          <alternatives>
            <EmptySubst/>
            <SubMap>
              <tvar name="alpha"/>
              <type/>
            </SubMap>
            <SubMap>
              <lKind k="var"/>
              <lKind/>
            </SubMap>
            <compose>
              <aSubMap/>
              <aSubMap/>
            </compose>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
    <p>
      The application of a substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> on X is written as
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <text content="X"/>
	</Subst>
      </btypes:TYPE>. 
      As a matter of notational convenience, we write:
      <btypes:TYPE>
        <aSubMap num="a.b"/> 
      </btypes:TYPE> to mean
      <btypes:TYPE>
        <compose>
          <aSubMap num="a"/> 
          <aSubMap num="b"/> 
        </compose>
      </btypes:TYPE>. Note that
      <btypes:TYPE>
        <eq>
          <Subst>
            <aSubMap num="a.b"/> 
            <text content="x"/>
          </Subst>
          <Subst>
            <compose>
              <aSubMap num="a"/> 
              <aSubMap num="b"/> 
            </compose>
            <text content="x"/>
          </Subst>
          <Subst>
            <aSubMap num="a"/> 
            <Subst>
              <aSubMap num="b"/>                 
              <text content="x"/>
            </Subst>
          </Subst>
          <Subst>
            <aSubMap num="b"/>                 
            <Subst>
              <aSubMap num="a"/> 
              <text content="x"/>
            </Subst>
          </Subst>
        </eq>
      </btypes:TYPE>.        
    </p>
    <definition id="meta">      
      <title>Meta Constructors</title>      
      <p>
        <btypes:TYPE>
          <floor>
            <type/>
          </floor>
        </btypes:TYPE>
        and 
        <btypes:TYPE>
          <ceil>
            <type/>
          </ceil>
        </btypes:TYPE>
        are "meta-constructors" which (respectively) minimize and
        maximize the mutability of a type, but are interpreted
        lazily. The meta-constructors are idempotent. 
      </p>
    </definition>
    Note that in our type system, we have restricted meta types to be
    syntactically present only as part of function types.
    <definition id="pcst">      
      <title>Meta Polymorphic Constraints</title>      
      <p>
        The constraint 
        <btypes:TYPE>
          <Pcst>
            <lKind/>
            <type/>
            <type dash="'"/>
          </Pcst>
        </btypes:TYPE> is used to express types that are polymorphic
        <em>over</em> polymorphism and mutability. 
        The type 
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE> can only be a specialization of 
        <btypes:TYPE>
          <type/>
        </btypes:TYPE>, obtained through some substituion.        
        A Substitution over the polymorphic constraint is defined as:
        <btypes:TYPE>
          <eq>
            <Subst>
              <aSubMap/>
              <Pcst>
                <lKind/>
                <type/>
                <type dash="'"/>
              </Pcst>
            </Subst>
            <Pcst>
              <Subst>
                <aSubMap/>                
                <lKind/>
              </Subst>
              <type/>              
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </Pcst>
          </eq>
        </btypes:TYPE>.
        A substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE> satisfies the set of constraints
        <btypes:TYPE>
          <set>
            <Pcst>
              <lKind k="var"/>
              <type/>
              <type num="1"/>
            </Pcst>
            <unspecified/>
            <Pcst>
              <lKind k="var"/>
              <type/>
              <type num="n"/>
            </Pcst>
          </set>
        </btypes:TYPE> if and only if:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <lKind k="var"/>
                </Subst>
                <lKind k="mono"/>
              </eq>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <type num="1"/>
                </Subst>
                <unspecified/>
                <Subst>
                  <aSubMap/>
                  <type num="n"/>
                </Subst>
              </eq>
            </btypes:TYPE>, or
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap/>
                  <lKind k="var"/>
                </Subst>
                <lKind k="poly"/>
              </eq>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <collection>
                <pred name="Immut">
                  <Subst>
                    <aSubMap/>
                    <type num="1"/>
                  </Subst>
                </pred>
                <unspecified/>
                <pred name="Immut">
                  <Subst>
                    <aSubMap/>
                    <type num="n"/>
                  </Subst>
                </pred>
              </collection>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <definition id="define_infer">
      <title>Type Inference</title> 
      <p>
        Type inference is a program
        transformation that accepts a program in which
        <progident>let</progident> expressions are not annotated
        with their kinds, and returns the same programs in which
        <progident>let</progident> expressions are annotated with
        their kinds and all expressions are annotated with their
        types.
      </p>
    </definition>
    <p>
      The equational type inference algorithm is as shown in
      Figure&nbsp;<xref ref="eq_infer"/>. 
      The inference judgment 
      <btypes:TYPE>
	<TEjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
          <constrain>
            <aCtset/>
          </constrain>
	</TEjudge>
      </btypes:TYPE>
      should be understood as: given the binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
      <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
      <btypes:TYPE><type/></btypes:TYPE> for the expression 
      <btypes:TYPE><aExpr/></btypes:TYPE> under the constraints
      <btypes:TYPE><aCtset/></btypes:TYPE>. 
      The Unification algorithm is given in 
      figure&nbsp;<xref ref="eq_unify"/> with some auxilary
      definitions and translations defined in 
      figure&nbsp;<xref ref="eq_helper"/>. 
      The unification algorithm takes in a set of constraints
      <btypes:TYPE><aCtset/></btypes:TYPE> and either fails with an
      error <btypes:TYPE><error/></btypes:TYPE>, or succeeds to 
      result in a pair consisting of residual constraints
      <btypes:TYPE><aCtset/></btypes:TYPE> 
      (which should only contain constraints of the form:
      <btypes:TYPE>
        <!-- a <= t  -->
        <Tsub>
          <tvar name="alpha"/>
          <type/>
        </Tsub>
        <text content=","/>
        <space/>
        <!-- t <= a  -->
        <Tsub>
          <type/>
          <tvar name="alpha"/>
        </Tsub>
        <text content=", "/>
        <space/>
        <!-- however, both of the cases a <= t and t <= a
        cannot occur since it can be reduced -->
        <!-- P(k, t1, t2)  -->
        <Pcst>
          <lKind k="var"/>
          <type/>
          <type dash="'"/>
        </Pcst>
        <text content=", and"/>
        <space/>
        <Pcst>
          <lKind k="poly"/>
          <type num="g"/>
          <type num="i"/>
        </Pcst>
        <text content=", where"/>
        <space/>
        <pred name="Immut">
          <type num="i"/>
        </pred>
        <text content=", and"/>
        <space/>
        <neq>
          <pred name="dtv">
            <type num="i"/>
          </pred>
          <Empty/>
        </neq>
        <text content="."/>            
      </btypes:TYPE>)
      and a list of
      substitutions <btypes:TYPE><aSubMap/></btypes:TYPE> for the
      constraints solved in this pass.
    </p>
    <definition id="stvs-eq">
      <title>Shallow Type Variables</title>
      <p>
        The set of type variables embedde in a type up to a 
        reference/function boundary. 
      </p>
      <p>
        <btypes:TYPE>
          <fnxn name="stv">
            <tvar name="alpha"/>
            <set>
              <tvar name="alpha"/>
            </set>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <unit/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <bool/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <fn>
              <type/>
              <type dash="'"/>
            </fn>
            <Empty/>
          </fnxn>          
          <br/>
          <fnxn name="stv">
            <ref>
              <type/>
            </ref>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="stv">
            <mutable>
              <type/>
            </mutable>
            <pred name="stv">
              <type/>
            </pred>
          </fnxn>
          <br/>
        </btypes:TYPE>
      </p>
    </definition>    
    <definition id="dtvs-eq">
      <title>Deep Type Variables</title>
      <p>
        The set of type variables embedde in a type up to a 
        function boundary. 
      </p>
      <p>        
        <btypes:TYPE>
          <fnxn name="dtv">
            <tvar name="alpha"/>
            <set>
              <tvar name="alpha"/>
            </set>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <unit/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <bool/>
            <Empty/>
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <fn>
              <type/>
              <type dash="'"/>
            </fn>
            <Empty/>
          </fnxn>          
          <br/>
          <fnxn name="dtv">
            <mutable>
              <type/>
            </mutable>
            <pred name="dtv">
              <type/>
            </pred>		
          </fnxn>
          <br/>
          <fnxn name="dtv">
            <ref>
              <type/>
            </ref>
            <pred name="dtv">
              <type/>
            </pred>		
          </fnxn>
        </btypes:TYPE>
      </p>
    </definition>    
    <theorem id="eq-unify-correct">
      <title>Correctness of Unification</title>
      <p>
        If:
        <btypes:TYPE>
          <eq>
            <unf>
              <aCtset/>
            </unf>
            <Pair>
              <aCtset dash="'"/>
              <aSubMap/>
            </Pair>
          </eq>
          <text content=", then"/>
          <Exists>
            <aSubMap num="s"/>
          </Exists>          
          <text content=" such that "/>
          <models name="sat"> 
            <assume>
              <aSubMap num="s"/>
            </assume>
            <aCtset dash="'"/>
          </models>
        </btypes:TYPE>
      </p>
    </theorem>
    <theorem id="eq-unify-decidable">
      <title>Decidability of Unification</title>
      <p>
        The unification algorithm
        <btypes:TYPE>
          <unf>
            <aCtset/>
          </unf>
          <text content=" computes to some "/>
          <Pair>
            <aCtset dash="'"/>
            <aSubMap/>
          </Pair>
          <text content=" or fails with "/>
          <error/>
          <text content=" decidably in a finite number of steps."/>
        </btypes:TYPE>
      </p>
    </theorem>
    <theorem id="eq-infer-sound">
      <title>Soundness of Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TEjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <constrain>
              <aCtset/>
            </constrain>
          </TEjudge>
          <text content=" and "/>
          <eq>
            <unf>
              <aCtset/>
            </unf>
            <Pair>
              <aCtset num="u"/>
              <aSubMap num="u"/>
            </Pair>
          </eq>
          <text content=", then "/>
          <Forall>
            <aSubMap num="s"/>
          </Forall>
          <text content=" such that "/>
          <models name="sat"> 
            <assume>
              <aSubMap num="s"/>
            </assume>
            <aCtset num="u"/>
          </models>
          <text content=", "/>  
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>                
                  <aExpr/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="s"/>
                  </scomp>                                  
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	                
        </btypes:TYPE>.
      </p>
    </theorem>
    <theorem id="eq-infer-complete">
      <title>Completeness of Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>	                          
          <text content=" then "/>
          <Exists>
            <aSubMap/>
          </Exists>
          <text content=" such that "/>
          <TEjudge>
            <assume>
              <gamma dash="'"/>
              <store dash="'"/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type dash="'"/>
              </tqExpr>
            </conclude>
            <constrain>
              <aCtset/>
            </constrain>
          </TEjudge>
          <text content=", "/>
          <models name="sat"> 
            <assume>
              <aSubMap/>
            </assume>
            <aCtset/>
          </models>
          <text content=", "/>
          <eq>
            <gamma/>
            <canonical>
              <Subst>
                <aSubMap/>
                <gamma dash="'"/>
              </Subst>
            </canonical>
          </eq>
          <text content=", "/>
          <eq>
            <store/>
            <canonical>
              <Subst>
                <aSubMap/>
                <store dash="'"/>
              </Subst>
            </canonical>
          </eq>
          <text content=" and "/>
          <eq>
            <type/>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </eq>
        </btypes:TYPE>.
      </p>
    </theorem>
  </sect1>
  <sect1 id="infer">
    <title>Heuristic Type Inference</title> 
    <xi:include href="include/formal/hm-infer.xmli"/>
    <xi:include href="include/formal/hm-unify.xmli"/>
    <xi:include href="include/formal/hm-solve.xmli"/>
    <xi:include href="include/formal/hm-inter.xmli"/>
    <btypes:TYPE>        
      <grammar>
        <bnf desc="Types">
          <type/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><type/><type/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><type/></ref>
            <mutable><type/></mutable>
          </alternatives>
        </bnfc>
        <bnfc desc="Maybe Type">
          <alternatives>
            <mbpair>
              <type/>
              <type dash="'"/>
            </mbpair>              
          </alternatives>
        </bnfc>
        <bnf desc="Unct. Types">
          <sType/>
          <alternatives>
            <tvar name="alpha"/>
            <unit/>
            <bool/>
            <fn M="yes"><sType/><sType/></fn>                  
          </alternatives>                
        </bnf>
        <bnfc desc="">
          <alternatives>
            <ref><sType/></ref>
            <mutable><sType/></mutable>
          </alternatives>
        </bnfc>
        <bnf desc="Type Scheme">
          <aTS/>
          <alternatives>
            <type/>
            <forall>                    
              <tvar name="alpha"/>
              <aTS/>
            </forall>
          </alternatives>
        </bnf>
        <bnf desc="Solvable Entities">
          <solvable/>
          <alternatives>
            <type/>
            <gamma/>
            <store/>
            <plus>
              <solvable/>
              <solvable/>
            </plus>
          </alternatives>
        </bnf>
      </grammar>
    </btypes:TYPE>
<!--     <definition id="djudge"> -->
<!--       <title><btypes:TYPE><judgeOp sym="diam"/></btypes:TYPE></title>       -->
<!--       <p> -->
<!--         We define the following derivation in the -->
<!--         interest of notational convenience in proofs. -->
<!--       </p> -->
<!--       <btypes:TYPE> -->
<!--         <Hrules> -->
<!--           <tyRule> -->
<!--             <tyPre> -->
<!--               <Sjudge> -->
<!--                 <assume> -->
<!--                   <canonical> -->
<!--                     <Subst> -->
<!--                       <aSubMap/> -->
<!--                       <gamma/> -->
<!--                     </Subst> -->
<!--                   </canonical> -->
<!--                   <canonical> -->
<!--                     <Subst> -->
<!--                       <aSubMap/> -->
<!--                       <store/> -->
<!--                     </Subst> -->
<!--                   </canonical> -->
<!--                 </assume> -->
<!--                 <tqExpr> -->
<!--                   <canonical> -->
<!--                     <Subst> -->
<!--                       <aSubMap/> -->
<!--                       <aExpr/> -->
<!--                     </Subst> -->
<!--                   </canonical> -->
<!--                   <canonical> -->
<!--                     <Subst> -->
<!--                       <aSubMap/> -->
<!--                       <type/> -->
<!--                     </Subst> -->
<!--                   </canonical> -->
<!--                 </tqExpr> -->
<!--               </Sjudge> -->

<!--             </tyPre> -->
<!--             <tyConc> -->
<!--               <Djudge> -->
<!--                 <aSubMap/> -->
<!--                 <gamma/> -->
<!--                 <store/> -->
<!--                 <aExpr/> -->
<!--                 <type/> -->
<!--               </Djudge> -->
<!--             </tyConc> -->
<!--           </tyRule> -->
<!--         </Hrules> -->
<!--       </btypes:TYPE> -->
<!--     </definition> -->
    <definition>
      <title>Constraint Set Closure</title>
      <p>
        A closure operation
        <btypes:TYPE>
          <pred name="close">
            <aCtset/> 
          </pred>
        </btypes:TYPE>
        on a constraint set 
        <btypes:TYPE>
          <aCtset/> 
        </btypes:TYPE> produces an equivalent set
        of atomic constraints by using the copy coercion rules defined
        in Figure&nbsp;<xref ref="decl_rules"/> (note that this
        conversion is total); and by explicitely adding all transitive
        relationships.
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <fn>
                        <type num="1"/>
                        <type num="2"/>
                      </fn>
                      <fn>
                        <type num="1" dash="'"/>
                        <type num="2" dash="'"/>
                      </fn>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type num="1"/>
                        <type num="1" dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type num="2"/>
                        <type num="2" dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type num="1" dash="'"/>
                        <type num="1"/>
                      </Tsub>
                      <Tsub>
                        <type num="2" dash="'"/>
                        <type num="2"/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <ref>
                        <type/>
                      </ref>
                      <ref>
                        <type dash="'"/>
                      </ref>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type/>
                        <type dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type dash="'"/>
                        <type/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <fnxn name="close">
                <unin>
                  <set>
                    <Tsub>
                      <mutable>
                        <type/>
                      </mutable>
                      <mutable>
                        <type dash="'"/>
                      </mutable>
                    </Tsub>
                  </set>
                  <aCtset/>
                </unin>
                <pred name="close">
                  <unin>
                    <aCtset/>
                    <set>
                      <Tsub>
                        <type/>
                        <type dash="'"/>
                      </Tsub>
                      <Tsub>
                        <type dash="'"/>
                        <type/>
                      </Tsub>
                    </set>
                  </unin>
                </pred>
              </fnxn>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <grouping>
                  <pred name="close">
                    <unin>
                      <set>
                        <Tsub>
                          <type num="1"/>
                          <type num="2"/>
                        </Tsub>
                        <Tsub>
                          <type num="2"/>
                          <type num="3"/>
                        </Tsub>
                      </set>
                      <aCtset/>
                    </unin>
                  </pred>
                  <space/>
                  <textit content="where"/>
                  <space/>
                  <notin>
                    <Tsub>
                      <type num="1"/>
                      <type num="3"/>
                    </Tsub>
                    <aCtset/>
                  </notin>
                  <br/>
                </grouping>
                <pred name="close">
                  <unin>
                    <set>
                      <Tsub>
                        <type num="1"/>
                        <type num="2"/>
                      </Tsub>
                      <Tsub>
                        <type num="2"/>
                        <type num="3"/>
                      </Tsub>
                      <Tsub>
                        <type num="1"/>
                        <type num="3"/>
                      </Tsub>
                    </set>                      
                    <aCtset/>
                  </unin>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <grouping>
                  <pred name="close">
                    <aCtset/>
                  </pred>
                  <space/>
                  <textit content="where none of the above cases "/>
                  <textit content="are applicable"/>
                  <space/>
                </grouping>
                <aCtset/>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <definition>
      <title>Normalization of Constraint Sets</title>
      <p>
        The normalization function
        <btypes:TYPE>
          <normalize>
            <aCtset/>
          </normalize>
        </btypes:TYPE> is used to obtain a normalized form of a
        constraint set 
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE> by re-writing it only in terms of closed
        subtype constraints.
      </p>
      <p>
        <btypes:TYPE>
          <eq>              
            <normalize>
              <aCtset/>
            </normalize>
            <pred name="close">
              <aCtset dash="'"/>
            </pred>
          </eq>
        </btypes:TYPE>
        where
        <btypes:TYPE>
          <aCtset dash="'"/>
        </btypes:TYPE>
        is obtained from
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE> using the normalizing translations:
      </p>
      <ul>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <eq>
                    <type num="1"/>
                    <type num="2"/>
                  </eq>
                </DBrac>
                <DBrac>
                  <collection>
                    <Tsub>
                      <type num="1"/>
                      <type num="2"/>
                    </Tsub>
                    <Tsub>
                      <type num="2"/>
                      <type num="1"/>
                    </Tsub>	      
                  </collection>
                </DBrac>
              </leadsto>	
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <ceq>
                    <type num="1"/>
                    <type num="2"/>
                  </ceq>
                </DBrac>
                <DBrac>
                  <collection>
                    <Tsub>
                      <type num="1"/>
                      <tvar name="alpha"/>
                    </Tsub>	      
                    <Tsub>
                      <type num="2"/>
                      <tvar name="alpha"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>,
            where
            <btypes:TYPE>
              <models name="new">
                <assume/>
                <tvar name="alpha"/>
              </models>
            </btypes:TYPE>.            
          </p>
        </li>
      </ul>
    </definition>
    <definition id="sat">
      <title>Constraint Satisfiability</title>
      <p>
        A Substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>
        satisfies a constraint set
        <btypes:TYPE>
          <aCtset/>
        </btypes:TYPE>, written
        <btypes:TYPE>
          <models name="sat">
            <aSubMap/>
            <aCtset/>
          </models>
        </btypes:TYPE>
        iff
        <btypes:TYPE>
          <normalize>
            <aCtset/>
          </normalize>
        </btypes:TYPE>
        consists only of tautologies (trivially).
      </p>
    </definition>    
    <definition id="structural_containment">
      <title>Structural Containment</title>
      <p>
        We write 
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <type/>
        </btypes:TYPE> is structurally present as a part of 
        <btypes:TYPE>
          <type dash="'"/>
        </btypes:TYPE>.
        We write 
        <btypes:TYPE>
          <in>
            <type/>
            <aExpr/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <type/>
        </btypes:TYPE> is structurally present as a part of  
        <btypes:TYPE>
          <aExpr/>
        </btypes:TYPE>, as a type annotation.
        Similarly, we write 
        <btypes:TYPE>
          <in>
            <type/>
            <gamma/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <Exists>
            <in>
              <mapping>
                <id/>
                <type dash="'"/>
              </mapping>
              <gamma/>
            </in>
          </Exists>          
        </btypes:TYPE> such that 
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE>.
        We write
        <btypes:TYPE>
          <in>
            <type/>
            <store/>
          </in>
        </btypes:TYPE> if
        <btypes:TYPE>
          <Exists>
            <in>
              <mapping>
                <loc/>
                <type dash="'"/>
              </mapping>
              <gamma/>
            </in>
          </Exists>          
        </btypes:TYPE> such that 
        <btypes:TYPE>
          <in>
            <type/>
            <type dash="'"/>
          </in>
        </btypes:TYPE>.
      </p>
    </definition>
    <definition id="ca">
      <title>Consistency and Acyclicity</title> 
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Exists>
                  <aSubMap/>
                </Exists>
                <text content=" such that "/>
                <models name="sat">
                  <aSubMap/>
                  <aCtset/>
                </models>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="cst">
                <assume/>
                <aCtset/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <SubMap>
                  <tvar name="alpha"/>
                  <type/>
                </SubMap>
                <text content=" and "/>
                <SubMap>
                  <tvar name="beta"/>
                  <type dash="'"/>
                </SubMap>
                <text content=" in "/>
                <aSubMap/>
                <text content=", "/>
                <eq>
                  <tvar name="alpha"/>
                  <tvar name="beta"/>
                </eq>
                <text content=" implies "/>
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>          
              </grouping>
            </tyPre>
            <tyConc>
              <models name="cst">
                <assume/>
                <aSubMap/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <grouping>
                    <Tsub>
                      <tvar name="alpha"/>
                      <type/>
                    </Tsub>
                    <text content=" or "/>
                    <Tsub>
                      <tvar name="alpha"/>
                      <type/>
                    </Tsub>
                  </grouping>
                  <normalize>
                    <aCtset/>
                  </normalize>
                </in>                
                <text content=", "/>
                <OR>
                  <paren>
                    <eq>
                      <type/>
                      <tvar name="alpha"/>
                    </eq>
                  </paren>
                  <paren>
                    <eq>
                      <type/>
                      <mutable>
                        <tvar name="alpha"/>
                      </mutable>
                    </eq>
                  </paren>
                  <paren>
                    <notin>
                      <tvar name="alpha"/>
                      <type/>
                    </notin>
                  </paren>
                </OR>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="acy">
                <assume/>
                <aCtset/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type/>
                  </SubMap>
                  <pred name="TransClose">
                    <aSubMap/>
                  </pred>
                </in>
                <text content=", "/>
                <notin>
                  <tvar name="alpha"/>
                  <type/>
                </notin>
              </grouping>
            </tyPre>
            <tyConc>
              <models name="acy">
                <assume/>
                <aSubMap/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <models name="cst">   
                <assume/>
                <aCtset/>
              </models>  	    
              <models name="acy">   
                <assume/>
                <aCtset/>
              </models>  	    	    
            </tyPre>
            <tyConc> 
              <models name="ca">   
                <assume/>
                <aCtset/>
              </models>  
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <models name="cst">   
                <assume/>
                <aSubMap/>
              </models>  	    
              <models name="acy">   
                <assume/>
                <aSubMap/>
              </models>  	    	    
            </tyPre>
            <tyConc> 
              <models name="ca">   
                <assume/>
                <aSubMap/>
              </models>  
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>
    </definition>      
    <definition id="solvable-entities">
      <title>Solvable Entities</title>
      <p>
        A solvable entity 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>
        is structurally defined to be:
      </p>
      <btypes:TYPE>                      
        <grammar notitle="yes">
          <bnf desc="Solvables">
            <solvable/>
            <alternatives>
              <type/>
              <gamma/>
              <store/>
              <aExpr/>
            </alternatives>
          </bnf>
        </grammar>
      </btypes:TYPE>
    </definition>
    <definition id="ctr_extract">
      <title>Constraint Set Extraction</title>
      <btypes:TYPE>
        <Hrules vspace="yes">
          <tyRule>
            <tyPre/>
            <tyConc>
              <eq>
                <spset>
                  <Empty/>
                </spset>
                <Empty/>
              </eq>
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <eq>
                    <id name="i"/>
                    <text content="1 ... n"/>
                  </eq>
                </Forall>
                <space/>
                <eq>
                  <spset>
                    <solvable num="i"/>
                  </spset>
                  <aCtset num="i"/>
                </eq>
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <solvable num="1"/>
                  <unspecified/>
                  <solvable num="n"/>
                </spset>
                <Unin>
                  <aCtset num="i"/>
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <eq>
                <spset>
                  <solvable num="1"/>
                </spset>
                <aCtset num="1"/>
              </eq>
              <eq>
                <spset>
                  <solvable num="2"/>
                </spset>
                <aCtset num="2"/>
              </eq>
            </tyPre>
            <tyConc>
              <eq>
                <unin>
                  <spset>
                    <solvable num="1"/> 
                  </spset>
                  <spset>
                    <solvable num="2"/>
                  </spset>
                </unin>
                <unin>
                  <aCtset num="1"/>
                  <aCtset num="2"/>
                </unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <mbpair>
                    <type num="i"/>                
                    <type num="i" dash="'"/>
                  </mbpair>
                  <type/>
                </in>
                <text content=","/>
                <space/>
                <eq>
                  <aCtset num="i"/>
                  <set>
                    <ceq>
                      <type num="i"/>
                      <inner>
                        <type num="i" dash="'"/>
                      </inner>
                    </ceq>
                  </set>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <type/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <type num="i"/>                
                  <aExpr/> 
                </in>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <aExpr/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>
        </Hrules>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <in>
                    <mapping>
                      <id/>
                      <type num="i"/>                
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <gamma/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>               
          <tyRule>
            <tyPre>
              <grouping>
                <Forall>
                  <in>
                    <mapping>
                      <loc/>
                      <type num="i"/>                
                    </mapping>
                    <store/>
                  </in>
                </Forall>
                <text content=","/>
                <space/>
                <eq>
                  <spset>
                    <type num="i"/>                
                  </spset>
                  <aCtset num="i"/>
                </eq>                    
              </grouping>
            </tyPre>
            <tyConc>
              <eq>
                <spset>
                  <store/>
                </spset>
                <Unin>
                  <aCtset num="i"/>                
                </Unin>
              </eq>
            </tyConc>
          </tyRule>       
        </Hrules>
      </btypes:TYPE>        
    </definition>
    <definition id="maybe-consistent">
      <title>Consistency of Maybe types</title>
      <p>
        We identify the following consistency property on maybe types.
      </p>
      <btypes:TYPE>
        <Hrules>
          <tyRule>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <mbpair>
                    <type/>
                    <type dash="'"/>
                  </mbpair>
                  <collection>
                    <solvable num="1"/> 
                    <unspecified/>
                    <solvable num="n"/> 
                  </collection>
                </in>
                <text content=", "/>
                <eq>
                  <type/>
                  <tvar name="alpha"/>
                </eq>
                <text content=", or "/>
                <ceq>
                  <type/>
                  <inner>
                    <type dash="'"/>
                  </inner>
                </ceq>
              </grouping>
            </tyPre>
            <tyPre>
              <grouping>
                <Forall/>
                <in>
                  <grouping>
                    <mbpair>
                      <tvar name="alpha"/>
                      <type/>
                    </mbpair>
                    <text content=" and "/>
                    <mbpair>
                      <tvar name="alpha"/>
                      <type dash="'"/>
                    </mbpair>
                  </grouping>
                  <collection>
                    <solvable num="1"/> 
                    <unspecified/>
                    <solvable num="n"/> 
                  </collection>
                </in>
                <text content=", "/>
                <eq>
                  <type/>
                  <type dash="'"/>
                </eq>
              </grouping>              
            </tyPre>
            <tyConc>
              <CST>
                <solvable num="1"/> 
                <unspecified/>
                <solvable num="n"/> 
              </CST>
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>
    </definition>
    <definition id="normalized-ctr-types">
      <title>Canonical forms of Solvable Entities</title>
      <p>
        For any 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <models name="sat">
            <EmptySubst/>
            <spset>
              <solvable/>
            </spset>
          </models>
        </btypes:TYPE>,
        we write 
        <btypes:TYPE>
          <canonical>
            <solvable/>
          </canonical>
        </btypes:TYPE> to represent the equivalent entity
        in which (1) all meta-constructors in are fully interpreted,
        and (2) the (tautological) constraints embedded within 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE> are removed to obtain an equivalent
        unconstrained entity.
      </p>
    </definition>    
    <p>
      For example, if
      <btypes:TYPE>
        <eq>
          <type/>
          <mbpair>
            <mutable>
              <bool/>
            </mutable>
            <bool/>
          </mbpair>
        </eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
        <eq>
          <canonical>
            <type/>
          </canonical>
          <mutable>
            <bool/>
          </mutable>
        </eq>
      </btypes:TYPE>, and if
      <btypes:TYPE>
        <eq>
          <gamma/>
          <mapping>
            <id/>
            <floor>
              <mutable>
                <unit/>
              </mutable>
            </floor>
          </mapping>
        </eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
        <eq>
          <canonical>
            <gamma/>
          </canonical>
          <mapping>
            <id/>
            <unit/>
          </mapping>
        </eq>
      </btypes:TYPE>. 
      That is, canonicalization obtains entities that are within the
      language and type system defined in 
      section&nbsp;<xref ref="language"/>.
    </p>
    <definition id="ext-ftvs">
      <title>FTVs (Extension)</title>
      <p>
        We need to enhance the definition of FTV as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <unspecified/>
            <br/>
            <eq>
              <ftvs>
                <mbpair>
                  <type num="1"/>
                  <type num="2"/>
                </mbpair>
              </ftvs>
              <unin>
                <ftvs>
                  <type num="1"/>
                </ftvs>
                <ftvs>
                  <inner>
                    <type num="2"/>
                  </inner>
                </ftvs>
              </unin>
            </eq>
          </btypes:TYPE>.
        </p>
      </example>
    </definition>
    <definition id="MTVs">
      <title>MTVs</title>
      <p>
        The function 
        <btypes:TYPE>
          <fnxn name="MTV">
            <solvable/>
            <tvars name="alpha"/>
          </fnxn>
        </btypes:TYPE> is defined to be the set of all type variables
        within the solvable entity 
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE>. That is, it returns the set of all
        type-variables 
        <btypes:TYPE>
          <tvars name="alpha"/>
        </btypes:TYPE> where  
        <btypes:TYPE>
          <tvar name="alpha"/>
        </btypes:TYPE> occurs within a maybe type as 
        <btypes:TYPE>
          <mbpair>
            <tvar name="alpha"/>
            <type num="h"/>
          </mbpair>            
        </btypes:TYPE>.
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="MTV">
              <tvar name="alpha"/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <unit/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <bool/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <mbpair>
                <tvar name="alpha"/>
                <type num="h"/>
              </mbpair>                            
              <unin>
                <tvar name="alpha"/>
                <pred name="MTV">
                  <type num="h"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <mbpair>
                <type/>
                <type num="h"/>
              </mbpair>                            
              <pred name="MTV">
                <type/>
              </pred>
            </fnxn>
            <text content=" where "/>
            <neq>
              <type/>
              <tvar name="alpha"/>
            </neq>
            <br/>
            <fnxn name="MTV">
              <ref>
                <type/>
              </ref>                            
              <pred name="MTV">
                <type/>
              </pred>
            </fnxn>              
            <br/>
            <fnxn name="MTV">
              <mutable>
                <type/>
              </mutable>                            
              <pred name="MTV">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>                            
              <unin>
                <pred name="MTV">
                  <type num="1"/>
                </pred>
                <pred name="MTV">
                  <type num="2"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <gamma/>
              <grouping>
                <Unin>
                  <pred name="MTV">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <id num="i"/>
                      <type num="i"/>
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="MTV">
              <store/>
              <grouping>
                <Unin>
                  <pred name="MTV">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <loc num="i"/>
                      <type num="i"/>
                    </mapping>
                    <store/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>              
    </definition>
    <definition id="NTVs">
      <title>NTVs</title>
      <p>
        The set of unconstrained variables is defined as:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="NTV">
              <tvar name="alpha"/>
              <set>
                <tvar name="alpha"/>
              </set>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <unit/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <bool/>
              <empty/>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <mbpair>
                <tvar name="alpha"/>
                <type num="h"/>
              </mbpair>                            
              <pred name="NTV">
                <type num="h"/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <mbpair>
                <type/>
                <type num="h"/>
              </mbpair>                            
              <pred name="NTV">
                <type/>
              </pred>
            </fnxn>
            <text content=" where "/>
            <neq>
              <type/>
              <tvar name="alpha"/>
            </neq>
            <br/>
            <fnxn name="NTV">
              <ref>
                <type/>
              </ref>                            
              <pred name="NTV">
                <type/>
              </pred>
            </fnxn>              
            <br/>
            <fnxn name="NTV">
              <mutable>
                <type/>
              </mutable>                            
              <pred name="NTV">
                <type/>
              </pred>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <fn>
                <type num="1"/>
                <type num="2"/>
              </fn>                            
              <unin>
                <pred name="NTV">
                  <type num="1"/>
                </pred>
                <pred name="NTV">
                  <type num="2"/>
                </pred>
              </unin>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <gamma/>
              <grouping>
                <Unin>
                  <pred name="NTV">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <id num="i"/>
                      <type num="i"/>
                    </mapping>
                    <gamma/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
            <br/>
            <fnxn name="NTV">
              <store/>
              <grouping>
                <Unin>
                  <pred name="NTV">
                    <type num="i"/>
                  </pred>
                </Unin>
                <text content=","/>
                <space/>
                <Forall>
                  <in>
                    <mapping>
                      <loc num="i"/>
                      <type num="i"/>
                    </mapping>
                    <store/>
                  </in>
                </Forall>
              </grouping>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>              
    </definition>
    <definition id="TVs">
      <title>TVs</title>
      <p>
        The set of all type variables in a solvable entity is given
        by TV() function, defined as follows:
      </p>
      <example>
        <p>
          <btypes:TYPE>
            <fnxn name="TV">
              <solvable/>
              <unin>
                <pred name="MTV">
                  <solvable/>
                </pred>
                <pred name="NTV">
                  <solvable/>
                </pred>
              </unin>
            </fnxn>
          </btypes:TYPE>
        </p>
      </example>
    </definition>
    <p>
      Note that this
      function is different from FTV(), defined in 
      Definition&nbsp;<xref ref="ext-ftvs"/>. 
    </p>
    <definition id="shorthand">
      <title>Notational Shorthands</title>
      <p>
        We use the following shorthand translations as a notational
        convenience. Shorthand&nbsp;(<xref ref="decl_shorthand"/>) was already defined
        and used in section&nbsp;<xref ref="type_system"/>
      </p>
      <ol>
        <li id="decl_shorthand">
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge sub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge>
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Tsub>
                      <type/>
                      <type dash="'"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge name="j" sub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge name="j">
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Tsub>
                      <type/>
                      <type dash="'"/>
                    </Tsub>
                  </collection>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TDjudge name="j" Msub="yes">
                    <aExpr/>
                    <type/>
                  </TDjudge>
                </DBrac>
                <DBrac>
                  <collection>
                    <TDjudge name="j">
                      <aExpr/>
                      <type dash="'"/>
                    </TDjudge>
                    <Msub>
                      <type/>
                      <type dash="'"/>
                    </Msub>
                  </collection>
                </DBrac>
              </leadsto>            
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>
                  <TIjudge>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </TIjudge>
                </DBrac>
                <DBrac>            
                  <TIjudge>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>            
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <EmptySubst/>
                    </propagate>
                  </TIjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>          
                  <TIjudge>
                    <precond>
                      <aSubMap num="0"/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <aSubMap/>
                    </propagate>
                  </TIjudge>
                </DBrac>
                <DBrac>          
                  <TIjudge>
                    <assume>
                      <Subst>
                        <aSubMap num="0"/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap num="0"/>
                        <store/>
                      </Subst>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <Subst>
                          <aSubMap num="0"/>
                          <aExpr/>
                        </Subst>
                        <type/>
                      </tqExpr>
                    </conclude>
                    <propagate>
                      <aSubMap/>
                    </propagate>
                  </TIjudge>
                </DBrac>
              </leadsto>   
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>              
              <leadsto>
                <DBrac>  
                  <judge>
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </DBrac>
                <DBrac>          
                  <Sjudge>
                    <assume>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </assume>
                    <tqExpr>
                      <Subst>
                        <aSubMap/>
                        <aExpr/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>              
              <leadsto>
                <DBrac>  
                  <judge name="j">
                    <precond>
                      <aSubMap/>
                    </precond>
                    <assume>
                      <gamma/>
                      <store/>
                    </assume>
                    <conclude>
                      <tqExpr>
                        <aExpr/>
                        <type/>
                      </tqExpr>
                    </conclude>
                  </judge>
                </DBrac>
                <DBrac>          
                  <Sjudge name="j">
                    <assume>
                      <Subst>
                        <aSubMap/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <store/>
                      </Subst>
                    </assume>
                    <tqExpr>
                      <Subst>
                        <aSubMap/>
                        <aExpr/>
                      </Subst>
                      <Subst>
                        <aSubMap/>
                        <type/>
                      </Subst>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac>          
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <aExpr/>
                    <type/>
                  </Djudge>
                </DBrac>
                <DBrac>          
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <leadsto>
                <DBrac> 
                  <Subst>
                    <aSubMap/>
                    <spset>
                      <unspecified/>
                    </spset>
                  </Subst>
                </DBrac>
                <DBrac>          
                  <Subst>                
                    <aSubMap/>
                    <grouping>
                      <spset>
                        <unspecified/>
                      </spset>
                    </grouping>
                  </Subst>
                </DBrac>
              </leadsto>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </definition>
    <p>
      The type inference algorithm is as shown in
      Figure&nbsp;<xref ref="hm_infer"/>. 
      The inference judgment 
      <btypes:TYPE>
	<TIjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <propagate>
	    <aSubMap/>
	  </propagate>
	</TIjudge>
      </btypes:TYPE>
      should be understood as: given the binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
      <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
      <btypes:TYPE><type/></btypes:TYPE> for the expression 
      <btypes:TYPE><aExpr/></btypes:TYPE>.
      <btypes:TYPE><aSubMap/></btypes:TYPE> is list of substitutions 
      obtained by unifications performed during inference, and must be
      propagated to further derivations. 
      The judgment
      <btypes:TYPE>
	<models name="new">
	  <assume/>
	  <tvars name="alpha"/>
	</models>
      </btypes:TYPE> identifies new type variables. 
    </p>
    <p>
      Unification rules are as shown in 
      Figure&nbsp;<xref ref="hm_unify"/>.
      The unification judgment
      <btypes:TYPE>
	<UNIFY>
	  <type num="1"/>                  
	  <type num="2"/>
	  <aSubMap/>
	</UNIFY>
      </btypes:TYPE>
      is understood as: 
      <btypes:TYPE>
	<type num="1"/>                  
      </btypes:TYPE>
      unifies with
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      under the substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE>. 
    </p>
    <p>
      A constraint solver for solving copy compatibility constraints at 
      let-boundaries is 
      defined in Figure&nbsp;<xref ref="hm_solve"/>.          
      The judgment 
      <btypes:TYPE>
	<Sjudge name="solve">
	  <assume>
	    <aSubMap/>
	    <id/>
	    <aExpr/>
	  </assume>
	  <corUp>
	    <type num="1"/>
	    <type num="2"/>
	  </corUp>
	</Sjudge>
      </btypes:TYPE>
      should be read as: the (possibly) constrained type 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE>
      for the identifier
      <btypes:TYPE>
	<id/>
      </btypes:TYPE>
      (possibly) used in the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      is transformed to the unconstrained type
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      by solving all the copy compatibility constraints.
    </p>
    <p>
      We prove the soundness of the inference system, through an
      intermediate declarative system defined in 
      Figure&nbsp;<xref ref="hm_inter_rules"/>
    </p>
    <lemma id="Tsub-implies-Msub">
      <title><btypes:TYPE><TsubOp/></btypes:TYPE> 
        implies <btypes:TYPE><MsubOp/></btypes:TYPE></title>
      <p>
        If
        <btypes:TYPE>
          <Tsub>
            <type/>
            <type dash="'"/>
          </Tsub>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Evident from the definition of 
        <btypes:TYPE><MsubOp/></btypes:TYPE> in 
        Figure&nbsp;<xref ref="hm_inter_rules"/>.
        Both
        <btypes:TYPE><TsubOp/></btypes:TYPE> and
        <btypes:TYPE><MsubOp/></btypes:TYPE> are partial functions on
        types, but 
        <btypes:TYPE><MsubOp/></btypes:TYPE> clearly covers all
        cases that 
        <btypes:TYPE><TsubOp/></btypes:TYPE> relates.
      </p>
    </proof>
    <lemma id="Msub-begets-Tsub">
      <title><btypes:TYPE><MsubOp/></btypes:TYPE> 
        begets <btypes:TYPE><TsubOp/></btypes:TYPE></title> 
      <p>
        If
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Exists>
            <aSubMap/>
          </Exists>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <Tsub>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </Tsub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By construction of 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>. One possible solution is        
        <btypes:TYPE>
          <eq>
            <aSubMap/>
            <grouping>
              <Forall>
                <in>
                  <mbpair>
                    <tvar name="alpha"/>
                    <type num="h"/>
                  </mbpair>
                  <type/> 
                </in>
              </Forall>
              <textit content=","/>
              <space/>
              <SubMap>
                <tvar name="alpha"/>
                <inner>
                  <type num="h"/>
                </inner>
              </SubMap>
            </grouping>
          </eq>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="Msub-consistent">
      <title>Consistency of <btypes:TYPE><MsubOp/></btypes:TYPE></title> 
      <p>
        If
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Forall>
            <aSubMap/>
          </Forall>
        </btypes:TYPE>
        such that
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <spset>
              <type/>
            </spset>
          </models>              
        </btypes:TYPE>, we have        
        <btypes:TYPE>
          <Tsub>
            <canonical>
              <Subst>
                <aSubMap/>
                <type/>
              </Subst>
            </canonical>
            <canonical>
              <Subst>
                <aSubMap/>
                <type dash="'"/>
              </Subst>
            </canonical>
          </Tsub>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By straightforward induction over the derivation of 
        <btypes:TYPE>
          <Msub>
            <type/>
            <type dash="'"/>
          </Msub>
        </btypes:TYPE>, with case analysis over the 
        definition of <btypes:TYPE><MsubOp/></btypes:TYPE> in
        Figure&nbsp;<xref ref="hm_inter_rules"/>.
        A normalizing derivation with no redundant applications of
        reflexive and transitive rules must be considered.
      </p>
    </proof>
    <lemma id="weakening-sat-cst">
      <title>Weakening of Satisfiability and Consistency</title>
      <ol>
        <li>
          <p>
            If 
            <btypes:TYPE>	    
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>
                <aCtset/>
              </models>
            </btypes:TYPE> and
            <btypes:TYPE>	    
              <subeq>
                <aCtset dash="'"/>
                <aCtset/>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>
                <aCtset dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p> 
            If 
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <aCtset/>
              </models>
            </btypes:TYPE> and
            <btypes:TYPE>	    
              <subeq>
                <aCtset dash="'"/>
                <aCtset/>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <aCtset dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>	    
              <CST>
                <solvable num="1"/>
                <unspecified/>
                <solvable num="n"/>
              </CST>
            </btypes:TYPE>, and            
            <btypes:TYPE>	
              <subeq>
                <set>
                  <solvable num="1"/>
                  <unspecified/>
                  <solvable num="m"/>
                </set>
                <set>
                  <solvable num="1"/>
                  <unspecified/>
                  <solvable num="n"/>
                </set>
              </subeq>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <CST>
                <solvable num="1"/>
                <unspecified/>
                <solvable num="m"/>
              </CST>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>	    
              <CST>
                <solvable num="1"/>
                <unspecified/>
                <solvable num="n"/>
              </CST>
            </btypes:TYPE>, then
            <btypes:TYPE>	    
              <models name="cst">
                <assume/>
                <spset>
                  <solvable num="1"/>
                  <unspecified/>
                  <solvable num="n"/>
                </spset>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Evident from 
        <btypes:TYPE>
          <defn tag="sat"/>
        </btypes:TYPE>,
        <btypes:TYPE>
          <defn tag="ca"/>
        </btypes:TYPE>, and
        <btypes:TYPE>
          <defn tag="maybe-consistent"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="cst-implies-sat">
      <title>Consistency Implies Satisfiability</title>
      <p>
        If 
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <aCtset/>
          </models>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <Exists>
            <aSubMap/>
          </Exists>
        </btypes:TYPE> such that
        <btypes:TYPE>
          <models name="sat">
            <aSubMap/>
            <aCtset/>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By inversion of the constraint consistency relationship in 
        <btypes:TYPE>
          <defn tag="ca"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="decl-sub">
      <title>Substitution on Declarative Derivation</title>
      <p>
        <btypes:TYPE>	    
          <text content="If "/>
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" then "/>
          <judge>
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>	
    </lemma>
    <proof>
      <p>
        Straightforward induction on the
        derivation of 
        <btypes:TYPE>	    
          <Sjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, except for the fact that we should use
        appropriate &alpha;-renaming on generalized variables 
        <btypes:TYPE>	    
          <forall>
            <in>
              <aTS/>
              <gamma/>
            </in>
          </forall>
        </btypes:TYPE>, so that generalized variables do not get
        substituted. 	  
      </p>
    </proof>
    <lemma id="ctr-subst-decl">
      <title>Corollary to Lemma&nbsp;<xref ref="decl-sub"/>.</title>
      <p>
        If
        <btypes:TYPE>
          <Djudge>
            <aSubMap num="1"/>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </Djudge>
        </btypes:TYPE>, and
        <btypes:TYPE>
          <aSubMap num="2"/>
        </btypes:TYPE>
        is some substitution such that
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <Subst>
              <scomp>
                <aSubMap num="1"/>
                <aSubMap num="2"/>
              </scomp>
              <spset>
                <gamma/>
                <store/>
                <aExpr/>
                <type/>
              </spset>
            </Subst>
          </models>
        </btypes:TYPE>
        then,
        <btypes:TYPE>
          <Djudge>
            <scomp>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </scomp>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </Djudge>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Straightforward extension to Lemma&nbsp;<xref
          ref="decl-sub"/>. 
      </p>
    </proof>
    <lemma id="int-consistent">
      <title>Consistency of Intermediate Derivation</title>
      <p>
        If 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>,
        then
        <btypes:TYPE>
          <CST>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </CST>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Evident from the definition of the intermediate type system in 
        figure&nbsp;<xref ref="hm_inter_rules"/> (each rule
        explicitrly includes a consistency constraint), and
        <btypes:TYPE>	    
          <lem tag="weakening-sat-cst"/>
        </btypes:TYPE> (weakening).
      </p>
    </proof>
    <theorem id="intermediate-sound">
      <title>Soundness of Intermediate System</title>
      <p>
        If:
      </p>
      <ol>
        <li id="inter-sound__a_derive">
          <p>
            <btypes:TYPE>
              <TDjudge name="j">
                <aExpr/>
                <type/>
              </TDjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li id="inter-sound__a_solve">
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap/>
                </assume>                
                <spset>
                  <gamma/>
                  <store/>
                  <aExpr/>
                  <type/>
                </spset>
              </models>
            </btypes:TYPE>.              
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Djudge>            
            <aSubMap/>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </Djudge>
        </btypes:TYPE>.        
      </p>
    </theorem>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>
        We proceed by case analysis on the last step,
        assuming &alpha;-reduction vacuously.        
      </p>
      <ol>
        <li id="ints_bases">
          <p>
            Cases J-Unit, J-True. J-False, J-Id, J-Hloc,
            J-Sloc are trivial. 
          </p>
        </li>
        <li id="ints_lam">
          <p>
            Case J-Lambda:               
          </p>
          <ol>
            <li id="ints_l1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="ints_l1_1">
                  <btypes:TYPE>
                    <Hrules vspace="yes">                      
                      <tyRule>
                        <tyPre>
                          <Sjudge>
                            <assume>
                              <extend>
                                <gamma/>
                                <mapping>
                                  <id/>
                                  <type num="1"/>
                                </mapping>
                              </extend>
                              <store/>
                            </assume>
                            <tqExpr>
                              <aExpr num="i"/>
                              <type num="2"/>
                            </tqExpr>
                          </Sjudge>
                          <models name="cst">
                            <assume/>
                            <spset>
                              <type num="1"/>
                            </spset>
                          </models>
                        </tyPre>
                        <tyConc>
                          <TDjudge name="j">
                            <lambda>
                              <id/>
                              <aExpr num="i"/>
                            </lambda>
                            <fn M="yes">
                              <type num="1"/>
                              <type num="2"/>
                            </fn>
                          </TDjudge>
                        </tyConc>
                      </tyRule>
                    </Hrules> 
                  </btypes:TYPE>
                </li>
                <li id="ints_l1_2">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap/>
                        </assume>
                        <spset>
                          <gamma/>
                          <store/>
                          <lambda>
                            <id/>
                            <aExpr num="i"/>
                          </lambda>
                          <fn M="yes">
                            <type num="1"/>
                            <type num="2"/>
                          </fn>
                        </spset>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
              <p>
                and we need to show that
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <type num="1"/>
                      <type num="2"/>
                    </fn>                    
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="inst_l2">
              <p>
                It is evident (from the syntactic structure) that                 
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <lambda>
                        <id/>
                        <aExpr num="i"/>
                      </lambda>
                    </spset>
                    <spset>
                      <aExpr num="i"/>
                    </spset>
                  </eq>
                </btypes:TYPE>
                and
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <fn M="yes">
                        <type num="1"/>
                        <type num="2"/>
                      </fn>
                    </spset>
                    <spset>
                      <type num="1"/>
                      <type num="2"/>
                    </spset>
                  </eq>
                </btypes:TYPE>. Therefore, we can re-write
                case (2.a.ii) as
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <gamma/>
                      <store/>
                      <aExpr num="i"/>
                      <type num="1"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>.
                Similarly, since
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <gamma/>
                      <type num="1"/>
                    </spset>
                    <spset>
                      <paren>
                        <extend>
                          <gamma/>
                          <mapping>
                            <id/>
                            <type num="1"/>
                          </mapping>
                        </extend>
                      </paren>
                    </spset>
                  </eq>
                </btypes:TYPE>, we can write
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l3">
              <p>
                Since we have
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                    </assume>
                    <tqExpr>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>, and 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>
                    <spset>
                      <extend>
                        <gamma/>
                        <mapping>
                          <id/>
                          <type num="1"/>
                        </mapping>
                      </extend>
                      <store/>
                      <aExpr num="i"/>
                      <type num="2"/>
                    </spset>
                  </models>
                </btypes:TYPE>,                
                from induction hypothesis, we obtain 
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <type num="1"/>
                      </mapping>
                    </extend>                    
                    <store/>
                    <aExpr num="i"/>
                    <type num="2"/>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l4">
              <p>
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <type num="1"/>
                      </mapping>
                    </extend>                    
                    <store/>
                    <aExpr num="i"/>
                    <type num="2"/>
                  </Djudge>
                </btypes:TYPE> is a shorthand for 
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <extend>
                            <gamma/>
                            <mapping>
                              <id/>
                              <type num="1"/>
                            </mapping>
                          </extend>                    
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>, which can be re-written as
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <mapping>
                          <id/>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="1"/>
                            </Subst>
                          </canonical>
                        </mapping>
                      </extend>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>
              </p>
            </li>
            <li id="ints_l5">
              <p>
                From case (2.d) and T-Lambda rule, we obtain
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <lambda>
                        <id/>
                        <canonical>                          
                          <Subst>
                            <aSubMap/>
                            <aExpr num="i"/>
                          </Subst>
                        </canonical>
                      </lambda>
                      <fn>
                        <minz>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="1"/>
                            </Subst>
                          </canonical>
                        </minz>
                        <maxz>
                          <canonical>
                            <Subst>
                              <aSubMap/>
                              <type num="2"/>
                            </Subst>
                          </canonical>
                        </maxz>
                      </fn>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="insts_l6">
              <p>
                From 
                <btypes:TYPE>
                  <defn tag="normalized-ctr-types"/>
                </btypes:TYPE> and
                <btypes:TYPE>
                  <defn tag="meta"/>
                </btypes:TYPE>, it is clear that
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <floor>
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                      </floor>
                    </canonical>                    
                    <minz>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                      </canonical>
                    </minz>
                  </eq>
                </btypes:TYPE>, and
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <ceil>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </ceil>
                    </canonical>
                    <maxz>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </canonical>
                    </maxz>
                  </eq>
                </btypes:TYPE>.
                Therefore, we can write
                <btypes:TYPE>
                  <eq br="yes">
                    <fn>
                      <minz>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <type num="1"/>
                          </Subst>
                        </canonical>
                      </minz>
                      <maxz>
                        <canonical>
                          <Subst>
                            <aSubMap/>
                            <type num="2"/>
                          </Subst>
                        </canonical>
                      </maxz>
                    </fn>
                    <fn>
                      <canonical>
                        <floor>
                          <Subst>
                            <aSubMap/>
                            <type num="1"/>
                          </Subst>
                        </floor>
                      </canonical>
                      <canonical>
                        <ceil>
                          <Subst>
                            <aSubMap/>
                            <type num="2"/>
                          </Subst>
                        </ceil>
                      </canonical>
                    </fn>
                    <canonical>
                      <fn M="yes">
                        <Subst>
                          <aSubMap/>
                          <type num="1"/>
                        </Subst>
                        <Subst>
                          <aSubMap/>
                          <type num="2"/>
                        </Subst>
                      </fn>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <fn M="yes">
                          <type num="1"/>
                          <type num="2"/>
                        </fn>
                      </Subst>                        
                    </canonical>
                  </eq>
                </btypes:TYPE>.
                It is further evident that
                <btypes:TYPE>
                  <eq>
                    <lambda>
                      <id/>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                    </lambda>
                    <canonical>
                      <Subst>
                        <aSubMap/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                      </Subst>
                    </canonical>
                  </eq>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_l7">
              <p>
                Substituting the equivalencies in case (2.f) into case
                (2.e), we obtain:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>                          
                        <Subst>
                          <aSubMap/>                          
                          <lambda>
                            <id/>
                            <aExpr num="i"/>
                          </lambda>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap/>
                          <fn>
                            <floor>
                              <type num="1"/>
                            </floor>
                            <ceil>
                              <type num="2"/>
                            </ceil>
                          </fn>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
                That is,
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <type num="1"/>
                      <type num="2"/>
                    </fn>                    
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li id="ints_app">
          <p>
            Case J-App:
          </p>
          <ol>
            <li id="ints_a1">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="ints_a1_1">
                  <p>
                    <btypes:TYPE>
                      <tyRule>
                        <tyPre>
                          <TDjudge name="j">
                            <aExpr num="1"/>
                            <type num="1"/>
                          </TDjudge>
                          <Msub>
                            <type num="1"/>
                            <fn M="yes">
                              <type num="a"/>
                              <type num="r"/>
                            </fn>
                          </Msub>
                        </tyPre>
                        <tyPre>
                          <TDjudge name="j">
                            <aExpr num="2"/>
                            <type num="2"/>
                          </TDjudge>
                          <Msub>
                            <type num="2"/>
                            <type num="a"/>
                          </Msub>                          
                          <Msub>
                            <type num="r"/>
                            <inner>
                              <type/>
                            </inner>
                          </Msub>
                        </tyPre>
                        <tyConc>
                          <TDjudge name="j">
                            <apply>
                              <aExpr num="1"/>
                              <aExpr num="2"/>
                            </apply>
                            <type/>
                          </TDjudge>
                        </tyConc>
                      </tyRule>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="ints_a1_2">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap/>
                        </assume>                
                        <spset>
                          <gamma/>
                          <store/>
                          <apply>
                            <aExpr num="1"/>
                            <aExpr num="2"/>
                          </apply>
                          <type/>
                        </spset>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
              <p>
                We need to show that 
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap/>
                    <gamma/>
                    <store/>
                    <apply>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                    </apply>
                    <type/>
                  </Djudge>
                </btypes:TYPE>.
              </p>                
            </li>
            <li id="ints_a2">
              <p>
                From case (3.a.ii), we obtain 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>                
                    <spset>
                      <gamma/>
                      <store/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                      <type/>
                    </spset>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a3">
              <p>
                Since 
                <btypes:TYPE>
                  <subeq>
                    <spset>
                      <gamma/>
                      <store/>
                    </spset>
                    <spset>
                      <gamma/>
                      <store/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>
                      <type/>
                    </spset>
                  </subeq>
                </btypes:TYPE>, from 
                case (3.b) and 
                <btypes:TYPE>
                  <lem tag="weakening-sat-cst"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap/>
                    </assume>                    
                    <spset>
                      <gamma/>
                      <store/>
                    </spset>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="ints_a4">
              <p>
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </proof>
    <lemma id="int-sub">
      <title>Substitution on Intermediate Derivation</title>
      <p>
        <btypes:TYPE>	    
          <text content="If "/>
          <Sjudge name="j">
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
          <text content=" and "/>          
          <aSubMap/>
          <text content=" is a substitution such that "/>
          <models name="cst">
            <assume/>
            <Subst>
              <aSubMap/>              
              <spset>
                <gamma/>
                <store/>
                <aExpr/>
                <type/>
              </spset>
            </Subst>
          </models>
          <text content=", then "/>
          <judge name="j">
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>	
    </lemma>
    <proof>
      <p>
        Straightforward induction on the
        derivation of 
        <btypes:TYPE>	    
          <Sjudge name="j">
            <assume>
              <gamma/>
              <store/>
            </assume>
            <tqExpr>
              <aExpr/>
              <type/>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>, similar to 
        <btypes:TYPE>	    
          <lem tag="decl-sub"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <theorem id="heuristic-inference-sound">
      <title>Soundness of Heuristic Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>
        then,
        <btypes:TYPE>
          <judge name="j">
            <precond>
              <aSubMap/>
            </precond>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
          </judge>
        </btypes:TYPE>.
      </p>
    </theorem>
    <p>
      _____________________________________________
    </p>
    <!-- 
    <lemma id="int-consistent">
      <title>Consistency of Intermediate Derivation</title>
      <p>
        If 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>
        and
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <spset>
              <gamma/>
              <store/>
            </spset>
          </models>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <spset>
              <gamma/>
              <store/>
              <aExpr/>
              <type/>
            </spset>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TDjudge name="j">
            <aExpr/>
            <type/>
          </TDjudge>
        </btypes:TYPE>.
      </p>
      <ol>
        <li>
          <p>
            The cases that introduce new types are J-ID and J-Lambda,
            and there is an explicit consistency constraint imposed in
            these steps.
          </p>
        </li>
        <li>
          <p>
            Case J-TqExpr has a (user) annotated type, but this must
            exactly match a derived type, which must be consistent by
            induction hypothesis.
            (This case is actually more restrictive than necessary,
            since it precludes typing of expressions like
            <btypes:TYPE>
              <tqExpr>
                <paren>
                  <tqExpr>
                    <aExpr/>
                    <type/>
                  </tqExpr>
                </paren>
                <mbpair>
                  <tvar name="alpha"/>
                  <type/>
                </mbpair>
              </tqExpr>
            </btypes:TYPE>.            
            but is sufficient to facilitate the proof of the main
            soundness theorem).
          </p>
        </li>
        <li>
          <p>
            The types obtained from all other cases are: 
          </p>
          <ol>
            <li>
              <p>
                Obtained from
                <btypes:TYPE>
                  <gamma/>
                </btypes:TYPE> or
                <btypes:TYPE>
                  <store/>
                </btypes:TYPE>, which are given to be consistent.
              </p>
            </li>
            <li>
              <p>
                Types that were derived from the previous steps,
                which are consistent by induction hypothesis.
              </p>
            </li>
            <li>
              <p>                
                Types of the form 
                <btypes:TYPE>
                  <type/>
                </btypes:TYPE> where
                <btypes:TYPE>
                  <Msub>
                    <type/>
                    <type dash="'"/>
                  </Msub>
                </btypes:TYPE>, and
                <btypes:TYPE>
                  <type dash="'"/>
                </btypes:TYPE> is a consistent type derived from a
                previous steps. The consistency is now proved by
                induction on the derivation of
                <btypes:TYPE>
                  <Msub>
                    <type/>
                    <type dash="'"/>
                  </Msub>
                </btypes:TYPE>. The interesting cases are M-May2 and
                M-May3 (figure&nbsp;<xref ref="hm_inter_rules"/>),
                which explicitly include assertions that preserve
                consistency.
              </p>
            </li>
          </ol>
        </li>
      </ol>
      <p>
        This consistency is a stronger property than what is required
        for  soundness of the intermediate system. That is,
        considering types like
        <btypes:TYPE>
          <mbpair>
            <unit/>
            <bool/>
          </mbpair>
        </btypes:TYPE>
        to be equivalent to 
        <btypes:TYPE>
          <unit/>
        </btypes:TYPE>, and only satisfying the constrained types of
        the form 
        <btypes:TYPE>
          <mbpair>
            <tvar name="alpha"/>
            <type/>
          </mbpair>
        </btypes:TYPE> is sufficient to prove soundness.
        However, proving the stronger property is more straightforward.
      </p>
    </proof>
    <lemma id="cst-multiple">
      <title>Partial Solutions</title>
      <p>
        If 
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <aCtset/>
          </models>
        </btypes:TYPE>, 
        <btypes:TYPE>
          <subeq>
            <aCtset dsah="'"/>
            <aCtset/>
          </subeq>
        </btypes:TYPE>, and 
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap/>
            </assume>
            <aCtset dash="'"/>
          </models>
        </btypes:TYPE>, then
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <Subst>              
              <aSubMap/>
              <aCtset/>
            </Subst>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <lemma id="sat-solvable">
      <title>Satisfying extracted constraints</title>
      <p>
        If 
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <spset>
                  <solvable num="1"/>
                  <text content="..."/>
                  <solvable num="n"/>
                </spset>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <aSubMap/>
            </btypes:TYPE> is a substitution
            such that
            <btypes:TYPE>
              <Forall>
                <tvar name="alpha"/>
                <type/>
                <type dash="'"/>
                <grouping>
                  <text content=" and "/>
                  <in>
                    <solvable num="i"/>
                    <set>
                      <solvable num="1"/>
                      <text content="..."/>
                      <solvable num="n"/>
                    </set>
                  </in>
                </grouping>
              </Forall>
              <text content=", "/>
              <in>
                <mbpair>
                  <tvar name="alpha"/>
                  <type/>
                </mbpair>
                <solvable num="i"/>
              </in>
              <text content=" implies "/>          
              <in>
                <SubMap>
                  <tvar name="alpha"/>
                  <type dash="'"/>
                </SubMap>
                <aSubMap/>
              </in> 
              <text content=", where "/>
              <ceq>
                <type dash="'"/>
                <inner>
                  <type/>
                </inner>
              </ceq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        then, we have,
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSolvable/>
            </assume>
            <spset>
              <solvable num="1"/>
              <text content="..."/>
              <solvable num="n"/>
            </spset>
          </models>          
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Since we have 
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <spset>
              <solvable num="1"/>
              <text content="..."/>
              <solvable num="n"/>
            </spset>
          </models>          
        </btypes:TYPE>, then 
        <btypes:TYPE>
          <Forall>
            <tvar name="alpha"/>
            <type dash="'"/>
            <type dash="''"/>
            <in>
              <grouping>
                <solvable num="i"/>
                <text content=" and "/>
                <solvable num="j"/>
              </grouping>
              <set>
                <solvable num="1"/>
                <text content="..."/>
                <solvable num="n"/>
              </set>
            </in>
          </Forall>
          <text content=", if "/>
          <in>
            <mbpair>
              <tvar name="alpha"/>
              <type dsah="'"/>
            </mbpair>
            <solvable num="i"/>
          </in>
          <text content=", and "/>
          <in>
            <mbpair>
              <tvar name="alpha"/>
              <type dash="''"/>
            </mbpair>
            <solvable num="j"/>
          </in>
          <text content=", then "/>
          <ceq>
            <inner>
              <type dash="'"/>
            </inner>
            <inner>
              <type dash="''"/>
            </inner>
          </ceq>
        </btypes:TYPE>.
        Now, it is evident that any substitution
        <btypes:TYPE>
          <SubMap>
            <tvar name="alpha"/>
            <type num="c"/>
          </SubMap>
        </btypes:TYPE> such that
        <btypes:TYPE>
          <ceq>
            <type num="c"/>
            <type dash="'"/>
            <type dash="''"/>
          </ceq>
        </btypes:TYPE>
        can satisfy the all the of constraints generated by the 
        constrained types of the form
        <btypes:TYPE>
          <mbpair>
            <tvar name="alpha"/>
            <type/>
          </mbpair>
        </btypes:TYPE>. Since 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE> is the composistion of all such substitutions,
        we obtain
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSolvable/>
            </assume>
            <spset>
              <solvable num="1"/>
              <text content="..."/>
              <solvable num="n"/>
            </spset>
          </models>          
        </btypes:TYPE>.
      </p>
    </proof>
    -->
    <definition id="sol-math">
      <title><btypes:TYPE><models name="sol"/></btypes:TYPE></title>
      <p>
        &thinsp;<br/>
      </p>
      <btypes:TYPE>
        <Hrules vspace="yes">
          <tyRule>
            <tyPre>
              <models name="sat">
                <aSubMap/>
                <spset>
                  <solvable/>
                </spset>
              </models>
              <eq>
                <inter>
                  <dom>
                    <aSubMap/>
                  </dom>
                  <pred name="TV">
                    <solvable/>
                  </pred>
                </inter>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </eq>
            </tyPre>
            <tyConc>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>            
    </definition>
    <p>
      That is, 
      <btypes:TYPE>
        <aSubMap/>
      </btypes:TYPE> solves all copy compatibility
      constraints in  
      <btypes:TYPE>
        <solvable/>
      </btypes:TYPE>, but does not contain substitutions to 
      other type variables in 
      <btypes:TYPE>
        <solvable/>
      </btypes:TYPE>. It is, however, free to contain other
      substitutions that do not matter wrt
      <btypes:TYPE>
        <solvable/>
      </btypes:TYPE>.
    </p>
    <definition id="ct">
      <title>Strong Consistency</title>
      <p>
        &thinsp;<br/>
      </p>
      <btypes:TYPE>
        <Hrules vspace="yes">
          <tyRule>
            <tyPre>
              <models name="cst">
                <assume/>
                <solvable/>
              </models>
              <eq>
                <inter>
                  <pred name="MTV">
                    <solvable/>
                  </pred>
                  <pred name="NTV">
                    <solvable/>
                  </pred>
                </inter>
                <Empty/>
              </eq>
            </tyPre>
            <tyConc>
              <models name="ct">
                <assume/>
                <solvable/>
              </models>
            </tyConc>
          </tyRule>
        </Hrules>
      </btypes:TYPE>            
    </definition>    
    <p>
      Since we have
      <btypes:TYPE>
        <models name="cst">
          <assume/> 
          <solvable/>
        </models>
      </btypes:TYPE>, if 
      <btypes:TYPE>
        <mbpair>
          <tvar name="alpha"/>
          <type num="h1"/>
        </mbpair>
      </btypes:TYPE> and
      <btypes:TYPE>
        <mbpair>
          <tvar name="alpha"/>
          <type num="h2"/>
        </mbpair>
      </btypes:TYPE> are structurally a part of
      <btypes:TYPE>
        <solvable/>
      </btypes:TYPE>, we must have
      <btypes:TYPE>
        <ceq>
          <inner>
            <mbpair>
              <tvar name="alpha"/>
              <type num="h1"/>
            </mbpair>
          </inner>
          <inner>
            <mbpair>
              <tvar name="alpha"/>
              <type num="h2"/>
            </mbpair>
          </inner>
        </ceq>
      </btypes:TYPE>.
      Further, 
      <btypes:TYPE>
        <eq>
          <inter>
            <pred name="MTV">
              <solvable/>
            </pred>
            <pred name="NTV">
              <solvable/>
            </pred>
          </inter>
          <Empty/>
        </eq>
      </btypes:TYPE>
      guarantees that constrained type variables do not appear
      unconstrained elsewhere in 
      <btypes:TYPE>
        <solvable/>
      </btypes:TYPE>.
      We call this property strong consistency, denoted by 
      <btypes:TYPE>
        <models name="ct"/>
      </btypes:TYPE>.
    </p>
    <definition id="reachable-store">
      <title>Reachable Store</title>
      <p>
        We define
        <btypes:TYPE>
          <relevant>
            <store/>
            <collection etc="yes">
              <aExpr num="1"/>
              <aExpr num="2"/>                
            </collection>
          </relevant>
        </btypes:TYPE>
        as a store such that 
        <btypes:TYPE>
          <subeq>
            <relevant>
              <store/>
              <collection etc="yes">
                <aExpr num="1"/>
                <aExpr num="2"/>                
              </collection>
            </relevant>
            <store/>
          </subeq>
        </btypes:TYPE>
        and 
        <btypes:TYPE>
          <relevant>
            <store/>
            <collection etc="yes">
              <aExpr num="1"/>
              <aExpr num="2"/>                
            </collection>
          </relevant>
        </btypes:TYPE>
        contains mappings for <em>only</em>
        those locations that are reachable from
        <btypes:TYPE>
          <collection etc="yes">
            <aExpr num="1"/>
            <aExpr num="2"/>                
          </collection>
        </btypes:TYPE>
        (that is, the location is syntactically a part of 
        <btypes:TYPE>
          <collection etc="yes">
            <aExpr num="1"/>
            <aExpr num="2"/>                
          </collection>
        </btypes:TYPE>).
      </p>
    </definition>
    <definition id="compat-subst">
      <title>Compatible Solutions (Substitutions)</title>
      <p>
        We write 
        <btypes:TYPE>
          <ceq>
            <aSubMap num="1"/>
            <aSubMap num="2"/>
          </ceq>
          <text content=" if "/>
          <Forall>
            <in>
              <SubMap>
                <tvar name="alpha"/>
                <type num="1"/>
              </SubMap>
              <aSubMap num="1"/>
            </in>
          </Forall>
          <text content=", it is true that "/>
          <in>
            <SubMap>
              <tvar name="alpha"/>
              <type num="2"/>
            </SubMap>
            <aSubMap num="2"/>
          </in>
          <text content=" (that is,"/>
          <eq>
            <dom>
              <aSubMap num="1"/>
            </dom>
            <dom>
              <aSubMap num="2"/>
            </dom>
          </eq>
          <text content="), and "/>
          <ceq>
            <type num="1"/>
            <type num="2"/>
          </ceq>
        </btypes:TYPE>.
      </p>
    </definition>
    <definition id="equiv-subst">
      <title>Equivalent Substitutions</title>
      <p>
        We write 
        <btypes:TYPE>
          <Sjudge name="eqi">
            <assume>
              <solvable/>
            </assume>              
            <approx>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </approx>
          </Sjudge>
          <text content=" if "/>
          <eq>
            <Subst>
              <aSubMap num="1"/>
              <solvable/>
            </Subst>
            <Subst>
              <aSubMap num="2"/>
              <solvable/>
            </Subst>            
          </eq>
        </btypes:TYPE>
      </p> 
      <p>
        For example:
        <btypes:TYPE>            
          <Sjudge name="eqi">
            <assume>
              <tvar name="alpha"/>
            </assume>              
            <approx>
              <SubMap>
                <tvar name="alpha"/>
                <type/>
              </SubMap>
              <compose>
                <SubMap>                  
                  <tvar name="alpha"/>
                  <tvar name="beta"/>
                </SubMap>
                <SubMap>
                  <tvar name="beta"/>
                  <type/>
                </SubMap>
              </compose>
            </approx>
          </Sjudge>
        </btypes:TYPE>.
      </p>
    </definition>
    <definition id="sub-subst">
      <title>Sub-Substitutions</title>
      <ol>
        <li>
          <p>
            We write           
            <btypes:TYPE>
              <subeq>
                <aSubMap dash="'"/>
                <aSubMap/>
              </subeq>
              <text content=" if "/>
              <Exists>
                <aSubMap num="1"/>
                <aSubMap num="2"/>
              </Exists>
              <text content=" such that "/>            
              <eq>
                <aSubMap/>
                <compose>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </compose>
              </eq>
              <text content=", and "/>
              <eq>
                <aSubMap dash="'"/>
                <aSubMap num="1"/>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            We write           
            <btypes:TYPE>
              <spEq>
                <aSubMap dash="'"/>
                <aSubMap/>
              </spEq>
              <text content=" if "/>
              <Exists>
                <aSubMap num="1"/>
                <aSubMap num="2"/>
              </Exists>
              <text content=" such that "/>            
              <eq>
                <aSubMap/>
                <compose>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </compose>
              </eq>
              <text content=", and "/>
              <ceq>
                <aSubMap dash="'"/>
                <aSubMap num="1"/>
              </ceq>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </definition>
    <theorem id="TI-unify-correct">
      <title>Correctness of Unification</title>
      <p>
        <btypes:TYPE>
          <text content="If "/>
          <eq>
            <normalize>
              <type num="1"/>
            </normalize>
            <ctype>
              <canonical>
                <type num="1"/>
              </canonical>
              <aCtset num="1"/>
            </ctype>
          </eq>            
          <text content=", "/>
          <eq>
            <normalize>
              <type num="2"/>
            </normalize>
            <ctype>
              <canonical>
                <type num="2"/>
              </canonical>		
              <aCtset num="2"/>
            </ctype>
          </eq>
          <text content=", "/>
          <models name="ca">   
            <assume/>
            <aCtset num="1"/>
          </models>                 
          <text content=", "/>
          <models name="ca">   
            <assume/>
            <aCtset num="2"/>
          </models>                 
          <text content=", "/>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>              
            <aSubMap/>
          </UNIFY>
          <text content=", then:"/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ca">   
                <assume/>
                <canonical>
                  <unin>
                    <set>
                      <eq>
                        <canonical>
                          <type num="1"/>
                        </canonical>
                        <canonical>
                          <type num="2"/>
                        </canonical>
                      </eq>
                    </set> 
                    <aCtset num="1"/>
                    <aCtset num="2"/>
                  </unin>
                </canonical>
              </models>
              <text content="."/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ca">   
                <nothing/>
                <plus>
                  <Subst>
                    <aSubMap/>
                    <type num="1"/>
                  </Subst>
                  <Subst>
                    <aSubMap/>
                    <type num="2"/>
                  </Subst>
                </plus>
              </models> 
              <text content=" and "/>
              <models name="ca">   
                <nothing/>
                <aSubMap/>
              </models> 
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </theorem>
    <theorem id="TI-solve-correct">
      <title>Correctness of the Constraint Solver</title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="sol">
            <assume>
              <aSubMap/>
            </assume>
            <solvable/>
          </Sjudge>              
        </btypes:TYPE>,
        then 
        <btypes:TYPE>
          <models name="sol">
            <assume>
              <aSubMap/>
            </assume>
            <solvable/>
          </models>              
        </btypes:TYPE>.
      </p>
    </theorem>
    <p>
      We will also use the following equivalent forms (or special
      cases of the above statement): 
    </p>
    <ol>
      <li>
        <p>
          If
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <solvable/>
            </Sjudge>              
          </btypes:TYPE>,
          then 
          <btypes:TYPE>
            <models name="cst">
              <assume/>
              <Subst>
                <aSubMap/>
                <solvable/>
              </Subst>
            </models>              
          </btypes:TYPE>.
        </p>
      </li>
      <li>
        <p>
          If
          <btypes:TYPE>
            <Sjudge name="sol">
              <assume>
                <aSubMap/>
              </assume>
              <solvable/>
            </Sjudge>              
          </btypes:TYPE>,
          then 
          <btypes:TYPE>
            <eq>
              <normalize>
                <Subst>
                  <aSubMap/>
                  <solvable/>
                </Subst>
              </normalize>
              <canonical>
                <Subst>
                  <aSubMap/>
                  <solvable/>
                </Subst>
              </canonical>
            </eq>
          </btypes:TYPE>.
        </p>
      </li>
      <li>
        <p>
          If          
          <btypes:TYPE>
            <Sjudge name="s">
              <assume>
                <aSubMap/>
              </assume>
              <corUp>
                <type/>
                <type dash="'"/>
              </corUp>
            </Sjudge>
            <text content=" then "/>
            <eq>
              <normalize>
                <Subst>
                  <aSubMap/>
                  <type/>
                </Subst>
              </normalize>
              <canonical>
                <type dash="'"/>
              </canonical>
            </eq>
          </btypes:TYPE>.
        </p>
      </li>
    </ol>
    <theorem id="TI-solve-total">
      <title>Totality of the Constraint Solver</title>
      <ol>
        <li>
          <p>
            If          
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <solvable/>
              </models>
              <text content=" then "/>
              <Exists>
                <aSubMap/>
              </Exists>
              <text content=" such that "/>            
              <Sjudge name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If          
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>
              <text content=" then "/>
              <Exists>
                <spEq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </spEq>
              </Exists>
              <text content=" such that "/>            
              <Sjudge name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If 
            <btypes:TYPE>
              <Sjudge name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </Sjudge>   
              <text content=", then "/>
              <eq>
                <dom>
                  <aSubMap/>
                </dom>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </theorem>
    <theorem id="unique-solve-solutions">
      <title>Uniqueness of Solutions Produced by the Solver</title> 
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="sol">
            <assume>
              <aSubMap num="1"/>
            </assume>
            <solvable/>
          </Sjudge>
          <text content=" and "/>
          <Sjudge name="sol">
            <assume>
              <aSubMap num="2"/>
            </assume>
            <solvable/>
          </Sjudge>
          <text content=", then "/>
          <eq>
            <aSubMap num="1"/>
            <aSubMap num="2"/>
          </eq>
        </btypes:TYPE>.
      </p>
    </theorem>
    <theorem id="TI-unify-decidable">
      <title>Decidability of Unification</title>
      <p>
        If
        <btypes:TYPE>
          <models name="acy">
            <assume/>
            <type num="1"/>
          </models>
          <text content=" and "/>
          <models name="acy">
            <assume/>
            <type num="2"/>
          </models>
        </btypes:TYPE>, then,        
        a normalizing derivation of 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>
            <aSubMap/>
          </UNIFY>
        </btypes:TYPE>
        where no two uses of U-Commut occur consecutively is
        decidable. 
      </p>
    </theorem>
    <proof>
      <p>
        The unifier and constraint solver builds a solution tree by
        always invoking itself types having <em>smaller</em> shapes of
        types (after eliminating redundant uses of the U-Commut rule).
        Since types are of bounded size and acyclic, and since
        unification itself does not produce any cycles
        (Theorem&nbsp;<xref ref="TI-unify-correct"/>), these
        derivations must be bounded. 
      </p>
    </proof>
    <theorem id="TI-solve-decidable">
      <title>Decidability of the Constraint Solver</title>
      <p>
        If
        <btypes:TYPE>
          <models name="acy">
            <assume/>
            <type/>
          </models>
        </btypes:TYPE>, then,
        the derivation of
        <btypes:TYPE>
          <Sjudge name="s">
            <assume>
              <aSubMap/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
          <text content=" is decidable."/>
        </btypes:TYPE>
      </p>
    </theorem>
    <proof>
      <p>
        Similar to Theorem&nbsp;<xref ref="TI-unify-decidable"/>. 
      </p>
    </proof>
    <lemma id="sol-math-properties"> 
      <title>Properties of 
        <btypes:TYPE><models name="sol"/></btypes:TYPE></title>
      <ol>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>              
              <text content=" then "/>
              <models name="cst">
                <assume/>
                <Subst>
                  <aSubMap/>
                  <solvable/>
                </Subst>
              </models>              
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <solvable/>
              </models>              
              <text content=" then "/>
              <Exists>
                <aSubMap/>
              </Exists>
              <text content=" such that "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>              
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <text content="If "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>              
              <text content=" then "/>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </canonical>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <lemma id="eqi-sol-properties">
      <title>Properties of Equivalent Substitutions</title>
      <p>
        <btypes:TYPE>
          <text content = " If "/>            
          <Sjudge name="eqi">
            <assume>
              <solvable/>
            </assume>
            <approx>
              <aSubMap num="1"/>
              <aSubMap num="2"/>
            </approx>
          </Sjudge>
          <text content = ", then:"/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="1"/>
                </assume>
                <solvable/>
              </models>
              <text content=" implies "/>
              <models name="sol">
                <assume>
                  <aSubMap num="2"/>
                </assume>
                <solvable/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <Subst>
                  <aSubMap num="1"/>
                  <solvable/>
                </Subst>
              </models>
              <text content=" implies "/>
              <models name="cst">
                <assume/>
                <Subst>
                  <aSubMap num="2"/>
                  <solvable/>
                </Subst>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <Subst>
                  <aSubMap num="1"/>
                  <solvable/>
                </Subst>
              </models>
              <text content=" implies "/>
              <models name="ct">
                <assume/>
                <Subst>
                  <aSubMap num="2"/>
                  <solvable/>
                </Subst>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="1"/>
                    <solvable/>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap num="1"/>
                    <solvable/>
                  </Subst>
                </canonical>
              </eq>                  
              <text content=" implies "/>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="2"/>
                    <solvable/>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap num="2"/>
                    <solvable/>
                  </Subst>
                </canonical>
              </eq>                  
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Evident from the definition of equivalent substitutions.
      </p>
    </proof>
    <lemma id="cst-implies-consistent">
      <title>Weakening of Consistency</title>
      <p>
        Strong consistency implies consistency. That is,
        If
        <btypes:TYPE>
          <models name="ct">
            <assume/> 
            <solvable/>
          </models>
          <text content=", then "/>
          <models name="cst">
            <assume/> 
            <solvable/>
          </models>
        </btypes:TYPE>.         
      </p>
    </lemma>
    <proof>
      <p>
        Evident from Definition&nbsp;<xref ref="ct"/>.
      </p>
    </proof>            
    <lemma id="coequal-solve-OK">
      <title>Relationship of Solutions</title>
      <p>
        If
        <btypes:TYPE>
          <models name="sol">
            <assume>
              <aSubMap num="1"/>
            </assume>
            <solvable/>
          </models>
          <text content=" and "/>
          <models name="sol">
            <assume>
              <aSubMap num="2"/>
            </assume>
            <solvable/>
          </models>
          <text content = " then  "/>
          <Exists>
            <aSubMap num="11"/>
            <aSubMap num="12"/>
            <aSubMap num="21"/>
            <aSubMap num="22"/>
          </Exists>
          <text content = " such that "/>
        </btypes:TYPE>
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <aSubMap num="1"/>
                <compose>
                  <aSubMap num="11"/>
                  <aSubMap num="12"/>
                </compose>
              </eq>
              <text content = " and  "/>
              <eq>
                <aSubMap num="2"/>
                <compose>
                  <aSubMap num="21"/>
                  <aSubMap num="22"/>
                </compose>
              </eq>           
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <dom>
                  <aSubMap num="11"/>
                </dom>
                <dom>
                  <aSubMap num="21"/>
                </dom>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <ceq>
                <aSubMap num="11"/>
                <aSubMap num="21"/>              
              </ceq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <Subst>
                  <aSubMap num="12"/>
                  <canonical>
                    <solvable/>
                  </canonical>
                </Subst>
                <Subst>
                  <aSubMap num="22"/>
                  <canonical>
                    <solvable/>
                  </canonical>
                </Subst>
                <canonical>
                  <solvable/>
                </canonical>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <lemma id="solve-sol-compat">
      <title>Relationship between 
        <btypes:TYPE><Sjudge name="solve"/></btypes:TYPE> and  
        <btypes:TYPE><Sjudge name="s"/></btypes:TYPE></title>
      <p>
        If
        <btypes:TYPE>
          <Sjudge name="s">
            <assume>
              <aSubMap num="1"/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp> 
          </Sjudge>           
          <text content=" and "/>
          <Sjudge name="solve">
            <assume>
              <aSubMap num="2"/>
              <id/>
              <aExpr/>
            </assume>
            <corUp>
              <type/>
              <type dash="''"/>
            </corUp> 
          </Sjudge>
          <text content=" then "/>
          <ceq>
            <type dash="'"/>
            <type dash="''"/>
          </ceq>
          <text content=" and "/>
          <ceq>
            <aSubMap num="1"/>
            <aSubMap num="2"/>
          </ceq>            
        </btypes:TYPE>.
      </p>
    </lemma>
    <lemma id="sol-plus-commut">
      <title>Commutativity 
        of<btypes:TYPE><plus><nothing/><nothing/></plus></btypes:TYPE>over
        Solvable Entities</title>
      <ol>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <solvable num="2"/>
                  <solvable num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <Sjudge name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </Sjudge>
              <text content=" then "/>
              <Exists>
                <ceq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </ceq>
              </Exists>
              <text content=" such that "/>            
              <Sjudge name="sol">
                <assume>
                  <aSubMap dash="'"/>
                </assume>
                <plus>
                  <solvable num="2"/>
                  <solvable num="1"/>
                </plus>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="cst">
                <assume/>
                <plus>
                  <solvable num="2"/>
                  <solvable num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable num="2"/>
                  <solvable num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <lemma id="solvable-weakening">
      <title>Weakening over Solvable Entities</title>
      <ol>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="cst">
                <assume/>
                <solvable num="1"/>
              </models>
              <text content=" and "/>
              <models name="cst">
                <assume/>
                <solvable num="2"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <solvable/>
              </models>
              <text content=" and "/>
              <subeq>
                <solvable dash="'"/>
                <solvable/>
              </subeq>  
              <text content=" then "/>
              <models name="cst">
                <assume/>
                <solvable dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="ct">
                <assume/>
                <solvable num="1"/>
              </models>
              <text content=" and "/>
              <models name="ct">
                <assume/>
                <solvable num="2"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <solvable/>
              </models>
              <text content=" and "/>
              <subeq>
                <solvable dash="'"/>
                <solvable/>
              </subeq>  
              <text content=" then "/>
              <models name="ct">
                <assume/>
                <solvable dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <solvable/>
                  </Subst>
                </canonical>
              </eq>
              <text content=" and "/>
              <subeq>
                <solvable dash="'"/>
                <solvable/>
              </subeq>  
              <text content=", then "/>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap/>
                    <solvable dash="'"/>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap/>
                    <solvable dash="'"/>
                  </Subst>
                </canonical>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <Exists>
                <subeq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </subeq>
              </Exists>
              <text content=" and "/>
              <Exists>
                <subeq>
                  <aSubMap dash="''"/>
                  <aSubMap/>
                </subeq>
              </Exists>
              <text content=" such that "/>
              <models name="sol">
                <assume>
                  <aSubMap dash="'"/>
                </assume>
                <solvable num="1"/>
              </models>
              <text content=" and "/>
              <models name="sol">
                <assume>
                  <aSubMap dash="''"/>
                </assume>
                <solvable num="2"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>
              <text content=" and "/>
              <subeq>
                <solvable dash="'"/>
                <solvable/>
              </subeq>  
              <text content=", then "/>
              <Exists>
                <subeq>
                  <aSubMap dash="'"/>
                  <aSubMap/>
                </subeq>
              </Exists>
              <text content=" such that "/>
              <models name="sol">
                <assume>
                  <aSubMap dash="'"/>
                </assume>
                <solvable dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" and "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <solvable num="1"/>
                  <solvable num="2"/>
                </plus>
              </models>
              <text content=" then "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable num="1"/>
              </models>
              <text content=" and "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable num="2"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            If
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable/>
                </plus>
              </models>
              <text content=" and "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable/>
              </models>
              <text content=" and "/>
              <subeq>
                <solvable dash="'"/>
                <solvable/>
              </subeq>  
              <text content=", then "/>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <solvable dash="'"/>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <lemma id="T-Weakening-ext">
      <title>Extension to 
        Weakening Lemma&nbsp;<xref ref="T-Weakening"/>.</title>
      <p>
        If 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <gamma/>
              </canonical>
              <canonical>
                <store/>
              </canonical>
            </assume>
            <tqExpr>
              <canonical>
                <aExpr/>
              </canonical>
              <canonical>
                <type/>
              </canonical>
            </tqExpr>
          </Sjudge>                
          <text content=" and "/>
          <supeq>
            <gamma dash="'"/>
            <gamma/>
          </supeq>
          <text content=" and "/>
          <supeq>
            <store dash="'"/>
            <store/>
          </supeq>
          <text content=" and "/>
          <eq>
            <normalize>
              <gamma dash="'"/>
            </normalize>
            <canonical>
              <gamma dash="'"/>
            </canonical>
          </eq>
          <text content=" and "/>
          <eq>
            <normalize>
              <store dash="'"/>
            </normalize>
            <canonical>
              <store dash="'"/>
            </canonical>
          </eq>            
          <text content=", then, "/>
          <Sjudge>
            <assume>
              <canonical>
                <gamma dash="'"/>
              </canonical>
              <canonical>
                <store dash="'"/>
              </canonical>
            </assume>
            <tqExpr>
              <canonical>
                <aExpr/>
              </canonical>
              <canonical>
                <type/>
              </canonical>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>.
      </p>
    </lemma>
    <lemma id="cst-subst">
      <title>Substitution on 
        Strongly Compatible Entities</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <solvable num="f"/>
                  <solvable/>
                  <solvable num="s"/>
                </plus>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <Subst>
                  <aSubMap/>
                  <solvable/>
                </Subst>
              </models>
            </btypes:TYPE>
            for some substitution 
            <btypes:TYPE>
              <aSubMap/>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="cst-subst__a_tvs-in-w">
          <p>
            <btypes:TYPE>                
              <subeq>
                <inter>
                  <dom>
                    <aSubMap/>
                  </dom>
                  <pred name="TV">
                    <plus>
                      <solvable num="f"/>
                      <solvable/>
                      <solvable num="s"/>
                    </plus>
                  </pred>                    
                </inter>                    
                <pred name="TV">
                  <solvable/>
                </pred>                    
              </subeq>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
      <p>
        Then, 
        <btypes:TYPE>
          <models name="ct">
            <assume/>
            <Subst>
              <aSubMap/>                
              <plus>
                <solvable num="f"/>
                <solvable/>
                <solvable num="s"/>
              </plus>
            </Subst>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        From 
        <btypes:TYPE>                
          <asm tag="cst-subst__a_tvs-in-w"/>
        </btypes:TYPE>, we know that only substitutions in  
        <btypes:TYPE>                
          <aSubMap/>
        </btypes:TYPE> that can affect 
        <btypes:TYPE>                
          <plus>
            <solvable num="f"/>
            <solvable/>
            <solvable num="s"/>
          </plus>
        </btypes:TYPE>
        are substitutions to type variables that are present in 
        <btypes:TYPE>                
          <solvable/>
        </btypes:TYPE>.
        From the definition of strong consistency, we know that all
        constrained types are compatibly constrained throughout the
        solvable entity. Therefore a substitution for some type
        variable within  
        <btypes:TYPE>
          <solvable/>
        </btypes:TYPE> cannot violate the strong consistency of
        <btypes:TYPE>
          <plus>
            <solvable num="f"/>
            <solvable/>
            <solvable num="s"/>
          </plus>
        </btypes:TYPE>. 
      </p>
      <p>
        Note that
        <btypes:TYPE>
          <solvable num="f"/>
          <text content=" or "/>
          <solvable num="s"/>
          <text content=" need not always present since"/>
          <text content=" we can imagine the presence of "/>
          <Empty/>
          <text content=" in that position. "/>
        </btypes:TYPE>            
      </p>
    </proof>
    <lemma id="sol-subst-must-be-compat">
      <title>Substitution Preserves 
        Compatibility of Solutions</title>
      <p>
        If
      </p>
      <ol>         
        <li>
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="1"/>
                </assume>
                <solvable/>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li id="sol-subst-must-be-compat__a_only-mtvs">
          <p>
            <btypes:TYPE>          
              <models name="sol">
                <assume>
                  <aSubMap num="2"/>
                </assume>
                <Subst>
                  <aSubMap/>
                  <solvable/>
                </Subst>              
              </models>            
              <text content=" for some "/>
              <aSubMap/>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <inter>
                  <dom>
                    <aSubMap num="1"/>
                  </dom>
                  <dom>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                  </dom>
                </inter>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Exists>
            <aSubMap num="1" dash="'"/>
            <aSubMap num="0"/>
          </Exists>
        </btypes:TYPE>
        such that
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <ceq>
                <aSubMap num="1"/>
                <aSubMap num="1" dash="'"/>
              </ceq>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge name="eqi">
                <assume>
                  <solvable/>
                </assume>                  
                <approx>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>                
                  <compose>
                    <aSubMap num="1" dash="'"/>
                    <aSubMap num="0"/>
                  </compose>
                </approx>
              </Sjudge>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        By construction of 
        <btypes:TYPE>
          <aSubMap num="1" dash="'"/>
          <text content=" and "/>
          <aSubMap num="0"/>
        </btypes:TYPE>.
      </p>
      <ol>
        <li>
          <p>
            For every substitution
            <btypes:TYPE>
              <in>
                <SubMap>
                  <tvar name="alpha"/>
                  <type/>
                </SubMap>
                <aSubMap num="1"/>
              </in>
              <text content=", where "/>
              <notin>
                <tvar name="alpha"/>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </notin>
              <text content=", add it to "/>
              <aSubMap num="1" dash="'"/>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            For every substitution 
            <btypes:TYPE>
              <in>
                <SubMap>
                  <tvar name="alpha"/>
                  <type/>
                </SubMap>
                <compose>
                  <aSubMap num="2"/>
                  <aSubMap/>
                </compose>
              </in>
              <text content=", where "/>
              <notin>
                <tvar name="alpha"/>
                <pred name="MTV">
                  <solvable/>
                </pred>
              </notin>
              <text content=", add it to "/>
              <aSubMap num="0"/>
            </btypes:TYPE>.
          </p>
        </li>          
        <li>
          <p>
            <btypes:TYPE>
              <Forall>
                <in>
                  <tvar name="alpha"/>
                  <pred name="MTV">
                    <solvable/>
                  </pred>
                </in>
              </Forall>
              <text content=", "/>
              <Exists>                  
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type/>
                  </SubMap>
                  <aSubMap num="1"/>
                </in>
              </Exists>
              <text content=" and "/>
              <Exists>                  
                <in>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type dash="'"/>
                  </SubMap>
                  <compose>                      
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                </in>
              </Exists>
              <text content=". If "/>
              <tvar name="alpha"/>
              <text content=" appears within  "/>
              <solvable/>                
              <text content=" in the form  "/>
              <mbpair>
                <tvar name="alpha"/>
                <type num="h"/>
              </mbpair>
              <text content=", we must have "/>
              <ceq>
                <type/>
                <Subst>
                  <aSubMap num="1"/>
                  <inner>
                    <type num="h"/>
                  </inner>
                </Subst>
              </ceq>
              <text content=". We must also have "/>
              <ceq>
                <type dash="'"/>
                <Subst>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                  <inner>
                    <type num="h"/>
                  </inner>
                </Subst>
              </ceq>                
            </btypes:TYPE>
          </p>
          <ol>
            <li>
              <p>
                If
                <btypes:TYPE>
                  <ceq>
                    <type/>
                    <type dash="'"/>
                  </ceq>
                  <text content=", then add "/>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type dash="'"/>
                  </SubMap>
                  <text content=" to "/>                
                  <aSubMap num="1" dash="'"/>
                </btypes:TYPE>.              
              </p>
            </li> 
            <li>
              <p>
                If
                <btypes:TYPE>
                  <nceq>
                    <type/>
                    <type dash="'"/>
                  </nceq>
                </btypes:TYPE>
                Since we have
                <btypes:TYPE>
                  <models name="cst">
                    <assume/>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <solvable/>
                    </Subst>
                  </models>              
                </btypes:TYPE>,
                from 
                <btypes:TYPE> 
                  <asm tag="sol-subst-must-be-compat__a_only-mtvs"/>
                </btypes:TYPE>, (and                
                Theorem&nbsp;<xref ref="TI-solve-correct"/>) and the
                fact that substitution must preserve the shape of a
                solvable entity, 
                <btypes:TYPE>                     
                  <type dash="'"/>
                </btypes:TYPE>
                can only differ from 
                <btypes:TYPE>                     
                  <type/>
                </btypes:TYPE>
                in top-level mutability, and/or by being a more
                specialized type (has some substitutions for type
                variables within 
                <btypes:TYPE>                     
                  <type/>
                </btypes:TYPE>).
                Therefore,                    
                <btypes:TYPE>
                  <Exists>
                    <aSubMap dash="''"/>
                  </Exists>
                  <text content=" (which possibly uses"/>
                  <text content=" fresh type variables)"/>
                  <text content=" such that the substitution"/>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type dash="'"/>
                  </SubMap>                    
                  <text content=" in "/>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                  <text content=" can be equivalently"/>                    
                  <text content=" re-written as "/>                    
                  <compose>
                    <SubMap>
                      <tvar name="alpha"/>
                      <type dash="''"/>
                    </SubMap>       
                    <aSubMap dash="''"/>
                  </compose>
                  <text content=" where "/>
                  <ceq>
                    <type/>
                    <type dash="''"/>
                  </ceq>
                  <text content=". Now add "/>
                  <SubMap>
                    <tvar name="alpha"/>
                    <type dash="''"/>
                  </SubMap>       
                  <text content=" to "/>
                  <aSubMap num="1" dash="'"/>
                  <text content=" and "/>
                  <aSubMap dash="''"/>
                  <text content=" to "/>
                  <aSubMap num="0"/>
                  <text content="."/>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>                    
      </ol>
    </proof>
    <lemma id="unify-strong-consistent">
      <title>Unification Preserves Strong Consistency</title>
      <p>
        If
        <btypes:TYPE>
          <models name="ct">   
            <nothing/>
            <plus>
              <type num="1"/>
              <type num="2"/>
            </plus>
          </models>          
          <text content=" and "/>
          <UNIFY>
            <type num="1"/>
            <type num="2"/>
            <aSubMap/>
          </UNIFY>
          <text content=" then "/>
          <models name="ct">   
            <nothing/>
            <plus>
              <Subst>
                <aSubMap/>
                <type num="1"/>
              </Subst>
              <Subst>
                <aSubMap/>
                <type num="2"/>
              </Subst>
            </plus>
          </models> 
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>        
        Follows from Theorem&nbsp;<xref ref="TI-unify-correct"/>, and
        by observing the rules U-Tvar, U-Mb-Mb, and U-Mb-Oth. 
      </p>
    </proof>
    <lemma id="unify-strong-consistent-cor">
      <title>Corollary to 
        Lemma&nbsp;<xref ref="unify-strong-consistent"/>.</title>
      <p>
        If
        <btypes:TYPE>
          <models name="ct">
            <assume/>
            <plus>
              <solvable/>
              <type/>
              <type dash="'"/>
            </plus>
          </models>
          <text content=" and "/>
          <UNIFY>
            <type dash="'"/>
            <type/>
            <aSubMap num="v"/>
          </UNIFY>
          <text content=" then "/> 
          <models name="ct">
            <assume/>
            <plus>
              <Subst>
                <aSubMap num="v"/>                      
                <solvable/>
              </Subst>
              <Subst>
                <aSubMap num="v"/>                      
                <type/>
              </Subst>
              <Subst>
                <aSubMap num="v"/>                      
                <type dash="'"/>
              </Subst>
            </plus>
          </models>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        Follows from 
        Lemma&nbsp;<xref ref="unify-strong-consistent"/> and
        Lemma&nbsp;<xref ref="cst-subst"/>.
      </p>
    </proof>
    <lemma id="unify-maybe">
      <title>Unification of Maybe Types</title>
      <p>
        If 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <mbpair>
              <type num="0"/>
              <type num="2"/>
            </mbpair>
            <aSubMap num="u"/>
          </UNIFY>
          <text content=" and "/>
          <models name="sol">
            <assume>
              <aSubMap num="s"/>
            </assume>              
            <plus>
              <Subst>
                <aSubMap num="u"/>
                <type num="1"/>
              </Subst>
              <Subst>
                <aSubMap num="u"/>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </plus>
          </models>
        </btypes:TYPE>,
        then:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="u"/>
                      <aSubMap num="s"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
                <canonical>
                  <floor>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </floor>
                </canonical>
              </Tsub>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <ceil>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </ceil>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="u"/>
                      <aSubMap num="s"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
              </Tsub>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="u"/>
                      <aSubMap num="s"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
                <canonical>
                  <minz>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </minz>
                </canonical>
              </Tsub>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <maxz>
                    <Subst>
                      <compose>
                        <aSubMap num="u"/>
                        <aSubMap num="s"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </maxz>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="u"/>
                      <aSubMap num="s"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
              </Tsub>	    
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        From the definition of maybe types, we have
        <btypes:TYPE>
          <ceq>
            <type num="0"/>
            <type num="2"/>
          </ceq>
        </btypes:TYPE>.
        Due to the unification 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <mbpair>
              <type num="0"/>
              <type num="2"/>
            </mbpair>
            <aSubMap num="u"/>
          </UNIFY>
        </btypes:TYPE>, we have
        <btypes:TYPE>
          <ceq>
            <Subst>
              <aSubMap num="u"/>
              <type num="1"/>
            </Subst>
            <Subst>
              <aSubMap num="u"/>
              <type num="2"/>
            </Subst>
          </ceq>
        </btypes:TYPE>.
        From 
        <btypes:TYPE>
          <models name="sol">
            <assume>
              <aSubMap num="s"/>
            </assume>              
            <plus>
              <Subst>
                <aSubMap num="u"/>
                <type num="1"/>
              </Subst>
              <Subst>
                <aSubMap num="u"/>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </plus>
          </models>
        </btypes:TYPE>
        and Lemma&nbsp;<xref ref="sol-math-properties"/>, we have:
        <btypes:TYPE>
          <models name="cst">
            <assume/>
            <plus>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="1"/>
              </Subst>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </plus>
          </models>
        </btypes:TYPE>
        Therefore, we must have:
        <btypes:TYPE>
          <ceq>
            <Subst>
              <compose>
                <aSubMap num="s"/>
                <aSubMap num="u"/>
              </compose>
              <type num="1"/>
            </Subst>
            <Subst>
              <compose>
                <aSubMap num="s"/>
                <aSubMap num="u"/>
              </compose>
              <type num="2"/>
            </Subst>
          </ceq>
        </btypes:TYPE>.
        Again, from Lemma&nbsp;<xref ref="sol-math-properties"/>, 
        we have:          
        <btypes:TYPE>
          <eq>
            <normalize>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="1"/>
              </Subst>
            </normalize>
            <canonical>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="1"/>
              </Subst>
            </canonical>
          </eq>        
          <text content=" and "/>
          <eq>
            <normalize>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </normalize>
            <canonical>
              <Subst>
                <aSubMap num="u"/>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </canonical>
          </eq>              
        </btypes:TYPE>.
        Since normalization does not violate any properties, we
        have: 
        <btypes:TYPE>
          <ceq>
            <canonical>
              <Subst>
                <compose>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
                <type num="1"/>
              </Subst>
            </canonical>
            <canonical>
              <Subst>
                <aSubMap num="u"/>
                <type num="2"/>
              </Subst>
            </canonical>
          </ceq>              
        </btypes:TYPE>.
        The conclusions are now evident from the definition of
        copy coercions in
        Figure&nbsp;<xref ref="decl_rules"/>.
      </p>
    </proof>      
    <lemma id="unify-maybe-cor">
      <title>Corollary to 
        Lemma&nbsp;<xref ref="unify-maybe"/></title>
      <p>
        If 
        <btypes:TYPE>
          <UNIFY>
            <type num="1"/>
            <mbpair>
              <type num="0"/>
              <type num="2"/>
            </mbpair>
            <aSubMap num="u"/>
          </UNIFY>
          <text content=" and "/>
          <models name="sol">
            <assume>
              <aSubMap num="s"/>
            </assume>              
            <plus>
              <Subst>
                <compose>
                  <aSubMap/>                  
                  <aSubMap num="u"/>                  
                </compose>
                <type num="1"/>
              </Subst>
              <Subst>
                <compose>
                  <aSubMap/>                  
                  <aSubMap num="u"/>                  
                </compose>
                <mbpair>
                  <type num="0"/>
                  <type num="2"/>
                </mbpair>
              </Subst>
            </plus>
          </models>
        </btypes:TYPE>,
        then:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap/>
                      <aSubMap num="u"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
                <canonical>
                  <floor>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </floor>
                </canonical>
              </Tsub>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <ceil>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </ceil>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap/>
                      <aSubMap num="u"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
              </Tsub>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap/>
                      <aSubMap num="u"/>
                    </compose>
                  </Subst>
                </canonical>
                <canonical>
                  <minz>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </minz>
                </canonical>
              </Tsub>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Tsub>
                <canonical>
                  <maxz>
                    <Subst>
                      <compose>
                        <aSubMap num="s"/>
                        <aSubMap/>
                        <aSubMap num="u"/>
                      </compose>
                      <type num="2"/>
                    </Subst>
                  </maxz>
                </canonical>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap/>
                      <aSubMap num="u"/>
                    </compose>
                    <type num="1"/>
                  </Subst>
                </canonical>
              </Tsub>	    
            </btypes:TYPE>
          </p>
        </li>
      </ol>
    </lemma>
    <proof>
      <p>
        Straightforward extension to 
        Lemma&nbsp;<xref ref="unify-maybe"/>.          
      </p>
    </proof>      
    <lemma id="inf-subst-valid">
      <title>Inferred Substitutions are Consistent.</title>
      <p>
        If
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="u"/>
            </propagate>
          </TIjudge>                
        </btypes:TYPE>,
        then 
        <btypes:TYPE>
          <models name="ct">
            <assume/>
            <plus>
              <Subst>
                <aSubMap num="u"/>                      
                <gamma/>
              </Subst>
              <Subst>
                <aSubMap num="u"/>                      
                <relevant>
                  <store/>
                  <aExpr/>
                </relevant>
              </Subst>
              <aExpr hat="yes"/>
              <type/>
            </plus>
          </models>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="u"/>
            </propagate>
          </TIjudge>                
        </btypes:TYPE> using 
        Lemma&nbsp;<xref ref="unify-strong-consistent"/>, and noting the
        facts that (1) all substitutions produced during inference are in
        turn produced by the unifier (or the solver), (2) all maybe
        types in the inference rules are introduced with fresh type
        variables, and (3) the two parts of a maybe type are never
        separated from each other.
      </p>
      <p>
        Since the store
        <btypes:TYPE>            
          <store/>
        </btypes:TYPE>
        can contain arbitrary typing assumptions in addition to the
        ones required for this derivation, we define the property on
        a canonicalized subset of the store.
      </p>
    </proof>
    <lemma id="inf-subst-valid-add">
      <title>Inferred Substitutions are 
        Cumulatively Consistent.</title>
      <p>
        If
      </p>
      <ol>
        <li id="inf-subst-valid-add__a1">
          <p>
            <btypes:TYPE>
              <TIjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="u1"/>
                </propagate>
              </TIjudge>                
            </btypes:TYPE>
          </p>
        </li>
        <li id="inf-subst-valid-add__a2">
          <p>
            <btypes:TYPE>
              <TIjudge>
                <assume>
                  <Subst>
                    <aSubMap num="u1"/>                      
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>                      
                    <store/>
                  </Subst>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="u2"/>
                </propagate>
              </TIjudge>                
            </btypes:TYPE>
          </p>
        </li>
        <li id="inf-subst-valid-add__a3">
          <p>
            Fresh variables used in the two derivations do not
            collide. 
          </p>
        </li>
      </ol>
      <p>
        Then 
        <btypes:TYPE>
          <models name="ct">
            <assume/>
            <plus br="yes">
              <Subst>
                <compose>
                  <aSubMap num="u2"/>                      
                  <aSubMap num="u1"/>                      
                </compose>
                <gamma/>
              </Subst>
              <Subst>
                <compose>
                  <aSubMap num="u2"/>                      
                  <aSubMap num="u1"/>                      
                </compose>                  
                <relevant>
                  <store/>
                  <collection>
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </collection>
                </relevant>
              </Subst>     
              <Subst>
                <compose>
                  <aSubMap num="u2"/>                      
                  <aSubMap num="u1"/>                      
                </compose>                  
                <aExpr hat="yes" num="1"/>
              </Subst>            
              <Subst>
                <compose>
                  <aSubMap num="u2"/>                      
                </compose>                                  
                <aExpr hat="yes" num="1"/>                
              </Subst>                      
              <Subst>
                <aSubMap num="u2"/>                      
                <type num="1"/>
              </Subst>
              <type num="2"/>
            </plus>
          </models>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <ol>
        <li>
          <p>
            The inference derivation for 
            <btypes:TYPE>
              <aExpr num="2"/>                  
            </btypes:TYPE>
            (which produces the substitution
            <btypes:TYPE>
              <aSubMap num="u2"/>                  
            </btypes:TYPE>)
            is done in an environment that already
            has applied the substitutions in
            <btypes:TYPE>
              <aSubMap num="u1"/>                  
            </btypes:TYPE>.
            From this fact, and 
            <btypes:TYPE>
              <asm tag="inf-subst-valid-add__a3"/>
            </btypes:TYPE>
            we can conclude that 
            <btypes:TYPE>
              <aSubMap num="u1"/>                  
              <text content=" and "/>
              <aSubMap num="u2"/>                  
            </btypes:TYPE> contain mutually exclusive substitutions.
          </p>
        </li>
        <li id="inf-subst-valid-add__d1">
          <p>
            From 
            <btypes:TYPE>
              <asm tag="inf-subst-valid-add__a1"/>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <lem tag="inf-subst-valid"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                    </relevant>
                  </Subst>
                  <type num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__d2">
          <p>
            From 
            <btypes:TYPE>
              <asm tag="inf-subst-valid-add__a2"/>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <lem tag="inf-subst-valid"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="2"/>
                    </relevant>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p> 
            Let
            <btypes:TYPE>
              <eq>        
                <relevant>
                  <store/>
                  <inter nosp="yes">
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </inter>
                </relevant>      
                <inter nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                </inter>
              </eq>
              <text content=" and "/>
              <eq>        
                <relevant>
                  <store/>
                  <minus nosp="yes">
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </minus>
                </relevant>      
                <minus nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="2"/>
                  </relevant>
                </minus>
              </eq>
              <text content=" and "/>
              <eq>        
                <relevant>
                  <store/>
                  <minus nosp="yes">
                    <aExpr num="2"/>
                    <aExpr num="1"/>
                  </minus>
                </relevant>      
                <minus nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="2"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                </minus>
              </eq>              
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__d11">
          <p>
            We can rewrite:
            <btypes:TYPE>
              <case tag="inf-subst-valid-add__d1"/>
            </btypes:TYPE>
            as
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <type num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__d22">
          <p>
            We can rewrite
            <btypes:TYPE>
              <case tag="inf-subst-valid-add__d2"/>
            </btypes:TYPE> 
            as
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus br="yes">
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="2"/>
                        <aExpr num="1"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__excl">
          <p>
            The only effect 
            <btypes:TYPE>
              <aSubMap num="u2"/>                  
            </btypes:TYPE>
            can have on 
            <btypes:TYPE>
              <type num="1"/>
            </btypes:TYPE> 
            (or 
            <btypes:TYPE>
              <relevant>
                <store/>
                <aExpr num="1"/>
              </relevant>
            </btypes:TYPE>) 
            is by providing a substitution for some
            type variable 
            <btypes:TYPE>
              <tvar name="alpha"/>
            </btypes:TYPE>
            which is a non-universally quantified free type variable
            within  
            <btypes:TYPE>
              <Subst>
                <aSubMap num="u1"/>
                <gamma/>
              </Subst>
            </btypes:TYPE> or is contained in 
            <btypes:TYPE>
              <relevant>
                <store/>
                <inter nosp="yes">
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </inter>
              </relevant>
            </btypes:TYPE> 
            and is also present in 
            <btypes:TYPE>
              <type num="1"/>
              <text content="( or "/>
              <relevant>
                <store/>
                <aExpr num="1"/>
              </relevant>
              <text content=")"/>
            </btypes:TYPE>.
            Therefore, we know that 
            <btypes:TYPE>
              <eq br="yes">
                <inter>
                  <dom>
                    <aSubMap num="u2"/>
                  </dom>
                  <pred name="TV">
                    <plus>
                      <Subst>
                        <aSubMap num="u1"/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap num="u1"/>
                        <relevant>
                          <store/>
                          <aExpr num="1"/>
                        </relevant>
                      </Subst>
                      <type num="1"/>
                    </plus>
                  </pred>
                </inter>
                <pred name="TV">
                  <plus>
                    <Subst>
                      <aSubMap num="u1"/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u1"/>
                      <relevant>
                        <store/>
                        <inter nosp="yes">
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                        </inter>
                      </relevant>
                    </Subst>
                  </plus>
                </pred>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__req1">
          <p>
            From 
            <btypes:TYPE>	
              <asm tag="inf-subst-valid-add__d1"/>
            </btypes:TYPE>
            and 
            <btypes:TYPE>	
              <lem tag="solvable-weakening"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>                      
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__req2">
          <p>
            From 
            <btypes:TYPE>	
              <asm tag="inf-subst-valid-add__d2"/>
            </btypes:TYPE>
            and 
            <btypes:TYPE>	
              <lem tag="solvable-weakening"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>                      
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-valid-add__cst1">
          <p>
            From             
            <btypes:TYPE>	
              <cases>
                <case tag="inf-subst-valid-add__req1"/>
                <case tag="inf-subst-valid-add__req2"/>
                <case tag="inf-subst-valid-add__excl"/>
              </cases>
              <text content=" and "/>
              <lem tag="cst-subst"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus br="yes">
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                </plus>
              </models>
              <text content=". That is,"/>
              <br/>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.            
          </p>
        </li>
        <li>
          <p>
            From 
            <btypes:TYPE>	
              <cases>
                <case tag="inf-subst-valid-add__d2"/>
                <case tag="inf-subst-valid-add__req2"/>
              </cases>
              <text content=" and "/>
              <asm tag="inf-subst-valid-add__a3"/>
            </btypes:TYPE>, we can easily obtain
            <btypes:TYPE>	
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>            
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>, in accordance to 
            <btypes:TYPE>	
              <defn tag="ct"/>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="ctr-subst-decl-cor">
      <title>Corollary to 
        Lemma&nbsp;<xref ref="ctr-subst-decl"/>.</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <gamma/>
                  </canonical>
                  <canonical>
                    <store/>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <type/>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <aSubMap/>
            </btypes:TYPE>
            is some substitution such that
            <btypes:TYPE>
              <models name="cst">
                <assume/>
                <Subst>
                  <aSubMap/>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </Subst>
              </models>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Exists>
            <aSubMap num="e"/>
          </Exists>
        </btypes:TYPE>
        such that:
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="e"/>
                    <aSubMap/>
                  </compose>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="e"/>
                    <aSubMap/>
                  </compose>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="e"/>
                    <aSubMap/>
                  </compose>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE> 
      </p>
    </lemma>
    <proof>
      <p>
        Straightforward extension to 
        Lemma&nbsp;<xref ref="ctr-subst-decl"/>.
        The extra substitution
        <btypes:TYPE>
          <aSubMap num="e"/>
        </btypes:TYPE>
        is necessary to solve any constraints introduced by the
        substitution 
        <btypes:TYPE>
          <aSubMap/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="relevant-subst-only">
      <title>Elimination of Irrelevant Substitutions.</title>
      <p>
        If:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>               
          </p>
        </li>          
      </ol>
      <p>
        Then, 
        <btypes:TYPE>
          <Exists>
            <subeq>
              <aSubMap dash="'"/>
              <aSubMap/>
            </subeq>
          </Exists>
          <text content=" such that "/>
          <models name="sol">
            <assume>
              <aSubMap dash="'"/>
            </assume>
            <plus>
              <type/>
              <gamma/>
              <relevant>
                <store/>
                <aExpr/>
              </relevant>
            </plus>
          </models>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap dash="'"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap dash="'"/>
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap dash="'"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        Follows from Lemma&nbsp;<xref ref="solvable-weakening"/> 
        and by observing the declarative type rules in
        Figure&nbsp;<xref ref="decl_rules"/>.
      </p>
    </proof>
    <lemma id="eqi-subst-decl-ok">
      <title>Equivalent Substitutions 
        Preserve Declarative Derivation.</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge name="eqi">
                <assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </assume>
                <approx>
                  <aSubMap num="1"/>
                  <aSubMap num="2"/>
                </approx>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li id="eqi-subst-decl-ok__a_derivation1">
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap num="2"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="2"/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap num="2"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        From Definition&nbsp;<xref ref="equiv-subst"/>, we have
        <btypes:TYPE>
          <eq>
            <Subst>
              <aSubMap num="1"/>
              <plus>
                <type/>
                <gamma/>
                <store/>
              </plus>
            </Subst>
            <Subst>
              <aSubMap num="2"/>
              <plus>
                <type/>
                <gamma/>
                <store/>
              </plus>
            </Subst>            
          </eq>
        </btypes:TYPE>. That is,
        <btypes:TYPE>
          <eq>
            <Subst>
              <aSubMap num="1"/>
              <type/>
            </Subst>
            <Subst>
              <aSubMap num="2"/>
              <type/>
            </Subst>
          </eq>
          <text content=" and "/>
          <eq>
            <Subst>
              <aSubMap num="1"/>
              <gamma/>
            </Subst>
            <Subst>
              <aSubMap num="2"/>
              <gamma/>
            </Subst>
          </eq>
          <text content=" and "/>
          <eq>
            <Subst>
              <aSubMap num="1"/>
              <store/>
            </Subst>
            <Subst>
              <aSubMap num="2"/>
              <store/>
            </Subst>
          </eq>
        </btypes:TYPE>.
        The result is now evident from 
        <btypes:TYPE>
          <asm tag="eqi-subst-decl-ok__a_derivation1"/>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="compat-subst-decl-ok">
      <title>Compatible Substitutions 
        Preserve Declarative Derivation.</title>
      <p>
        If
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="s"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <ceq>
                <aSubMap num="s"/>
                <aSubMap num="s" dash="'"/>
              </ceq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        From Definition&nbsp;<xref ref="sol-math"/>, we know that
        <btypes:TYPE>
          <eq>
            <aSubMap num="s"/>
            <compose>
              <aSubMap num="m"/>
              <aSubMap num="o"/>
            </compose>
          </eq>
        </btypes:TYPE>
        where
        <btypes:TYPE>
          <aSubMap num="m"/>
        </btypes:TYPE>
        contains substitutions to
        <btypes:TYPE>
          <pred name="MTV">
            <plus>
              <type/>
              <gamma/>
              <store/>
            </plus>
          </pred>
        </btypes:TYPE>
        and
        <btypes:TYPE>
          <aSubMap num="o"/>
        </btypes:TYPE>
        is irrelevant to
        <btypes:TYPE>
          <canonical>
            <plus>
              <type/>
              <gamma/>
              <store/>
            </plus>
          </canonical>
        </btypes:TYPE>.
        From the definition of compatibility of substitutions
        (Definition&nbsp;<xref ref="compat-subst"/>),
        <btypes:TYPE>
          <aSubMap num="s" dash="'"/>
        </btypes:TYPE>
        must have compatible substitutions to <em>only</em> these
        type variables. The required result can be obtained by
        straightforward induction on the derivation of
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>
        </btypes:TYPE>.
      </p>
    </proof>
    <lemma id="compat-subst-decl-ok-cor1">
      <title>Corollary to 
        Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>.</title> 
      <p>
        If
      </p>
      <ol>
        <li>            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="s"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="s" dash="'"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>                
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then, 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap num="s" dash="'"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Follows from 
        Lemma&nbsp;<xref ref="coequal-solve-OK"/> and
        Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>.          
      </p>
    </proof>
    <lemma id="compat-subst-decl-ok-cor2">
      <title>Corollary to 
        Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor1"/>.</title> 
      <p>
        If
      </p>
      <ol>
        <li>            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="e"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </plus>
              </models>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="e"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="e"/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>                          
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="e"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>
          </p>
        </li>
        <li id="compat-subst-decl-ok-cor2__a_sols">            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="s"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>                
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then, 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap num="s"/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap num="s"/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <aSubMap num="s"/>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <ol>
        <li>
          <p>
            From 
            <btypes:TYPE>
              <asm tag="compat-subst-decl-ok-cor2__a_sols"/>
            </btypes:TYPE>, the fact that 
            <btypes:TYPE>
              <subeq>
                <relevant>
                  <store/>
                  <aExpr/>
                </relevant>
                <store/>
              </subeq>
            </btypes:TYPE>, and 
            Lemma&nbsp;<xref ref="solvable-weakening"/>, 
            we conclude that 
            <btypes:TYPE>
              <Exists>
                <subeq>
                  <aSubMap num="s" dash="'"/>                    
                  <aSubMap num="s"/>
                </subeq>
              </Exists>
              <text content=" such that "/>
              <models name="sol">
                <assume>
                  <aSubMap num="s" dash="'"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </plus>
              </models>                
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From assumption (2 and 3) and case (1) above, and               
            Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor1"/>, 
            we have          
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="s" dash="'"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="s" dash="'"/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="s" dash="'"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>.
          </p>
        </li> 
        <li>
          <p>
            From case (1), we can write:
            <btypes:TYPE>
              <eq>
                <aSubMap num="s"/>
                <compose>
                  <aSubMap num="o"/>
                  <aSubMap num="s" dash="'"/>                    
                </compose>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            From assumption (3) and 
            Lemma&nbsp;<xref ref="sol-math-properties"/>, we have              
            <btypes:TYPE>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <plus>
                      <gamma/>
                      <store/>
                      <type/>
                    </plus>
                  </Subst>
                </normalize>                      
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <plus>
                      <gamma/>
                      <store/>
                      <type/>
                    </plus>
                  </Subst>                    
                </canonical>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Since we have:
            <btypes:TYPE>
              <subeq>
                <relevant>
                  <store/>
                  <aExpr/>
                </relevant>
                <store/>                  
              </subeq>
            </btypes:TYPE>,              
            (and thus               
            <btypes:TYPE>
              <subeq>
                <Subst>
                  <aSubMap num="s"/>                                          
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </Subst>
                <Subst>
                  <aSubMap num="s"/>                      
                  <store/>                  
                </Subst>
              </subeq>
            </btypes:TYPE>),              
            from case (4) and
            Lemma&nbsp;<xref ref="solvable-weakening"/>, we obtain
            <btypes:TYPE>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <plus>
                      <gamma/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                      <type/>
                    </plus>
                  </Subst>
                </normalize>                      
                <canonical>
                  <Subst>
                    <aSubMap num="s"/>                      
                    <plus>
                      <gamma/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                      <type/>
                    </plus>
                  </Subst>                    
                </canonical>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p>
            Case (5) can be re-written as:
            <btypes:TYPE>
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="o"/>                      
                    <Subst>
                      <aSubMap num="s" dash="'"/>                      
                      <plus>
                        <gamma/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <type/>
                      </plus>
                    </Subst>
                  </Subst>
                </normalize>                      
                <canonical>
                  <Subst>
                    <aSubMap num="o"/>                      
                    <Subst>
                      <aSubMap num="s" dash="'"/>                      
                      <plus>
                        <gamma/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <type/>
                      </plus>
                    </Subst>
                  </Subst>                    
                </canonical>
              </eq>
            </btypes:TYPE>.              
          </p>
        </li>
        <li>
          <p>
            From cases (2 and 6) and 
            Lemma&nbsp;<xref ref="ctr-subst-decl"/>, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="o"/>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <gamma/>
                      </Subst>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="o"/>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </Subst>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="o"/>
                      <Subst>
                        <aSubMap num="s" dash="'"/>
                        <type/>
                      </Subst>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>. 
            That is,
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <relevant>
                        <store/>
                        <aExpr/>
                      </relevant>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>. 
          </p>
        </li>
        <li>
          <p>
            Since we have:
            <btypes:TYPE>
              <supeq>
                <store/>                  
                <relevant>
                  <store/>
                  <aExpr/>
                </relevant>
              </supeq>
            </btypes:TYPE>,              
            (and thus               
            <btypes:TYPE>
              <supeq>
                <Subst>
                  <aSubMap num="s"/>                      
                  <store/>                  
                </Subst>
                <Subst>
                  <aSubMap num="s"/>                                          
                  <relevant>
                    <store/>
                    <aExpr/>
                  </relevant>
                </Subst>
              </supeq>
            </btypes:TYPE>),              
            from cases (4 and 7), and
            Lemma&nbsp;<xref ref="T-Weakening-ext"/>, 
            we finally obtain:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="s"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>. 
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="valid-subst-decl-ok">
      <title>Valid Substitutions 
        Preserve Declarative Derivation.</title>
      <p>
        If
      </p>
      <ol>
        <li>            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="1"/>
                </assume>
                <plus>
                  <type/>
                  <gamma/>
                  <store/>
                </plus>
              </models>                
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="1"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>            
          <p>
            <btypes:TYPE>
              <models name="sol">
                <assume>
                  <aSubMap num="2"/>
                </assume>
                <Subst>
                  <aSubMap/>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </Subst>
              </models>                
              <text content=" for some substitution "/>
              <aSubMap/>                
            </btypes:TYPE>
          </p>
        </li>          
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <inter>
                  <dom>
                    <aSubMap num="1"/>
                  </dom>
                  <dom>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                  </dom>
                </inter>
                <pred name="MTV">
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </pred>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then, 
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <Subst>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>
                  <type/>
                </Subst>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE> 
      </p>
    </lemma>
    <proof>
      <ol>
        <li>
          <p>
            From Lemma&nbsp;<xref ref="sol-subst-must-be-compat"/>, 
            assumptions (1, 3 and 4), we conclude that
            <btypes:TYPE>
              <Exists>
                <aSubMap num="1" dash="'"/>
                <aSubMap num="0"/>
              </Exists>
            </btypes:TYPE>
            such that: <br/>
            (a)
            <btypes:TYPE>
              <ceq>
                <aSubMap num="1"/>
                <aSubMap num="1" dash="'"/>
              </ceq>
            </btypes:TYPE> and 
            (b)
            <btypes:TYPE>
              <Sjudge name="eqi">
                <assume>
                  <plus>
                    <type/>
                    <gamma/>
                    <store/>
                  </plus>
                </assume>                  
                <approx>
                  <compose>
                    <aSubMap num="2"/>
                    <aSubMap/>
                  </compose>                
                  <compose>
                    <aSubMap num="1" dash="'"/>
                    <aSubMap num="0"/>
                  </compose>
                </approx>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            From assumption (1 and 2), case (1.a) above, and
            Lemma&nbsp;<xref ref="compat-subst-decl-ok"/>, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="1" dash="'"/>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="1" dash="'"/>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="1" dash="'"/>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            From assumption (3) and 
            Lemma&nbsp;<xref ref="sol-math-properties"/>, we have
            <btypes:TYPE>                
              <eq>
                <normalize>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="2"/>
                      <aSubMap/>
                    </compose>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </canonical>
              </eq>             
            </btypes:TYPE>              
          </p>
        </li>
        <li>
          <p>
            From cases (3 and 1.b), and 
            Lemma&nbsp;<xref ref="eqi-sol-properties"/>, we
            have
            <btypes:TYPE>                
              <eq>
                <normalize>
                  <Subst>
                    <compose>
                      <aSubMap num="1" dash="'"/>
                      <aSubMap num="0"/>
                    </compose>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <compose>
                      <aSubMap num="1" dash="'"/>
                      <aSubMap num="0"/>
                    </compose>
                    <plus>
                      <type/>
                      <gamma/>
                      <store/>
                    </plus>
                  </Subst>
                </canonical>
              </eq>                   
            </btypes:TYPE>              
            That is,
            <btypes:TYPE>                
              <eq>
                <normalize>
                  <Subst>
                    <aSubMap num="0"/>
                    <Subst>
                      <aSubMap num="1" dash="'"/>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </Subst>
                </normalize>
                <canonical>
                  <Subst>
                    <aSubMap num="0"/>
                    <Subst>
                      <aSubMap num="1" dash="'"/>
                      <plus>
                        <type/>
                        <gamma/>
                        <store/>
                      </plus>
                    </Subst>
                  </Subst>
                </canonical>
              </eq>                   
            </btypes:TYPE>.              
          </p>
        </li>
        <li>
          <p>
            From cases (2 and 4), and 
            Lemma&nbsp;<xref ref="ctr-subst-decl"/>, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <aSubMap num="0"/>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <gamma/>
                      </Subst>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <aSubMap num="0"/>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <store/>
                      </Subst>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <aSubMap num="0"/>
                      <Subst>
                        <aSubMap num="1" dash="'"/>
                        <type/>
                      </Subst>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>.
            That is,
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="1" dash="'"/>
                        <aSubMap num="0"/>
                      </compose>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="1" dash="'"/>
                        <aSubMap num="0"/>
                      </compose>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="1" dash="'"/>
                        <aSubMap num="0"/>
                      </compose>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>.              
          </p>
        </li>
        <li>
          <p>
            Finally, from cases (1.b and 4), and 
            Lemma&nbsp;<xref ref="eqi-subst-decl-ok"/>, we have:
            <btypes:TYPE>
              <Sjudge>
                <assume>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <gamma/>
                    </Subst>
                  </canonical>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <store/>
                    </Subst>
                  </canonical>
                </assume>
                <tqExpr>
                  <aExpr/>
                  <canonical>
                    <Subst>
                      <compose>
                        <aSubMap num="2"/>
                        <aSubMap/>
                      </compose>
                      <type/>
                    </Subst>
                  </canonical>
                </tqExpr>
              </Sjudge>	    
            </btypes:TYPE>.              
          </p>
        </li>          
      </ol>
    </proof>
    <lemma id="inf-subst-compose">
      <title>Composability of Inferred Substitutions</title>
      <p>
        If
      </p>
      <ol>
        <li id="inf-subst-compose__a1">
          <p>
            <btypes:TYPE>
              <TIjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr num="1"/>
                    <type num="1"/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="u"/>
                </propagate>
              </TIjudge>                
            </btypes:TYPE>
          </p>
        </li>
        <li id="inf-subst-compose__a2">
          <p>
            <btypes:TYPE>
              <TIjudge>
                <precond>                  
                  <aSubMap num="u"/>                      
                </precond>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr num="2"/>
                    <type num="2"/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="v"/>
                </propagate>
              </TIjudge>                
            </btypes:TYPE>
          </p>
        </li>
        <li id="inf-subst-compose__a3">
          <p>
            Fresh variables used in
            <btypes:TYPE>
              <cases>
                <case tag="inf-subst-compose__a1"/>
                <case tag="inf-subst-compose__a2"/>
              </cases>
            </btypes:TYPE> do not collide. 
          </p>
        </li>
        <li id="inf-subst-compose__a4">
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap num="i"/>
                </assume>
                <Subst>
                  <aSubMap num="u"/>
                  <spset>
                    <type num="1"/>
                    <gamma/>
                    <store/>
                    <aExpr num="1"/>
                  </spset>
                </Subst>
              </models>
            </btypes:TYPE>
          </p>
        </li>
        <li id="inf-subst-compose__a5">
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap num="j"/>
                </assume>
                <Subst>
                  <scomp>
                    <aSubMap num="u"/>
                    <aSubMap num="v"/>
                  </scomp>
                  <spset>
                    <type num="2"/>
                    <gamma/>
                    <store/>
                    <aExpr num="2"/>
                  </spset>
                </Subst>
              </models>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then 
        <btypes:TYPE>
          <Exists>
            <aSubMap num="s"/>
          </Exists>
        </btypes:TYPE> such that
        <btypes:TYPE>
          <models name="sat">
            <assume>
              <aSubMap num="s"/>
            </assume>
            <Subst>
              <scomp>
                <aSubMap num="u"/>
                <aSubMap num="v"/>
              </scomp>
              <spset>
                <type num="1"/>
                <type num="2"/>
                <gamma/>
                <store/>
                <aExpr num="1"/>
                <aExpr num="2"/>
              </spset>
            </Subst>
          </models>
        </btypes:TYPE>
      </p>
    </lemma>
    <proof>
      <p>
        By construction of 
        <btypes:TYPE>          
          <aSubMap num="s"/>
        </btypes:TYPE>. 
      </p>
      <ol>
        <li>
          <p>
            The inference derivation for 
            <btypes:TYPE>
              <aExpr num="2"/>                  
            </btypes:TYPE>
            (which produces the substitution
            <btypes:TYPE>
              <aSubMap num="v"/>                  
            </btypes:TYPE>)
            is done in an environment that already
            has applied the substitutions in
            <btypes:TYPE>
              <aSubMap num="u"/>                  
            </btypes:TYPE>.
            From this fact, and 
            <btypes:TYPE>
              <asm tag="inf-subst-compose__a3"/>
            </btypes:TYPE>
            we can conclude that 
            <btypes:TYPE>
              <aSubMap num="u"/>                  
              <text content=" and "/>
              <aSubMap num="v"/>                  
            </btypes:TYPE> contain mutually exclusive substitutions.
          </p>
        </li>
        <li id="inf-subst-compose__d1">
          <p>
            From 
            <btypes:TYPE>
              <asm tag="inf-subst-compose__a1"/>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <lem tag="inf-subst-valid"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                    </relevant>
                  </Subst>
                  <type num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__d2">
          <p>
            From 
            <btypes:TYPE>
              <asm tag="inf-subst-compose__a2"/>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <lem tag="inf-subst-valid"/>
            </btypes:TYPE>, we obtain
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="2"/>
                    </relevant>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li>
          <p> 
            Let
            <btypes:TYPE>
              <eq>        
                <relevant>
                  <store/>
                  <inter nosp="yes">
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </inter>
                </relevant>      
                <inter nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                </inter>
              </eq>
              <text content=" and "/>
              <eq>        
                <relevant>
                  <store/>
                  <minus nosp="yes">
                    <aExpr num="1"/>
                    <aExpr num="2"/>
                  </minus>
                </relevant>      
                <minus nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="2"/>
                  </relevant>
                </minus>
              </eq>
              <text content=" and "/>
              <eq>        
                <relevant>
                  <store/>
                  <minus nosp="yes">
                    <aExpr num="2"/>
                    <aExpr num="1"/>
                  </minus>
                </relevant>      
                <minus nosp="yes">
                  <relevant>
                    <store/>
                    <aExpr num="2"/>
                  </relevant>
                  <relevant>
                    <store/>
                    <aExpr num="1"/>
                  </relevant>
                </minus>
              </eq>              
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__d11">
          <p>
            We can rewrite:
            <btypes:TYPE>
              <case tag="inf-subst-compose__d1"/>
            </btypes:TYPE>
            as
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <type num="1"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__d22">
          <p>
            We can rewrite
            <btypes:TYPE>
              <case tag="inf-subst-compose__d2"/>
            </btypes:TYPE> 
            as
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus br="yes">
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="2"/>
                        <aExpr num="1"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__excl">
          <p>
            The only effect 
            <btypes:TYPE>
              <aSubMap num="u2"/>                  
            </btypes:TYPE>
            can have on 
            <btypes:TYPE>
              <type num="1"/>
            </btypes:TYPE> 
            (or 
            <btypes:TYPE>
              <relevant>
                <store/>
                <aExpr num="1"/>
              </relevant>
            </btypes:TYPE>) 
            is by providing a substitution for some
            type variable 
            <btypes:TYPE>
              <tvar name="alpha"/>
            </btypes:TYPE>
            which is a non-universally quantified free type variable
            within  
            <btypes:TYPE>
              <Subst>
                <aSubMap num="u1"/>
                <gamma/>
              </Subst>
            </btypes:TYPE> or is contained in 
            <btypes:TYPE>
              <relevant>
                <store/>
                <inter nosp="yes">
                  <aExpr num="1"/>
                  <aExpr num="2"/>
                </inter>
              </relevant>
            </btypes:TYPE> 
            and is also present in 
            <btypes:TYPE>
              <type num="1"/>
              <text content="( or "/>
              <relevant>
                <store/>
                <aExpr num="1"/>
              </relevant>
              <text content=")"/>
            </btypes:TYPE>.
            Therefore, we know that 
            <btypes:TYPE>
              <eq br="yes">
                <inter>
                  <dom>
                    <aSubMap num="u2"/>
                  </dom>
                  <pred name="TV">
                    <plus>
                      <Subst>
                        <aSubMap num="u1"/>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <aSubMap num="u1"/>
                        <relevant>
                          <store/>
                          <aExpr num="1"/>
                        </relevant>
                      </Subst>
                      <type num="1"/>
                    </plus>
                  </pred>
                </inter>
                <pred name="TV">
                  <plus>
                    <Subst>
                      <aSubMap num="u1"/>
                      <gamma/>
                    </Subst>
                    <Subst>
                      <aSubMap num="u1"/>
                      <relevant>
                        <store/>
                        <inter nosp="yes">
                          <aExpr num="1"/>
                          <aExpr num="2"/>
                        </inter>
                      </relevant>
                    </Subst>
                  </plus>
                </pred>
              </eq>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__req1">
          <p>
            From 
            <btypes:TYPE>	
              <asm tag="inf-subst-compose__d1"/>
            </btypes:TYPE>
            and 
            <btypes:TYPE>	
              <lem tag="solvable-weakening"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <aSubMap num="u1"/>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <aSubMap num="u1"/>
                    <relevant>                      
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__req2">
          <p>
            From 
            <btypes:TYPE>	
              <asm tag="inf-subst-compose__d2"/>
            </btypes:TYPE>
            and 
            <btypes:TYPE>	
              <lem tag="solvable-weakening"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>                      
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.
          </p>
        </li>
        <li id="inf-subst-compose__cst1">
          <p>
            From             
            <btypes:TYPE>	
              <cases>
                <case tag="inf-subst-compose__req1"/>
                <case tag="inf-subst-compose__req2"/>
                <case tag="inf-subst-compose__excl"/>
              </cases>
              <text content=" and "/>
              <lem tag="cst-subst"/>
            </btypes:TYPE>, we have
            <btypes:TYPE>
              <models name="ct">
                <assume/>
                <plus br="yes">
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <inter nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </inter>
                    </relevant>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <minus nosp="yes">
                        <aExpr num="1"/>
                        <aExpr num="2"/>
                      </minus>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                </plus>
              </models>
              <text content=". That is,"/>
              <br/>
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                </plus>
              </models>
            </btypes:TYPE>.            
          </p>
        </li>
        <li>
          <p>
            From 
            <btypes:TYPE>	
              <cases>
                <case tag="inf-subst-compose__d2"/>
                <case tag="inf-subst-compose__req2"/>
              </cases>
              <text content=" and "/>
              <asm tag="inf-subst-compose__a3"/>
            </btypes:TYPE>, we can easily obtain
            <btypes:TYPE>	
              <models name="ct">
                <assume/>
                <plus>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <gamma/>
                  </Subst>
                  <Subst>
                    <compose>
                      <aSubMap num="u2"/>
                      <aSubMap num="u1"/>
                    </compose>
                    <relevant>
                      <store/>
                      <aExpr num="1"/>
                      <aExpr num="2"/>            
                    </relevant>
                  </Subst>
                  <Subst>
                    <aSubMap num="u2"/>
                    <type num="1"/>
                  </Subst>
                  <type num="2"/>
                </plus>
              </models>
            </btypes:TYPE>, in accordance to 
            <btypes:TYPE>	
              <defn tag="ct"/>
            </btypes:TYPE>.
          </p>
        </li>
      </ol>
    </proof>
    <lemma id="vars-new">
      <title>Non-colliding type variables</title>
      <p>
        New type variables introduced in different branches of
        an inference derivation are mutually exclusive
      </p>
    </lemma>
    <proof>
      <p>
        Evident from the inference rules in 
        Figure&nbsp;<xref ref="hm_infer"/>.
      </p>
    </proof>    
    <theorem id="infer-sound">
      <title>Soundness of Type Inference</title>
      <p>
        If:
      </p>
      <ol>
        <li id="infer-sound__a_infer">
          <p>
            <btypes:TYPE>
              <TIjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr/>
                    <type/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="u"/>
                </propagate>
              </TIjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li id="infer-sound__a_solve">
          <p>
            <btypes:TYPE>
              <models name="sat">
                <assume>
                  <aSubMap num="s"/>
                </assume>                
                <Subst>
                  <aSubMap num="u"/>                                    
                  <spset>
                    <type/>
                    <gamma/>
                    <store/>
                    <aExpr/>
                  </spset>
                </Subst>
              </models>
            </btypes:TYPE>.              
          </p>
        </li>
      </ol>
      <p>
        Then,
        <btypes:TYPE>
          <Djudge>            
            <scomp>
              <aSubMap num="s"/>
              <aSubMap num="u"/>                  
            </scomp>
            <gamma/>
            <store/>
            <aExpr/>
            <type/>
          </Djudge>
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        By induction on the derivation of 
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="u"/>
            </propagate>
          </TIjudge>
        </btypes:TYPE>.
        We proceed by case analysis on the last step,
        assuming &alpha;-reduction vacuously.
      </p>
      <ol>
        <li>
          <p>
            Cases I-Unit, I-True. I-False, I-Id, I-Hloc,
            I-Sloc are trivial. 
          </p>
        </li>
        <li>
          <p>
            Case I-Lambda:               
          </p>
          <ol>
            <li>
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="infer-sound__lam_infer">
                  <p>
                    <btypes:TYPE>
                      <Hrules vspace="yes">
                        <tyRule>
                          <tyPre>
                            <TIjudge>
                              <assume>
                                <extend>
                                  <gamma/>
                                  <mapping>
                                    <id/>
                                    <tvar name="alpha"/>
                                  </mapping>
                                </extend>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <aExpr num="i"/>
                                  <type num="r"/>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <aSubMap num="u"/>
                              </propagate>
                            </TIjudge>
                            <models name="new">
                              <assume/>
                              <tvar name="alpha"/>
                            </models>
                          </tyPre>
                          <tyConc>
                            <TIjudge>
                              <assume>
                                <gamma/>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <lambda> 
                                    <id/>
                                    <aExpr num="i"/>
                                  </lambda>
                                  <fn>
                                    <floor>
                                      <Subst>
                                        <aSubMap num="u"/>
                                        <tvar name="alpha"/>
                                      </Subst>
                                    </floor>
                                    <ceil>
                                      <type num="r"/>
                                    </ceil>
                                  </fn>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <compose>
                                  <aSubMap num="u"/>
                                </compose>                    
                              </propagate>
                            </TIjudge>
                          </tyConc>
                        </tyRule>
                      </Hrules>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__lam_sol">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap num="s"/>
                        </assume>
                        <Subst>
                          <aSubMap num="u"/>
                          <spset>
                            <fn M="yes">
                              <Subst>
                                <aSubMap num="u"/>
                                <tvar name="alpha"/>
                              </Subst>
                              <type num="r"/>
                            </fn>
                            <gamma/>
                            <store/>
                            <lambda>
                              <id/>
                              <aExpr/>
                            </lambda>
                          </spset>
                        </Subst>
                      </models>
                    </btypes:TYPE>. 
                  </p>
                </li>
              </ol>
              <p>
                and we need:
                <btypes:TYPE>
                  <Djudge>            
                    <scomp>
                      <aSubMap num="s"/>
                      <aSubMap num="u"/>                  
                    </scomp>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <Subst>
                        <aSubMap num="u"/>
                        <tvar name="alpha"/>
                      </Subst>
                      <type num="r"/>
                    </fn>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_ih">
              <p>
                From induction hypothesis, we have:
              </p>
              <ol>
                <li id="infer-sound__lam_ih1">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap num="si"/>
                        </assume>
                        <Subst>
                          <aSubMap num="u"/>
                          <spset>
                            <type num="r"/>
                            <paren>
                              <extend>
                                <gamma/>
                                <mapping>
                                  <id/>
                                  <tvar name="alpha"/>
                                </mapping>
                              </extend>
                            </paren>
                            <store/>
                            <aExpr num="i"/>
                          </spset>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__lam_ih2">
                  <p>
                    <btypes:TYPE>
                      <Djudge>
                        <scomp>
                          <aSubMap num="si"/>
                          <aSubMap num="u"/>
                        </scomp>
                        <extend>
                          <gamma/>
                          <mapping>
                            <id/>
                            <tvar name="alpha"/>
                          </mapping>
                        </extend>
                        <store/>
                        <aExpr num="i"/>
                        <type num="r"/>
                      </Djudge>	    
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li id="infer-sound__lam_expand">                
              <p>
                Using 
                <btypes:TYPE>
                  <defn tag="ctr_extract"/>
                </btypes:TYPE>, we can
                re-write 
                <btypes:TYPE>
                  <case tag="infer-sound__lam_ih1"/> 
                </btypes:TYPE>
                as 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap num="si"/>
                    </assume>
                    <Subst>
                      <aSubMap num="u"/>
                      <spset>
                        <type num="r"/>
                        <gamma/>
                        <tvar name="alpha"/>
                        <store/>
                        <aExpr num="i"/>
                      </spset>
                    </Subst>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_functionalize">
              <p>
                It is evident that
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <tvar name="alpha"/>
                      <type num="r"/>
                    </spset>
                    <spset>
                      <fn M="yes">
                        <tvar name="alpha"/>
                        <type num="r"/>
                      </fn>
                    </spset>
                  </eq>                  
                </btypes:TYPE> and
                <btypes:TYPE>
                  <eq>
                    <spset>
                      <lambda>
                        <id/>
                        <aExpr num="i"/>
                      </lambda>
                    </spset>
                    <spset>
                      <aExpr num="i"/>
                    </spset>
                  </eq>                  
                </btypes:TYPE>. Therefore, we can rewrite 
                <btypes:TYPE>
                  <case tag="infer-sound__lam_expand"/>
                </btypes:TYPE>
                as 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap num="si"/>
                    </assume>
                    <Subst>
                      <aSubMap num="u"/>
                      <spset>
                        <fn M="yes">
                          <tvar name="alpha"/>
                          <type num="r"/>
                        </fn>
                        <gamma/>
                        <store/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                      </spset>
                    </Subst>
                  </models>
                </btypes:TYPE>. Further, this is 
                equivalent to 
                <btypes:TYPE>
                  <models name="sat">
                    <assume>
                      <aSubMap num="si"/>
                    </assume>
                    <Subst>
                      <aSubMap num="u"/>
                      <spset>
                        <fn M="yes">
                          <Subst>
                            <aSubMap num="u"/>                            
                            <tvar name="alpha"/>
                          </Subst>
                          <type num="r"/>
                        </fn>
                        <gamma/>
                        <store/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                      </spset>
                    </Subst>
                  </models>
                </btypes:TYPE> (redundant substitution specification).
              </p>
            </li>
            <li>
              <p>
                Using cases (d and a.ii), we conclude that 
                <btypes:TYPE>
                  <eq>
                    <aSubMap num="si"/>
                    <aSubMap num="s"/>
                  </eq>                      
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
                Let
                <btypes:TYPE>
                  <eq>
                    <aSubMap num="su"/>
                    <scomp>
                      <aSubMap num="s"/>
                      <aSubMap num="u"/>
                    </scomp>
                  </eq>
                </btypes:TYPE>.
                Using cases (e and b.ii), we obtain
                <btypes:TYPE>
                  <Djudge>
                    <aSubMap num="su"/>
                    <extend>
                      <gamma/>
                      <mapping>
                        <id/>
                        <tvar name="alpha"/>
                      </mapping>
                    </extend>
                    <store/>
                    <aExpr num="i"/>
                    <type num="r"/>
                  </Djudge>	    
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_decl_rewrite">
              <p>
                That is, 
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <extend>
                            <gamma/>
                            <tqExpr>
                              <id/>
                              <tvar name="alpha"/>
                            </tqExpr>
                          </extend>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <type num="r"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>, which can be re-written as
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <extend>
                        <canonical>                            
                          <Subst>
                            <aSubMap num="su"/>
                            <gamma/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <tqExpr>
                            <id/>
                            <Subst>
                              <aSubMap num="su"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </tqExpr>
                        </canonical>
                      </extend>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <type num="r"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_decl">
              <p>
                From 
                <btypes:TYPE>
                  <case tag="infer-sound__lam_decl_rewrite"/>
                </btypes:TYPE>, and the T-Lambda rule, we obtain
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <lambda>
                        <id/>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <aExpr num="i"/>
                          </Subst>
                        </canonical>
                      </lambda>
                      <fn>
                        <minz>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </canonical>
                        </minz>
                        <maxz>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <type num="r"/>
                            </Subst>
                          </canonical>
                        </maxz>
                      </fn>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_norm">
              <p>
                From 
                <btypes:TYPE>
                  <defn tag="normalized-ctr-types"/>
                </btypes:TYPE> and
                <btypes:TYPE>
                  <defn tag="meta"/>
                </btypes:TYPE>, we know that
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <floor>
                        <Subst>
                          <aSubMap num="su"/>
                          <tvar name="alpha"/>
                        </Subst>
                      </floor>
                    </canonical>                    
                    <minz>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <tvar name="alpha"/>
                        </Subst>
                      </canonical>
                    </minz>
                  </eq>
                </btypes:TYPE>, and
                <btypes:TYPE>
                  <eq>
                    <canonical>
                      <ceil>
                        <Subst>
                          <aSubMap num="s"/>
                          <type num="r"/>
                        </Subst>
                      </ceil>
                    </canonical>
                    <maxz>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <type num="r"/>
                        </Subst>
                      </canonical>
                    </maxz>
                  </eq>
                </btypes:TYPE>.
                Therefore, we can write
                <btypes:TYPE>
                  <eq br="yes">
                    <fn>
                      <minz>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <tvar name="alpha"/>
                          </Subst>
                        </canonical>
                      </minz>
                      <maxz>
                        <canonical>
                          <Subst>
                            <aSubMap num="su"/>
                            <type num="r"/>
                          </Subst>
                        </canonical>
                      </maxz>
                    </fn>
                    <fn>
                      <canonical>
                        <floor>
                          <Subst>
                            <aSubMap num="su"/>
                            <tvar name="alpha"/>
                          </Subst>
                        </floor>
                      </canonical>
                      <canonical>
                        <ceil>
                          <Subst>
                            <aSubMap num="su"/>
                            <type num="r"/>
                          </Subst>
                        </ceil>
                      </canonical>
                    </fn>
                    <canonical>
                      <fn M="yes">
                        <Subst>
                          <aSubMap num="su"/>
                          <tvar name="alpha"/>
                        </Subst>
                        <Subst>
                          <aSubMap num="su"/>
                          <type num="r"/>
                        </Subst>
                      </fn>
                    </canonical>
                    <canonical>
                      <Subst>
                        <aSubMap num="su"/>
                        <fn M="yes">
                          <Subst>
                            <aSubMap num="u"/>
                            <tvar name="alpha"/>
                          </Subst>
                          <type num="r"/>
                        </fn>
                      </Subst>                        
                    </canonical>
                  </eq>
                </btypes:TYPE>.
              </p>
            </li>
            <li id="infer-sound__lam_lambda_canonical">
              <p>
                It is evident that 
                <btypes:TYPE>
                  <eq>
                    <lambda>
                      <id/>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <aExpr num="i"/>
                        </Subst>
                      </canonical>
                    </lambda>
                    <canonical>
                      <Subst>
                        <aSubMap num="su"/>
                        <lambda>
                          <id/>
                          <aExpr num="i"/>
                        </lambda>
                      </Subst>
                    </canonical>
                  </eq>
                </btypes:TYPE>
              </p>
            </li>
            <li id="infer-sound__lam_done">
              <p>
                Substituting the results of                 
                <btypes:TYPE>
                  <cases>
                    <case tag="infer-sound__lam_norm"/>
                    <case tag="infer-sound__lam_done"/>
                  </cases>
                </btypes:TYPE>
                in 
                <btypes:TYPE>
                  <case tag="infer-sound__lam_decl"/>
                </btypes:TYPE>, we obtain
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <store/>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <lambda>
                            <id/>
                            <aExpr num="i"/>
                          </lambda>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <aSubMap num="su"/>
                          <fn M="yes">
                            <Subst>
                              <aSubMap num="u"/>
                              <tvar name="alpha"/>
                            </Subst>
                            <type num="r"/>
                          </fn>
                        </Subst>                        
                      </canonical>
                    </tqExpr>
                  </Sjudge>
                </btypes:TYPE>.
                That is,
                <btypes:TYPE>
                  <Djudge>            
                    <scomp>
                      <aSubMap num="s"/>
                      <aSubMap num="u"/>                  
                    </scomp>
                    <gamma/>
                    <store/>
                    <lambda>
                      <id/>
                      <aExpr num="i"/>
                    </lambda>
                    <fn M="yes">
                      <Subst>
                        <aSubMap num="u"/>
                        <tvar name="alpha"/>
                      </Subst>
                      <type num="r"/>
                    </fn>
                  </Djudge>
                </btypes:TYPE>.
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Case I-App:
          </p>
          <ol>
            <li id="infer-sound__app_given">
              <p>
                In this case, we have:
              </p>
              <ol>
                <li id="infer-sound__app_given_infer">
                  <p>
                    <btypes:TYPE>
                      <Hrules vspace="yes">
                        <tyRule>
                          <tyPre>
                            <grouping>                              
                              <text content="[I]  "/>
                              <TIjudge>
                                <assume>
                                  <gamma/>
                                  <store/>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <aExpr num="f"/>
                                    <type num="f"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <aSubMap num="f"/>
                                </propagate>
                              </TIjudge>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>                              
                              <text content="[II]  "/>
                              <TIjudge>
                                <precond>
                                  <aSubMap num="f"/>
                                </precond>
                                <assume>
                                  <gamma/>
                                  <store/>
                                </assume>
                                <conclude>
                                  <tqExpr>
                                    <aExpr num="a"/>
                                    <type num="a"/>
                                  </tqExpr>
                                </conclude>
                                <propagate>
                                  <aSubMap num="a"/>
                                </propagate>
                              </TIjudge>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="[III]  "/>
                              <UNIFY>
                                <Subst>
                                  <aSubMap num="a"/>
                                  <type num="f"/>
                                </Subst>
                                <mbpair>
                                  <tvar name="beta"/>
                                  <fn M="yes">
                                    <tvar name="delta"/>
                                    <tvar name="alpha"/>
                                  </fn>
                                </mbpair>
                                <aSubMap num="v"/>
                              </UNIFY>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="[IV]  "/>
                              <UNIFY>
                                <type num="a"/>	      
                                <mbpair>
                                  <tvar name="gamma"/>		
                                  <minz>
                                    <Subst>
                                      <aSubMap num="v"/>
                                      <tvar name="delta"/>
                                    </Subst>
                                  </minz>
                                </mbpair>
                                <aSubMap num="w"/>
                              </UNIFY>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="[V]  "/>
                              <eq>
                                <type/>
                                <mbpair>
                                  <tvar name="epsiv"/>
                                  <minz>
                                    <Subst>
                                      <scomp>
                                        <aSubMap num="w"/>
                                        <aSubMap num="v"/>
                                      </scomp>
                                      <tvar name="alpha"/>
                                    </Subst>
                                  </minz>
                                </mbpair>
                              </eq>
                            </grouping>
                          </tyPre>
                          <tyPre>
                            <grouping>
                              <text content="[VI]  "/>
                              <models name="new">
                                <assume/>
                                <grouping>
                                  <tvar name="alpha"/>
                                  <tvar name="beta"/>
                                  <tvar name="gamma"/>
                                  <tvar name="delta"/>
                                  <tvar name="epsiv"/>
                                </grouping>
                              </models>
                            </grouping>
                          </tyPre>
                          <tyConc>
                            <TIjudge>
                              <assume>
                                <gamma/>
                                <store/>
                              </assume>
                              <conclude>
                                <tqExpr>
                                  <apply>
                                    <aExpr num="f"/>
                                    <aExpr num="a"/>
                                  </apply>                 
                                  <type/>
                                </tqExpr>
                              </conclude>
                              <propagate>
                                <scomp>
                                  <aSubMap num="w"/>
                                  <aSubMap num="v"/>
                                  <aSubMap num="a"/>
                                  <aSubMap num="f"/>
                                </scomp>
                              </propagate>
                            </TIjudge>
                          </tyConc>
                        </tyRule>
                      </Hrules>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__app_given_comp1">                    
                  <p>
                    <btypes:TYPE>
                      <eq>
                        <aSubMap num="u"/>
                        <compose>
                          <aSubMap num="w"/>
                          <aSubMap num="v"/>
                          <aSubMap num="a"/>
                          <aSubMap num="f"/>
                        </compose>
                      </eq>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__app_given_ecomp">
                  <p>
                    <btypes:TYPE>
                      <eq>
                        <aExpr/>
                        <apply>
                          <aExpr num="f"/>
                          <aExpr num="a"/>
                        </apply>
                      </eq>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__app_given_sol">
                  <p>
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap num="s"/>
                        </assume>
                        <Subst>
                          <aSubMap num="u"/>			                                    
                          <spset>
                            <type/>
                            <gamma/>
                            <store/>
                            <aExpr/>
                          </spset>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
              </ol>
              <p>
                Let
                <btypes:TYPE>
                  <eq>
                    <aSubMap num="su"/>
                    <compose>
                      <aSubMap num="s"/>
                      <aSubMap num="u"/>
                    </compose>
                  </eq>
                </btypes:TYPE>. We need
                <btypes:TYPE>
                  <Djudge>            
                    <aSubMap num="su"/>
                    <gamma/>
                    <store/>
                    <aExpr/>
                    <type/>
                  </Djudge>
                </btypes:TYPE>.                  
              </p>
            </li>            
            <li id="infer-sound__app_ih1">
              <p>
                From induction hypothesis (wrt [I]), we have:
              </p>
              <ol>
                <li id="infer-sound__app_ih11">
                  <p>                      
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap num="i"/>
                        </assume>
                        <Subst>
                          <aSubMap num="f"/>                          
                          <spset>
                            <type num="f"/>
                            <gamma/>
                            <store/>
                            <aExpr num="f"/>
                          </spset>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__app_ih12">
                  <p>
                    <btypes:TYPE>
                      <Djudge>            
                        <scomp>
                          <aSubMap num="i"/>
                          <aSubMap num="f"/>
                        </scomp>
                        <gamma/>
                        <store/>
                        <aExpr num="f"/>
                        <type num="f"/>
                      </Djudge>
                    </btypes:TYPE>
                  </p>
                </li>                  
              </ol>
            </li>
            <li id="infer-sound__app_ih2">
              <p>
                Similarly, from induction hypothesis (wrt [II]), 
                we have:
              </p>
              <ol>
                <li id="infer-sound__app_ih21">
                  <p>                      
                    <btypes:TYPE>
                      <models name="sat">
                        <assume>
                          <aSubMap num="j"/>
                        </assume>
                        <Subst>
                          <scomp>
                            <aSubMap num="a"/>                          
                            <aSubMap num="f"/>
                          </scomp>
                          <spset>
                            <type num="a"/>
                            <gamma/>
                            <store/>
                            <aExpr num="a"/>
                          </spset>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li id="infer-sound__app_ih22">
                  <p>
                    <btypes:TYPE>
                      <Djudge>            
                        <scomp>
                          <aSubMap num="j"/>
                          <aSubMap num="a"/>
                          <aSubMap num="f"/>
                        </scomp>
                        <gamma/>
                        <store/>
                        <aExpr num="a"/>
                        <type num="a"/>
                      </Djudge>
                    </btypes:TYPE>
                  </p>
                </li>                  
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From [I], [II], 
                    Lemma&nbsp;<xref ref="vars-new"/> (non-colliding
                    fresh type variables),
                    and
                    Lemma&nbsp;<xref ref="inf-subst-compose"/>
                    (consistency of inferred substitutions), we
                    have:
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <plus>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <collection>
                                <aExpr num="f"/>
                                <aExpr num="a"/>
                              </collection>
                            </relevant>
                          </Subst>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                          <type num="a"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    We know that 
                    <btypes:TYPE>
                      <eq>
                        <relevant>
                          <store/>
                          <collection>
                            <apply>
                              <aExpr num="f"/>
                              <aExpr num="a"/>
                            </apply>
                          </collection>
                        </relevant>
                        <relevant>
                          <store/>
                          <collection>
                            <aExpr num="f"/>
                            <aExpr num="a"/>
                          </collection>
                        </relevant>
                      </eq>
                    </btypes:TYPE>,
                    and from case (3.a.v),                       
                    <btypes:TYPE>
                      <eq>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <relevant>
                          <store/>
                          <collection>
                            <aExpr num="f"/>
                            <aExpr num="a"/>
                          </collection>
                        </relevant>
                      </eq>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.e.i and 3.e.ii), we obtain:
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <plus>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                          <type num="a"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.e.iii) and
                    Lemma&nbsp;<xref ref="cst-implies-consistent"/>
                    (weakening of consistency), 
                    we obtain:
                    <br/>
                    <btypes:TYPE>
                      <models name="cst">
                        <assume/>
                        <plus>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                          <type num="a"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>                
            </li>
            <li>
              <p>
                From case (3.e.iv) and
                Lemma&nbsp;<xref ref="sol-math-properties"/> 
                (property 2), 
                we conclude that 
                <btypes:TYPE>
                  <Exists>
                    <aSubMap num="e"/>
                  </Exists>
                  <text content=" such that "/>
                  <models name="sol">
                    <assume>
                      <aSubMap num="e"/>
                    </assume>
                    <plus>
                      <Subst>
                        <scomp>
                          <aSubMap num="a"/>                      
                          <aSubMap num="f"/>                      
                        </scomp>
                        <gamma/>
                      </Subst>
                      <Subst>
                        <scomp>
                          <aSubMap num="a"/>                      
                          <aSubMap num="f"/>                      
                        </scomp>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </Subst>
                      <Subst>
                        <aSubMap num="a"/>                      
                        <type num="f"/>
                      </Subst>
                      <type num="a"/>
                    </plus>
                  </models>
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <p>
              </p>
              <ol>
                <li>
                  <p>
                    We know that 
                    <btypes:TYPE>
                      <subeq>                          
                        <relevant>
                          <store/>
                          <aExpr num="f"/>
                        </relevant>                          
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                      </subeq>
                    </btypes:TYPE>.
                    Therefore, from cases (3.e.iii and 3.f) and 
                    Lemma&nbsp;<xref ref="solvable-weakening"/>
                    (weakening -- case (4)), we have:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e"/>
                        </assume>
                        <plus>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr num="f"/>
                            </relevant>
                          </Subst>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.                      
                    That is, 
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e"/>
                        </assume>
                        <Subst>                              
                          <aSubMap num="a"/>                      
                          <plus>
                            <Subst>                                                              
                              <aSubMap num="f"/>                      
                              <gamma/>
                            </Subst>
                            <Subst>                                                              
                              <aSubMap num="f"/>                      
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                            <Subst>                                                              
                              <aSubMap num="f"/>                                                      
                              <type num="f"/>
                            </Subst>
                          </plus>
                        </Subst>
                      </models>
                    </btypes:TYPE>.                                            
                    Note that
                    <btypes:TYPE>
                      <eq>
                        <Subst>
                          <aSubMap num="f"/>
                          <type num="f"/>
                        </Subst>
                        <type num="f"/>
                      </eq>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.d.i and 3.b.ii), and
                    Lemma&nbsp;<xref ref="relevant-subst-only"/>
                    (elimination of irrelevant substitutions), 
                    we can conclude that                       
                    <btypes:TYPE>
                      <Exists>
                        <subEq>
                          <aSubMap num="i" subnum="1"/> 
                          <aSubMap num="i"/>
                        </subEq>
                      </Exists>
                    </btypes:TYPE>
                    such that:
                  </p>
                  <ol>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <models name="sol">
                            <assume>
                              <aSubMap num="i" subnum="1"/>
                            </assume>
                            <plus>
                              <Subst>                                  
                                <aSubMap num="f"/>
                                <gamma/>
                              </Subst>
                              <Subst>                                  
                                <aSubMap num="f"/>
                                <relevant>
                                  <store/>
                                  <aExpr num="f"/>
                                </relevant>
                              </Subst>
                              <Subst>
                                <aSubMap num="f"/>
                                <type num="f"/>
                              </Subst>
                            </plus>
                          </models>	    
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <Sjudge>
                            <assume>
                              <canonical>
                                <Subst>
                                  <aSubMap num="i" subnum="1"/>
                                  <Subst>                                  
                                    <aSubMap num="f"/>
                                    <gamma/>
                                  </Subst>
                                </Subst>
                              </canonical>
                              <canonical>
                                <Subst>
                                  <aSubMap num="i" subnum="1"/>
                                  <Subst>                                  
                                    <aSubMap num="f"/>
                                    <relevant>
                                      <store/>
                                      <aExpr num="f"/>
                                    </relevant>
                                  </Subst>
                                </Subst>
                              </canonical>
                            </assume>
                            <tqExpr>
                              <aExpr num="f"/>
                              <canonical>
                                <Subst>
                                  <aSubMap num="i" subnum="1"/>
                                  <Subst>
                                    <aSubMap num="f"/>
                                    <type num="f"/>
                                  </Subst>
                                </Subst>
                              </canonical>
                            </tqExpr>
                          </Sjudge>	    
                        </btypes:TYPE>.                      
                      </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>
                    <!--                     Let -->
                    <!--                     <btypes:TYPE> -->
                    <!--                       <eq br="yes"> -->
                    <!--                         <solvable dash="'"/> -->
                    <!--                         <plus> -->
                    <!--                           <Subst>                                   -->
                    <!--                             <aSubMap num="f"/> -->
                    <!--                             <gamma/> -->
                    <!--                           </Subst> -->
                    <!--                           <Subst>                                   -->
                    <!--                             <aSubMap num="f"/> -->
                    <!--                             <relevant> -->
                    <!--                               <store/> -->
                    <!--                               <aExpr num="f"/> -->
                    <!--                             </relevant> -->
                    <!--                           </Subst> -->
                    <!--                           <Subst> -->
                    <!--                             <aSubMap num="f"/> -->
                    <!--                             <type num="f"/> -->
                    <!--                           </Subst> -->
                    <!--                         </plus> -->
                    <!--                       </eq> -->
                    <!--                     </btypes:TYPE>. -->
                    In step (3.g.ii), we can pick 
                    <btypes:TYPE>
                      <aSubMap num="i" subnum="1"/>
                    </btypes:TYPE>
                    such that
                    <btypes:TYPE>
                      <eq>
                        <dom>
                          <aSubMap num="i" subnum="1"/>
                        </dom>
                        <pred name="MTV">                            
                          <plus>
                            <Subst>
                              <aSubMap num="f"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <type num="f"/>
                            </Subst>
                          </plus>                          
                          <solvable dash="'"/>
                        </pred>
                      </eq>
                    </btypes:TYPE>.
                    From case (3.g.i), it is clear that
                    <btypes:TYPE>
                      <subEq>
                        <dom>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                          </scomp>
                        </dom>
                        <pred name="MTV">
                          <plus>
                            <Subst>
                              <aSubMap num="f"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <type num="f"/>
                            </Subst>
                          </plus>                          
                        </pred>
                      </subEq>
                    </btypes:TYPE>.
                    Therefore,
                    <btypes:TYPE>
                      <eq br="yes">
                        <inter>
                          <dom>
                            <aSubMap num="i" subnum="1"/>
                          </dom>                          
                          <dom>
                            <scomp>
                              <aSubMap num="e"/>
                              <aSubMap num="a"/>
                            </scomp>
                          </dom>
                        </inter>
                        <pred name="MTV">
                          <plus br="yes">
                            <Subst>
                              <aSubMap num="f"/>
                              <gamma/>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <relevant>
                                <store/>
                                <aExpr num="f"/>
                              </relevant>
                            </Subst>
                            <Subst>
                              <aSubMap num="f"/>
                              <type num="f"/>
                            </Subst>
                          </plus>                          
                        </pred>
                      </eq>
                    </btypes:TYPE>.
                    (This property can be shown for any other correct
                    value of
                    <btypes:TYPE>
                      <aSubMap num="i" subnum="1"/>
                    </btypes:TYPE> using 
                    Lemma&nbsp;<xref ref="vars-new"/>).
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                From cases (3.g.ii.A, 3.g.ii.B, 3.g.i and 3.g.iii), and 
                Lemma&nbsp;<xref ref="valid-subst-decl-ok"/>, 
                we have:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                          </scomp>
                          <Subst>                                  
                            <aSubMap num="f"/>
                            <gamma/>
                          </Subst>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                          </scomp>
                          <Subst>                                  
                            <aSubMap num="f"/>
                            <relevant>
                              <store/>
                              <aExpr num="f"/>
                            </relevant>
                          </Subst>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <aExpr num="f"/>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                          </scomp>
                          <Subst>
                            <aSubMap num="f"/>
                            <type num="f"/>
                          </Subst>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.                      
              </p>
              <p>
                That is,
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <relevant>
                            <store/>
                            <aExpr num="f"/>
                          </relevant>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <aExpr num="f"/>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <type num="f"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.                      
              </p>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From case (f) and
                    Lemma&nbsp;<xref ref="sol-math-properties"/> and
                    Lemma&nbsp;<xref ref="solvable-weakening"/> (weakening),
                    we can obtain
                    <btypes:TYPE>
                      <eq>
                        <normalize>
                          <Subst>
                            <scomp>
                              <aSubMap num="e"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <gamma/>
                          </Subst>
                        </normalize>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <gamma/>
                          </Subst>
                        </canonical>
                      </eq>
                      <text content=" and "/>
                      <eq>
                        <normalize>
                          <Subst>
                            <scomp>
                              <aSubMap num="e"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                        </normalize>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                        </canonical>
                      </eq>
                    </btypes:TYPE>.                      
                  </p>
                </li>
                <li>
                  <p>
                    Since                  
                    <btypes:TYPE>
                      <supeq>
                        <relevant>
                          <store/>
                          <aExpr/>
                        </relevant>
                        <relevant>
                          <store/>
                          <aExpr num="f"/>
                        </relevant>
                      </supeq>
                    </btypes:TYPE>, 
                    we have 
                    <btypes:TYPE>
                      <supeq>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                        <Subst>
                          <compose>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </compose>
                          <relevant>
                            <store/>
                            <aExpr num="f"/>
                          </relevant>
                        </Subst>
                      </supeq>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Now, from cases (h, i.i and i.ii), and
                    Lemma&nbsp;<xref ref="T-Weakening-ext"/>, we have
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e"/>
                                <aSubMap num="a"/>
                                <aSubMap num="f"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e"/>
                                <aSubMap num="a"/>
                                <aSubMap num="f"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </canonical>
                        </assume>
                        <tqExpr>
                          <aExpr num="f"/>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e"/>
                                <aSubMap num="a"/>
                                <aSubMap num="f"/>
                              </scomp>
                              <type num="f"/>
                            </Subst>
                          </canonical>
                        </tqExpr>
                      </Sjudge>	    
                    </btypes:TYPE>.                      
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Similarly, we have: <br/>
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <aExpr num="a"/>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="e"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <type num="a"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.                      
              </p>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    It is evident that 
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <mbpair>
                          <tvar name="beta"/>
                          <fn>
                            <floor>
                              <tvar name="delta"/>
                            </floor>
                            <ceil>
                              <tvar name="alpha"/>
                            </ceil>
                          </fn>
                        </mbpair>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    Since
                    <btypes:TYPE>
                      <collection and="yes">
                        <tvar name="alpha"/>
                        <tvar name="beta"/>
                        <tvar name="delta"/>
                      </collection>
                    </btypes:TYPE>
                    are fresh type variables, we can write
                    (using case (3.e.iii)):
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <plus br="yes">
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                          <type num="a"/>
                          <mbpair>
                            <tvar name="beta"/>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </mbpair>                            
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Due to
                    Lemma&nbsp;<xref ref="sol-plus-commut"/> 
                    (commutativity) 
                    and case (3.k.ii), we  can write:
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <plus br="yes">
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="a"/>                      
                              <aSubMap num="f"/>                      
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <type num="a"/>
                          <Subst>
                            <aSubMap num="a"/>                      
                            <type num="f"/>
                          </Subst>
                          <mbpair>
                            <tvar name="beta"/>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </mbpair>                            
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.k.iii), [III], and
                    Lemma&nbsp;<xref ref="unify-strong-consistent-cor"/>,
                    we have:
                    <btypes:TYPE>
                      <models name="ct">
                        <assume/>
                        <plus br="yes">
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <type num="a"/>
                          <Subst>
                            <aSubMap num="v"/>
                            <aSubMap num="a"/>
                            <type num="f"/>
                          </Subst>
                          <Subst>
                            <aSubMap num="v"/>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.                      
                  </p>
                </li>
              </ol>                
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From case (3.k.iv) and 
                    Lemma&nbsp;<xref ref="cst-implies-consistent"/>
                    (weakening of consistency) we have:
                    <btypes:TYPE>
                      <models name="cst">
                        <assume/>
                        <plus br="yes">
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <type num="a"/>
                          <Subst>
                            <aSubMap num="v"/>
                            <aSubMap num="a"/>
                            <type num="f"/>
                          </Subst>
                          <Subst>
                            <aSubMap num="v"/>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Now, from case (3.l.i) and
                    Lemma&nbsp;<xref ref="sol-math-properties"/>
                    (property 2), we conclude that 
                    <btypes:TYPE>
                      <Exists>
                        <aSubMap num="e" subnum="1"/>
                      </Exists>
                      <text content=" such that "/>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="1"/>
                        </assume>
                        <plus br="yes">
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <gamma/>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <relevant>
                              <store/>
                              <aExpr/>
                            </relevant>
                          </Subst>
                          <type num="a"/>
                          <Subst>
                            <scomp>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                            </scomp>
                            <type num="f"/>
                          </Subst>
                          <Subst>
                            <aSubMap num="v"/>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Similar to the argument in cases (g) through
                    (j), we obtain:                  
                  </p>
                  <ol>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <Sjudge>
                            <assume>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <gamma/>
                                </Subst>
                              </canonical>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <relevant>
                                    <store/>
                                    <aExpr/>
                                  </relevant>
                                </Subst>
                              </canonical>
                            </assume>
                            <tqExpr>
                              <aExpr num="f"/>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <type num="f"/>
                                </Subst>
                              </canonical>
                            </tqExpr>
                          </Sjudge>	    
                        </btypes:TYPE>.                      
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <Sjudge>
                            <assume>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <gamma/>
                                </Subst>
                              </canonical>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <relevant>
                                    <store/>
                                    <aExpr/>
                                  </relevant>
                                </Subst>
                              </canonical>
                            </assume>
                            <tqExpr>
                              <aExpr num="a"/>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="1"/>
                                    <aSubMap num="v"/>
                                    <aSubMap num="a"/>
                                    <aSubMap num="f"/>
                                  </scomp>
                                  <type num="a"/>
                                </Subst>
                              </canonical>
                            </tqExpr>
                          </Sjudge>	    
                        </btypes:TYPE>.                      
                      </p>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    it is evident that 
                    <btypes:TYPE>
                      <eq>
                        <Subst>
                          <scomp>
                            <aSubMap num="v"/>
                            <aSubMap num="a"/>
                            <aSubMap num="f"/>
                          </scomp>
                          <type num="a"/>
                        </Subst>
                        <type num="a"/>
                      </eq>
                    </btypes:TYPE>.
                    From case (3.a.ii), we know that
                    <btypes:TYPE>
                      <eq>
                        <aSubMap num="u"/>
                        <scomp>
                          <aSubMap num="w"/>
                          <aSubMap num="v"/>
                          <aSubMap num="a"/>
                          <aSubMap num="f"/>
                        </scomp>
                      </eq>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    Let
                  </p>
                  <ol>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="1"/>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                                <aSubMap num="a"/>
                                <aSubMap num="f"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="2"/>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                                <aSubMap num="a"/>
                                <aSubMap num="f"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="3"/>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                                <aSubMap num="a"/>
                              </scomp>
                              <type num="f"/>
                            </Subst>
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="4"/>
                            <Subst>
                              <aSubMap num="w"/>                              
                              <type num="a"/>
                            </Subst>
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="5"/>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                              </scomp>
                              <mbpair>
                                <tvar name="beta"/>
                                <fn>
                                  <floor>
                                    <tvar name="delta"/>
                                  </floor>
                                  <ceil>
                                    <tvar name="alpha"/>
                                  </ceil>
                                </fn>
                              </mbpair>
                            </Subst>
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <eq>
                            <solvable num="6"/>
                            <Subst>
                              <aSubMap num="w"/>
                              <mbpair>
                                <tvar name="gamma"/>
                                <floor>
                                  <Subst>
                                    <aSubMap num="v"/>
                                    <tvar name="delta"/>
                                  </Subst>
                                </floor>
                              </mbpair>
                            </Subst>                              
                          </eq>
                        </btypes:TYPE>
                      </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>
                    Similar to cases (k) and (l) above, for the
                    unification performed in step [IV], we conclude that
                    <btypes:TYPE>
                      <Exists>
                        <aSubMap num="e" subnum="2"/>
                      </Exists>
                    </btypes:TYPE>
                    such that:
                  </p>
                  <ol>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <models name="ct">
                            <assume/>
                            <plus>
                              <solvable num="1"/>
                              <solvable num="2"/>
                              <solvable num="3"/>
                              <solvable num="4"/>
                              <solvable num="5"/>
                              <solvable num="6"/>
                            </plus>
                          </models>
                        </btypes:TYPE>.
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <models name="sol">
                            <assume>
                              <aSubMap num="e" subnum="2"/>
                            </assume>
                            <plus>
                              <solvable num="1"/>
                              <solvable num="2"/>
                              <solvable num="3"/>
                              <solvable num="4"/>
                              <solvable num="5"/>
                              <solvable num="6"/>
                            </plus>
                          </models>
                        </btypes:TYPE>.
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <Sjudge>
                            <assume>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <gamma/>
                                </Subst>
                              </canonical>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <relevant>
                                    <store/>
                                    <aExpr/>
                                  </relevant>
                                </Subst>
                              </canonical>
                            </assume>
                            <tqExpr>
                              <aExpr num="f"/>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <type num="f"/>
                                </Subst>
                              </canonical>
                            </tqExpr>
                          </Sjudge>	    
                        </btypes:TYPE>.                      
                      </p>
                    </li>
                    <li>
                      <p>
                        <btypes:TYPE>
                          <Sjudge>
                            <assume>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <gamma/>
                                </Subst>
                              </canonical>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <relevant>
                                    <store/>
                                    <aExpr/>
                                  </relevant>
                                </Subst>
                              </canonical>
                            </assume>
                            <tqExpr>
                              <aExpr num="a"/>
                              <canonical>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <type num="a"/>
                                </Subst>
                              </canonical>
                            </tqExpr>
                          </Sjudge>	    
                        </btypes:TYPE>.                      
                      </p>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From [III], we have:
                    <btypes:TYPE>
                      <UNIFY>
                        <Subst>
                          <aSubMap num="a"/>
                          <type num="f"/>
                        </Subst>
                        <mbpair>
                          <tvar name="beta"/>
                          <fn>
                            <floor>
                              <tvar name="delta"/>
                            </floor>
                            <ceil>
                              <tvar name="alpha"/>
                            </ceil>
                          </fn>
                        </mbpair>
                        <aSubMap num="v"/>
                      </UNIFY>
                    </btypes:TYPE>                      
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.m.iii.A and 3.m.iii.B)  and                       
                    Lemma&nbsp;<xref ref="solvable-weakening"/>
                    (weakening), we have:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <Subst>
                          <plus>
                            <solvable num="3"/>
                            <solvable num="5"/>
                          </plus>
                        </Subst>
                      </models>
                    </btypes:TYPE>.
                    That is,
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <Subst>
                          <plus>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                                <aSubMap num="a"/>
                              </scomp>
                              <type num="f"/>
                            </Subst>
                            <Subst>
                              <scomp>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                              </scomp>
                              <mbpair>
                                <tvar name="beta"/>
                                <fn>
                                  <floor>
                                    <tvar name="delta"/>
                                  </floor>
                                  <ceil>
                                    <tvar name="alpha"/>
                                  </ceil>
                                </fn>
                              </mbpair>
                            </Subst>                          
                          </plus>
                        </Subst>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    The case (3.n.ii) can be re-written as: 
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <Subst>
                            <scomp>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                            </scomp>
                            <Subst>
                              <aSubMap num="a"/>
                              <type num="f"/>
                            </Subst>
                          </Subst>
                          <Subst>
                            <scomp>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                            </scomp>
                            <mbpair>
                              <tvar name="beta"/>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </mbpair>
                          </Subst>                     
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.n.i), (3.n.iii) and 
                    Lemma&nbsp;<xref ref="unify-maybe-cor"/> 
                    (property 3), we have: 
                    <br/>
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                            </scomp>
                            <Subst>
                              <aSubMap num="a"/>
                              <type num="f"/>
                            </Subst>
                          </Subst>
                        </canonical>
                        <canonical>
                          <minz>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                              </scomp>
                              <fn>
                                <floor>
                                  <tvar name="delta"/>
                                </floor>
                                <ceil>
                                  <tvar name="alpha"/>
                                </ceil>
                              </fn>
                            </Subst>
                          </minz>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.
                  </p>
                  <p>
                    That is,
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                            </scomp>                              
                            <type num="f"/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                            </scomp>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    The case (3.n.iv) can be re-written as:
                    <br/>
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>                              
                            <type num="f"/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                              <aSubMap num="a"/>
                              <aSubMap num="f"/>
                            </scomp>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>, since these substitutions have
                    no effect.
                  </p>
                </li>
                <li>
                  <p>
                    Due to cases (3.a.ii), the above case (3.n.v) is
                    equivalent to 
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="u"/>
                            </scomp>                              
                            <type num="f"/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="u"/>
                            </scomp>
                            <fn>
                              <floor>
                                <tvar name="delta"/>
                              </floor>
                              <ceil>
                                <tvar name="alpha"/>
                              </ceil>
                            </fn>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    The case (3.n.vi) is further equivalent to
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="u"/>
                            </scomp>                              
                            <type num="f"/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <fn>
                            <floor>
                              <Subst>
                                <scomp>
                                  <aSubMap num="e" subnum="2"/>
                                  <aSubMap num="u"/>
                                </scomp>                                  
                                <tvar name="delta"/>
                              </Subst>
                            </floor>
                            <ceil>
                              <Subst>
                                <scomp>
                                  <aSubMap num="e" subnum="2"/>
                                  <aSubMap num="u"/>
                                </scomp>
                                <tvar name="alpha"/>
                              </Subst>
                            </ceil>
                          </fn>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.                      
                  </p>
                </li>
                <li>
                  <p>
                    Similarly, for the unification performed in
                    step [IV], we have: 
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="e" subnum="2"/>
                              <aSubMap num="u"/>
                            </scomp>
                            <type num="a"/>
                          </Subst>
                        </canonical>
                        <canonical>
                          <floor>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="u"/>
                              </scomp>         
                              <tvar name="delta"/>
                            </Subst>
                          </floor>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.                                            
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From cases (3.m.iii.C and 3.n.vii), we obtain:
                    <br/>
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </canonical>
                        </assume>
                        <Tsub>
                          <aExpr num="f"/>
                          <canonical>
                            <fn>
                              <floor>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>                                  
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="e" subnum="2"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </fn>
                          </canonical>
                        </Tsub>
                      </Sjudge>	    
                    </btypes:TYPE>.                      
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.m.iii.D and 3.n.viii) we obtain:
                    <br/>
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="e" subnum="2"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </canonical>
                        </assume>
                        <Tsub>
                          <aExpr num="a"/>
                          <canonical>
                            <floor>
                              <Subst>
                                <scomp>
                                  <aSubMap num="e" subnum="2"/>
                                  <aSubMap num="u"/>
                                </scomp>         
                                <tvar name="delta"/>
                              </Subst>
                            </floor>
                          </canonical>
                        </Tsub>
                      </Sjudge>	    
                    </btypes:TYPE>.                      
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From (3.m.iii.A and 3.m.iii.B) and 
                    Lemma&nbsp;<xref ref="solvable-weakening"/>
                    (weakening), we have
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <solvable num="6"/>
                        </plus>
                      </models>
                    </btypes:TYPE>. That is,
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <Subst>
                            <aSubMap num="w"/>                            
                            <mbpair>
                              <tvar name="gamma"/>
                              <floor>
                                <Subst>
                                  <aSubMap num="v"/>
                                  <tvar name="alpha"/>
                                </Subst>     
                              </floor>                       
                            </mbpair>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Since 
                    <btypes:TYPE>
                      <tvar name="gamma"/>
                    </btypes:TYPE> is a fresh type variable (from
                    [VI]), we can write:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <Subst>
                            <aSubMap num="w"/>                            
                            <floor>
                              <Subst>
                                <aSubMap num="v"/>
                                <tvar name="alpha"/>
                              </Subst>     
                            </floor>                       
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>. 
                    And further,
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <Subst>
                            <aSubMap num="w"/>                            
                            <minz>
                              <Subst>
                                <aSubMap num="v"/>
                                <tvar name="alpha"/>
                              </Subst>     
                            </minz>                       
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Let the hint for the return type
                    <btypes:TYPE>
                      <eq>
                        <type num="rh"/>
                        <Subst>
                          <aSubMap num="w"/>                            
                          <minz>
                              <Subst>
                              <aSubMap num="v"/>
                              <tvar name="alpha"/>
                            </Subst>     
                          </minz>                       
                        </Subst>
                      </eq>
                    </btypes:TYPE>. 
                    From the previous step, we can write: 
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <type num="rh"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    Let 
                    <btypes:TYPE>
                      <eq>
                        <aSubMap num="E"/>
                        <compose>
                          <aSubMap num="e" subnum="2"/>
                          <SubMap>
                            <tvar name="epsiv"/>
                            <type num="rh"/>
                          </SubMap>
                        </compose>
                      </eq>
                      <text content=". A substitution for "/>
                      <tvar name="epsiv"/>
                      <text content=" with any type "/>
                      <ceq> 
                        <type/>                          
                        <type num="rh"/>
                      </ceq>
                      <text content=" will actually work"/>
                      <text content=" in this case."/>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.p.iii and 3.q.i), 
                    and 
                    Definition&nbsp;<xref ref="sol-math"/>,
                    we can easily obtain:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>          
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <mbpair>
                            <tvar name="epsiv"/>
                            <type num="rh"/>
                          </mbpair>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                    That is,
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>          
                        <plus>
                          <solvable num="1"/>
                          <solvable num="2"/>
                          <type num="res"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                    Further, using the weakening lemma
                    (Lemma&nbsp;<xref ref="solvable-weakening"/>)
                    we obtain:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>          
                        <type num="res"/>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    Similar to case (3.p.i), we obtain 
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="e" subnum="2"/>
                        </assume>
                        <Subst>
                          <aSubMap num="w"/>
                          <Subst>
                            <aSubMap num="v"/>
                            <tvar name="alpha"/>
                          </Subst>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.q.i), it is evident that:
                    <btypes:TYPE>
                      <models name="eqi">
                        <assume>
                          <Subst>
                            <scomp>
                              <aSubMap num="w"/>           
                              <aSubMap num="v"/>
                            </scomp>
                            <tvar name="alpha"/>
                          </Subst>
                        </assume>
                        <approx>
                          <aSubMap num="e" subnum="2"/>
                          <aSubMap num="E"/>
                        </approx>
                      </models>
                    </btypes:TYPE>.
                    Therefore, from case (3.r.i), we have:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>
                        <Subst>
                          <aSubMap num="w"/>
                          <Subst>
                            <aSubMap num="v"/>
                            <tvar name="alpha"/>
                          </Subst>
                        </Subst>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.r.ii), and by observing the
                    constraint solver rules in  
                    Figure&nbsp;<xref ref="hm_solve"/>, we can also
                    write:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>
                        <ceil>
                          <Subst>
                            <scomp>
                              <aSubMap num="w"/>
                              <aSubMap num="v"/>
                            </scomp>
                            <tvar name="alpha"/>
                          </Subst>
                        </ceil>
                      </models>
                    </btypes:TYPE> and
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>
                        <Subst>
                          <aSubMap num="w"/>
                          <minz>
                            <Subst>
                              <aSubMap num="v"/>
                              <tvar name="alpha"/>
                            </Subst>
                          </minz>
                        </Subst>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.r.iii) and 
                    Lemma&nbsp;<xref ref="sol-math-properties"/>, we
                    have:
                    <btypes:TYPE>
                      <eq>
                        <normalize>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </normalize>
                        <canonical>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="w"/>
                                <aSubMap num="v"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </canonical>
                      </eq>
                    </btypes:TYPE> and
                    <btypes:TYPE>
                      <eq>
                        <normalize>
                          <Subst>
                            <scomp>
                              <aSubMap num="E"/>                        
                              <aSubMap num="w"/>
                            </scomp>
                            <minz>
                              <Subst>
                                <aSubMap num="v"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </minz>
                          </Subst>
                        </normalize>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="E"/>                        
                              <aSubMap num="w"/>
                            </scomp>
                            <minz>
                              <Subst>
                                <aSubMap num="v"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </minz>
                          </Subst>
                        </canonical>
                      </eq>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p> 
                    From the definition of It is evident that 
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="w"/>           
                                <aSubMap num="v"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </canonical>
                        <canonical>
                          <Subst>
                            <scomp>
                              <aSubMap num="E"/>
                              <aSubMap num="w"/>           
                            </scomp>
                            <minz>
                              <Subst>
                                <aSubMap num="v"/>
                                <tvar name="alpha"/>
                              </Subst>
                            </minz>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.
                    That is (from case (3.q.1)),
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="w"/>           
                                <aSubMap num="v"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="rh"/>                              
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.                    
                  </p>
                </li>                  
                <li>
                  <p>
                    From case (3.q.i), we can conclude that
                    <btypes:TYPE>
                      <eq>
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="res"/>
                          </Subst>
                        </canonical>                          
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="rh"/>
                          </Subst>
                        </canonical>
                      </eq>
                    </btypes:TYPE>.
                    (We actually only need a compatibility relationship
                    here, in case we chose any other compatible type
                    in case (3.q.i)).
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.r.v and 3.r.vi), we obtain
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="w"/>           
                                <aSubMap num="v"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="res"/>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    The case (3.r.vii) can be written as
                    <btypes:TYPE>
                      <Tsub>
                        <canonical>
                          <ceil>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <tvar name="alpha"/>
                            </Subst>
                          </ceil>
                        </canonical>
                        <canonical>
                          <Subst>
                            <aSubMap num="E"/>
                            <type num="res"/>
                          </Subst>
                        </canonical>
                      </Tsub>
                    </btypes:TYPE>, since the extra substitutions
                    have no effect.            
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From case (3.q.i), it is evident that
                    <btypes:TYPE>
                      <models name="eqi">
                        <assume>
                          <plus>
                            <solvable num="1"/>
                            <solvable num="2"/>
                            <fn>
                              <floor>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <Subst>
                                  <aSubMap num="u"/>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </fn>
                          </plus>
                        </assume>          
                        <approx>
                          <aSubMap num="E"/>
                          <aSubMap num="e" subnum="2"/>
                        </approx>
                      </models>
                    </btypes:TYPE>.                  
                    Therefore, from case (3.o.i) and 
                    Lemma&nbsp;<xref ref="eqi-subst-decl-ok"/>, 
                    we have:
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </canonical>
                        </assume>
                        <Tsub>
                          <aExpr num="f"/>
                          <canonical>
                            <fn>
                              <floor>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="E"/>
                                    <aSubMap num="u"/>
                                  </scomp>                                  
                                  <tvar name="delta"/>
                                </Subst>
                              </floor>
                              <ceil>
                                <Subst>
                                  <scomp>
                                    <aSubMap num="E"/>
                                    <aSubMap num="u"/>
                                  </scomp>
                                  <tvar name="alpha"/>
                                </Subst>
                              </ceil>
                            </fn>
                          </canonical>
                        </Tsub>
                      </Sjudge>	    
                    </btypes:TYPE>.                                            
                  </p>
                </li>
                <li>
                  <p>
                    Similarly, we have:
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="E"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <relevant>
                                <store/>
                                <aExpr/>
                              </relevant>
                            </Subst>
                          </canonical>
                        </assume>
                        <Tsub>
                          <aExpr num="a"/>
                          <canonical>
                            <floor>
                              <Subst>
                                <scomp>
                                  <aSubMap num="E"/>
                                  <aSubMap num="u"/>
                                </scomp>         
                                <tvar name="delta"/>
                              </Subst>
                            </floor>
                          </canonical>
                        </Tsub>
                      </Sjudge>	    
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Now, from cases (3.s.i), (3.s.ii), (3.r.viii) and
                T-App rule, we obtain:
                <btypes:TYPE>
                  <Sjudge>
                    <assume>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="E"/>
                            <aSubMap num="u"/>
                          </scomp>
                          <gamma/>
                        </Subst>
                      </canonical>
                      <canonical>
                        <Subst>
                          <scomp>
                            <aSubMap num="E"/>
                            <aSubMap num="u"/>
                          </scomp>
                          <relevant>
                            <store/>
                            <aExpr/>
                          </relevant>
                        </Subst>
                      </canonical>
                    </assume>
                    <tqExpr>
                      <apply>
                        <aExpr num="f"/>
                        <aExpr num="a"/>
                      </apply>
                      <canonical>
                        <Subst>
                          <aSubMap num="E"/>
                          <type num="res"/>
                        </Subst>
                      </canonical>
                    </tqExpr>
                  </Sjudge>	    
                </btypes:TYPE>.
              </p>
            </li>
            <li>
              <ol>
                <li>
                  <p>
                    From case (3.q.ii) and
                    Lemma&nbsp;<xref ref="sol-plus-commut"/>
                    (commutativity), we obtain:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="E"/>
                        </assume>          
                        <plus>
                          <type num="res"/>
                          <solvable num="1"/>
                          <solvable num="2"/>
                        </plus>
                      </models>
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    From case (3.a.iii) and 
                    Theorem&nbsp;<xref ref="TI-solve-correct"/>, 
                    we have:
                    <btypes:TYPE>
                      <models name="sol">
                        <assume>
                          <aSubMap num="s"/>
                        </assume>
                        <plus>
                          <type num="res"/>
                          <Subst>
                            <aSubMap num="u"/>			                                    
                            <gamma/>
                          </Subst>
                          <Subst>
                            <aSubMap num="u"/>			                                    
                            <store/>
                          </Subst>
                        </plus>
                      </models>
                    </btypes:TYPE>
                  </p>
                </li>
                <li>
                  <p>
                    From cases (3.u.i), (t), (3.u.ii), and 
                    Lemma&nbsp;<xref ref="compat-subst-decl-ok-cor2"/>,
                    we obtain:
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="s"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <scomp>
                                <aSubMap num="s"/>
                                <aSubMap num="u"/>
                              </scomp>
                              <store/>
                            </Subst>
                          </canonical>
                        </assume>
                        <tqExpr>
                          <apply>
                            <aExpr num="f"/>
                            <aExpr num="a"/>
                          </apply>
                          <canonical>
                            <Subst>
                              <aSubMap num="s"/>
                              <type num="res"/>
                            </Subst>
                          </canonical>
                        </tqExpr>
                      </Sjudge>	    
                    </btypes:TYPE>.
                  </p>
                </li>
                <li>
                  <p>
                    Finally, from cases (3.a.iv) and (3.a.v), 
                    we obtain the desired result:
                    <btypes:TYPE>
                      <Sjudge>
                        <assume>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <gamma/>
                            </Subst>
                          </canonical>
                          <canonical>
                            <Subst>
                              <aSubMap num="su"/>
                              <store/>
                            </Subst>
                          </canonical>
                        </assume>
                        <tqExpr>
                          <aExpr/>
                          <canonical>
                            <Subst>
                              <aSubMap num="s"/>
                              <type num="res"/>
                            </Subst>
                          </canonical>
                        </tqExpr>
                      </Sjudge>	    
                    </btypes:TYPE>.
                  </p>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          <p>
            Cases I-Let-&alpha;: Similar to case (3) (I-App),
            except for the use of
            Lemma&nbsp;<xref ref="solve-sol-compat"/>.
          </p>
        </li>	
        <li>
          <p>
            Cases I-If, I-Dup, I-Deref, I-Set,  
            I-Tqexpr, I-Let-&alpha;-Tq are similar.
          </p>
        </li>	
      </ol>
    </proof>
    <lemma id="infer-sound-cor1">
      <title>Corollary&ndash;1 to Soundness of Type Inference</title>
      <p>
        If:
      </p>
      <ol>
        <li>
          <p>
            <btypes:TYPE>
              <TIjudge>
                <assume>
                  <gamma/>
                  <store/>
                </assume>
                <conclude>
                  <tqExpr>
                    <aExpr/>
                    <type/>
                  </tqExpr>
                </conclude>
                <propagate>
                  <aSubMap num="u"/>
                </propagate>
              </TIjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge name="s">
                <assume>
                  <aSubMap num="s"/>
                </assume>
                <corUp>
                  <type/>
                  <type dash="'"/>
                </corUp>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <Sjudge name="sol">
                <assume>
                  <aSubMap num="e"/>
                </assume>
                <Subst>
                  <compose>
                    <aSubMap num="s"/>
                    <aSubMap num="u"/>
                  </compose>
                  <plus>
                    <gamma/>
                    <relevant>
                      <store/>
                      <aExpr/>
                    </relevant>
                  </plus>
                </Subst>
              </Sjudge>
            </btypes:TYPE>
          </p>
        </li>
        <li>
          <p>
            <btypes:TYPE>
              <eq>
                <aSubMap/>
                <compose>		
                  <aSubMap num="e"/>
                  <aSubMap num="s"/>
                  <aSubMap num="u"/>
                </compose>
              </eq>
            </btypes:TYPE>
          </p>
        </li>
      </ol>
      <p>
        Then
        <btypes:TYPE>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <type dash="'"/>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE>.
      </p>
    </lemma>
    <proof>
      <p>
        Follows from 
        Theorem&nbsp;<xref ref="infer-sound"/>, properties of solvable
        entities (Definition&nbsp;<xref ref="solvable-entities"/>),
        and Lemma&nbsp;<xref ref="inf-subst-valid"/>.
      </p>
    </proof>
    <theorem id="infer-sound-cor2">
      <title>Corollary&ndash;2 to Soundness of Type Inference</title>
      <p>
        If:
        <btypes:TYPE>
          <TIjudge>
            <assume>
              <gamma/>
              <store/>
            </assume>
            <conclude>
              <tqExpr>
                <aExpr/>
                <type/>
              </tqExpr>
            </conclude>
            <propagate>
              <aSubMap num="u"/>
            </propagate>
          </TIjudge>
          <text content=" and "/>
          <Sjudge name="s">
            <assume>
              <aSubMap num="s"/>
            </assume>
            <corUp>
              <type/>
              <type dash="'"/>
            </corUp>
          </Sjudge>
          <text content=" then "/>
          <Exists>
            <aSubMap num="e"/>
          </Exists>
          <text content=" such that "/>
          <eq>
            <aSubMap/>
            <compose>		
              <aSubMap num="e"/>
              <aSubMap num="s"/>
              <aSubMap num="u"/>
            </compose>
          </eq>
          <text content=" and "/>
          <Sjudge>
            <assume>
              <canonical>
                <Subst>
                  <aSubMap/>
                  <gamma/>
                </Subst>
              </canonical>
              <canonical>
                <Subst>
                  <aSubMap/>
                  <store/>
                </Subst>
              </canonical>
            </assume>
            <tqExpr>
              <aExpr/>
              <canonical>
                <type dash="'"/>
              </canonical>
            </tqExpr>
          </Sjudge>	    
        </btypes:TYPE>.
      </p>
    </theorem>
    <proof>
      <p>
        Follows from 
        Lemma&nbsp;<xref ref="infer-sound-cor1"/>.
      </p>
    </proof>
  </sect1>
  <nocite ref="sridhar2006plos"/>
  <bibliography>
    <bibentry label="shapBitcSpec2006">
      <key>Shapiro06</key>
      J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
      Specification''
      <link
      href="http://bitc-lang.org/docs/bitc/spec.html">
      <progident>http://www.bitc-lang.org/docs/bitc/spec.html</progident>
      </link>
    </bibentry>
    <bibentry label="sridhar2006plos">
      <key>Sridhar06</key>
       S. Sridhar and J. Shapiro. ``Type Inference for Unboxed Types
       and First Class Mutability'' <doctitle>Proc. 3rd ECOOP Workshop
       on Programming Languages and Operating Systems (PLOS
       2006)</doctitle> San Jose, CA. 2006.
    </bibentry>
  </bibliography>
 
</article>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->


<!--  LocalWords:  ptsz authorgroup firstname orgname sridharmutinfer bnf desc
 -->
<!--  LocalWords:  sLoc hLoc aVal aExpr lvalues lVal tqExpr bnfc dup opsem eval
 -->
<!--  LocalWords:  opState dyn sem Grossman qtypes levalOp evalOp RVAL aTS pred
 -->
<!--  LocalWords:  subst Csubst ceqOp maxzOp minzOp eq maxz neq minz metaCT ol
 -->
<!--  LocalWords:  covariant arg ret ceil Tsub TDjudge Hrules tyRule TW tyPre
 -->
<!--  LocalWords:  tyConc lval decl judgeOp Garriage's spEqOp notin spEq unin
 -->
<!--  LocalWords:  uninOp Sjudge dom mapsto rexec leadin leval supeq aSubMap Ph
 -->
<!--  LocalWords:  VSubstitution LSubstitution SubMap TEjudge UNF unf subeq ACM
 -->
<!--  LocalWords:  mbpair TIjudge vaughanHM Hindley Milner mdash epsiv corUp HL
 -->
<!--  LocalWords:  TypesBook corUpOp carrys epsi ASET SRL unkinded pagebreak SL
 -->
<!--  LocalWords:  Garriague's vspace CTX MTVs FTVs NTVs cst commut sust ok su
 -->
<!--  LocalWords:  canonicalized ndash si uf ua vf rh va sa subeqOp supeqOp eqi
 -->
 
<!--  LocalWords:  nceq documentclass sigplanconf FirstName LastName notitle ih
 -->

<!--  LocalWords:  horz idemp Acyclicity otheroptions nocopyrightspace FTV NTV
 -->
<!--  LocalWords:  explicitely tvs asm mtvs lem nosp req defn scomp subnum sep
 -->
<!--  LocalWords:  fnize cong sm ecomp subEq
 -->


