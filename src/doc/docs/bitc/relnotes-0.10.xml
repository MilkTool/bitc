<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [

<!ENTITY LangVersion "0.10">
<!ENTITY BitcVersion "0.10.1">
]>
  <article id="capidl-spec" xmlns:xi="http://www.w3.org/2001/XInclude">
  <docinfo>
    <title>BitCC Release Notes</title>
    <subtitle>Version &BitcVersion;</subtitle>
    <authorgroup>
      <author>
	<firstname>Jonathan</firstname>
	<surname>Shapiro</surname>
	<degree>Ph.D.</degree>
      </author>
      <author>
	<firstname>Swaroop</firstname>
	<surname>Sridhar</surname>
      </author>
      <affiliation>
	<orgname>Systems Research Laboratory</orgname>
	<address>Dept. of Computer Science</address>
	<address>Johns Hopkins University</address>
      </affiliation>
    </authorgroup>
    <pubdate>June 17, 2006</pubdate>
    <copyright>
      <year>2006</year> 
      <holder>Jonathan S. Shapiro</holder>
      <holder>Swaroop Sridhar</holder>
    </copyright>
    <categories>
      <category>dev/bitc-notyet</category>
    </categories>
    <synopsis>
      <p>Release notes for BitCC version &BitcVersion;.</p>
    </synopsis>
  </docinfo>
  <abstract latex.incolumn="yes">
    <p>
      Describes how to obtain BitCC version &BitcVersion; and known
      issues in the implementation.
    </p>
  </abstract>
  <p>
    <b>NOTE THIS IS NOT YET CURRENT!!!</b>
  </p>
  <p>
    We are very pleased to announce the release of BitCC version
    &BitcVersion;. This is a compiler conforming (mostly) to the
    version &LangVersion; specification for the BitC programming
    language. This document describes how to obtain and build the
    compiler, known issues or incompletenesses in the implementation.
  </p>
  <p>
    Instructions for download have changed. to download this
    release, follow the instructions on the website under the "Get
    It" tab.
  </p>
  <sect1>
    <title>Compiler Usage</title>
    <p>
      This version of <command>BitCC</command> is a <em>whole
      program</em> compiler. The expected command line is:
    </p>
    <literallayout>
bitcc [-I if-root] [-L libdir] -o target src1.bitc ... srcN.bitc
</literallayout>
    <p indent="no">
      Source files specified on the command line should include
      <em>only</em> source units of compilation. Imports will be
      resolved and loaded automatically by the compiler.
    </p>
    <p>
      The <progident>-I&nbsp;if-root</progident> option can be
      repeated. Each such option names the <em>top</em> of a directory
      tree containing interface modules. An attempt to import the
      module <progident>foo.bar.baz</progident> will be resolved by
      attempting to import <filename>foo/bar/baz.bitc</filename> in
      turn from each of the specified <filename>if-root/</filename>
      directory trees.
    </p>
    <sect2>
      <title>Seeing the C Code</title>
      <p>
        If you wish to examine the C code generated by the compiler &mdash;
        which is interesting primarily as an illustration of just how
        ugly C code can get &mdash; you can use:
      </p>
      <literallayout>
bitcc [-I if-root] [-L libdir] -l c -o target.c src1.bitc ... srcN.bitc
</literallayout>
    </sect2>
    <sect2>
      <title>Default Program Entry Point</title>
      <p>
Program entry points may now be specified by the command line
        <command>-e&nbsp;<em>name</em></command> option, where
        <progident><em>name</em></progident> takes the form
        <progident><em>if</em>.<em>ident</em></progident> Note that
        the interface name component does not draw its identifiers
        from the same namespace as other identifiers. The identifier
        <progident>bitc.main.main</progident> describes an
        <em>interface name</em> <progident>bitc.main</progident>
        followed by an identifier <em>main</em>.
      </p>
      <p>
        In the absence of other specification on the command line, the
        entry point of a BitC program is now
        <progident>bitc.main.main</progident>. This is a
        library-provided interface whose definition is not provided by
        the library. A unit of compilation that provides the main
        procedure should proceed by something like:
      </p>
      <programlisting>
(provide main bitc.main)
(define (main.main argv) <em>body</em>)</programlisting>
      <p indent="no">
        This has the additional advantage that argument types for main
        need not be explicitly specified in the source unit because
        they will unify with the <em>proclaim</em> provided by the
        library.
      </p>
      <p>
        If the entry point <progident>bitc.main.main</progident> is
        selected (either on the command line or by default), the back
        end will emit a wrapper procedure <progident>main</progident>
        that will handle command line argument vector processing and
        call the <progident>bitc.main.main</progident> procedure. It
        will also emit and arrange to call a procedure that performs
        global initialization. If the entry point(s) specified do
        <em>not</em> include <progident>bitc.main.main</progident>,
        the initializer procedure will be emitted but will not be
        called, and no wrapper procedure will be emitted. It is
        assumed in this case that the developer will take
        responsibility for interfacing with the surrouding host
        runtime environment in order to get the program started.
      </p>
    </sect2>
    <sect2>
      <title>Wrapping An Existing Library</title>
      <p>
        If you wish to implement a wrapper for an existing C library,
        you may wish to examine the
        <filename>ccs/bitcc-bootstrap/libbitc/</filename> directory
        and examine its use of the <progident>-h</progident> command
        line option to <command>BitCC</command>. Where the
        <command>-l&nbsp;c</command> option says "generate C code",
        the <command>-l&nbsp;h</command> command says "generate a
        header file that can be used to implement a supporting wrapper
        library." This header file will contain declarations for:
      </p>
      <ul>
        <li>
          <p>
            Every exception declared in the imported modules.
          </p>
        </li>
        <li>
          <p>
            Every <progident>proclaim</progident> that is marked
            <progident>external</progident>, provided that the
            proclaimed procedure does not have polymorphic type.
          </p>
        </li>
        <li>
          <p>
            Every type that is (recursively) reachable from these.
          </p>
        </li>
      </ul>
      <p>
        There is now a mechanism for suppressing name mangling in
        order to interface with existing C code.
      </p>
      <sect3>
        <title>External Names for Values</title>
        <p>
          One change in this release is that <command>BitCC</command>
          now supports the <progident>external</progident> keyword more
          fully, including specification of the external identifier
          name. This should make it possible to wrap external libraries
          using human readable (and therefore possibly maintainable)
          identifiers. External declarations can be provided only for
          fully concrete procedures, values, and (in some cases)
          types. In the case of procedures and values the supplied
          external name will be used verbatim, thus, given the declarations
        </p>
        <programlisting>
(proclaim someid : int32 external libbitc_someid)
(proclaim f : (fn (int32 int32) bool) external
libbitc_f)</programlisting>
        <p indent="no">
          will use the identifiers <progident>libbitc_someid</progident>
          and <progident>libbitc_f</progident> to refer to
          <progident>someid</progident> and <progident>f</progident>
          respectively. An external name can be supplied at the
          <progident>proclaim</progident> form even if the value is
          later defined in BitC. The forms:
        </p>
        <programlisting>
(proclaim id : int32 external libbitc_someid)
(define id 32)</programlisting>
        <p indent="no">
          say that <progident>id</progident> should be emitted using the
          name <progident>libbitc_someid</progident> throughout. It can
          be referenced by the external code, but its
          <em>definition</em> is provided by the BitC code.
        </p>
      </sect3>
      <sect3>
        <title>External Names for Types</title>
        <p>
          The same mechanism can be used in a more restricted form for
          types, but in this case some name mangling must be performed
          because a single name in BitC serves simultaneously as a
          constructor name and a type name. In practice, the most
          interesting case is the external declaration of exceptions
          (because C libraries will often need to raise these when
          things go wrong). The form:
        </p>
        <programlisting>
(defexception OutOfMemory)</programlisting>
        <p indent="no">
          must declare three things: a type, a value (an exception or
          union case having no fields has only a singleton constant
          instance), and a ``tag'' value (which is used in the
          <progident>catch</progident> clause to dispatch on the
          exception). For union values, an enumeration type must also
          be emitted.  If an <progident>external</progident>
          declaration with an identifier is also given, as in:
        </p>
        <programlisting>
(proclaim OutOfMemory : exception external OutOfMemory)</programlisting>
        <p indent="no">
          then a tag, type, and value will be emitted. In general, the
          renaming for types is as follows:
        </p>
        <table>
          <tbody>
            <tr valign="top">
              <td><em>tag</em></td>
              <td><progident>tag_OutOfMemory</progident></td>
            </tr>
            <tr valign="top">
              <td><em>value</em></td>
              <td><progident>val_OutOfMemory</progident></td>
            </tr>
            <tr valign="top">
              <td><em>constructor</em></td>
              <td><progident>ct_OutOfMemory</progident></td>
            </tr>
            <tr valign="top">
              <td><em>type</em></td>
              <td><progident>ty_OutOfMemory</progident></td>
            </tr>
            <tr valign="top">
              <td><em>enumeration</em></td>
              <td><progident>en_OutOfMemory</progident></td>
            </tr>
          </tbody>
        </table>
        <p>
          We are not committed to this specific renaming (yet).
        </p>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>New Behavior</title>
    <p>
      <leadin>Main Entry Point</leadin> The most important behavioral
      change in this release is that the normal entry point is now
      <progident>bitc.main.main</progident>. This will require minor
      changes in existing code.
    </p>
    <p>
      <leadin>Integer Literals</leadin> Integer literals are not
      values in this release. We are going back and forth on what to
      do with this. The problem lies in forms like:
    </p>
<programlisting>
(let ((p 1))
  (set! p 2)
  (+ p 1))</programlisting>
    <p indent="no">
      which returns <progident>2</progident> (surprise!) if
      <progident>p</progident> is assigned a polymorphic type. The
      source of the difficulty is that the type of
      <progident>p</progident> must be decided by the end of the
      bindings and before the <progident>let</progident> body, and the
      <progident>set!</progident> has not been seen by this
      point. Since detection can be handled structurally, we are
      considering a separate pass expressly to notice the
      <progident>set!</progident> and syntactically rewrite such forms into:
    </p>
<programlisting>
(let ((p:(mutable 'a) 1))
  (set! p 2)
  (+ p 1))</programlisting>
    <p indent="no">
      which will force the value restriction in these cases and
      eliminate the source of the confusion. As an interim measure we
      have made integer and floating point values be non-values, but
      in the limit what is really wanted here is analysis on the
      initializer that lets us understand whether it can be viewed as
      a pure term. Implementing the check for
      <progident>set!</progident> will provide a short-term solution
      in the near future.
    </p>
    <p>
      <leadin>Field Names</leadin> Unions and exceptions now have
      field names. The <progident>case</progident> construct has been
      removed in favor of <progident>switch</progident>, which is
      described in section <link
      href="spec.html#7.16">7.16</link> of the language
      specification. Because of this change, value patterns are now gone.
    </p>
    <p>
      <leadin>Vector Convenience</leadin> Square braces can now be
      used as a convenience syntax for vector indexing. They are
      <em>not</em> used for array indexing.
    </p>
    <p>
      <leadin>Type-Qualification Convenience</leadin> The
      <progident><em>expr</em>:<em>type</em></progident> syntax has
      returned, though note the restriction described in section <link
      href="spec.html#7.3">7.3</link> of the language
      specification.
    </p>
    <p>
      <leadin>Repr</leadin> The <progident>defrepr</progident> form is
      now defined, but is not implemented by this compiler (yet).
    </p>
  </sect1>
  <sect1>
    <title>Issues Resolved Since 0.9</title>
    <p>
      <leadin>Type Classes</leadin>
      Type classes are now partially implemented. The extent of a
      type class is the entire program. No type class can be
      instantiated twice over the same type relation.
      <progident>BitCC</progident> does not <em>yet</em> permit
      specialization overloading. For example, it is not possible
      (yet) to define a type class over
      <progident>(list&nbsp;'a)</progident> and later specialize it
      for <progident>(list&nbsp;char)</progident>.
    </p>
    <p>
      <leadin>Union Representation</leadin> The Cardelli-style
      representation optimizations described in section <link
      href="spec.html#3.6.2.2">3.6.2.2</link> of the specification is
      now implemented, however: we may decide to make them optional
      for runtime systems that cannot express them, notably the
      Microsoft <progident>.NET</progident> platform.
    </p>
    <p>
      <leadin><progident>int</progident> type</leadin> With the
      introduction of the Cardelli optimization and type classes, it
      is no longer necessary for the <progident>int</progident> type
      (arbitrary precision integers) to be part of the language
      definition. We would welcome an IP-unencumbered, BSD-licensed
      implementation of bignum division, or pointers to one (we can do
      it, but it's better to reuse one that works).
    </p>
    <p>
      <leadin><progident>case</progident> patterns</leadin> The
      <progident>case</progident> construct has gone away in favor of
      <progident>switch</progident>.
    </p>
    <p>
      <leadin>Closure Conversion</leadin> Closure conversion is now
      implemented, and the restrictions on inner
      lambdas are gone.
    </p>
    <p>
      <leadin>Stateless Interfaces</leadin> have been dropped in this
      version of the language specification.  This may be a mistake in
      the long term, but our sense is that BitC is already complex
      enough and there are other things that we want to visit before
      looking at this. Mark Miller and Jonathan Shapiro have been
      discussing some alternative approaches that may work just as
      effectively.
    </p>
  </sect1>
  <sect1>
    <title>Known Issues</title>
    <p>
      This is very much a ``draft zero'' compiler, and several things
      are completely or partially unimplemented in this compiler.
    </p>
    <p>
      <leadin>Mutual Tail Recursion</leadin> Section <link
      href="spec.html#10.1">10.1</link> of the specification requires
      proper tail recursion for statically resolvable calls within a
      single <progident>letrec</progident> form. This is not
      implemented by the current compiler. We hope that this will be
      implemented shortly.
    </p>
    <p>
      <em>This may have been fixed, but I cannot contact Swaroop at
      the moment to confirm.</em>
    </p>
    <p>
      <leadin>Value Polyinstantiation</leadin> Immunitable values of
      underspecialized polymorphic type will be multiply instantiated
      by the compiler. No BitC program can detect this, but it is
      potentially visible to runtime library extensions.
    </p>
    <p>
      <leadin>Initializer Order</leadin> There is a <em>major bug</em>
      in the compiler whose effect is that two interfaces may exploit
      forward declarations to create mutually recursive top-level
      initializers. This will lead to an invalid program. We have
      finally worked out how to specify the correct behavior, but
      implementing it requires a strictness analysis pass. We may or
      may not resolve this (ever) in the bootstrap compiler.
    </p>
    <p>
      <leadin>Quad Precision Floats</leadin> Quad precision floating
      point values are unimplemented.
    </p>
    <p>
      <leadin>Literals not Values</leadin> The "literals are not
      values" decision can lead to strange typings in the current
      implementation:
    </p>
<programlisting>
(define (add-one x)
  (+ x 1))
add-one: (forall (arith 'a) (fn ('a) 'a))

(define (add-one x)
  (let ((one 1))
    (lambda (x) (+ one x))))
add-one: (fn (int8) int8))
</programlisting>
    <p>
      The compiler is choosing a type arbitrarily, which it should
      only do when the choice is unambiguous.
    </p>
  </sect1>
  </article>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->
