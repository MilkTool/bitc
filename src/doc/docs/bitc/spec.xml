<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                  "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd"
[
<!ENTITY BitcVersion "0.11+">
]>
  <article id="bitc-spec-0.11" xmlns:xi="http://www.w3.org/2001/XInclude">
  <docinfo twocolumn="yes">
    <title>BitC (0.11 Transitional) Language Specification</title>
    <subtitle>Version &BitcVersion;</subtitle>
    <authorgroup>
      <author>
	<firstname>Jonathan</firstname>
	<surname>Shapiro</surname>
	<degree>Ph.D.</degree>
      </author>
      <affiliation>
	<orgname>The EROS Group, LLC</orgname>
      </affiliation>
    </authorgroup>
    <authorgroup>
      <author>
	<firstname>Swaroop</firstname>
	<surname>Sridhar</surname>
      </author>
      <author>
	<firstname>Scott</firstname>
	<surname>Doerrie</surname>
      </author>
      <affiliation>
	<orgname>Systems Research Laboratory</orgname>
	<address>Dept. of Computer Science</address>
	<address>Johns Hopkins University</address>
      </affiliation>
    </authorgroup>
    <pubdate>September 28, 2008</pubdate>
    <copyright>
      <year>2008</year> 
      <holder>Jonathan S. Shapiro</holder>
      <holder>Swaroop Sridhar</holder>
    </copyright>
    <legalnotice>
      <p indent="no">
	THIS SPECIFICATION IS PROVIDED ``AS IS'' WITHOUT ANY
	WARRANTIES, INCLUDING ANY WARRANTY OF MERCHANTABILITY,
	NON-INFRINGEMENT, FITNESS FOR ANY PARTICULAR PURPOSE, OR ANY
	WARRANTY OTHERWISE ARISING OF ANY PROPOSAL, SPECIFICATION OR
	SAMPLE.
      </p>
    </legalnotice>
    <categories>
      <category>dev/bitc</category>
    </categories>
    <synopsis>
      <p>Provisional specification for the BitC programming language.</p>
      <p>
        Version 0.11 is a transitional version that is working our
        the final surface syntax. This version of the language
        supports the old s-expression syntax and the new syntax
        simultaneously to ease transition.
      </p>
    </synopsis>
  </docinfo>
  <abstract latex.incolumn="yes" latex.breakafter="yes">
    <p>
      BitC is a systems programming language that combines the ``low
      level'' nature of C with the semantic rigor of Scheme or
      ML. BitC was designed by careful selection and exclusion of
      language features in order to support proving properties (up to
      and including total correctness) of critical systems programs.
    </p>
    <p>
      This document provides an English-language description of the
      BitC semantics. It will in due course be augmented by a formal
      specification of the BitC semantics. The immediate purpose of
      this document is to quickly capture an informal but fairly
      complete description of the language so that participants in
      ongoing discussions about verifiable systems programming
      languages have a common frame of reference on which to base
      their discussions.
    </p>
  </abstract>
  <toc/>
  <sect1>
    <title>Overview</title>
    <p>
      The BitC project is part of the successor work to the EROS
      system <cite ref="shap1999fastcapsystem"/>.  By 2004, it had
      become clear that a number of important practical ``systems''
      lessons had been learned in the EROS effort. These motivated a
      re-examination of the architecture. With the decision to craft a
      revised design and a new implementation came the opportunity to
      consider methods of achieving greater and more objective
      confidence in the security of the system. In particular, the
      question of whether a formally verified <em>implementation</em>
      of the EROS successor might be feasible with modern theorem
      proving tools.  Following some thought, it appeared that the
      answer to this question might be ``yes,'' but that there existed
      no programming language providing an appropriate combination of
      power, formally founded semantics, and control over low-level
      representation. BitC was created to fill this gap.
    </p>
    <sect2>
      <title>About the Language</title>
      <p>
	BitC is conceptually derived in various measure from Standard
	ML, and C. Like Standard ML <cite
	ref="milner1997definition"/>, BitC has a formal semantics,
	static typing, a type inference mechanism, and type variables.
	Like C <cite ref="ansi1999c"/>, BitC provides full control
	over data structure representation, which is necessary for
	high-performance systems programming. BitC also provides
	support for unboxed mutable locations.  The BitC language is a
	direct expression of the typed lambda calculus with side
	effects, extended to be able to reflect the semantics of
	explicit representation.
      </p>
      <p>
        Versions of BitC up to 0.10 used an s-expression syntax
        similar to that of Scheme <cite ref="kelsey1998r5rs"/>.  This
        allowed us to focus our attention on type inference and
        semantic issues first. The main goal of version 0.11 is to
        choose the production surface syntax for the language. For the
        sake of people who are already familiar with the s-expression
        syntax, this version of the specification includes
        <em>both</em> syntactic variants.
      </p>
      <p>
        The transitional syntax is testing a curried style of
	application syntax so that we can experiment with mixfix
	operators. In spite of this syntax, BitC application is not
	curried. Currying encourages the formation of closures that
	capture non-global state. This requires dynamic storage
	allocation to instantiate these closures at runtime, and it is
	difficult for the programmer to determine syntactically when
	this is happening. Since there are applications of BitC in
	which dynamic allocation is prohibited, currying is an
	inappropriate default idiom for this language. We will
	consider introducing explicit convenience syntax for curried
	application if this proves to be an impediment to effective
	use of the language.
      </p>
      <p>
	In contrast to both Scheme and ML, BitC does <em>not</em>
	provide or require full tail recursion. Procedure calls must
	be tail recursive exactly if the called procedure and the
	calling procedure are bound in the same
	<progident>def</progident>, and if the identity of the
	called procedure is statically resolvable at compile
	time. This restriction preserves all of the useful cases of
	tail recursion that we know about, while still permitting a
	high-performance translation of BitC code to C code.
      </p>
      <!-- <p> -->
      <!--   Building on the features of ACL2 <cite ref="kaufmann00acl2"/>, -->
      <!--   BitC incorporates explicit support for stating theorems and -->
      <!--   invariants about the program as part of the program's text. -->
      <!-- </p> -->
      <p>
	As a consequence of these modifications, BitC is suitable for
	the expression of verifiable, low-level ``systems'' programs.
	There exists a well-defined, statically enforceable subset
	language that is directly translatable to a low-level language
	such as C. This translation is direct in both the sense that
	the translation is simple and the result does not violate
	programmer intuitions about what the program does or the
	program's data representation. Indeed, this was a key reason
	for our decision to move our implementation efforts into BitC.
      </p>
    </sect2>
    <sect2>
      <title>Transitional Input Language</title>
      <p>
        We are in the process of migrating from the S-expression
        syntax to the final BitC surface syntax. S-expression forms
        are now being incrementally replaced by the corresponding
        block-style forms, and the compiler no longer accepts some of
        the older S-expression conventions. I am trying to update this
        document as the S-expression forms are retired.
      </p>
    </sect2>
    <sect2>
      <title>Conventions Used in This Document</title>
      <p>
	In the description of the language syntax below, certain
	conventions are used to render the presentation more compact.
      </p>
      <p>
	Input that is to be typed as shown appears in
	<progident>fixed</progident> font.
      </p>
      <p>
	Syntactic ``placeholders'' are shown in italics, and should
	generally be self-explanatory in context. Variable names,
	expressions, patterns, and types appear respectively as italic
	<em>v</em>, <em>e</em>, <em>p</em>, or <em>T</em>, with an
	optional disambiguating subscript. For clarity, the defining
	occurrence of a name will sometimes appear in the abstract
	syntax as <em>nm</em>.
      </p>
      <p>
	When a sequence of similar elements is permitted, this is
	shown using "...".  Such a sequence must have at least one
	element. For example:
      </p>
      <literallayout>
(begin <em>e</em> ... <em>e</em>)</literallayout>
      <p indent="no">
	indicates that the <progident>begin</progident> form takes a
	(non-empty) sequence of expressions. When it is intended that
	zero elements should be permitted in a sequence, the example
	will be written:
      </p>
      <literallayout>
(begin [<em>e</em> ... <em>e</em>])</literallayout>
      <p indent="no">
	Note that the square braces <b>[</b> and <b>]</b> have no
	syntactic significance in the BitC core language after
	s-expression expansion. When they appear in the specification,
	they should be read as metasyntax.
      </p>
    </sect2>
    <sect2>
      <title>Type Inference</title>
      <p>
	BitC incorporates a polymorphic type inference mechanism.
        Like SML, BitC imposes the value restriction for polymorphic
        type generalization. The algorithm for type inference is not
        yet specified here, and will be added at a future date &mdash;
        we want to be sure that it converges.  We currently plan to
        use a constraint-based type inference system similar to the
        Hindy-Milner type inference algorithm <cite
        ref="milner1997definition"/>.
      </p>
      <p>
	The practical consequence of type inference is that explicitly
	stated types in BitC are rare. Usually, it is necessary to
	specify types only when the inference engine is unable to
	resolve them unambiguously, or to specify that two expressions
	must have the same result type.  In this situation, a type may
	be written by appending a trailing type qualifier to an
	expression indicating its result type, as in:
      </p>
      <literallayout>
(a + b) : int32
(+ a b) : int32</literallayout>
      <p indent="no">
	by similarly qualifying a formal parameter, as in:
      </p>
      <literallayout>
def fact x =
  if (x &lt; 0) then - (fact (-x))
  else if (x == 0) then 1
  else x * fact (x - 1)

(def (fact x:int32)
  (cond ((&lt; x 0) (- (fact (- x))))
        ((= x 0) 1)
        (otherwise
          (* x (fact (- x 1))))))</literallayout>
      <p indent="no">
	In general, wherever a type is permitted by the grammar, it is
	also permissible to write a <term>type variable</term>. A type
	variable is written as an identifier prefixed by a single
	quote. The scope of a type variable is the scope of its
	containing definition form.  The type inference engine will
	infer the type associated with the type variable. Within a
	definition, all appearances of a type variable will be resolved
	to the same type. This is particularly useful in the
	specification of recursive types.  For historical reasons,
	<progident>'a</progident>, <progident>'b</progident>, etc. are
	often pronounced ``alpha,'' ``beta,'' and so forth.
      </p>
    </sect2>
    <sect2>
      <title>Documentation Strings</title>
      <p>
        Certain productions in the grammar (Section&nbsp;<xref
        ref="grammar"/>) incorporate an optional documentation string
        labeled
        <progident><em>docstring</em></progident>. Documentation
        strings have predefined syntactic positions to facilitate
        automated extraction by documentation tools. If present, the
        documentation string must be a syntactically well-formed
        string, but the string is otherwise ignored for compilation
        purposes. In certain contexts a documentation string may be
        followed by an expression syntax, which creates a parse
        ambiguity. The parser should handle these cases by accepting
        the expression sequence and then checking to see if it has
        length greater than 1 and its first element is a string. Note
        that in such cases the string would be semantically irrelevant
        in any case. The only point of care here is to note that an
        expression sequence consisting of a single string is a value,
        not a documentation string.
      </p>
    </sect2>
  </sect1>
  <subpart>
    <title>The Core Language</title>
    <sect1>
      <title>Input Processing</title>
      <p>
	The BitC surface syntax is an impure s-expression
	language. Expressions can be augmented with type qualifiers,
	and the language provides syntactic conveniences for field
	reference and array indexing. All of these have canonicalizing
	rewrites into s-expressions.
      </p>
      <p>
        Input units of compilation are defined to use the Unicode
        character set as defined in version 4.1.0 of the Unicode
        standard <cite ref="unicode410"/>. Input units must be encoded
        using the UTF-8 encoding and Normalization Form C.  All
        keywords and syntactically significant punctuation fall within
        the 7-bit US-ASCII subset, and the language provides for 7-bit
        US-ASCII encodable ``escapes'' that can be used to express the
        full Unicode character code space in character and string
        literals.
      </p>
      <p>
        Tokens are terminated by white space if not otherwise
        terminated. For purposes of input processing, the characters
        <em>space</em> (U+0020), <em>tab</em> (U+0009), <em>carriage
        return</em> (U+000D), and <em>linefeed</em> (U+000A) are
        considered to be white space.
      </p>
      <p>
        Input lines are terminated by a linefeed character (U+000A), a
        carriage return (U+000D) or by the two character sequence
        consisting of a carriage return followed by a line feed.  This
        is primarily significant for comment processing, layout
        processing, and diagnostic purposes, as the rest of the
        language treats linefeeds carriage returns as white space
        without further significance.
      </p>
      <sect2>
	<title>Comments</title>
	<p>
          A comment introduced by the two-character sequence "//"
	  extends up to but not including the trailing newline and/or
	  carriage return of the current line (the end of line markers
	  are significant for purposes of line numbering).
        </p>
        <p>
          A comment introduced by the two-character sequence "/*"
          extends up to the following two-character sequence "*/".
          If an end-of-line sequence is encountered within the
          comment, the next token encountered after the comment is
          considered the first token on a new line.
        </p>
        <p>
          For lexical purposes, comments are considered white space.
          This implies that the comment syntax cannot be successfully
          exploited for identifier splicing as in early C
          preprocessors.
	</p>
        <p>
          Characters within comments are processed only to determine
          where the comment ends. Nested comments are not supported.
        </p>
      </sect2>
      <sect2 id="identifiers">
	<title>Identifiers</title>
	<p>
          Because of BitC's support for user-defined expression syntax
          (mixfix), the definition of a well-formed identifier is
          regrettably more complicated than in most languages.
          We
          begin by defining three lexical classes:
        </p>
        <ul>
          <li>
            <p>
              Any sequence of code points beginning with an
              ``identifier character'' (Unicode 4.1.0 <cite
                ref="unicode410"/> character class XID_Start), followed
              by any number of optional ``identifier continue
              characters'' (Unicode 4.1.0 character class
              XID_Continue) is a <em>alphanumeric identifier fragment</em>.
            </p>
          </li>
          <li>
            <p>
              Any sequence of the following characters is a valid
              <em>operator identifier fragment</em>:
            </p>
            <literallayout>
! $ % &amp; * + - / &lt; = &gt; ? ^ | ~</literallayout>
          </li>
          <li>
            <p>
              An underscore (U+005F, ``_''), sharp underscore (U+005F
              U+0023, ``#_''), or the at-sign (U+0040, ``@'') is a
              valid <em>separator</em>.
            </p>
          </li>
        </ul>
        <p>
          A well-formed identifier matches the regular expression:
        </p>
        <literallayout>
<b>_</b><sup>*</sup>(<b>#_</b>)<sup>?</sup><em>fragment</em>((<b>_</b>|<b>#_</b>|<b>@</b>)<em>fragment</em>)<sup>*</sup>(<b>#_</b>|<b>_</b>)<sup>?</sup></literallayout>
        <p indent="no">
          that is: a sequence of alphanumeric or punctuation fragments
          that are joined by separators with an optional leading and
          trailing separator, with the whole optionally preceded by an
          arbitrary number of underscores. Each fragment is either an
          alphanumeric or a punctuation sequence.
        </p>
        <p>
          Identifiers are case sensitive.  Reserved words are not
          identifiers.  Identifiers starting with <em>two or more</em>
          leading underscores (U+005F, ``_'') are reserved for use by
          the runtime system.  Non-reservedIdentifiers are valid for
          use as mixfix identifiers.
        </p>
        <p>
          The sheer perverse obscurity of the specification for
          identifiers is motivated by mixfix support, and will
          hopefully make more sense after a review of that section.
        </p>
      </sect2>
      <sect2 id="if-identifiers">
	<title>Interface Names and Identifiers</title>
	<p>
          Interface names consist of a sequence of interface
	  identifiers joined by dots (``.'').  
          An interface may start with any interface identifier
	  character, followed by any interface continue character. In
	  addition, an underscore (``_'') may appear in any position
	  of an interface identifier, and a hyphen (``-'') may be used
	  in any position <em>other than</em> the first position.
        </p>
        <p>
	  Interface identifier characters are the Unicode identifier
	  characters (Unicode 4.1.0 <cite ref="unicode410"/> character
	  class XID_Start) falling within the 7-bit US ASCII subset
	  (the first 128 Unicode code points). Interface continue
	  characters are similarly the Unicode identifier continue
	  characters (Unicode 4.1.0 <cite ref="unicode410"/> character
	  class XID_Continue) falling within the 7-bit US ASCII
	  subset.
        </p>
        <p>
          The restriction on acceptable character code points in interface
	  identifiers is designed to ensure that interface names can
	  be mapped directly to file names in current file systems. It
	  is expected that the legal namespace for interface
	  identifiers will expand as the capabilities of widely used
	  file system interfaces improve.
        </p>
	<p>
          Interface names whose leading interface identifier is
	  ``bitc'' are reserved for use by the BitC runtime system and
	  standard library.
	</p>
	<p>
          Reserved words are <em>permitted</em> as interface
          identifiers.
	</p>
        <p>
          While BitC treats interface identifiers as case-sensitive,
          it is <em>strongly discouraged</em> for source code to rely
          solely on case distinctions to discriminate between
          interface names. The choice of legal interface identifiers
          is intentionally chosen to support a direct mapping to file
          names across a wide range of file systems. At least one
          pervasively used file system provides only haphazard support
          for case sensitivity in file names.
        </p>
      </sect2>
      <sect2>
	<title>Reserved Words</title>
	<p>
	  The following identifiers are syntactic keywords, and may not
	  be rebound:
	</p>
	<literallayout indent="no">
-&gt;         and           apply         
array         ArrayRef      as            
begin         bitc          bitfield      
block         bool          boxed         
ByRef         case          catch         
char          cond          const         
continue      declare       def           
defaxiom      definvariant  deftheory     
defthm        exception     deref         
disable       do            double        
dup           enable        exception     
extends       external      false         
fill          fixint        float         
from          if            import        
impure        in            instance      
int8          int16         int32         
int64         interface     is            
fn            lambda        let           
letrec        MakeVector    member        
mutable       not           object        
opaque        or            otherwise     
pair          proclaim      provide       
pure          quad          repr          
return        set!          sizeof        
string        struct        suspend       
switch        tag           the           
throw         trait         try           
true          tyfn          uint8         
uint16        uint32        uint64        
unboxed       union         use           
vector        version       where         
until         word</literallayout>
	<p>
	  The following identifiers are reserved for use as future
	  keywords:
	</p>
	<literallayout indent="no">
assert        break         check         
coindset      constrain     deep-const    
defequiv      object     defrefine     
deftype       defvariant    do*           
import!       indset        inner-ref     
int           let*          list          
location      module        namespace     
read-only     require       ref           
sensory       super         tycon         
using         value-at</literallayout>
	<p>
          In addition to the reserved words identified above, all
	  definitions provided in the standard prelude are implicitly
	  imported into the initial top-level environment of every
	  compilation unit. 
	</p>
	<p>
	  Note that BitC does <em>not</em> permit redefinition of
	  bound variables in the same scope. This guarantees that
	  top-level forms receive the default bindings of these
	  identifiers in their environment.
	</p>
	<p>
	  For the moment, all identifiers beginning with
	  ``<progident>def</progident>'' are reserved words. This
	  restriction is a temporary expedient that is not expected to
	  last in the long term.
	</p>
	<p indent="no">
	  Finally, the identifiers defined as part of the BitC standard
	  runtime environment (described below) are bound in the
	  top-level environment.
	</p>
      </sect2>
      <sect2>
	<title>Literals</title>
        <p>
          The handling of literal input and output is implemented by
          the standard prelude functions <progident>read</progident>
          and <progident>show</progident>. Source tokenization,
          requires that foundational literals have a defined canonical
          form.
        </p>
<!-- 	<sect3> -->
<!-- 	  <title>Boolean Literals</title> -->
<!-- 	  <p> -->
<!-- 	    The boolean literals are <progident>false</progident> and -->
<!-- 	    <progident>true</progident>, respectively denoting false and -->
<!-- 	    true. -->
<!-- 	  </p> -->
<!-- 	</sect3> -->
	<sect3 id="intlit">
	  <title>Integer Literals</title>
	  <p>
            An integer literal takes one of the following forms:
	  </p>
	  <literallayout>
<em>decimal digits</em>  // decimal integer literal
0x<em>hex digits</em>  // hexadecimal integer literal
0o<em>octal digits</em>  // octal integer literal
0b<em>binary digits</em>  // binary integer literal
0<em>octal digits</em>  // octal integer literal</literallayout>
	  <p indent="no">
            A decimal integer literal may not begin with a leading
            zero.  <em>Digits</em> are selected from the characters
	  </p>
	  <literallayout>
0 1 2 3 4 5 6 7 8 9 a b c d e f</literallayout>
	  <p indent="no">with the customary hexadecimal valuations. The
	    letters may appear in either lowercase or uppercase. It is
	    an error for a digit to be present whose value as a digit is
	    greater than or equal to the specified base.
	  </p>
	  <p>
	    Integer literals of a particular fixed-precision type may be
	    written by using a type qualifier. The expression:
	  </p>
	  <literallayout>
564 : uint32</literallayout>
	  <p indent="no">
	    specifies an unsigned 32 bit quantity whose value is
	    564. It is a compile-time error to qualify an integer
	    literal with a type that is incapable of representing the
	    literal's value.  In the absence of explicit
	    qualification, the type assigned to an integer literal
	    will be some subset of:
	  </p>
          <literallayout>
int8  int16  int32  int64
uint8 uint16 uint32 uint64
word</literallayout>
          <p indent="no">
            Any concrete type that cannot represent the literal value
            will be omitted from the set of types
            assigned.<footnote><p>There is an issue here: doesn't the
            initial set need to be the set of all integer field sizes
            so that initialization can work? Shap thinks that the
            answer is probably yes, but that it isn't a problem in
            practice because the arithmetic operators are only defined
            over homogeneous argument types. Swaroop points out that
            expanding the set isn't what creates the problem for type
            inference.</p></footnote>
          </p>
	</sect3>
	<sect3 id="floatlit">
	  <title>Floating Point Literals</title>
	  <p>
	    The general form of a floating point literal is:
	  </p>
	  <literallayout>
<em>digits</em><b>.</b><em>digits</em>[<b>e</b>[<b>-</b>]<em>exponent</em>]</literallayout>
	  <p indent="no">
	    where all digits are decimal. Floating point values may
	    not have any radix other than 10. The <em>exponent</em>
	    may include an optional initial minus sign. Note that the
	    decimal point is not optional, and must have at least one
	    digit on both sides. Thus, <progident>0.0</progident> is a
	    valid floating point literal, but
	    <progident>0.</progident> and <progident>.0</progident>
	    are not. Also <progident>1e11</progident> is not a valid
	    floating point literal; <progident>1.0e11</progident>
	    should be used instead.
	  </p>
	  <p>
	    As with integer literals, floating point literals of an
	    explicitly stated representation type may be written using a
	    type qualifier. The expression:
	  </p>
	  <literallayout>
0.0 : float</literallayout>
	  <p indent="no">
	    specifies a 32-bit (single precision) IEEE floating point
	    quantity whose value is zero. As with integer literals, it
	    is a compile-time error to specify a value cannot be
	    represented within the representable range of the
	    qualifying type.<footnote><p>It is <em>not</em> an error
	    if conversion of the literal value causes loss of
	    precision in the low-order bits of the mantissa.</p>
	    </footnote> In the absence of explicit
	    qualification, the type of a floating point literal is
	    some subset of:
          </p>
          <literallayout>
float double quad</literallayout>
          <p indent="no">
            Any concrete type whose representable range cannot express
            the literal value will be omitted from the assigned set.
          </p>
          <p>
            Conversion of a floating point literal to internal
	    representation follows the customary IEEE floating point
	    rounding rules when the specified literal cannot be
	    exactly represented.<footnote><p>A more precise statement
	    is needed for floating point literal conversion, but I
	    don't know enough about floating point conventions to know
	    what that statement should be.</p>
            </footnote>
          </p>
	</sect3>
	<sect3 id="charlit">
	  <title>Character Literals</title>
	  <p>
	    BitC uses the Unicode character set as defined in version
	    4.1.0 of the Unicode standard <cite
	    ref="unicode410"/>. Characters are 32 bits wide.
	    Character literals can be expressed in two ways.
	  </p>
	  <p>
	    A character literal may be written as
	  </p>
	  <literallayout>
'<em>printable-character</em>'</literallayout>
	  <p>
	    Where <progident><em>printable-character</em></progident>
            is any character specified in the Unicode 4.1.0 standard
            <em>except</em> those with general categories "Cc"
            (control codes) "Cf" (format controls), "Cs" (surrogates),
            "Cn" (unassigned), or "Z" (separators).  That is, any
            printable character, excluding spaces.  Notwithstanding
            the listed Unicode categories, the characters ``\''
            (U+005C) and single quote (U+0027) are excluded, and the
            character ``space'' (U+0020) is considered printable.
	  </p>
	  <p>
            An arbitrary character may also be specified numerically
	    in one of the following forms:
	  </p>
	  <literallayout>
'\U+<em>hex digits</em>'  // unicode code point
'\<em>decimal digits</em>'  // unicode code point expressed in decimal
'\0x<em>hex digits</em>'  // unicode code point expressed in hexadecimal
'\0o<em>octal digits</em>'  // unicode code point expressed in octal
'\0b<em>binary digits</em>'  // unicode code point expressed in binary
'\0<em>octal digits</em>'  // unicode code point expressed in octal</literallayout>
	  <p indent="no">
	    The value supplied
	    must be a valid unicode code point, which is a value in
	    the range 0..10FFFF hexadecimal.
	  </p>
	  <p>
	    Certain commonly used non-printing characters have
	    convenience representations as character literals:
	  </p>
	  <literallayout>
'\space', '\s'
'\linefeed', '\n'
'\return', '\r'
'\tab', '\t'
'\backspace', '\b'
'\formfeed', '\f'
'\backslash', '\\'
'\squote', '\''
'\dquote', '\"'</literallayout>
	</sect3>
	<sect3 id="stringlit">
	  <title>String Literals</title>
	  <p>
	    BitC strings are written within double quotes, and may
	    contain the previously listed ``printable characters''
	    <em>excluding</em> backslash ``\'' (U+005C), or the double quote
	    character.
	  </p>
	  <p>
	    Within a string, the backslash character ``\'' (U+005C) is
	    interpreted as beginning an encoding of an escaped
	    character. The character following the ``\'' (U+005C) is
	    either a single-character embedding from the list given
	    above, or a curly brace character ``{'' (U+007B)
	    identifying the start of a numeric or named embedding that
	    is terminated by ``}'' (U+007D).
          </p>
	</sect3>
      </sect2>
      <sect2>
	<title>Compilation Units</title>
        <p>
          There are two types of compilation units in BitC: interfaces
          and source compilation units. An interface compilation unit
          defines or declares types (and consequently the code of type
          constructors), defines type classes, defines constants, and
          declares values. A source compilation unit can define types,
          type classes, constants, and values.
        </p>
	<p>
	  Every valid BitC compilation unit must begin
          (ignoring comments) with a
          <progident>bitc version</progident> form.  The syntax of the
          <progident>bitc version</progident> form is:
	</p>
	<literallayout>
 bitc version <em>n.m</em></literallayout>
	<p indent="no">
	  where <progident><em>n.m</em></progident> is the version
	  of BitC version (major <em>dot</em> minor) to which this program
	  conforms. For the version of BitC described in this
	  document, the proper version is
	  <progident>&BitcVersion;</progident>. It is a compile-time
	  error if the language version accepted by the current
	  compiler is not backwards compatible with the version
	  specified by the <progident>bitc version</progident> form.
	</p>
        <p>
          In an interface compilation unit, the 
          <progident>bitc version</progident> form is followed by
          exactly one <progident>interface</progident> form
          (Section&nbsp;<xref ref="Interfaces"/>).  In a source
          compilation unit, the optional
          <progident>bitc version</progident> form is followed by one
          or more <progident>module</progident> forms (Section <xref
          ref="Interfaces"/>).
        </p>
        <p>
          A source compilation unit may alternatively consist of the
          <progident>bitc version</progident> form followed
          by an arbitrary sequence of imports, definitions,
          declarations, and use forms that are <em>not</em>
          <progident>interface</progident> forms. In this case the
          forms following the <progident>bitc version</progident> are
          deemed to be implicitly enclosed by a
          <progident>module</progident> form, and the compilation unit
          defines exactly one source module.
        </p>
        <sect3>
          <title>Definitions and Declarations</title>
          <p>
            The top level forms that introduce programmatic
            definitions and declarations are:
          </p>
          <literallayout>
def       instance  repr
struct    trait     union  
proclaim
use</literallayout>
          <p>
            The <progident>def</progident>,
            <progident>union</progident>,
            <progident>repr</progident>, and
            <progident>struct</progident> forms support simple
            recursion. That is, the identifier(s) being defined may be
            used in their definition. However, the identifier(s) being
            defined are deemed incomplete until the end of the
            enclosing defining form. Restrictions on the use of
            incomplete identifiers are described in the sections on
            types and value binding.
          </p>
          <p>
            The <progident>proclaim</progident> form is used to
            provide opaque value declarations. The identifier declared
            by a <progident>proclaim</progident> form is considered
            incomplete. If a completing definition is later provided
            within the same compilation unit, the identifier is
            considered complete in the balance of the defining
            compilation unit after the the close of its defining form.
            An incomplete declaration may be used within a procedure,
            but may not be used as part of a top-level initializer
            (see <progident>def</progident>, Section&nbsp;<xref ref="def"/>).
          </p>
          <p>
            The <progident>use</progident> form is used to provide
            an alternative identifier that is equivalent in all
            respects to some existing top-level identifier.
          </p>
          <p>
            All definition forms are expressions that return a
            value of type <b>unit</b>.
          </p>
        </sect3>
      </sect2>
      <sect2 id="layout">
	<title>Layout</title>
        <p>
          The goal of the layout system is to provide programmer
          convenience by automatically inserting curly braces and
          semicolons wherever they have not been inserted by the
          programmer.  Left curly braces are conditionally inserted
          after certain preceding tokens. Semicolons are conditionally
          inserted based on the indentation level of each line. Right
          curly braces are conditionally inserted before certain
          tokens and also based on the indentation level of the curren
          tline.
        </p>
        <sect3 id="layout:concept">
          <title>Concept</title>
          <p>
            The ``trick'' to the layout scheme is in two parts:
          </p>
          <ol>
            <li>
              <p>
                There are several sequencing constructs in the language whose
                general form is a semicolon-separated sequence of things
                surrounded by curly braces. This lets us use the same layout rules
                for multiple purposes.
              </p>
            </li>
            <li>
              <p>
                At each point where a left curly brace  might be automatically
                inserted, a preceding token (one of
                <progident>let</progident>,
                <progident>do</progident>, or
                ``<progident>=</progident>'')
                signals unambiguously that a left
                curly brace must follow:
              </p>
              <literallayout>
def f x y = <b>{</b> ...
def x = <b>{</b> 5 <b>}</b>
struct S 'a 'b = <b>{</b> a : int; ...
let <b>{</b> x = <b>{</b> 5 <b>}</b> <b>}</b> in <b>{</b> ...
while (<em>expr</em>) do <b>{</b> ...
do <b>{</b> ... <b>}</b> while (<em>expr</em>)</literallayout>
            </li>
          </ol>
          <p>
            We rely on the fact that (a) knowing the preceding and
            current token is enough to know whether to insert a curly
            brace (b) because blocks are values, all binding expressions
            can safely be wrapped in blocks, (c) because such wrapping
            is always safe, it can be done in a way that is invisible to
            the programmer In fact, the parser insists that this be
            true. While it is nearly universal practice in Bitc to write
            code without semicolons in many places, most notably:
          </p>
          <literallayout>
let x = 5 in <em>body</em></literallayout>
          <p indent="no">
            But what the compiler actually <em>sees</em> is:
          </p>
          <literallayout>
let { x = { 5 } } in <em>body</em></literallayout>
          <p>
            We also rely on the fact that correct programs do not
            under-indent lines capriciously.
          </p>
        </sect3>
        <sect3 id="layout:specification">
          <title>Specification</title>
          <ul>
            <li>
              <p>
                The term <em>offset</em>, as used here, is defined as
                the number of preceding UCS4 code points that occur to
                the left of the token on the same line. The first code
                point on a line is deemed to have offset zero. Offsets
                are determined without regard to comments. That is,
                in:
              </p>
              <literallayout>
a b c /*
 */ x</literallayout>
              <p indent="no">
                the token <tt>x</tt> appears at offset 5 and is the
                first token on
                its line.
              </p>
            </li>
            <li>
              <p>
                The term <em>layout item sequence</em> is a sequence
                of layout items that are separated by semicolons and
                surrounded (bracketed) by curly braces. An opening '{'
                signals the beginning of a layout item sequence.
              </p>
            </li>
            <li>
              <p>
                A left curly brace will be automatically inserted
                after the keywords <b>let</b>, <b>do</b>, and <b>=</b>
                (binding) if none appears explicitly in the
                input. Note that a left curly brace is required by the
                grammar at each of these positions.
              </p>
            </li>
            <li>
              <p>
                The lexer maintains a record of every left curly brace
                (whether or not inserted), in a stack of layout
                contexts. Each entry records the preceding keyword
                (<b>let</b>, <b>do</b>, or <b>=</b>), whether the left
                curly brace in question was automatically inserted or
                not, and the offset of that layout context. The most
                recent entry on the layout context stack is ``popped''
                whenever an implicit or explicit '}' is encountered.
              </p>
            </li>
            <li>
              <p>
                On encountering the <b>in</b> token, the lexer will
                insert implicit close braces ('}'), popping layout
                contexts as it goes, until one of the following
                conditions holds:
              </p>
              <ol>
                <li>
                  <p>
                    The last layout context popped was associated with
                    the <b>let</b> keyword. That is: curly braces
                    inserted before <b>in</b> will only balance up to
                    the nearest preceding <b>let</b>.
                  </p>
                </li>
                <li>
                  <p>
                    The top entry on the context stack was
                    explicit. That is: implicit closing curly braces
                    will only balance implicit open curly braces.
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                On encountering end-of-file, the lexer will insert
                implicit close braces ('}'), popping layout contexts
                as it goes, until the top entry on the context stack
                is explicit.
              </p>
            </li>
            <li>
              <p>
                Every (implicit or explicit) '{' begins a layout item
                sequence. After processing the '{', the lexer examines
                the next token. If it is end-of-file or <b>in</b>,
                processing proceeds as described above. Otherwise:
              </p>
              <ul>
                <li>
                  <p>
                    If the offset of the token is <em>greater
                    than</em> the current sequence offset, it becomes
                    the current sequence offset and is recorded in the
                    top (most recent) layout context stack
                    entry. Regardless of offset, no implicit semicolon
                    will be inserted before this token.
                  </p>
                </li>
                <li>
                  <p>
                    If the offset of the token is <em>less than or
                    equal to</em> the current sequence offset, and the
                    most recent open brace was implicit, an implicit
                    close brace is immediately inserted.
                  </p>
                </li>
              </ul>
            </li>
            <li>
              <p>
                Provided it does not follow an opening brace, the
                offset of the first token on every line is used to
                determine whether a closing curly brace '}' or a
                semicolon should be conditionally inserted as follows:
              </p>
              <ul>
                <li>
                  <p>
                    If the offset of the token is <em>greater
                    than</em> the current sequence offset,
                    or if the
                    last character on the preceding line is ``\''
                    (signalling that the line is continued),
                    nothing is inserted.
                  </p>
                </li>
                <li>
                  <p>
                    If the offset of the token is <em>less than</em>
                    the current sequence offset, and the most recent
                    open brace was implicit, an implicit close brace
                    is immediately inserted.
                  </p>
                </li>
                <li>
                  <p>
                    If the offset of the token is <em>equal to</em>
                    the current sequence offset, is not a semicolon
                    (';'), and the most recently returned token was
                    not a semicolon, a semicolon is automatically
                    inserted.
                  </p>
                </li>
              </ul>
            </li>
            <li>
              <p>
                An implicit '{' must be matched by an implicit
                '}'. Similarly, an explicit '{' must be matched by an
                explicit '}'. If this requirement is violated, an
                error is signalled.
              </p>
            </li>
          </ul>
        </sect3>
      </sect2>
    </sect1>
    <sect1>
      <title>Types</title>
      <p>
	BitC provides explicit control over data structure
	representation while preserving a memory-safe and type-safe
	language design.
      </p>
      <sect2>
        <title>Categories of Types</title>
        <p>
          BitC has two categories of types: value types and reference
          types.
        </p>
        <p>
          A value type is one whose value representation is
          ``embedded'' in the representation of its containing
          composite type or stack frame. The lifetime of an instance
          of value type is determined by the lifetime of its
          container, and it is the responsibility of the container
          to allocate storage for its contained value types.
        </p>
        <p>
          A reference type is a type whose value representation
          resides in the heap. Every instance of a reference type has
          at least one reference value that denotes it. The
          <em>reference</em> is a value type; the value
          <em>denoted</em> by the reference is a reference type.
        </p>
        <p>
          If <progident><em>T</em></progident> is a value type, then
          <progident>(ref&nbsp;<em>T</em>)</progident> is the type of
          a reference denoting a heap-allocated instance of
          <progident><em>T</em></progident>. Similarly, if
          <progident><em>T</em></progident> is a reference type, then
          <progident>(val&nbsp;<em>T</em>)</progident> is the
          corresponding value type. The <progident>val</progident>
          type constructor can only be applied to reference types
          whose target is of statically known size. Storage for a
          value of value type is allocated from its containing type.
        </p>
        <p>
          BitC does not provide automatic assignment conversion
          between value types and reference types.
        </p>
      </sect2>
      <sect2>
	<title>Primary Types</title>
	<p>
	  The primary types of BitC are:
	</p>
	<deflist>
	  <defli>
	    <label><term>unit</term></label>
	    <li>
	      <p>
                The unit type, having as its singleton member the unit
		value, both of which are written as
		<progident>()</progident>.<footnote><p>Note that
		<term>unit</term> is not a keyword.</p>
		</footnote>
              </p>
	    </li>
	  </defli>
 	  <defli>
 	    <label><term>bool</term></label>
 	    <li>
 	      <p>
                 A boolean value, either <progident>false</progident> or
 		<progident>true</progident>. The representation of this
 		type is a single byte, aligned at a byte boundary.
               </p>
 	    </li>
 	  </defli>
 	  <defli>
 	    <label><term>char</term></label>
 	    <li>
 	      <p>
                A unicode code point. The representation of this type
 		is a 32-bit unsigned integer, aligned at a 32-bit boundary.
               </p>
 	    </li>
 	  </defli>
 	  <defli>
 	    <label><term>word</term></label>
 	    <li>
              <p>
                The type <progident>word</progident> is the smallest
                unsigned integral type whose range of values is
                sufficient to represent the bit representation of a
                pointer on the underlying machine. This type is
                architecture dependent, and is <em>not</em> directly
                assignment compatible with unsigned integral types of
                the same size. Values of type
                <progident>word</progident> are aligned at a boundary
                that is a multiple of their size.
               </p>
 	    </li>
 	  </defli>
<!-- 	  <defli> -->
<!-- 	    <label><term>fixint</term></label> -->
<!-- 	    <li> -->
<!-- 	      <p> -->
<!-- 		The <progident>fixint</progident> form describes a -->
<!-- 		fixed-precision integer field: -->
<!-- 	      </p> -->
<!-- 	      <literallayout> -->
<!-- (fixint <em>size</em> <em>align</em> <em>signed</em>) -->
<!-- </literallayout> -->
<!-- 	      <p indent="no"> -->
<!--                 Legal values for <em>align</em> are 8, 16, 32, and -->
<!--                 64. The value of <em>size</em> must be less than or -->
<!--                 equal to the value of <em>align</em>. The value of -->
<!--                 <em>signed</em> must be either false or true. The arguments -->
<!--                 to the <progident>fixint</progident> form must be -->
<!--                 literals. Type equivalence for -->
<!--                 <progident>fixint</progident> types is determined -->
<!--                 structurally: two appearances of a -->
<!--                 <progident>fixint</progident> form having the same -->
<!--                 values for <em>size</em>, <em>align</em>, and -->
<!--                 <em>signed</em> denote the same type. -->
<!-- 	      </p> -->
<!-- 	      <p>The form</p> -->
<!-- 	      <literallayout> -->
<!-- (fixint 4 32 true) -->
<!-- </literallayout> -->
<!-- 	      <p indent="no"> -->
<!-- 		describes a two's complement four bit field placed -->
<!-- 		within a 32-bit alignment frame. The type -->
<!-- 		<progident>int32</progident> is internally defined as -->
<!-- 	      </p> -->
<!-- 	      <literallayout> -->
<!-- (fixint 32 32 true) -->
<!-- </literallayout> -->
<!-- 	    </li> -->
<!-- 	  </defli> -->
	  <defli>
	    <label><term>bitfield</term></label>
	    <li>
	      <p>
		The <progident>bitfield</progident> form describes a
		fixed-precision integer field:
	      </p>
	      <literallayout>
(bitfield <em>basetype</em> <em>size</em>)</literallayout>
	      <p indent="no">
                Where <progident><em>basetype</em></progident> is one
                of the primary fixed-precision integral types and
                <progident><em>size</em></progident> is a literal
                not exceeding the size in bits of the base type.
              </p>
	      <p>
                The form
              </p>
	      <literallayout>
(bitfield int32 4)</literallayout>
	      <p indent="no">
		describes a two's complement four bit field placed
		within a 32-bit alignment frame.
	      </p>
              <p>
                Bitfields may only be used as types of structure,
                union, or tag fields. The type of a bitfield is deemed
                to be assignment and binding compatible with its
                <em>basetype</em>. A bitfield over a signed base type
                is sign-extended as needed when copying to its base
                type. A bitfield over an unsigned base type is zero
                extended.
	      </p>
	    </li>
	  </defli>
          <defli>
            <label><term>float, double, quad</term></label>
	    <li>
	      <p>
		The types <progident>float</progident>,
		<progident>double</progident>, and
		<progident>quad</progident> describe, respectively,
		IEEE floating point values as described in <cite
		  ref="ieee1985std754"/><cite ref="ieee1987std854"/>.
                The <progident>quad</progident> type is an extended
		precision floating point type with a 15 bit exponent
		and a 112 bit mantissa.
	      </p>
	    </li>
	  </defli>
	</deflist>
      </sect2>
      <sect2>
	<title>Simple Constructed Types</title>
	<p>
          Constructed types compose existing types into new
          types. Type equivalence for the simple constructed types is
          determined by structural equivalence.
	</p>
	<sect3>
	  <title>Reference Types</title>
	  <p>
            If <progident><em>T</em></progident> is a value type, then
          </p>
          <literallayout>
(ref <em>T</em>)</literallayout>
          <p indent="no">
            is the type of a reference denoting a heap-allocated
            instance of <progident><em>T</em></progident>.
	  </p>
	  <p>
	    <leadin>Storage Layout</leadin> The representation of a
	    <progident>ref</progident> instance is architecture
	    dependent. It is customarily determined by the size of the
	    machine's integer registers, and aligned at any address
	    that is congruent mod 0 to the integer register size.
	  </p>
	</sect3>
	<sect3>
	  <title>Function Types</title>
	  <p>
	    If <progident><em>t<sub>arg</sub></em></progident> and
	    <progident><em>t<sub>result</sub></em></progident> are
	    types (including type variables), then:
	  </p>
	  <literallayout>
(fn <em>t<sub>arg_1</sub></em>...<em>t<sub>arg_n</sub></em> -&gt; <em>t<sub>result</sub></em>)</literallayout>
	  <p indent="no">
	    is the type of a function taking <em>n</em> arguments of
	    types <em>t<sub>arg1</sub></em> through
	    <em>t<sub>argn</sub></em>, respectively, and returning a
	    value of type
	    <progident><em>t<sub>result</sub></em></progident>. The
	    type of a
	    function taking zero arguments is written as:
          </p>
	  <literallayout>
(fn -&gt; <em>t<sub>result</sub></em>)</literallayout>
          <p>
            Function types are considered reference types that denote
            an object of statically undefined size. The size and
            alignment of a value of function type is determined by the
            underlying processor architecture.
          </p>
	</sect3>
      </sect2>
      <sect2>
        <title>Sequence Types</title>
        <p>
          BitC provides fixed-length (<progident>array</progident>)
          and variable-length (<progident>vector</progident>) types.
        </p>
        <sect3 id="type:array">
	  <title>Arrays</title>
	  <p>
            An array is a value type whose value is a fixed
            product type
            <progident><em>T</em><sup><em>i>0</em></sup></progident>,
            all of whose elements are of common type. The type:
	  </p>
	  <literallayout>
(array <em>T</em> <em>i</em>)</literallayout>
          <p indent="no">
            describes the type of fixed-length arrays of element type
            <progident><em>T</em></progident> and length
            <progident><em>i</em></progident>, where
            <progident><em>i</em></progident> is an integer literal of
            type <progident>word</progident> that is greater than
            zero.
          </p>
	  <p>
	    <leadin>Storage Layout</leadin> The value representation
	    of a <em>k</em>-element array is laid out in memory as the
	    concatenation of <em>k</em> contiguous element cells whose
	    size and alignment are determined by their respective
	    element types. The elements of the array appear at
	    increasing addresses in order from left to right.
	  </p>
	</sect3>
	<sect3>
	  <title>Vectors</title>
	  <p>
            A vector is a dynamically sized array whose elements are
            of type <progident><em>T</em></progident>. Vectors are
            reference types. Because they are dynamically sized, there
            is no corresponding value type. The type:
	  </p>
	  <literallayout>
(vector <em>T</em>)</literallayout>
	  <p>
	    describes vectors of element type
	    <progident><em>T</em></progident>. 
	  </p>
	</sect3>
        <sect3 id="type:ArrayRef">
	  <title>Array References</title>
          <p>
            An array reference is a sequence type whose elements are
            of type <progident><em>T</em></progident> and whose length
            is dynamic. A parameter or let binding of type
            <progident>(ArrayRef&nbsp;<em>T</em>)</progident> will
            accept as its corresponding actual parameter or
            initializer a value of either type
            <progident>(ArrayRef&nbsp;<em>T</em>)</progident> or type
            <progident>(array&nbsp;<em>T</em>&nbsp;<em>len</em>)</progident>
            for <em>any</em> length. There is no value constructor for
            array reference types.
          </p>
          <p>
            Array references are not permitted to escape. Pending
            definition of a standardized escape analysis for BitC, the
            <progident>ArrayRef</progident> type is not permitted as
            the return value of a procedure, a non-value expression, a
            structure field, or a closed-over value. The type:
          </p>
	  <literallayout>
(ArrayRef <em>T</em>)</literallayout>
	  <p>
	    describes array references of element type
	    <progident><em>T</em></progident>.
	  </p>
        </sect3>
      </sect2>
      <sect2>
        <title>Named Constructed Types</title>
        <p>
          The named constructed types are types whose compatibility
          rules are determined by name equivalence. Two values of
          named constructed types are equivalent if (a) they are
          instances of the same statically appearing type definition,
          and (b) their corresponding elements are equivalent.
        </p>
        <p>
          Unless otherwise qualified, a named constructed type
          declaration declares a reference type.
        </p>
	<sect3 id="type:structure">
	  <title>Structures</title>
	  <p>
	    A structure definition defines a named type whose
	    instances are an ordered sequence of named cells. The
	    syntax of a structure declaration is:
	  </p>
	  <literallayout>
(struct <em>nm</em> <em>field</em> ...)
(struct (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>) <em>field</em> ...)</literallayout>
	  <p indent="no">
            where each <progident><em>field</em></progident> is one of:
          </p>
<literallayout>
<em>nm</em>:<em>type</em>
(the <em>type</em> <em>nm</em>)
(fill <em>bitfield-type</em>)
(reserved <em>bitfield-type</em> <em>value</em>)</literallayout>
          <p indent="no">
            All names <progident><em>nm</em></progident> are disjoint
	    identifiers giving the names of the structure fields, and
	    the respective <progident><em>type</em></progident> forms
	    are the types of the respective fields.  Given a variable
	    <progident>v</progident> that is an instance of a
	    structure type having a field named
	    <progident>f</progident>, the expression
	    <progident>v.f</progident> unifies with the field
	    <progident>f</progident> within that structure.
          </p>
          <p>
            A <progident>fill</progident> element may be used to
            support precise specification of alignment. The alignment
            and storage layout of a fill field follows the alignment
            and storage layout of its base type, however a fill field
            has no name or defined value, and cannot be
            programatically referenced.
          </p>
          <p>
            A <progident>reserved</progident> element may be used to
            specify a reserved bit position in a low-level data
            structure that is required to hold a known value. It is
            otherwise identical to a <progident>field</progident>
            element.
          </p>
          <p>
	    An identifier that is bound to a structure type may be used
	    as a procedure to instantiate new values of that structure
	    type. The arguments to this procedure are the initial values
	    of the respective structure fields.
	  </p>
	  <p>
	    An identifier that is bound to a non-parameterized
	    structure type may be used as a type name.  An identifier
	    that is bound to a parameterized structure type may be
	    used in a type constructor application within a type
	    specification. Its arguments are the types over which the
	    newly instantiated structure type should be instantiated.
	    For example, the declarations:
          </p>
          <literallayout>
(struct ipair a:int32 b:int32)

(struct (tree-of 'a):boxed
  left : (optional (tree-of 'a))
  right : (optional (tree-of 'a))
  height : int8
  value : 'a)</literallayout>
          <p indent="no">
            define (respectively) the type name <progident>ipair</progident> and
            the single argument type constructor
            <progident>tree-of</progident>.
          </p>
          <sect4>
            <title>Storage Layout</title>
            <p>
              A structure having <em>k</em> fields is laid out in
              memory at increasing addresses from left to right as
              <em>k</em> contiguous cells whose size and alignment are
              determined by their respective element types. These
              cells are then packed according to the previously
              described alignment and layout packing rules. <font
              color="red"><em>Did we describe them?</em></font>
            </p>
          </sect4>
	</sect3>
	<sect3>
	  <title>Unions</title>
	  <p>
	    The <progident>union</progident> form defines
	    enumerations, discriminated unions, and mixes of
	    these. The type being defined is in-scope within the
	    definition of the type, but is incompletely defined.  The
	    syntax of a union declaration is one of:
	  </p>
	  <literallayout>
(union <em>nm</em> <em>C<sub>1</sub></em> ... <em>C<sub>n</sub></em>)
(union (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>)
  <em>C<sub>1</sub></em> ... <em>C<sub>n</sub></em>)</literallayout>
	  <p indent="no"> 
            where each
            <progident><em>tv<sub>i</sub></em></progident> is a type
            variable and <progident><em>C<sub>i</sub></em></progident>
            is a <term>constructor form</term>.  A constructor form
            consists of either a single identifier or a parenthesized
            identifier followed by a sequence of field or fill
            declarations (see <progident>struct</progident>). All
            field names appearing in a
            <progident>union</progident>, including constructor
            names, must be disjoint.
	  </p>
          <p>
            An identifier bound to a union constructor having no
            fields denotes the value of the unique corresponding union
            instance for that union type.
          </p>
          <p>
            An identifier bound to a union constructor having
            associated fields is a procedure that may be used to
            instantiate new instances of that union type. The
            arguments to this procedure are the initial values of the
            union fields associated with that union variant.
          </p>
          <p>
            An identifier that is bound to a non-parameterized union
            type is a valid type name.  An identifier that is bound to
            a paramterized union type may be used in a type
            constructor application within a type specification. Its
            arguments are the types over which the newly instantiated
            structure type should be instantiated.  For example, the
            declarations:
	  </p>
          <literallayout>
(union contrived
  (asChar c:char) (asInt i:int32))

(union (optional 'a) :unboxed
  none
  (some value:'a))</literallayout>
          <p indent="no">
            define (respectively) a reference type holding either a
            <progident>char</progident> or an
            <progident>int32</progident>, and a value type of optional
            elements.
          </p>
          <p>
            The declaration:
          </p>
          <literallayout>
(union (list 'a):boxed
  nil
  (cons car:'a cdr:(list 'a)))</literallayout>
          <p indent="no">
            Defines the reference type of homogeneous lists.
          </p>
          <sect4>
            <title>Storage Layout</title>
            <p>
              Each variant of a union declaration effectively defines
              a <em>k+1</em> element structure, where the first
              element contains the tag and the remaining <em>k</em>
              elements are the fields of the constructor leg. In the
              usual case, the representation of the union leg is
              arranged as though it had actually been this structure,
              without regard to the layout of other legs.
            </p>
            <p>
              In the unusual case of a union whose tag representation
              can be elided (see below), each individual union leg
              will be arranged as though it had been the corresponding
              structure declaration.
            </p>
            <p>
              In the case of a union having no tag, the union
              representation will match the size and alignment of
              reference cells.  The storage occupied by a union of
              value type is the maximum of the storage required for
              each individual case of the discriminated union
              (including the type tag, if present).
            </p>
          </sect4>
	  <sect4>
	    <title>Type Tag Size and Alignment</title>
	    <p>
	      In the absence of declaration, the union type tag will be
	      given an implementation-defined size and alignment
	      selected to maximize performance efficiency. Explicit
	      control over the size and alignment can be achieved using
	      a <progident>tag-type</progident> declaration. The
	      declaration:
	    </p>
	    <literallayout>
(union (list 'a):boxed
  (declare (tag-type uint8))
  nil
  (cons car:'a cdr:(list 'a)))</literallayout>
	    <p indent="no">
	      indicates that the tag should be implemented using an
	      unsigned byte.  The declared tag type must be an unsigned
	      integral or bitfield type having a sufficient number
	      of distinct values to assign a unique value to each
	      constructor.
	    </p>
          </sect4>
          <sect4 id="TagRepresentation">
            <title>Tag Representation</title>
            <p>
              The prelude type
              <progident>(nullable&nbsp;'a)</progident> must be
              implemented in a single pointer-sized machine word, with
              the <progident>Null</progident> case being tagged by a
              word value of zero and the <progident>ptr</progident>
              case being tagged by a non-null word value. This yields
              a concrete representation that is compatible with the
              representation of nullable pointers in other languages.
            </p>
            <p>
              The following representation requirements are required
              unless they cannot be legally implemented on the
              underlying machine, as in JVM or CLR.
            </p>
            <p>
              In the absence of an explicit declaration of the type
              tag representation, a union type having exactly one
              union leg whose first element is of type
              <progident>(ref&nbsp;'a)</progident> or
              <progident>(nullable&nbsp;'a)</progident>, and all of
              whose other legs have no fields shall be represented in
              such a way that the tag word reuses the storage of the
              ref/nullable field. The ref/nullable leg shall be
              denoted by a tag field whose least significant bit is
              zero. The n'th enumeration leg's tag value (in order of
              appearance) shall be encoded as
              <progident>n*2+1</progident>.  This representation is
              sometimes known as the Cardelli optimization, because it
              permits a two-word implementation of CONS cells, as in
              Scheme or LISP.
            </p>
            <p>
              If a union type tag is explicitly declared to be of a
              field type whose size in bits <progident>b</progident>
              is such that the machine's natural heap alignment
              restriction for objects is
              <progident>align&gt;=2<sup>b</sup></progident>, the
              total number of distinct legs of the union does not
              exceed <progident>2<sup>b</sup></progident>, and there
              is exactly one union leg whose first element is of type
              <progident>(ref&nbsp;'a)</progident> or
              <progident>(nullable&nbsp;'a)</progident>, then the tag
              field shall overlay the least significant bits of the
              ref/nullable field, the tag value zero shall denote the
              ref/nullable leg, and all other tag values shall be
              non-zero.
            </p>
	  </sect4>
	</sect3>
        <sect3 id="ty_repr">
          <title>Reprs</title>
          <p>
            There are examples of low-level hardware data structures
            for which the unions and structures that can be specified
            using <progident>struct</progident> or
            <progident>union</progident> are insufficiently
            expressive. One example is the Pentium GDT data structure,
            which has nested union discriminators, but simultaneously
            has an overall bit-level layout requirement. Another
            example is data structures where the representation of the
            tag must appear at a specific location that is not
            adjacent to the fields guarded by the tag. The
            <progident>repr</progident> form is included to permit
            the expression of these data structures. 
          </p>
          <p>
            The following scheme for <progident>repr</progident> is
            based on the bit-data representation proposed by Iavor Diatchki,
            <foreignphrase>et. al.</foreignphrase>&nbsp;<cite
              ref="diatchki2005representation"/>. 
          </p>
          <p>
            Similar to unions and structures, a
            <progident>repr</progident> delaration takes the
            following form:
          </p>
          <literallayout indent="no">
(repr name
  (Ctr1 f11:type f21:type ... fn1:type
    (where (== fp1 v11) (== fq1 v21) ...
           (== fm1 vm1))

  (Ctr2 f12:type f22:type ... fn2:type
    (where (== fp2 v12) (== fq2 v22) ... 
           (== fm2 vm2))

  ... )</literallayout>
          <p>
            The following restrictions apply. For all constructors
            <progident>Ctrx</progident>, <progident>Ctry</progident>, 
            <progident>Ctrz</progident>, <progident>...</progident>:
          </p>
          <ul>
            <li>
              <p>
                All fields <progident>fpx</progident>, fqx...fmx
                appearing in the <progident>when</progident> clause of
                a constructor form <progident>Ctrx</progident> must be
                described within the body of
                <progident>Ctrx</progident>. That is,
                {<progident>fpx</progident>,
                <progident>fqx</progident>, <progident>...</progident>
                <progident>fmx</progident>} &sube;
                {<progident>f1x</progident>, <progident>...</progident> 
                <progident>fnx</progident>}.
              </p>
            </li>
            <li>
              <p>
                Identically named fields within two different
                constructor forms must be located at the same bit
                level offset from the beginning of both the
                constructor forms. That is, <progident>fpx</progident>
                = <progident>fpy</progident> implies
                bit-offset(<progident>fpx</progident>) =
                bit-offset(<progident>fpy</progident>).
              </p>
            </li>
            <li>
              <p>
                Identically named fields within two different
                constructor must have the same type. That is,
                <progident>fpx</progident>  =
                <progident>fpy</progident> implies 
                type-of(<progident>fpx</progident>) =
                type-of(<progident>fpy</progident>).
              </p>
            </li>
            <li>
              <p>
                The fields within the <progident>when</progident>
                clauses of all constructor forms must uniquely
                distinguish all constructible values of the union. The
                compiler will not introduce any more tag bits for a
                <progident>repr</progident> value.
              </p>
            </li>
            <li>
              <p>
                Currently, the <progident>repr</progident> form
                will not accept type arguments over which
                it can be instantiated.
                That is, the following definition is not legal.
              </p>
              <literallayout indent="no">
(repr (name 'a 'b ... ) ... )</literallayout>
            </li>
            <li>
              <p>
                Currently, the discriminating fields
                <progident>fp1</progident>,
                <progident>fp2</progident>, etc must have a
                integer/bitfield type, and the discriminator values  
                <progident>v11</progident>,
                <progident>v12</progident>, etc must be an integer
                literal.  
              </p>
            </li>
          </ul>
          <p>
            We can envision a larger language construct
            <progident>UNION</progident>, which accepts both type
            arguments and <progident>when</progident> clauses. The
            <progident>union</progident> and
            <progident>repr</progident> are just specializations of
            this <progident>UNION</progident> construct. However,
            currently the language only supports
            <progident>union</progident> (which does not accept the
            <progident>when</progident> clause) and
            <progident>repr</progident> (which does not accept type
            arguments). 
          </p>          
        </sect3>
        <sect3 id="ty_object">
          <title>Objects</title>
          <p>
            <em>This description is provisional. The feature is a work
            in progress.</em>
          </p>
          <p>
            In BitC, an object provides a form of existential
            dispatch. Objects are declared similarly to
            structures. The syntax of an object declaration is:
          </p>
	  <literallayout>
(object <em>nm</em> <em>field</em> ...)
(object (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>) <em>field</em> ...)</literallayout>
          <p indent="no">
            where each field is required to be of <link
              href="#ty_method">method</link> type.
          </p>
          <p>
	    An identifier that is bound to a object type may be used
	    as a procedure to instantiate new values of that object
	    type. The single argument to this procedure must be an
	    instance of some compatible structure type
	    <progident><em>S</em></progident>. A structure type
	    <progident><em>S</em></progident> is deemed compatible if
	    <progident><em>S</em></progident> is of reference type and
	    for every method <progident><em>m</em></progident> in the
	    object type, there must be a corresponding method of the
	    same name in <progident><em>S</em></progident> whose type
	    is at least as general as the method type declared in the
	    object type.
          </p>
	  <p>
	    An identifier that is bound to a non-parameterized
	    object type may be used as a type name.  An identifier
	    that is bound to a parameterized object type may be
	    used in a type constructor application within a type
	    specification. Its arguments are the types over which the
	    newly instantiated object type should be instantiated.
	    For example, the declarations:
          </p>
          <literallayout>
(object O i:int32)
(object (Oparam 'a) x:'a)</literallayout>
          <p indent="no">
            define (respectively) the type name
            <progident>O</progident> and the single argument type
            constructor <progident>Oparam</progident>.
          </p>
          <p>
            An object occupies two words of storage one of which is a
            reference to a method table and the other is a reference
            to an object of corresponding structure type. Construction
            of an object from a structure instance entails capturing a
            reference to that instance and a reference to a method
            table mapping the method declarations of the object onto
            the corresponding method definitions of the referenced
            structure type.  Invocation of an object method is
            realized as invocation of the corresponding method of the
            referenced structure instance.
          </p>
          <sect4>
            <title>Storage Layout</title>
            <p>
              An object occupies two machine words, the first of which
              is a reference to a method table and the second of which
              is a reference to an object of corresponding structure
              type. The alignment of this structure is dictated by the
              pointer alignment requirements of the underlying
              hardware implementation. 
            </p>
          </sect4>
        </sect3>
        <sect3>
          <title>Value vs. Reference Types</title>
          <p>
            In the absence of other specification, the
            <progident>struct</progident>,
            <progident>repr</progident>,
            <progident>union</progident>, and
            <progident>object</progident>, forms declare reference
            types.  The developer may optionally qualify the
            declaration to make this intention explicit:
          </p>
	  <literallayout>
(struct <em>nm</em><b>:boxed</b> <em>field</em> ...)
(struct (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>)<b>:boxed</b>
  <em>field</em> ...)
(union <em>nm</em><b>:boxed</b> <em>C<sub>1</sub></em> ... <em>C<sub>n</sub></em>)
(union (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>)<b>:boxed</b>
  <em>C<sub>1</sub></em> ... <em>C<sub>n</sub></em>)
(repr <em>nm</em><b>:boxed</b> (<em>body</em>))
(repr (<em>nm</em> <em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>)<b>:boxed</b> (<em>body</em>))</literallayout>
          <p>
            The qualifier ``:boxed'' indicates that the type declared
            (and consequently the type returned by value constructors)
            is a heap-allocated type, sometimes known as a ``reference
            type.'' The qualifier ``:unboxed'' indicates that the type
            declared is a type whose storage is allocated within its
            containing data structure (which may be the stack). These
            are sometimes refered to as ``value types.'' The qualifier
            ``:opaque'' indicates that the type declared is a value
            type whose internal structure is not accessable outside of
            the defining interface and the providers of that
            interface. An importer of an opaque type may declare
            fields and variables of that type and can <em>copy</em>
            instances of that type, but can neither apply the type
            constructors nor make reference to the contents of
            instances.
          </p>
          <p>
            Note that if the type declared is a value type, it cannot
            be instantiated within the body of the declaration because
            its size is not statically known. That is, it is legal to
            have a field that is a <em>reference</em> to a value of
            the type currently being defined, but not a value of that
            type.
          </p>
        </sect3>
        <sect3>
          <title>Forward Declarations</title>
          <p>
            The declarations
          </p>
          <literallayout>
<em>qual</em> struct <em>nm</em> [<em>external</em>];
<em>qual</em> union <em>nm</em> [<em>external</em>];
<em>qual</em> repr <em>nm</em> [<em>external</em>];
<em>qual</em> struct <em>nm</em>(<em>tv<sub>1</sub></em>, ... <em>tv<sub>n</sub></em>) 
          [<em>external</em>]
<em>qual</em> union <em>nm</em>(<em>tv<sub>1</sub></em>, ... <em>tv<sub>n</sub></em>)
          [<em>external</em>]
<em>qual</em> repr <em>nm</em>(<em>tv<sub>1</sub></em> ... <em>tv<sub>n</sub></em>)
          [<em>external</em>]</literallayout>
          <p indent="no">
            state (respectively) that <progident>nm</progident> is a
            structure (respectively union) reference type of the
            stated arity whose internal structure is not disclosed.
            The qualifier
            <progident><em>qual</em></progident> declares
            the type to be one of ``boxed'', ``unboxed'', or
            ``opaque''. In the absence of qualification, the default
            is ``boxed''<footnote>
              <p>The qualifier is presently mandatory
            on struct, union, and repr declarations during syntax
            transition. This requirement will be relaxed in a future
            revision of the specification.</p>
            </footnote>
            If present, the <em>external</em> portion
            consists of the keyword <progident>external</progident>
            followed by an optional identifier (see discussion of
            external identifiers in <progident>proclaim</progident>).
          </p>
          <p>
            For example, the following declaration is include in the
            library <progident>bitc.int</progident> interface to
            declare the bignum type:
          </p>
          <literallayout>
unboxed struct int external bitc_int</literallayout>
          <p>
            The structure of these types may optionally be disclosed
            later in the same compilation unit by a type definition
            for <progident>nm</progident>. If the declaring form
            appears within an interface, the corresponding type
            definition may appear in a providing unit of compilation,
            in which case the type is opaque to importers of the
            interface.
          </p>
          <p>
            Note that a forward declaration of a value type is
            sufficient to declare <em>references</em> to that type,
            but not <em>instances</em> of that type. A complete
            definition of the value type is required to be in scope in
            order to declare fields and variables of value type.
          </p>
        </sect3>
	<sect3 id="ty_method">
	  <title>Method Types</title>
<!--           <p> -->
<!--             A method is a function that is syntactically associated -->
<!--             with a particular object type. If -->
<!--             <progident><em>e</em></progident> is an expression of -->
<!--             structure or object type <progident>T</progident>, and -->
<!--             <progident>m</progident> is a method of -->
<!--             <progident>T</progident>, then -->
<!--             <progident>(<em>e</em>.m&nbsp;...)</progident> is an -->
<!--             application of that method to the object returned by -->
<!--             <progident><em>e</em></progident>. -->
<!--           </p> -->
	  <p>
	    If <progident>S</progident> is a structure or object type,
	    and <progident><em>t<sub>arg</sub></em></progident> and
	    <progident><em>t<sub>result</sub></em></progident> are
	    types (including type variables), then a field
	    <progident><em>m</em></progident> of
	    <progident>S</progident> may be declared as:
	  </p>
	  <literallayout>
(method <em>t<sub>arg_1</sub></em>...<em>t<sub>arg_n</sub></em> -&gt; <em>t<sub>result</sub></em>)</literallayout>
          <p indent="no">
            A method type may only be specified as a field type of a
            field within a structure or object type. Methods occupy no
            storage in their associated structure or object.
          </p>
          <sect4>
            <title>Structure Methods</title>
            <p>
              In a structure type, methods may be viewed as a
              procedure proclamation that is coupled to a convenience
              syntax supported by application. The declarations:
            </p>
            <literallayout>
(struct S
  m: (method int32 -&gt; bool))
(struct T : val
  m: (method int32 -&gt; bool))</literallayout>
            <p indent="no">
              implicitly proclaim (respectively) the procedures:
            </p>
            <literallayout>
(proclaim S.m: (fn S int32 -&gt; bool))
(proclaim T.m:
   (fn (by-ref T) int32 -&gt; bool))</literallayout>
            <p indent="no">
              where the parameter corresponding to the argument of
              structure type is <progident>by-ref</progident> exactly if
              the corresponding structure type is a value type.
              Implementations of these procedures must be provided
              elsewhere by the developer.
            </p>
            <p>
              Given these declarations, and an expression
              <progident><em>e</em></progident> returning a value of
              type <progident>S</progident>, the application:
            </p>
            <literallayout>
(<em>e</em>.m 3)</literallayout>
            <p indent="no">
              is a syntactic convenience for:
            </p>
            <literallayout>
(S.m <em>e</em> 3)</literallayout>
          </sect4>
          <sect4>
            <title>Object Methods</title>
            <p>
              In an object type, methods may be viewed as a procedure
              proclamation that is likewise coupled to a convenience
              syntax supported by application. As with structure
              methods, they implicitly proclaim corresponding
              procedures. In <em>contrast</em> to structure methods,
              the implementation of these procedures is provided by
              the compiler.
            </p>
          </sect4>
	</sect3>
	<sect3>
	  <title>Named Type Conveniences</title>
	  <p>
            The following types are defined in the BitC standard
 	    prelude.
          </p>
          <literallayout>
(struct (pair 'a 'b) :unboxed
   fst:'a snd:'b)

(union (list 'a) :boxed
   nil
   (cons 'a (list 'a)))</literallayout>
          <p indent="no">
            Note that <progident>pair</progident> is a keyword that is
            specially recognized in binding patterns.
          </p>
          <p>
            The
            <progident>pair</progident> type is supported by a
            right-associative infix convenience syntax:
          </p>
          <literallayout>
(a, b) =&gt; (pair a b)
(a, b, c) =&gt; (pair a (pair b c))</literallayout>
          <p indent="no">
            This convenience syntax may be used in types, binding
            patterns, and value construction.
          </p>
<!--           <p> -->
<!--             The <progident>list</progident> type is also supported by -->
<!--             a right-associative convenience syntax: -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- []      =&gt;  nil -->
<!-- [a]     =&gt; (cons a nil) -->
<!-- [a,b]   =&gt; (cons a (cons b nil)) -->
<!-- [a,b,c] =&gt; -->
<!--   (cons a (cons b (cons c nil)))</literallayout> -->
<!--           <p indent="no"> -->
<!--             This convenience syntax may be used in value patterns and -->
<!--             value construction. -->
<!--           </p> -->
<!--           <note> -->
<!--             <p> -->
<!--               The <progident>list</progident> form may become a -->
<!--               syntactic form in future versions of this specification, -->
<!--               because we are considering adding pattern matching -->
<!--               support for it. -->
<!--             </p> -->
<!--           </note> -->
	</sect3>
      </sect2>
      <sect2>
        <title>Const</title>
        <p>
          The <progident>const</progident> keyword is a type
          <em>metaconstructor</em>. If
          <progident><em>T</em></progident> is a type, then the type
          <progident>(const&nbsp;<em>T</em>)</progident> is a type
          that is copy-compatible (<xref ref="type:copy-compatible"/>)
          with <progident><em>T</em></progident>, but has had all
          mutability stripped (recursively) at all shallow constituent
          fields. This enables a local, shallowly constant copy to be
          made of a structure containing mutable constituents.
        </p>
        <p>
          The <progident>const</progident> construct is considered a
          meta-constructor because of its ``sticky'' behavior under
          unification. The type
          <progident>(const&nbsp;<em>'a</em>)</progident> does not
          unify with any type (shallowly) containing a mutable
          constituent field.
        </p>
      </sect2>
      <sect2>
        <title>Mutable</title>
        <p>
          Unless modified by the <progident>mutable</progident>
          keyword, the preceding types yield immutable
          instantiations.  If <progident><em>T</em></progident> is a
          type, then the type
          <progident>(mutable&nbsp;<em>T</em>)</progident>
          is the type of mutable instances of
          <progident><em>T</em></progident>. If the type
          <progident><em>T</em></progident> is a reference type
          (including <progident>:boxed</progident> structure types), then the type
          <progident>(mutable&nbsp;<em>T</em>)</progident> describes a
          mutable reference to a memory location in the heap.
        </p>
        <sect3>
          <title>Mutability of Aggregates</title>
          <p>
            Array types and by-value structure types are aggregate
            types. While all fields of an array are of like type,
            structures may contain a combination of mutable and
            immutable constituent fields. An instance of aggregate
            type is mutable as a whole exactly if all of its contained
            constituent fields are mutable:
          </p>
          <literallayout indent="no">
(def p (pair (mutable #\c) 3:int32))
...
;; legal, field is mutable:
(set! p.first #\d)
;; illegal
(set! p.second 5)

(def mp (pair (mutable #\c)
           3:(mutable int32)))
;; legal, all fields mutable:
(set! mp (pair #\d 4))</literallayout>
          <p indent="no">
            The test of constituent mutability does not extend across
            reference boundaries.
          </p>
          <p>
            If <progident><em>T</em></progident> is an aggregate type,
            then <progident>(mutable&nbsp;<em>T</em>)</progident> is a
            valid type exactly if <em>T</em> is mutable at all
            constituents.
          </p>
        </sect3>
        <sect3>
          <title>Shallow vs. Deep Mutability</title>
          <p>
            If <progident><em>T</em></progident> is an immutable type,
            and if all of its unboxed fields (recursively) are of
            immutable type up to <progident>ref</progident>
            boundaries, then <progident><em>T</em></progident> is said
            to be <term>shallow immutable</term>. If any of those
            elements are mutable, then <progident><em>T</em></progident> is
            said to be <term>shallow mutable</term>.  We use the term
            <term>deep mutable</term> to refer to mutable types that
            appear <em>behind</em> a <progident>ref</progident>
            boundary.
          </p>
          <p>
            The type
            <progident>(ref&nbsp;(mutable&nbsp;'a))</progident> is
            shallow immutable but deep mutable.
          </p>
        </sect3>
      </sect2>
<!--       <sect2> -->
<!--         <title>Method Types</title> -->
<!--         <p> -->
<!--           The type: -->
<!--         </p> -->
<!--         <literallayout> -->
<!-- (method (<em>TC</em> 'a ... 'z)  -->
<!--         (fn <em>T<sub>arg</sub></em> <em>T<sub>out</sub></em>))</literallayout> -->
<!--         <p indent="no"> -->
<!--           describes the type of <em>methods</em> (see type classes, -->
<!--           below) that are members of some type class -->
<!--           <progident><em>TC</em></progident>. The types of the -->
<!--           arguments and return values may refer to the type variable -->
<!--           paramaters of the type class. Multiple type class -->
<!--           requirements can be expressed using <progident>and</progident>: -->
<!--         </p> -->
<!--         <literallayout> -->
<!-- (method (and (<em>TC1</em> 'a ... 'z) -->
<!--              (<em>TC2</em> 'a ... 'z)) -->
<!--         (fn <em>T<sub>arg</sub></em> <em>T<sub>out</sub></em>))</literallayout> -->
<!--       </sect2> -->
      <sect2>
        <title>Exceptions</title>
        <p>
          BitC provides declared exceptions. The type
          <progident>exception</progident> should be viewed as an
          ``open'' union reference type whose variant constructors are
          defined by <progident>exception</progident>. The syntax
          of an exception declaration is:
        </p>
        <literallayout>
(exception <em>nm</em> [<em>field<sub>1</sub></em> ... <em>field<sub>n</sub></em>])</literallayout>
        <p indent="no"> where each
	    <progident><em>field<sub>i</sub></em></progident> is a
          field declaration (see <progident>struct</progident>)
          whose type is a concrete type.
        </p>
        <p>
          An identifier bound to an exception name is a procedure that
          may be used to instantiate new instances of that exception.
          The arguments to this procedure are the values of the fields
          associated with the exception.
        </p>
      </sect2>
      <sect2>
	<title>Type Variables</title>
        <p>
          A type variable is a type variable identifier preceded by a
          single quote, as in <progident>'a</progident>. Type
          variables may appear in any position where a type can
          appear. Type variables are most commonly used as type
          constructor arguments for named constructed types (see
          below). They can also be used to annotate expressions, for
          example to require that two expressions must have the same
          type. The expression:
        </p>
        <literallayout>
(myfun x y:'a):'a</literallayout>
        <p indent="no">
          says that the type of <progident>x</progident> is
          unspecified by the program author (and should therefore be
          inferred), the return type is also unspecified (and should
          be inferred), but the program author is stating that the
          return type and the last argument type are the same. This
          type of annotation is sometimes useful to assist the
          inference engine.
        </p>
        <p>
          The scope of a type variable is its outermost defining form.
        </p>
      </sect2>
      <sect2 id="type:copy-compatible">
        <title>Copy Compatibility</title>
        <p>
          The combination of mutability and value types in the BitC
          type system raises the need to specify what happens at
          ``copy boundaries.'' Given a value of type
          <progident><em>T<sub>1</sub></em></progident> and a location
          or formal parameter (the receiver) of type
          <progident><em>T<sub>2</sub></em></progident>, when is the
          value compatible with the receiver for purposes of argument
          passing and assignment?  We refer to this as <term>copy
          compatibility</term>.
        </p>
        <sect3>
          <title>Trivial Copy Compatibility</title>
          <p>
            The types <progident><em>T</em></progident> and
            <progident>(mutable&nbsp;<em>T</em>)</progident> are
            trivially copy compatible, because they differ only in
            top-level mutability. A location of type
            <progident>(mutable&nbsp;<em>T</em>)</progident> may be
            assigned a value of either type, and a parameter of type
            <progident><em>T</em></progident> may be passed a value of
            either type.
          </p>
          <p>
            The intrinsic type class
            <progident>(top-copy-compat&nbsp;<em>T<sub>1</sub></em>&nbsp;<em>T<sub>2</sub></em>)</progident>
            describes a relation between all pairs of types
            <progident><em>T<sub>1</sub></em></progident> and <progident><em>T<sub>2</sub></em></progident>
            that are trivially copy compatible.  This type class is
            rarely the right thing to use in input programs, but may
            sometimes be seen in the type checker output.
          </p>
        </sect3>
        <sect3>
          <title>Structural Copy Compatibility</title>
          <p>
            Two structured types
            <progident><em>T<sub>1</sub></em></progident> and
            <progident><em>T<sub>2</sub></em></progident> are
            structurally copy compatible if (a) they are trivially
            copy compatible or (b) they are value types that are
            fieldwise structurally copy compatible. Note that this
            definition explicitly does <em>not</em> descend
            recursively across reference types. The conceptual
            intuition is this: any element that will actually be
            copied by assignment or argument passing must be
            compatible ignoring mutability, but any object that is
            <em>pointed to</em> must have exactly matching type in
            both the value and its receiver.
          </p>
          <p>
            The intrinsic type class
            <progident>(copy-compat&nbsp;<em>T<sub>1</sub></em>&nbsp;<em>T<sub>2</sub></em>)</progident>
            describes a relation between all pairs of types
            <progident><em>T<sub>1</sub></em></progident> and <progident><em>T<sub>2</sub></em></progident>
            that are structually copy compatible. If you are trying to
            abstract over mutability, this type class is usually the
            one that you want. Note that
            <progident>(top-copy-compat&nbsp;<em>T<sub>1</sub></em>&nbsp;<em>T<sub>2</sub></em>)</progident> implies
            <progident>(copy-compat&nbsp;<em>T<sub>1</sub></em> <em>T<sub>2</sub></em>)</progident>, but the
            reverse is not true.
          </p>
        </sect3>
        <sect3>
          <title>Inner and Outer Procedure Types</title>
          <p>
            A curious consequence of copy compatibility is that
            functions have two types. Consider the function:
          </p>
          <literallayout>
(def (inc x:(mutable int32))
  (set! x (+ x 1))
  x)</literallayout>
          <p indent="no">
            From the perspective of the function's implementation,
            <progident>x</progident> is a mutable location having type
            <progident>(mutable&nbsp;int32)</progident>, and since
            <progident>x</progident> is returned, the return type of
            this function is also
            <progident>(mutable&nbsp;int32)</progident>. From this, we
            would conclude that the type of <progident>inc</progident>
            should be:
          </p>
<literallayout indent="no">
inc: (fn ((mutable int32)) (mutable int32))</literallayout>
          <p indent="no">
            Given the copy compatibility rules, however, the fact that
            <progident>inc</progident> internally mutates its argument
            is not something that the caller needs to know in order to
            call <progident>inc</progident> directly. The externally
            observable type reported for <progident>inc</progident>
            therefore strips shallow mutability, giving:
          </p>
<literallayout>
inc: (fn (int32) int32)</literallayout>
          <p>
            In addition to preserving abstraction, reducing type
            incompatibilities at function reference types, and
            providing some degree of separation of concerns, copy
            compatibility can also be exploited by polyinstantiating
            implementations to significantly reduce the amount of
            redundant instantiation that would otherwise be required.
          </p>
        </sect3>
      </sect2>
      <sect2>
        <title>Restrictions</title>
        <p>
          BitC imposes a value restriction <cite
          ref="garrigue2004value"/> on polymorphism. A binding is only
          permitted to be of polymorphic type if its defining
          expression is a syntactic value.
        </p>
        <p>
          As is usual in let-polymorphic languages, polymorphic
          function arguments cannot be used polymorphically within the
          function. For example, the following function is disallowed:
        </p>
        <literallayout>
(def (foo f)
  (pair
    (f (cons 1 (cons 2 nil)))
    (f (cons true (cons false nil)))))</literallayout>
      </sect2>
    </sect1>
    <sect1>
      <title>Type Classes and Qualified Types</title>
      <p>
        A <term>type class</term> defines an n-ary relation on types,
        and provides a means for specifying <foreignphrase>ad
        hoc</foreignphrase> polymorphism. Every type class is
        parameterized over <em>n</em>&ge;1 types, and defines a set of
        methods over those types.  Type classes provide a form of
        <em>open</em> type-directed operations: a user can add a new
        member to the relation established by a given type class by
        providing a new instantiation of the type class.
      </p>
      <p>
        Closely connected with type classes is the notion of
        <term>qualified types</term>. For example, consider the
        following definition of <progident>list-max</progident>:
      </p>
<literallayout>
(def (list-max x)
  (switch tmp x
    (nil (raise ValueError))
    (cons
     (if (null? tmp.cdr)
         tmp.car
         (let ((m (list-max tmp.cdr)))
           (if (>= tmp.car m)
               tmp.car m))))))</literallayout>
      <p indent="no">
        which is typed as:
      </p>
<literallayout>
(forall ((Ord 'a))
        (fn ((list 'a)) 'a))</literallayout>
      <p>
        This type should be read informally as
        ``<progident>list-max</progident> is a procedure accepting
        lists of type <progident>'a</progident> and returning a value
        of type <progident>'a</progident>. It is defined over all
        types <progident>'a</progident> such that there is an
        instantiation of the <progident>(Ord&nbsp;'a)</progident> type
        class.''
      </p>
      <p>
        In this example, <progident>(Ord&nbsp;'a)</progident> is the
        type class that describes types having a total order. That is:
        types over which the procedure <progident>&gt;=</progident> is
        defined. Obviously, it not semantically sensible to request
        the greatest element of a list whose element type does not
        have at total ordering.
      </p>
      <p>
        Contrast this example with the following alternative:
      </p>
<literallayout>
(def (list-max gte x)
  (switch tmp x
    (nil (raise ValueError))
    (cons
     (if (null? tmp.cdr)
         tmp.car
         (let ((m (list-max tmp.cdr)))
           (if (gte tmp.car m)
               tmp.car m))))))</literallayout>
      <p indent="no">
        which is typed as:
      </p>
<literallayout>
(fn ((fn ('a 'a) bool)
     (list 'a)) 'a))</literallayout>
      <p indent="no">
        In this second example, the comparison operator is provided as
        an argument, and there is no requirement for additional type
        constraints. Note, however, that in practice any comparison
        function that might actually be passed in this position is
        likely to depend on the <progident>&lt;=</progident> operator
        in some fashion, and is therefore likely to end up having a
        qualified type.
      </p>
      <sect2>
        <title>Definition of Type Classes</title>
        <p>
          A type class is defined by the abstract syntax:
        </p>
        <literallayout>
(trait (<em>nm</em> <em>tv</em> ... <em>tv</em>)
  [<em>tyfn-declarations</em>]
  [:closed]
  <em>method-definitions</em>)</literallayout>
        <p indent="no">
          where a <em>tyfn-declaration</em> is a statement of
          functional dependency between types <cite
          ref="jones2000tcfndepend"/>:
        </p>
        <literallayout>
(tyfn (<em>tv</em> ... <em>tv</em>) <em>tv</em>)</literallayout>
        <p indent="no">
          and each method definition takes the form:
        </p>
        <literallayout>
nm : <em>function-type</em></literallayout>
        <p indent="no">
          Each method is an abstract procedure that may be
          instantiated for some particular type by a later use of
          <progident>instance</progident>. The method may be
          invoked prior to the point where the instantiation is
          visible.  Each method defined by a type class is introduced
          into the scope containing the type class definition.
        </p>
        <p>
          By providing an instantiation of a class over some
          particular set of types, the programmer simultaneously
          proves (by example) that the set of types is a member of the
          class and defines (by example) how the operations of the
          class are implemented for that type. If the type class has
          been marked ``closed,'' the instance definition must appear
          in the same interface or module that contains the type class
          definition.
        </p>
        <p>
          Type functions, when present, indicate that there is a
          dependent relationship between two or more types of the type
          class relation. For example, the (incomplete) declaration:
        </p>
        <literallayout>
(trait (sample 'a 'b 'c)
  (tyfn ('a 'b) 'c)
  ...)</literallayout>
        <p indent="no">
          states that <progident>sample</progident> is a type relation
          over three types, but also says that for any pair of types
          <progident>'a</progident> and <progident>'b</progident>
          there there is one valid choice of
          <progident>'c</progident>.
        </p>
        <sect3>
          <title>Example: <progident>Eql</progident></title>
          <p>
            As a first example, consider the equality comparison
            operations. The type class <progident>Eql</progident>
            defines a single element type relation on types
            <progident>'a</progident>: describing whether the type is
            admissable under equality. Some types &mdash; notably
            function types &mdash; cannot be compared for equality.
            The definition of this type class is written:
          </p>
          <literallayout>
(trait (Eql 'a)
  == : (fn ('a 'a) bool))
  != : (fn ('a 'a) bool))</literallayout>
          <p indent="no">
            which states that <progident>Eq.</progident> is the
            single element type relation over all types
            <progident>'a</progident> that can be passed as arguments to
            <progident>==</progident> and <progident>!=</progident>.
          </p>
        </sect3>
        <sect3>
          <title>Qualification: <progident>Ord</progident></title>
          <p>
            A type class can also be introduced in qualified form. The
            syntax for such a type class definition is:
          </p>
          <literallayout>
(forall (<em>constraint ... constraint</em>)
  (trait 
     (<em>nm</em> <em>tv</em> ... <em>tv</em>))
     [<em>tyfn-declarations</em>]
     <em>method-definitions</em>)</literallayout>
          <p indent="no">
            where each constraint takes the form:
          </p>
          <literallayout>
(<em>tc-name</em> <em>tv</em> ... <em>tv</em>)</literallayout>
          <p indent="no">
            where <progident>tc-name</progident> is a typeclass name.
            An example of this use is the <progident>Ord</progident>
            type class:
          </p>
          <literallayout>
(forall ((Eql 'a))
  (trait (Ord 'a)
    &lt; : (fn ('a 'a) 'a)))</literallayout>
          <p indent="no">
            This type class states that <progident>Ord</progident> is
            the single element type relation over all types
            <progident>'a</progident> that can be passed as arguments to
            <progident>&lt;</progident>. It also states that the
            <progident>Ord</progident> relation is only defined for
            types that are also members of the
            <progident>Eql</progident> relation (that is: types that
            admit equality comparison).
          </p>
          <p>
            Note that in the presence of this definition, the
            procedures <progident>&gt;</progident>, 
<progident>&lt;=</progident>, and 
<progident>&gt;=</progident> can be defined as:
          </p>
          <literallayout>
(def (&gt; x y)
  (not (or (&lt; x y) (== x y)))
(def (&lt;= x y)
  (or (&lt; x y) (== x y)))
(def (&gt;= x y)
  (or (&gt; x y) (== x y)))</literallayout>
          <p indent="no">
            all of which will be inferred to have the type:
          </p>
          <literallayout>
(forall ((Ord 'a)) (fn ('a 'a) bool))</literallayout>
          <p>
            This may seem like a very long-winded way of saying that
            an orderable type is any type that can be passed to the
            operators <progident>&lt;</progident> and
            <progident>==</progident>. However, type classes are
            statements about <em>relations</em> among types. This may
            become clearer with the following example.
          </p>
          <p>
            Note that because <progident>(Ord&nbsp;'a)</progident> has
            <progident>(Eql&nbsp;'a)</progident>, the types: 
          </p>
          <literallayout>
(forall ((Ord 'a) (Eql 'a))
        (fn ('a 'a) bool))
(forall ((Ord 'a)) (fn ('a 'a) bool))</literallayout>
          <p indent="no">
            are equivalent. The second is stylistically preferred for
            reasons of brevity. It is also more robust: in the (in
            this example unlikely) event that the definition of
            <progident>Ord</progident> should be modified to depend on
            some other type class in place of
            <progident>Eql</progident> the future, the first
            definition will mistakenly retain an additional,
            unncessary type dependency, while the second will continue
            to type check as intended.
          </p>
          <p>
            <b>Restriction:</b> Qualified type relationships must be
            acyclic.
          </p>
        </sect3>
<!--         <sect3> -->
<!--           <title>Example: <progident>Convert</progident></title> -->
<!--           <p> -->
<!--             Value promotion and demotion is provided by the -->
<!--             Conversions type class, which defines the -->
<!--             <progident>convert</progident> method: over a variety of -->
<!--             input types, following the conventions of the C -->
<!--             programming language: -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- convert : (fn (int8)  int16) -->
<!-- convert : (fn (int8)  int32) -->
<!-- convert : (fn (int8)  int64) -->

<!-- convert : (fn (int16) int8) -->
<!-- convert : (fn (int16) int32) -->
<!-- convert : (fn (int16) int64) -->
<!-- ...</literallayout> -->
<!--           <p indent="no"> -->
<!--             this is accomplished by defining the method -->
<!--             <progident>convert</progident> as a member of the -->
<!--             multi parameter type class <progident>Conversions</progident> -->
<!--             (elided here): -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- (trait (Conversions 'a 'b) -->
<!--   convert: (fn ('a) 'c) -->
<!--   ...)</literallayout> -->
<!--           <p indent="no"> -->
<!--             What this says is that the operator -->
<!--             <progident>convert</progident> can be applied to any two -->
<!--             types <progident>'a</progident> and -->
<!--             <progident>'b</progident>. -->
<!--           </p> -->
<!--         </sect3> -->
        <sect3>
          <title>Example: <progident>tyfn</progident></title>
          <p>
            <font color="red">Need an example of type
            functions.</font>
          </p>
        </sect3>
      </sect2>
      <sect2>
        <title>Instantiation of Type Classes</title>
        <p>
          Whenever a type class method is invoked, the compiler must
          identify some concrete member of the type class relation
          that is sufficient to choose an appropriate implementation
          of that method. This is done by locating an appropriate
          instantiation.
        </p>
        <p>
          A type class instantiation is a demonstration by example
          that some particular set of types satisfies the relation
          required by the type class. Type class instantiations are
          defined by the <progident>instance</progident> form.  The
          abstract syntax of <progident>instance</progident> is:
        </p>
        <literallayout>
(instance <em>tc-instance</em>
  <em>function ... function</em>)
(forall (<em>constraint ... constraint</em>)
  (instance <em>tc-instance</em>)
    <em>function ... function</em>)</literallayout>
        <p indent="no">
          where <em>tc-instance</em> takes the form:
        </p>
        <literallayout>
(<em>typeclass-name</em> <em>type</em> ... <em>type</em>)</literallayout>
        <p>
          For example, the definition:
        </p>
        <literallayout>
(instance (Ord int32)
  int32-ops.&lt;)</literallayout>
        <p indent="no">
          states that <progident>int32</progident> is member of the
          type relation <progident>Ord</progident> because there is an
          instance function <progident>int32.&lt;</progident> that
          provides an implementation of the ``less than'' operation
          over arguments of type <progident>int32</progident>.  If the
          type class definition is closed, all instance definitions
          must occur in the same interface or module ad the type class
          definition.
        </p>
        <p>
          In practice, this definition is insufficient, because we
          must first demonstrate that <progident>int32</progident> is
          a member of the <progident>Eq</progident> relation (which is
          a superclass of <progident>Ord</progident>)
          In consequence, two separate instantiations are required:
        </p>
        <literallayout>
(instance (Eq int32)
  int32-ops.==
  int32-ops.!=)
(instance (Ord int32)
  int32-ops.&lt;)</literallayout>
        <p>
          A type class instantiation is deemed to be in scope for
          purposes of procedure instantiation if it is defined by the
          end of the outermost unit of compilation.
        </p>
        <p>
          It is a compile time error to define two type class
          instances covering the same concrete types unless one
          instance is ``preferred'' to the other. Preference is
          determined by comparing the respective type variable
          instantiations positionally. Given two instances A and B
          over type variables
          <progident>tv<sub>1</sub></progident>...<progident>tv<sub>n</sub></progident>,
          instance A is preferable to instance B if there exists some
          subset of the respective type variable instantiations such
          that the instantiation under A is strictly more concrete
          than the instantiation under B, and the two instantiations
          are identical (modulo type variable renaming) at all other
          positions. If this comparison does not (transitively)
          determine a most preferred instantiation, then no
          instantiation is preferred and a compile time error is
          signalled.
        </p>
      </sect2>
      <sect2>
        <title>Qualified Types</title>
        <p>
          <font color="red"><em>Constraints are now permitted only as
              the outermost form. This section needs to be updated
              accordingly.</em></font>
        </p>
        <p>
          It is sometimes necessary to qualify the types of instances,
          type classes, constructed type definitions, or value
          declarations explicitly. A qualified type takes the general
          form:
        </p>
        <literallayout>
(forall (<em>constraint ... constraint</em>)
        <em>type</em>)</literallayout>
        <p>
          Qualified types may appear only as the types of binding
          patterns; they may not qualify expressions generally.  For
          example:
        </p>
        <literallayout>
(def add1:(forall ((Num 'a))
                     (fn 'a 'a))
  (lambda (x) (+ (the 'a 1) x)))</literallayout>
        <p indent="no">
          explicitly states that the <progident>add1</progident>
          procedure takes arguments whose type admit
          <progident>+</progident>, and therefore must be members of
          the <progident>Num</progident> type class.
        </p>
        <p>
          If multiple qualifications appear in the same binding
          pattern, they must unify. The following is legal, if
          somewhat obscure:
        </p>
        <literallayout>
(def
  (v1:(forall ((Eql 'a)) 'a), v2:'b)
  : (forall ((Num 'c))
      ((fn ('c) bool), 'b)) ...)</literallayout>
        <p indent="no">
          with the effect that <progident>v1</progident> receives the
          qualified type:
        </p>
<literallayout>
(forall ((Eql (fn ('c) bool))
         (Num 'c))
        (fn ('c) bool))</literallayout>
        <p indent="no">
          which will ultimately fail to type check, because functions
          are not admissable under value equality.
        </p>
        <p>
          Qualifications may also be applied to structure and union
          declarations, with the abstract syntax:
        </p>
<literallayout>
(forall (<em>constraints</em>)
  (struct (<em>struct-name</em> <em>tvars</em>) [<b>:unboxed</b>])
    <em>nm<sub>1</sub></em>[<b>:</b><em>t<sub>1</sub></em>] ... <em>nm<sub>n</sub></em>[<b>:</b><em>t<sub>n</sub></em>])
(forall (<em>constraints</em>)
  (union (<em>union-name</em> <em>tvars</em>) [<b>:unboxed</b>])
    <em>C<sub>1</sub> ... C<sub>n</sub></em>)
</literallayout>
        <p>
          Qualifications may similarly appear in the binding patterns
          of structure, union, and value declarations.
        </p>
      </sect2>
      <sect2>
        <title>Core Type Classes</title>
        <p>
          BitC defines several core type classes. These classes cover
          type relations that are required internally by the type
          checker, or in some cases relations that cannot be expressed
          within the language. All of these type classes are closed,
          though not necessarily finite &mdash; the compiler
          implements their membership internally.
        </p>
        <sect3>
          <title><progident>ref-types</progident></title>
          <p>
            <progident>(ref-types&nbsp;'a)</progident> is the type
            class consisting of all heap-allocated types:
            <progident>(ref&nbsp;'a)</progident>,
            <progident>(vector&nbsp;'a)</progident>, and
            <progident>string</progident>. Use of this type class is
            appropriate when a structure or union should not be
            instantiated over value types. The
            <progident>(nullable&nbsp;'a)</progident> type is an
            example of this.
          </p>
        </sect3>
        <sect3>
          <title><progident>copy-compat</progident></title>
          <p>
            <progident>(copy-compat&nbsp;'a&nbsp;'b)</progident> is an
            equivalence relation containing all pairs of types
            <progident>'a</progident> and <progident>'b</progident>
            that are ``copy compatible''. That is: all types for which
            a value of type <progident>'b</progident> may be assigned
            to a location of type
            <progident>(mutable&nbsp;'a)</progident>, and all types
            for which a formal parameter of type
            <progident>'a</progident> may be passed an actual
            parameter of type <progident>'b</progident>.
          </p>
        </sect3>
        <sect3>
          <title><progident>top-copy-compat</progident></title>
          <p>

            <progident>(top-copy-compat&nbsp;'a&nbsp;'b)</progident>
            is an equivalence relation containing all pairs of types
            <progident>'a</progident>, <progident>'b</progident> such
            that <progident>'a=='b</progident>,
            <progident>(mutable&nbsp;'a)=='b</progident>, or
            <progident>'a==(mutable&nbsp;'b)</progident>. That is: types
            that are the same ignoring top-level mutability.
          </p>
        </sect3>
      </sect2>
    </sect1>
    <sect1>
      <title>Binding of Values</title>
      <sect2>
	<title>Binding Patterns</title>
	<p>
	  Binding patterns are used to bind names to values. They
	  appear in the definition of formal parameters and in binding
	  forms such as <progident>def</progident>,
	  <progident>let</progident>, <progident>letrec</progident>,
	  and <progident>do</progident>. A binding pattern consists of
	  an identifier that is optionally qualified by a type:
	</p>
	<literallayout>
id
(the <em>T</em> <em>id</em>)
id : T
</literallayout>
        <p>
          In top-level bindings (those introduced by a top-level
          <progident>def</progident>, the
          <progident><em>id</em></progident> may be qualified by an
          interface binding name corresponding to some interface that
          the current unit of compilation provides (Section&nbsp;<xref
          ref="provide"/>). Thus, if
          <progident>my.interface</progident> is an interface name, it
          is legal for a source unit of compilation to contain:
        </p>
	<literallayout>
;; State that we are a provider
;; of my.interface:
(provide if my.interface)
;;...
;; Define some variable declared
;; in the interface:
(def (if.varname x)
  (+ x 1))</literallayout>
      </sect2>
      <sect2 id="def">
	<title>def</title>
	<p>
	  Variable and procedure bindings are introduced by
	  <progident>def</progident>:
	</p>
	<literallayout>
(def <em>bp</em> <em>e</em>)
(def (<em>id</em> [<em>bp<sub>1</sub></em> ... <em>bp<sub>n</sub></em>])
  <em>e</em> ... <em>e</em>)</literallayout>
	<p indent="no">
	  where each <progident><em>bp</em></progident> is a binding
	  pattern.  In the first form, the newly bound identifiers are
	  not in scope within the body. The second form permits
	  recursive bindings.
          Identifiers defined within a recursive
          <progident>def</progident> are deemed ``incomplete''
          until the end of the enclosing <progident>def</progident>
          form.
	</p>
        <p>
	  The right hand form of a <progident>def</progident> is
	  evaluated to obtain a value, which is then bound to the
	  identifier on the left-hand side.
        </p>
	<p>
	  Mutually recursive procedure definitions at top level can be
          achieved either by use of <progident>letrec</progident> or
          by declaring the procedures ahead of their definitions.
	</p>
      </sect2>
      <sect2>
	<title>Local Binding Forms</title>
        <sect3 id="let">
          <title>let</title>
<!--           <p> -->
<!--             BitC provides an extended form of the -->
<!--             <progident>let</progident> binding construct that are -->
<!--             familiar from Scheme.  BitC does not (currently) provide a -->
<!--             mechanism for local type declarations. -->
<!--           </p> -->
          <p>
            The <progident>let</progident> form provides a mechanism
            for locally binding identifiers to the result of an
            expression evaluation.  Each identifier bound in a
            <progident>let</progident> form must appear exactly once
            among the collection of binding patterns being bound.
            Evaluation of the initialization expressions occurs in
            order from <progident>e<sub>1</sub></progident> to
            <progident>e<sub>n</sub></progident>.  The environment in
            which the expression(s) are evaluated does not contain the
            identifiers being bound in the current
            <progident>let</progident> form.
          </p>
          <p>
            The syntax of <progident>let</progident> is:
          </p>
          <literallayout>
(let ((<em>bp<sub>1</sub></em> <em>e<sub>1</sub></em>)
      ...
      (<em>bp<sub>n</sub></em> <em>e<sub>n</sub></em>))
  <em>e<sub>body-1</sub></em>
  ...
  <em>e<sub>body-n</sub></em>)</literallayout>
          <p>
            One common form of these expressions is the one in which
            the left hand patterns are simple identifier names, as in:
          </p>
          <literallayout>
(let ((x <em>e<sub>1</sub></em>)
      ...
      (y <em>e<sub>2</sub></em>))
  ; <em>x, y are bound in:</em>
  <em>e<sub>body-1</sub></em>
  ...
  <em>e<sub>body-n</sub></em>)</literallayout>
          <p>
            The value of a <progident>let</progident> form
            is the value of the last form executed within the body.
          </p>
          <p>
            In similar languages, <progident>let</progident> is often
            presented as a form derived from
            <progident>lamdba</progident>. In BitC, as in other
            let-polymorphic languages, the value restriction for
            lambda arguments means that this is not (quite) true.
          </p>
        </sect3>
        <sect3 id="letrec">
          <title>letrec</title>
<!--           <p> -->
<!--             BitC provides an extended form of the -->
<!--             <progident>letrec</progident> binding construct that are -->
<!--             familiar from Scheme. -->
<!--           </p> -->
          <p>
            The <progident>letrec</progident> form provides a
            mechanism for locally binding identifiers to an expression
            value.  Each identifier bound in a
            <progident>letrec</progident> form must appear exactly
            once among the collection of binding patterns being
            bound. <!-- <font color="blue">The type of every identifier
            bound in a <progident>letrec</progident> must be some
            function type.</font><footnote>
              <p>
                This is a temporary limitation that will be removed
                shortly.
              </p>
            </footnote> --> Evaluation of the initialization
            expressions occurs in order from
            <progident>e<sub>1</sub></progident> to
            <progident>e<sub>n</sub></progident>.  The syntax of
            <progident>letrec</progident> is:
          </p>
          <literallayout>
(let ((<em>bp<sub>1</sub></em> <em>e<sub>1</sub></em>)
      ...
      (<em>bp<sub>n</sub></em> <em>e<sub>n</sub></em>))
  ; Identifiers in <em>bp<sub>i</sub></em>
  ; are bound in:
  <em>e<sub>body-1</sub></em>
  ...
  <em>e<sub>body-n</sub></em>)</literallayout>
          <p>
            The environment in
            which the expression(s) are evaluated contains (via
            unification) the identifiers being bound in the current
            <progident>letrec</progident> form. This allows
            <progident>letrec</progident> to bind recursive procedure
            definitions:
          </p>
          <literallayout>
(letrec
  ((odd
     (lambda (x) ; odd
       (cond ((= x 0) false)
             ((&lt; x 0) (odd (- x)))
             (otherwise
               (not
                 (even (- x 1)))))))
   (even
     (lambda (x) ; even
       (cond ((= x 0) true)
             ((&lt; x 0) (even (- x)))
             (otherwise
               (not
                 (odd (- x 1))))))))
  <em>body</em>)</literallayout>
<!-- 	<p> -->
<!-- 	  The ``named <progident>let</progident>'' syntax is a -->
<!-- 	  shorthand for a <progident>letrec</progident> that wraps a -->
<!-- 	  <progident>lambda</progident>, enabling a local recursive -->
<!-- 	  procedure: -->
<!-- 	</p> -->
<!-- 	<literallayout> -->
<!-- (let fn ((<em>bp<sub>1</sub></em> <em>e<sub>1</sub></em>) -->
<!--          (<em>bp<sub>2</sub></em> <em>e<sub>2</sub></em>)) -->
<!--   <em>e<sub>body</sub></em>) = -->
<!-- (letrec  -->
<!--   ((fn (lambda (<em>p<sub>1</sub></em>, -->
<!--                 <em>p<sub>2</sub></em>) -->
<!--          <em>e<sub>body</sub></em>))) -->
<!--     (fn (<em>e<sub>1</sub></em>, <em>e<sub>2</sub></em>))) -->
<!-- </literallayout> -->
          <p>
            The value of a <progident>letrec</progident> form is the value
            of the last form executed within the body.
          </p>
          <p>
            Within the defining expressions of a
            <progident>letrec</progident> form, use of the identifiers
            being defined is subject to the same restrictions
            described for <progident>def</progident>. This ensures
            that cyclical constant data cannot be
            introduced.<footnote><p>Cyclical constants impede
            termination reasoning in the prover.</p>
            </footnote>
          </p>
<!--           <p> -->
<!--             Any binding pattern appearing in the -->
<!--             <progident><em>bp<sub>i</sub></em></progident> position in -->
<!--             a <progident>letrec</progident> must be statically -->
<!--             decomposable at compile time. It is not sufficient that -->
<!--             the corresponding -->
<!--             <progident><em>e<sub>i</sub></em></progident> be of -->
<!--             compatible type. This restriction allows the binding -->
<!--             patterns to be flattened away by the compiler without -->
<!--             internally violating the completeness -->
<!--             restriction.<footnote><p>The alternative was to disallow -->
<!--             binding patterns in <progident>letrec</progident> -->
<!--             forms. The static decomposition constraint preserves -->
<!--             greater syntactic consistency with -->
<!--             <progident>let</progident>.</p> -->
<!--             </footnote> -->
<!--           </p> -->
        </sect3>
        <sect3 id="local-def">
          <title>local defininitions</title>
          <p>
            The <progident>def</progident> form may be used to
            introduce local definitions in any expression sequence,
            provided the local definition is not the last form of the
            sequence.  For this purpose, the bodies of
            <progident>begin</progident>,
            <progident>lambda</progident> (including those implied by
            derived form rewrites), <progident>let</progident>,
            <progident>letrec</progident>,
            <progident>while</progident>, or
            <progident>do-while</progident> constitute expression
            sequences.
          </p>
          <p>
            Local <progident>def</progident> is a derived form.
            The canonical rewriting of the local
            <progident>def</progident> form using core language
            constructs is:
          </p>
          <literallayout>
(begin ...
  (def id e<sub>def</sub>) e<sub>2</sub> [...]) =&gt;
(begin ...
  (let ((id e<sub>def</sub>))
    e<sub>2</sub> [...]))
(begin ...
  (def (id [args]) e<sub>def</sub>) e<sub>2</sub> [...]) =&gt;
(begin ...
  (letrec ((id (lambda(args) e<sub>def</sub>)))
    e<sub>2</sub> [...]))</literallayout>
          <p indent="no">
            This rewrite proceeds left to right. Successive definitions
            are gathered into <progident>let</progident> or
            <progident>letrec</progident> forms that are progressively
            more deeply nested, which means that later local
            definitions of an identifier shadow earlier definitions.
          </p>
        </sect3>
      </sect2>
      <sect2>
        <title>Value Non-Recursion</title>
        <p>
          In any recursive binding (introduced by
          <progident>letrec</progident> or
          <progident>def</progident>) such as:
        </p>
        <literallayout>
(def <em>bp</em> <em>e</em>)</literallayout>
        <p indent="no">
          if <progident><em>id</em></progident> is an identifier
          that appears in the binding pattern (and is therefore
          incomplete), free occurrences of
          <progident><em>id</em></progident> in
          <progident><em>e</em></progident> must occur only within a
          <progident>lambda</progident> body. This ensures that
          <progident><em>id</em></progident> will be initialized
          before it is used.
        </p>
        <p>
          This restriction intentionally prevents infinitely recursive
          data constant definitions.
        </p>
      </sect2>
      <sect2>
        <title>Static Initialization Restriction</title>
        <p>
          <font color="red">I continue to look for a more rigorous
            way to express the following requirement.</font>
        </p>
        <p>
          Statically declared (global) variables must be initialized
          before the main entry point is entered. This presents a
          challenge of specification. The language definition must
          impose a sufficient ordering constraint on initializations
          to ensure that no initializer can depend (transitively) on
          any uninitialized variable. To ensure this, we introduce
          the notions of ``compile-time evaluable'' and ``compile
          time applicable'' expressions, and the restriction that
          every initializing expression of a statically declared
          variable must be compile-time evaluable.<footnote>
            <p>
              This notion is conceptually related to the Standard ML
              notion of ``syntactic constants,'' and achieves the
              same goal. The definition of ``compile-time
              evaluable'' is slightly richer, and allows for more
              expressive initializing expressions.
            </p>
          </footnote> Informally: it must be possible for the
          compiler to evaluate the initializing expression at
          compile time without (conservatively) referencing any
          uninitialized variable.
        </p>
        <p>
          Literals are compile-time evaluable.
        </p>
        <p>
          A locally bound identifier is compile-time evaluable
          exactly if its initializing expression is compile-time
          evaluable. It is compile-time applicable exactly if the
          return value of its defining expression is compile-time
          applicable.
        </p>
        <p>
          A globally bound identifier is compile-time evaluable
          provided its definition is lexically observable and
          compile-time evaluable. By ``lexically observable,'' we
          mean that either (a) it appears as a lexically preceding
          definition in the same unit of compilation, or (b) there
          exists some chain of interfaces
          <progident>I<sub>0</sub></progident>...<progident>I<sub><em>n</em></sub></progident>
          such that the global identifier is defined in
          <progident>I<sub><em>n</em></sub></progident>, the unit
          defining <progident>out</progident> imports
          <progident>I<sub>0</sub></progident>,
          <progident>I<sub>0</sub></progident> imports
          <progident>I<sub>1</sub></progident>,
          <progident>I<sub>1</sub></progident> imports
          <progident>I<sub>2</sub></progident> ... and
          <progident>I<sub><em>n-1</em></sub></progident> imports
          <progident>I<sub><em>n</em></sub></progident>.
        </p>
        <p>
          A globally bound identifier is compile-time applicable
          provided it is of function type, it is lexically
          observable, and all expressions appearing in its defining
          <progident>lambda</progident> form are compile-time
          evaluable. For purposes of this analysis, it is assumed
          that any formal parameter of the function is both
          compile-time evaluable and (if of function type)
          compile-time applicable.
        </p>
        <p>
          Any expression <em>other than</em> an application or an
          assignment is compile-time evaluable provided that all of
          its free identifiers are
          compile-time evaluable.
        </p>
        <p>
          An application is compile-time evaluable provided that (a)
          the expression in the function position is compile-time
          evaluable, (b) all of its arguments are compile-time
          evaluable, and (c) any arguments of function type are
          compile-time evaluable.
        </p>
        <p>
          An assignment (as with <progident>set!</progident>) is
          compile-time evaluable provided its expression is
          <em>both</em> compile-time evaluable and (if of function
          type) compile-time applicable. This prevents later
          assignments from altering the compile-time evaluability of
          previously defined identifiers.
        </p>
        <p>
          <b>Dangling:</b>
        </p>
        <p>
          The result of an expression evaluation (including
          application and constructor application) is observably known
          if (a) the definitions of all identifiers that are free in
          the expression are observably known, and (b) any procedure
          that is applied is observably applicable.  Requirement (b)
          is satisfied by definition for all type constructors.
        </p>
        <p>
          Note that these definitions are conservative with respect to
          mutability. Because no initializing expression can reference
          an observably unknown value, nor perform an application that
          is not observably applicable, it follows that no assignment
          performed from within an initializing expression can cause
          an identifier to transition from observably known to
          observably unknown.
        </p>
      </sect2>
    </sect1>
    <sect1>
      <title>Declarations</title>
      <p>
        The <progident>proclaim</progident> form is used to provide
        opaque value declarations. The declaration:
      </p>
      <literallayout>
(proclaim x:int32)</literallayout>
        <p indent="no">
        states that <progident>x</progident> is the name of a value of
        type <progident>int32</progident> whose definition and
        initialization is provided by some implementing unit of
        compilation. This form can legally appear only at top level
        within a source unit of compilation or within an interface.
      </p>
      <p>
        The identifier declared by a <progident>proclaim</progident>
        form is considered incomplete. If a completing definition is
        later provided within the same compilation unit, the
        identifier is considered complete in the balance of the
        defining compilation unit after the the close of its defining
        form.  An incomplete declaration may be used within a
        procedure, but may not be used as part of a top-level
        initializer (see <progident>def</progident>,
        Section&nbsp;<xref ref="def"/>).
      </p>
      <p>
        It is occasionally necessary to make reference to procedures
        or values that are implemented by an externally provided
        runtime library. This may be accomplished by an
        <progident>external</progident> declaration:
      </p>
      <literallayout>
(proclaim proc:(fn (int32) char)
          external)
(proclaim proc:(fn (int32) char)
          external ident)</literallayout>
      <p indent="no">
        This has the effect of advising the BitC compiler that no
        definition of this identifier will be supplied in BitC source
        code. It is primarily intended to support portions of the BitC
        runtime library. Use of this mechanism for other purposes is
        strongly discouraged, and we reserve the right to revise this
        syntax incompatibly in future revisions of the BitC
        specification.
      </p>
      <p>
        If a proclaimed external procedure provides an optional
        trailing <progident>ident</progident>, this identifier will be
        used verbatim in the generated code in place of the normal
        identifier name generated by BitC. The trailing identifier is
        permitted only if the external procedure has non-polymorphic
        type.
      </p>
    </sect1>
    <sect1>
      <title>Expressions</title>
      <sect2>
	<title>Literals</title>
	<p>
	  Every literal is an expression whose type is the type of the
	  literal (as described above) and whose value is the literal
	  value itself.
	</p>
      </sect2>
      <sect2>
	<title>Identifiers</title>
	<p>
	  Every lexically valid identifier is an expression whose type
	  is the type of the identifier and whose value is the value
	  to which the identifier is bound.
	</p>
      </sect2>
      <sect2>
        <title><progident>sizeof</progident>,
          <progident>bitsizeof</progident></title>
        <p>
          The <progident>sizeof</progident> and
          <progident>bitsizeof</progident> forms report the size, in
          bytes (respectively bits), of a type. When applied to
          expressions, they report the size of the <em>type</em> of
          that expression. The expression is typed by the compiler,
          but it is not evaluated.
        </p>
        <literallayout>
sizeof(<em>e</em>)
sizeof(<em>T</em>)
bitsizeof(<em>e</em>)
bitsizeof(<em>T</em>)</literallayout>
        <p indent="no">
          The return type of <progident>sizeof</progident>,
          <progident>bitsizeof</progident> is <progident>word</progident>.
        </p>
      </sect2>
      <sect2>
	<title>Type-Qualified Expressions</title>
	<p>
	  Any expression <progident><em>e</em></progident> may be
	  qualified with an explicit result type by writing either of
        </p>
        <literallayout>
(the <em>T</em> <em>e</em>)
<em>e</em> : <em>T</em></literallayout>
        <p indent="no">
	  where <progident><em>T</em></progident> is a type. This
	  indicates that the result type of the
	  <progident>the</progident> form is constrained to be of type
	  <progident><em>T</em></progident>. The
	  <progident>the</progident> form is syntax, its
	  expression argument is not conveyed by application, and is
	  therefore not subject to copying as a consequence of type
	  qualification.
        </p>
        <p>
          The result <em>value</em> of the expression is not changed
	  by type qualification, except to the extent that a type
	  restriction may lead the inference engine to resolve the
	  types of other expressions and the selection of overloaded
	  primitive arithmetic operators in ways that produce
	  different results.
	</p>
        <p>
          <leadin>Syntactic Restriction</leadin> The
          <progident><em>e</em>:<em>T</em></progident> convenience
          syntax is not permitted in combination with the member
          selection convenience syntax ``.''. The sequence of grammar
          expansions:
        </p>
        <literallayout>
<em>expr</em> -> <em>expr</em>.Id
<em>expr</em> -> <em>expr</em>:<em>type</em>.Id
<em>expr</em> -> <em>expr</em>:Id.Id.Id
               ^</literallayout>
        <p indent="no">
          leads to a shift/reduce conflict at the indicated position.
          The grammar resolves this by disallowing the helper
          type-qualification syntax in this context. If required, a
          type qualification in this context can be obtained using
          either of the following alternatives:
        </p>
        <literallayout>
(the <em>T</em> <em>e</em>).Id
(member <em>e</em>:<em>T</em> Id)</literallayout>
<!--         <p> -->
<!--           The expression: -->
<!--         </p> -->
<!--           <literallayout> -->
<!-- <em>e</em><b>:</b><em>T</em> -->
<!-- </literallayout> -->
<!--           <p indent="no"> -->
<!--             is a convenience shorthand for -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- (type-qualify <em>e</em> <em>T</em>) -->
<!-- </literallayout> -->
      </sect2>
      <sect2>
        <title>Value Constructors</title>
        <sect3>
          <title>unit</title>
          <p>
            The expression:
          </p>
          <literallayout>
()</literallayout>
          <p indent="no">
            denotes the singleton unit value.
          </p>
        </sect3>
        <sect3>
          <title>MakeVector</title>
          <p>
            The expression:
          </p>
          <literallayout>
(MakeVector <em>e<sub>len</sub></em> <em>e<sub>init</sub></em>)</literallayout>
          <p indent="no">
            creates a new vector whose length is determined by the
            value of the expression
            <progident><em>e<sub>len</sub></em></progident>, which
            must evaluate to a value of type
            <progident>word</progident>.  The argument
            <progident><em>e<sub>init</sub></em></progident> must be a
            function from word to some type <em>T</em>, where the
            vector created will be of type
            <progident>(vector&nbsp;<em>T</em>)</progident>. The
            initializer value for each cell will be obtained by
            invoking the procedure
            <progident><em>e<sub>init</sub></em></progident> a total
            of <progident><em>e<sub>len</sub></em></progident> times,
            passing as an argument the index of the vector position to
            be initialized. The procedure
            <progident><em>e<sub>init</sub></em></progident> should
            return the desired initializer value for the corresponding
            position.
          </p>
          <p>
            For example, the procedure
            <progident>list-&gt;vector</progident> may be written as:
          </p>
<literallayout>
(import bitc.list as ls)
(def (list->vector lst)
  (MakeVector
    (length lst)
    (lambda (n)
       (ls.list-nth lst n))))</literallayout>
          <p>
            Care should be taken to ensure that the type returned by
            the initializer function is mutable if the slots of the
            vector are intended to be mutable.
          </p>
        </sect3>
        <sect3>
          <title>array, vector</title>
          <p>
            The expressions:
          </p>
          <literallayout>
(array <em>e<sub>0</sub></em> ... <em>e<sub>n</sub></em>)
(vector <em>e<sub>0</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
          <p indent="no">
            create a new array (respectively, vector) whose length is
            determined by number of arguments. The first argument
            expression becomes the first cell of the created array
            (respectively, vector), the second becomes the second, and
            so forth. All expressions must be of like type.
          </p>
        </sect3>
        <sect3>
          <title>Convenience Syntax</title>
          <p>
            <em>Derived forms</em>
          </p>
          <p>
            The following are right-associative convenience syntax for
            types defined in the standard prelude:
          </p>
          <literallayout>
(a,b) =&gt; (pair a b)
(a,b,c) =&gt; (pair a (pair b c))</literallayout>

<!-- At some point we seem to have lost the following convenience syntax:
[]    =&gt; nil
[a] =&gt; (cons a nil)
[a,b] =&gt; (cons a (cons b nil)) -->
        </sect3>
      </sect2>
      <sect2>
        <title>Expression Sequences</title>
        <p>
          The expression:
        </p>
        <literallayout>
(begin <em>e<sub>1</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
        <p indent="no">
          executes the forms
          <progident><em>e<sub>1</sub></em></progident> through
          <progident><em>e<sub>n</sub></em></progident> in sequence,
          where each form is an expression. The value of a
          <progident>begin</progident> expression is the value
          produced by the last <em>expression</em> executed in the
          begin block.
        </p>
      </sect2>
      <sect2 id="labeled-blocks">
        <title>Labeled Sequences and Escape</title>
        <p>
          The expression:
        </p>
        <literallayout>
(block <em>ident</em> <em>e<sub>1</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
        <p indent="no">
          executes the forms
          <progident><em>e<sub>1</sub></em></progident> through
          <progident><em>e<sub>n</sub></em></progident> in sequence,
          where each form is an expression. The value of a
          <progident>block</progident> expression is the value
          produced by the last <em>expression</em> executed within the
          block.
        </p>
        <p>
          Within the body of the <progident>block</progident> form,
          the identifier <progident><em>ident</em></progident> is
          lexically bound as an escape label, and the expression
        </p>
        <literallayout>
(from <em>ident</em> return <em>e</em>)</literallayout>
        <p>
          Causes an immediate return from the
          <progident>block</progident> with the value computed by the
          expression <progident><em>e</em></progident>.  Control does
          not continue past the end of this form.
        </p>
        <p>
          The identifier
          <em>ident</em> must be in scope as an escape label, and the
          <progident>block</progident> and its associated
          <progident>return-from</progident> must appear within the
          body of the same lambda form. That is: the
          <progident>return-from</progident> may <em>not</em> appear
          within a <progident>lambda</progident> that is in turn
          nested within a <progident>block</progident>.
        </p>
      </sect2>
      <sect2>
        <title>Iteration</title>
        <p>
          <em>Derived form</em>
        </p>
        <p>
          BitC provides the looping construct
          <progident>loop</progident>, which conditionally evaluates its body
          multiple times.
        </p>
        <literallayout>
(loop ((<em>bp<sub>1</sub></em> <em>e<sub>init-1</sub></em> <em>e<sub>step-1</sub></em>)
       ...
       (<em>bp<sub>n</sub></em> <em>e<sub>init-n</sub></em> <em>e<sub>step-n</sub></em>))
    (<em>e<sub>test</sub></em> <em>e<sub>result</sub></em>)
   <em>e<sub>body-1</sub></em>
   ...
   <em>e<sub>body-n</sub></em>)</literallayout>
        <p>
          Do is an iteration construct taken from Scheme <cite
          ref="kelsey1998r5rs"/>. It specifies a set of variables to
          be bound along with an initializer expression and an update
          expression for each variable. Evaluation of the
          <progident>loop</progident> form proceeds as follows:
        </p>
        <p>
          The <progident><em>e<sub>init-i</sub></em></progident>
          expressions are evaluated in order in the lexical context
          containing the <progident>do</progident> form. In this
          context, the variables bound by the loop have not yet been
          bound. All other expressions are evaluated within an inner
          lexical context that includes the
          <progident>loop</progident>-bound variables.  After all of the
          initialization values are computed in order, the
          <progident>loop</progident>-bound variables are bound to the
          initial results in parallel, and body processing begins.
        </p>
        <p>
          At the start of each pass over the body, the expression
          <progident><em>e<sub>test</sub></em></progident> is
          evaluated. If this expression returns <b>true</b>, then
          <progident><em>e<sub>result</sub></em></progident> is
          evaluated and its result returned. Otherwise, the expresions
          of the body are evaluated in sequence.
        </p>
        <p>
          At the end of each execution of the loop body, the
          <progident><em>e<sub>step-i</sub></em></progident> expressions
          are evaluated in sequence. Once all of the expression values
          have been evaluated, the 
          <progident>loop</progident>-bound variables are bound to the
          newly computed results in parallel and a new pass is
          initiated over the loop body as previously described.
        </p>
        <p>
          The execution of a given pass of the loop body can be
          terminated immediately by the:
        </p>
        <literallayout>
(continue)</literallayout>
        <p indent="no">
          form. This causes an immediate transfer of control to the
          end of the nearest enclosing loop body. Note that the
          initializer, step, test, and result expressions are
          <em>not</em> part of the loop body.
        </p>
        <p>
          The <progident>loop</progident> form is not
          let-polymorphic. In consequence, the binding patterns bound
          within the <progident>do</progident> form are not
          polymorphic bindings.
        </p>
      </sect2>
      <sect2>
        <title>Interface Member Reference</title>
        <p>
          If <progident><em>if</em></progident> is an identifier
          naming an interface binding established through
          <progident>import</progident>, and
          <progident><em>id</em></progident> is an identifier defined
          in that interface, then either of:
        </p>
        <literallayout>
(member <em>if</em> <em>id</em>)
<em>if</em>.<em>id</em></literallayout>
        <p indent="no">
          is an expression that returns the value of that identifier.
          The returned value is a location, and can be used as an
          argument to <progident>set!</progident>.
        </p>
      </sect2>
      <sect2>
        <title>Structure, Repr Field Reference</title>
        <p>
          If <progident><em>e<sub>loc</sub></em></progident> is a
          location expression of structure or repr type, and
          <progident><em>field</em></progident> is an identifier
          naming some invariant field in that type then either of:
        </p>
        <literallayout>
(member <em>e<sub>loc</sub></em> <em>field</em>)
<em>e<sub>loc</sub></em><b>.</b><em>field</em></literallayout>
        <p indent="no">
          is an expression that returns the field
          value. <progident>member</progident> is a syntactic
          form. The returned value is a location, and can be used as
          an argument to <progident>set!</progident>.
        </p>
      </sect2>
      <sect2 id="tagref">
        <title>Union, Repr Tag Reference</title>
        <p>
          If <progident><em>e<sub>loc</sub></em></progident> is a
          location expression of union or repr type, and
          <progident><em>tagid</em></progident> is an identifier
          naming some union discriminator tag in that union or repr
          type then either of:
        </p>
        <literallayout>
(member <em>e<sub>loc</sub></em> <em>tagid</em>)
<em>e<sub>loc</sub></em>.<em>tagid</em>
</literallayout>
        <p indent="no">
          is a boolean expression that returns true exactly if the tag
          value of the corresponding tag is
          <progident>tagid</progident>.
        </p>
      </sect2>
      <sect2>
        <title>Array and Vector Expressions</title>
        <sect3>
          <title>Array, ArrayRef, and Vector lengths</title>
          <p>
            If <progident><em>e</em></progident> is an expression of
            array, ArrayRef, or vector type, then
          </p>
          <literallayout>
<em>e</em>.length
</literallayout>
          <p indent="no">
            returns a <progident>word</progident> whose value is the
            number of elements in the array, ArrayRef, or vector.
          </p>
        </sect3>
        <sect3>
          <title>Array, ArrayRef, and Vector indexing</title>
          <p>
            If <progident><em>e</em></progident> is an expression of
            array, ArrayRef, or vector) type, and
            <progident><em>e<sub>i</sub></em></progident> is an
            expression with result type <progident>word</progident>,
            then:
          </p>
          <literallayout>
<em>e</em>[<em>e<sub>i</sub></em>]</literallayout>
          <p indent="no">
            returns the
            <em>e<sub>i</sub></em>'th element of the array, ArrayRef,
            or vector.  If the value
            <progident><em>e<sub>i</sub></em></progident> is greater
            than or equal to the length of the array, ArrayRef, or
            vector), then a <progident>IndexBoundsError</progident>
            exception is thrown.
          </p>
          <p>
            Note that type inference for these types is currently
            incomplete. In the absence of declaration, the type
            <progident>vector</progident> will be inferred for
            <em>e</em>. Since the type <progident>ArrayRef</progident>
            can only be declared at parameters and is never inferred,
            a surprising inference result probably means that
            something needs to be declared as an array type. Future
            extensions of BitC are expected to provide generalized
            accessors, after which this inconvenience will be
            (backwards compatibly) resolved.
          </p>
        </sect3>
      </sect2>
      <sect2>
	<title>Procedure Values</title>
	<p>
	  Procedure values are introduced by the keyword
	  <progident>lambda</progident>.  In contrast to Scheme,
	  Haskell, and Standard ML, BitC procedures take zero or more
	  arguments.  The syntax of a procedure definition is:
	</p>
	<literallayout>
(lambda ([<em>bp<sub>1</sub></em> ... <em>bp<sub>n</sub></em>]
  <em>e<sub>1</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
	<p indent="no">
	  where each <progident><em>bp<sub>i</sub></em></progident> is
	  a binding pattern matching the formal parameters of the
	  procedure and
	  <progident><em>e<sub>1</sub></em>...<em>e<sub>n</sub></em></progident>
	  is the body of the procedure. The return value of the
	  procedure is the value computed by the last expression
	  executed in the body.
	</p>
	<p>
	  Each formal argument binding pattern defines a set of
	  variable bindings that are in scope in the body of the
	  lambda. Each formal argument binding pattern is unified with
	  its corresponding actual parameter. Any identifier that is
	  free in the binding pattern is unified with the structurally
	  corresponding element of its associated actual parameter.
        </p>
        <p>
          BitC argument and return value passing are ``by value.''
          Formal argument and return values must be of value type, which
          means that <em>references</em> can be passed, but the values
          denoted by these references cannot.  The ``by value'' policy
          also implies that local variables are <em>copies</em> of their
          initializing expressions, which may yield surprising results
          if the initializer is of mutable type. A
          <progident>let</progident> binding is not an alias for its
          initializer. A <progident>let</progident> binding of a (top
          level) mutable value cannot simply be substituted by
          &beta;-reduction into the body of the
          <progident>let</progident> form.
        </p>
        <sect3>
          <title>By-Reference Parameters</title>
          <p>
            By-reference
            parameters provide an optimized argument passing mechanism
            for parameters. A by-reference formal parameter is an
            <em>alias</em> of the passed argument; the internal
            implementation passes a pointer to the argument
            rather than a copy of the argument. A by-reference
            parameter may be a reference to an component of an
            aggregate type, such as a field or a vector member.
          </p>
          <p>
            The BitC specification permits the representation of a
            by-reference parameter to be either one word or two. This
            is intended to simplify the handling of inner pointers by
            the garbage collector.
          </p>
          <p>
            By-reference parameters can escape only as part of a
            first-class procedure, but the lifetime of a by-reference
            parameter cannot exceed the lifetime of its containing
            scope.
          </p>
          <p>
            The formal parameters of a function can be declared as by
            by-reference parameters as in:            
          </p>
          <literallayout>
(lambda (x:(by-ref &tau;) ...) ...)         ;; or
(def (f x:(by-ref &tau;) ...) ...)</literallayout>
          <p>
            A <progident>by-ref</progident> declaration can only
            appear as a qualifier for the type of a  parameter. This
            is a syntactic restriction.
          </p>
<!-- The bit about dereferencing should not be stated in the -->
<!-- specification of the language. The bit about non-escaping is -->
<!-- mistaken; a first-class procedure value having a by-reference -->
<!-- parameter can escape, taking the by-reference parameter with it. -->
<!--           <p> -->
<!--             By-reference parameters are implicitly -->
<!--             dereferenced at all use-occurrences except as the -->
<!--             target of an assignment.  -->
<!--             This ensures that by-reference parameters cannot -->
<!--             be captured within data-structures or by escaping -->
<!--             closures.  -->
<!--           </p> -->
          <p>
            A function with a formal parameter declared as 
            <progident>(by-ref &tau;)</progident>
            can only be apllied to an actual argument of type 
            <progident>&tau;</progident>. That is, unlike 
            normal parameters, an actual argument of type 
            <progident>(mutable &tau;)</progident>
            where the formal parameter is of type 
            &tau; 
            or <foreignphrase>vice versa</foreignphrase> is not
            permitted
            [Here, &tau; &ne; (mutable &tau;<sup>&prime;</sup>)].
          </p>
        </sect3>
      </sect2>
      <sect2 id="explicit-return">
        <title>Explicit Procedure Return</title>
        <p>
          <em>Derived form</em>
        </p>
	<p>
	  The expression:
	</p>
	<literallayout>
(return <em>e</em>)</literallayout>
        <p>
          causes the nearest enclosing <progident>lambda</progident>
          form to immediately return the value computed by the
          expression <progident><em>e</em></progident>. This form
          executes a form of labeled break. Control does not continue
          past the end of this form.
        </p>
        <p>
          <leadin>Derivation</leadin> The canonical rewriting of
          <progident>return</progident> requires that the containing
          <progident>lambda</progident> also be rewritten:
        </p>
        <literallayout>
(lambda (<em>args</em>) <em>body</em>) =&gt;
(lambda (<em>args</em>) 
  (block __return <em>body</em>))

(return <em>e</em>) =&gt;
(from __return return <em>e</em>)</literallayout>
      </sect2>
      <sect2>
	<title>Function Application</title>
	<p>
	  The expression:
	</p>
	<literallayout>
(<em>e<sub>fn</sub></em> [<em>e<sub>1</sub></em> ... <em>e<sub>n</sub></em>])</literallayout>
	<p indent="no">
	  denotes function application. The evaluation of the
	  expression <progident><em>e<sub>fn</sub></em></progident>
	  must yield a procedure value. 
<!--           Applications taking a single -->
<!-- 	  argument are handled by passing the argument expression -->
<!-- 	  directly. Applications taking zero, two, or more arguments -->
<!-- 	  are normalized to applications of a single argument by -->
<!-- 	  implicit pair construction and unit introduction: -->
        </p>
<!--         <literallayout> -->
<!-- (<em>e<sub>fn</sub></em>) =&gt; (<em>e<sub>fn</sub></em> ()) -->
<!-- (<em>e<sub>fn</sub></em> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> [ ... <em>e<sub>n</sub></em>]) =&gt; -->
<!--   (<em>e<sub>fn</sub></em> (<em>e<sub>1</sub></em>, <em>e<sub>1</sub></em> [, ... <em>e<sub>n</sub></em>])) -->
<!-- </literallayout> -->
<!--         <p> -->
<!--           The type of thedthis procedure's argument -->
<!-- 	  must be compatible with the type -->
<!-- 	</p> -->
<!-- 	<literallayout> -->
<!-- ([<em>T<sub>1</sub></em>[, ... <em>T<sub>n</sub></em>]]) -->
<!-- </literallayout> -->
<!-- 	<p indent="no"> -->
<!-- 	  where each <progident><em>T<sub>i</sub></em></progident> is -->
<!-- 	  the return type of the corresponding expression -->
<!-- 	  <progident><em>e<sub>i</sub></em></progident>. -->
<!-- 	</p> -->
        <p>
          Note that the identifier <progident><em>fn</em></progident>
          may either evaluate to a procedure or may name a value
          constructor for a named constructed type.
        </p>
      </sect2>
      <sect2 id="conditional-execution">
	<title>Conditional Execution</title>
        <sect3 id="condexec:if">
          <title>if</title>
          <p>
            <em>Derived form</em>
          </p>
          <p>
            The <progident>if</progident> form is used to represent conditional
            control flow:
          </p>
          <literallayout>
(if <em>e<sub>test</sub></em> <em>e<sub>then</sub></em> <em>e<sub>else</sub></em>)</literallayout>
          <p>
            Where <progident><em>e<sub>test</sub></em></progident>,
            <progident><em>e<sub>then</sub></em></progident>, and
            <progident><em>e<sub>else</sub></em></progident>, are BitC
            expressions.
          </p>
          <p>
            The value of an <progident>if</progident> form is either
            the value of the
            <progident><em>e<sub>then</sub></em></progident> form or
            the value of the
            <progident><em>e<sub>else</sub></em></progident>
            expression. Exactly one of the
            <progident><em>e<sub>then</sub></em></progident> or
            <progident><em>e<sub>else</sub></em></progident> forms is
            evaluated.
          </p>
          <p>
            The value returned by the
            <progident><em>e<sub>test</sub></em></progident> expression
            must be of boolean type.
          </p>
          <p>
            The types of the
            <progident><em>e<sub>then</sub></em></progident> and
            <progident><em>e<sub>else</sub></em></progident> must be
            compatible.
          </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>if</progident> is:
          </p>
          <literallayout>
(if <em>e<sub>test</sub></em> <em>e<sub>then</sub></em> <em>e<sub>else</sub></em>) =&gt;
(case <em>e<sub>test</sub></em>
  (true <em>e<sub>then</sub></em>)
  (false <em>e<sub>else</sub></em>))
(if <em>e<sub>test</sub></em> <em>e<sub>then</sub></em>) =&gt;
(case <em>e<sub>test</sub></em>
  (true <em>e<sub>then</sub></em> ())
  (false ())</literallayout>
        </sect3>
        <sect3 id="condexec:when">
          <title>when</title>
          <p>
            <em>Derived form</em>
          </p>
          <p>
            The <progident>when</progident> form is used to represent
            conditional control flow when only one condition is of interest:
          </p>
          <literallayout>
(when <em>e<sub>test</sub></em> <em>e<sub>then</sub></em> ...)</literallayout>
          <p>
            Where <progident><em>e<sub>test</sub></em></progident> and
            <progident><em>e<sub>then</sub></em></progident> are BitC
            expressions.
          </p>
          <p>
            The 
            <progident><em>e<sub>test</sub></em></progident> expression
            must compatible with boolean. There are no restrictions on
            the types of the
            <progident><em>e<sub>then</sub></em></progident> forms.
            The type of a <progident>when</progident> form is Unit.
          </p>
          <p>
            The 
            <progident><em>e<sub>then</sub></em></progident> forms are
            evaluated only if the value of the 
            <progident><em>e<sub>test</sub></em></progident> form is
            <progident>true</progident>.
          </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>when</progident> is:
          </p>
          <literallayout>
(when <em>e<sub>test</sub></em> <em>e<sub>then</sub></em> ...) =&gt;
(case <em>e<sub>test</sub></em>
  (true <em>e<sub>then</sub></em> ... ())
  (false ()))</literallayout>
        </sect3>
	<sect3 id="condexec:not">
	  <title>not</title>
          <p>
            <em>Derived form</em>
          </p>
	  <p>
	    The <progident>not</progident> form is used to invert a
	    boolean result. The form:
	  </p>
	  <literallayout>
(not <em>e</em>)</literallayout>
          <p>
            returns true if its argument evaluates to false, and false
            it its argument evaluates to true.
          </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>not</progident> is:
          </p>
          <literallayout>
(not <em>e</em>) =&gt;
(if <em>e</em> false true)</literallayout>
        </sect3>
	<sect3 id="condexec:and">
	  <title>and</title>
          <p>
            <em>Derived form</em>
          </p>
	  <p>
	    The <progident>and</progident> form is used to perform lazy
	    expression evaluation. The form:
	  </p>
	  <literallayout>
(and <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
	  <p>
	    returns true if every one of the expressions
	    <progident><em>e<sub>1</sub></em>
	      ... <em>e<sub>n</sub></em></progident> evaluates as
	    true. Expressions are evaluated left to right. Each
	    expression must return a result of type
	    <progident>bool</progident>. If any expression evaluates as
	    <progident>false</progident>, no further expressions are
	    evaluated. For this reason, the <progident>and</progident>
	    form cannot be implemented as a procedure.
	  </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>and</progident> proceeds by first rewriting
            multiargument <progident>and</progident> forms into forms
            of no more than two arguments:
          </p>
          <literallayout>
(and <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>) =&gt;
(and <em>e<sub>1</sub></em>
     (and <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>))</literallayout>
          <p indent="no">
            and then rewriting each two argument
            <progident>and</progident> form as:
          </p>
          <literallayout>
(and <em>e<sub>1</sub></em> <em>e<sub>2</sub></em>) =&gt;
(if <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> false)</literallayout>
	</sect3>
	<sect3 id="condexec:or">
	  <title>or</title>
          <p>
            <em>Derived form</em>
          </p>
	  <p>
	    The <progident>or</progident> form is used to perform lazy
	    expression evaluation. The form:
	  </p>
	  <literallayout>
(or <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>)</literallayout>
	  <p>
	    returns true if any of the expressions
	    <progident><em>e<sub>1</sub></em>
	    ... <em>e<sub>n</sub></em></progident> evaluates as
	    true. Expressions are evaluated left to right. Each
	    expression must return a result of type
	    <progident>bool</progident>. If any expression evaluates
	    as <progident>true</progident>, no further expressions are
	    evaluated. For this reason, the <progident>or</progident>
	    form cannot be implemented as a procedure.
	  </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>or</progident> proceeds by first rewriting
            multiargument <progident>or</progident> forms into forms
            of no more than two arguments:
          </p>
          <literallayout>
(or <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>) =&gt;
(or <em>e<sub>1</sub></em>
     (or <em>e<sub>2</sub></em> ... <em>e<sub>n</sub></em>))</literallayout>
          <p indent="no">
            and then rewriting each two argument
            <progident>or</progident> form as:
          </p>
          <literallayout>
(or <em>e<sub>1</sub></em> <em>e<sub>2</sub></em>) =&gt;
(if <em>e<sub>1</sub></em> true <em>e<sub>2</sub></em>)</literallayout>
	</sect3>
	<sect3 id="condexec:cond">
	  <title>cond</title>
          <p>
            <em>Derived form</em>
          </p>
	  <p>
	    The <progident>cond</progident> form is used to represent
	    conditional control flow where there are multiple possible
	    outcomes:
	  </p>
	  <literallayout>
(cond (<em>e<sub>test1</sub></em> <em>e<sub>1</sub></em>)
      (<em>e<sub>test2</sub></em> <em>e<sub>2</sub></em>)
      ; ...
      (otherwise <em>e<sub>n</sub></em>))</literallayout>
	  <p>
	    The <progident><em>e<sub>test-i</sub></em></progident>
	    expressions are evaluated in sequence until one of them
	    evaluates as true.  The corresponding
	    <progident><em>e<sub>i</sub></em></progident> is then evaluated
	    and its result becomes the value of the
	    <progident>cond</progident> expression. Subsequent
	    <progident><em>e<sub>test-i</sub></em></progident>
	    expressions are not evaluated. Exactly one of the
	    <progident><em>e<sub>i</sub></em></progident> expressions
	    will be evaluated. The <progident>otherwise</progident>
	    clause is <em>not</em> optional.
	  </p>
	  <p>
	    Any <progident>cond</progident> form can be rewritten as a
	    chain of <progident>if</progident> forms without alteration
	    to meaning.
	  </p>
	  <p>
	    The values returned by the
	    <progident><em>e<sub>test</sub></em></progident> expressions
	    must be of type <progident>bool</progident>. All of the
	    expressions <progident><em>e<sub>i</sub></em></progident>
	    must be of compatible result types.<footnote><p>If we choose
		to relax the type compatibility rules for
		<progident>if</progident>, we should relax them here too.</p>
	    </footnote>
	  </p>
          <p>
            <leadin>Derivation</leadin> The canonical rewriting of
            <progident>cond</progident> proceeds by removing each
            conditional expression in turn:
          </p>
          <literallayout>
(cond (<em>e<sub>test1</sub></em> <em>e<sub>1</sub></em>)
      (<em>e<sub>test2</sub></em> <em>e<sub>2</sub></em>)
      ; ...
      (otherwise <em>e<sub>n</sub></em>)) =&gt;
(if <em>e<sub>test1</sub></em>
    <em>e<sub>1</sub></em>
    (cond (<em>e<sub>test2</sub></em> <em>e<sub>2</sub></em>)
         ; ...
         (otherwise <em>e<sub>n</sub></em>)))</literallayout>
          <p indent="no">
            until only two cases remain in the
            <progident>cond</progident> expression, the last of which
            has a true predicate. This final cond is
            rewritten as:
          </p>
          <literallayout>
(cond (<em>e<sub>test1</sub></em> <em>e<sub>1</sub></em>)
      (otherwise <em>e<sub>n</sub></em>)) =&gt;
(if <em>e<sub>test1</sub></em>
    <em>e<sub>1</sub></em>
    <em>e<sub>n</sub></em>)</literallayout>
	</sect3>
      </sect2>
      <sect2>
	<title>Mutability</title>
        <p>
          The expression:
        </p>
        <literallayout>
(set! <em>e<sub>loc</sub> e<sub>val</sub></em>)</literallayout>
        <p indent="no">
          is used to set the value of a mutable entity. The
          expression <em>e<sub>loc</sub></em> should evaluate to a
          location of mutable type <progident>(mutable&nbsp;<em>T</em>)</progident>. The expression
          <em>e<sub>val</sub></em> should evaluate to an
          assignment-compatible type
          <progident><em>T</em></progident>.
          The return value of <progident>set!</progident> is the unit value.
        </p>
<!--         <sect3> -->
<!--           <title>mutable</title> -->
<!--           <p> -->
<!--             The <progident>mutable</progident> syntactic form, when -->
<!--             applied in ``value constructor'' form, is actually a -->
<!--             convenience shorthand for a type constraint. When applied -->
<!--             to an expression: -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- (mutable <em>e</em>) -->
<!-- </literallayout> -->
<!--           <p indent="no"> -->
<!--             the <progident>mutable</progident> operator induces a -->
<!--             requirement on the type checker and the type inference -->
<!--             engine that the type of its argument must unify with the -->
<!--             type <progident>(mutable&nbsp;'a)</progident>. That is, -->
<!--             the effect of <progident>mutable</progident> is a -->
<!--             constraint on the type of its argument.<footnote><p>Note -->
<!--             that the <progident>(mutable&nbsp;<em>e</em>)</progident> -->
<!--             expression form is a redundant convenience syntax. An -->
<!--             equivalent effect can be obtained by writing the type -->
<!--             qualifier -->
<!--             <progident><em>e</em>:(mutable&nbsp;'a)</progident>.</p> -->
<!--             </footnote> The <progident>mutable</progident> value -->
<!--             constructor does not copy its argument; the return value -->
<!--             is identically the same as its argument value. -->
<!--           </p> -->
<!--         </sect3> -->
<!--         <sect3> -->
<!--           <title>read-only</title> -->
<!--           <p> -->
<!--             <font color="red">We need a definition of what it means to -->
<!--             strip mutability. Until then, -->
<!--             <progident>read-only</progident> is not -->
<!--             implemented.</font> -->
<!--           </p> -->
<!--           <p> -->
<!--             The <progident>read-only</progident> ``value constructor'' -->
<!--             is a syntactic form that strips its argument type of -->
<!--             mutability. The <progident>read-only</progident> value -->
<!--             constructor does not copy its argument; the return value -->
<!--             is identically the same as its argument value.  When -->
<!--             applied to an expression: -->
<!--           </p> -->
<!--           <literallayout> -->
<!-- (read-only <em>e</em>) -->
<!-- </literallayout> -->
<!--           <p indent="no"> -->
<!--             the <progident>read-only</progident> operator returns its -->
<!--             argument value, with any top-level mutability stripped -->
<!--             from its type. That is, if the type of -->
<!--             <progident><em>e</em></progident> would unify with -->
<!--             <progident>(mutable&nbsp;'a)</progident>, the type of the -->
<!--             return value is <progident>'a</progident>, otherwise, the -->
<!--             type of the return value is the same as the type of the -->
<!--             input value. -->
<!--           </p> -->
<!--         </sect3> -->
      </sect2>
      <sect2>
	<title>References</title>
        <sect3>
          <title>dup</title>
          <p>
            If <progident><em>e</em></progident> is an expression of
            non-procedure type, the expression
	  </p>
          <literallayout>
(dup <em>e</em>)</literallayout>
          <p indent="no">
            returns a reference to a heap-allocated <em>copy</em> of
            the value returned by the expression
            <progident><em>e</em></progident>.
          </p>
        </sect3>
        <sect3>
          <title>deref</title>
          <p>If
          <progident><em>e</em></progident> is an expression of reference
            type <progident>(ref &tau;)</progident>, then:
          </p>
          <literallayout>
(deref <em>e</em>)</literallayout>
          <p indent="no">
            returns the value named by the
            reference. <progident>deref</progident> is a syntactic
            form. The returned value is a location, and can be used as
            an argument to <progident>set!</progident>.
          </p>
          <p>
            The expression:
          </p>
          <literallayout>
<em>e</em><b>^</b></literallayout>
          <p indent="no">
            is a convenience shorthand for
          </p>
          <literallayout>
(deref <em>e</em>)</literallayout>
        </sect3>
<!--         <sect3> -->
<!--           <title>inner-ref</title> -->
<!--           <p>If -->
<!--             <progident><em>e</em></progident> is an expression of -->
<!--             reference type, which evaluates to a value  -->
<!--             <progident><em>v</em></progident>,             -->
<!--             the <progident>inner-ref</progident> -->
<!--             construct can be used to obtain a reference to a -->
<!--             subcomponent of <progident><em>v</em></progident>. -->
<!--             The permitted cases are:   -->
<!--           </p> -->
<!--           <ol> -->
<!--             <li> -->
<!--               <p> -->
<!--                 If -->
<!--               </p> -->
<!--               <ol> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>e</em></progident> -->
<!--                     is an expression with type -->
<!--                     <progident>(<em>s</em> &tau;<sub>1</sub> -->
<!--                       ... &tau;<sub>n</sub>)</progident> -->
<!--                     </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>s</em></progident> -->
<!--                     is a reference -->
<!--                     (<progident>:boxed</progident>) structure type -->
<!--                   </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>l</em></progident> is a valid -->
<!--                     field-label in structure -->
<!--                     <progident><em>s</em></progident> -->
<!--                   </p> -->
<!--                 </li>                     -->
<!--                 <li> -->
<!--                   <p>                                         -->
<!--                     The type of the value stored at field -->
<!--                     <progident><em>l</em></progident> is &tau; -->
<!--                   </p> -->
<!--                 </li> -->
<!--               </ol>               -->
<!--               <p> -->
<!--                 then, the expression  -->
<!--                 <progident>(inner-ref <em>e</em> <em>l</em>)</progident> -->
<!--                 returns a reference to the inner field with type  -->
<!--                 <progident>(ref &tau;)</progident> -->
<!--               </p> -->
<!--             </li> -->
<!--             <li> -->
<!--               <p> -->
<!--                 If -->
<!--               </p> -->
<!--               <ol> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>e</em></progident> -->
<!--                     is an expression with type -->
<!--                     <progident>(ref (<em>s</em> &tau;<sub>1</sub> -->
<!--                       ... &tau;<sub>n</sub>))</progident> -->
<!--                     </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>s</em></progident> -->
<!--                     is a value -->
<!--                     (<progident>:unboxed</progident>) structure type -->
<!--                   </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>l</em></progident> is a valid -->
<!--                     field-label in structure -->
<!--                     <progident><em>s</em></progident> -->
<!--                   </p> -->
<!--                 </li>                     -->
<!--                 <li> -->
<!--                   <p>                                         -->
<!--                     The type of the value stored at field -->
<!--                     <progident><em>l</em></progident> is &tau; -->
<!--                   </p> -->
<!--                 </li> -->
<!--               </ol>               -->
<!--               <p> -->
<!--                 Then, -->
<!--                 the expression  -->
<!--                 <progident>(inner-ref <em>e</em> <em>l</em>)</progident> -->
<!--                 returns a reference to the inner field with type  -->
<!--                 <progident>(ref &tau;)</progident>. -->
<!--               </p> -->
<!--             </li> -->
<!--             <li> -->
<!--               <p> -->
<!--                 If -->
<!--               </p> -->
<!--               <ol> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>e</em></progident> -->
<!--                     is an expression with type -->
<!--                     <progident>(vector &tau;)</progident> -->
<!--                   </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p> -->
<!--                     <progident><em>e<sub>n</sub></em></progident> -->
<!--                     is a valid index expression with type -->
<!--                     <progident>word</progident> -->
<!--                   </p> -->
<!--                 </li> -->
<!--               </ol>               -->
<!--               <p> -->
<!--                 then, the expression  -->
<!--                 <progident>(inner-ref <em>e</em> <em>e<sub>n</sub></em>)</progident> -->
<!--                 returns a reference to the inner element with type  -->
<!--                 <progident>(ref &tau;)</progident> -->
<!--               </p> -->
<!--             </li> -->
<!--             <li> -->
<!--               <p> -->
<!--                 If -->
<!--               </p> -->
<!--               <ol> -->
<!--                 <li> -->
<!--                   <p>                     -->
<!--                     <progident><em>e</em></progident> -->
<!--                     is an expression with type -->
<!--                     <progident>(ref (array &tau;))</progident> -->
<!--                   </p> -->
<!--                 </li> -->
<!--                 <li> -->
<!--                   <p> -->
<!--                     <progident><em>e<sub>n</sub></em></progident> -->
<!--                     is a valid index expression with type -->
<!--                     <progident>word</progident> -->
<!--                   </p> -->
<!--                 </li> -->
<!--               </ol>               -->
<!--               <p> -->
<!--                 then, the expression  -->
<!--                 <progident>(inner-ref <em>e</em> <em>e<sub>n</sub></em>)</progident> -->
<!--                 returns a reference to the inner element with type  -->
<!--                 <progident>(ref &tau;)</progident> -->
<!--               </p> -->
<!--             </li> -->
<!--           </ol>           -->
<!--         </sect3> -->
      </sect2>
      <sect2 id="switch">
	<title>Value Matching</title>
        <p>
          The <progident>switch</progident> form provides a
          mechanism for obtaining access to variant fields of a
          value of union or repr type. The syntax of
          <progident>switch</progident> is:
        </p>
        <literallayout>
(switch <em>id</em> <em>e</em>
  (<em>match<sub>1</sub></em> <em>e<sub>1.1</sub></em> ... <em>e<sub>1.n1</sub></em>)
  (<em>match<sub>2</sub></em> <em>e<sub>2.1</sub></em> ... <em>e<sub>2.n2</sub></em>)
  ; ...
  (<b>otherwise</b> <em>e<sub>other</sub></em>))</literallayout>
        <p indent="no">
          where each <em>match</em> form is either a single union
          tag identifier (constructor) or a parenthesized
          sequence of union tag identifiers. Multiple union
          constructors may be matched by a single clause only if all
          matched constructors dominate identical fields. Since the
          type and bit-offsets of identically named fields within
          repr-constructors are required to be the same, multiple
          repr-constructors can be matched in a single clause. In this
          case, only the common fields of all matched
          repr-constructors will be visible for selection within
          <progident><em>e<sub>i.i</sub></em>...<em>e<sub>i.i</sub></em></progident>.
        </p>
        <p>
          A <progident>switch</progident> expression performs a value
          match on the tag fields of the expression
          <progident><em>e</em></progident> (or if
          <progident><em>e</em></progident> is of repr type, on the
          tags of its outermost body) in sequence. The first
          <progident><em>match<sub>i</sub></em></progident> expression
          containining a matching tag value is selected, and the
          corresponding expression sequence
          <progident><em>e<sub>i.1</sub></em>...<em>e<sub>i.ni</sub></em></progident>
          is executed in an environment where <progident>x</progident>
          is a value of anonymous type.  For every field of the
          original expresion type such that all of its containing
          union or repr tag qualifications are satisfied, the
          anonymous type contains a field with the same name denoting
          the same portion of the The value of
          <progident>x</progident> is a <em>copy</em> of the
          (discriminated) value returned by the expression
          <progident><em>e</em></progident>.
        </p>
        <p>
          An expression of anonymous type may only appear only as
          the expression argument of the
          <progident>member</progident> form, or as the expression
          <progident><em>e</em></progident> of a
          <progident>switch</progident> form. It may not be passed
          as an argument, rebound, or returned as a result value.
        </p>
        <p>
          If an otherwise form is present, then the body of the
          otherwise clause is executed in an environment where
          <progident>x</progident> is bound to a <em>copy</em> of the
          (undiscriminated) value returned by the expression
          <progident><em>e</em></progident>.<footnote>
            <p>
              Technically, this need not be a copy, and we are
              reviewing whether the copy should be bypassed in the
              otherwise form.
            </p>
          </footnote>
        </p>
        <p>
          If the matches performed by a given
          <progident>switch</progident> are exhaustive, the
          <progident>otherwise</progident> clause can be omitted.
        </p>
        <p>
          For purposes of literal case analysis, the
          <progident>switch</progident> form will also accept
          expressions <progident><em>e</em></progident> of primary
          scalar type and matching values that are literals of the
          corresponding type.
        </p>
      </sect2>
      <sect2>
	<title>Exception Handling</title>
	<sect3>
	  <title>Try/Catch</title>
	  <p>
	    The <progident>try</progident> form is used as the control
	    flow resumption point of a <progident>throw</progident>
	    form. When a <progident>throw</progident> occurs, control
	    resumes at the nearest dynamically containing
	    <progident>try</progident> form whose matching patterns
	    match the name of the exception that was thrown.
	  </p>
	  <p>
	    The try block syntax is:
	  </p>
	  <literallayout>
(try <em>expr</em>
  (catch <em>id</em> [(<em>tagid<sub>1</sub></em> <em>e<sub>1</sub></em>)
            ...
            (<em>tagid<sub>2</sub></em> <em>e<sub>2</sub></em>)
            ((<em>tagid<sub>x</sub></em> <em>tagid<sub>y</sub></em>) <em>e<sub>xy</sub></em>)]
            [(otherwise <em>e<sub>n</sub></em>)]))</literallayout>
          <p indent="no">
            In the absence of a programmer-specified
            <progident>otherwise</progident> clause, the
            <progident>catch</progident> block behaves as though the
            clause
          </p>
          <literallayout>
(otherwise (throw <em>id</em>))</literallayout>
          <p indent="no">
            had been present.
          </p>
	  <p>
	    If the evaluation of <progident><em>expr</em></progident>
	    does not cause an exception, the value of the
	    <progident>try</progident> block is the value of
	    <progident><em>expr</em></progident>.
	  </p>
	  <p>
	    If the evaluation of <progident><em>expr</em></progident>
	    causes an exception to be thrown, execution proceeds as if
	    the catch block were rewritten to the procedure:
          </p>
          <literallayout>
(lambda (e:exception)
  (switch nm e
    (<em>tagid<sub>1</sub></em> <em>e<sub>1</sub></em>)
    (<em>tagid<sub>2</sub></em> <em>e<sub>2</sub></em>)
    ...
    (otherwise <em>e<sub>otherwise</sub></em>)))</literallayout>
          <p indent="no">
            and this procedure were applied to the received exception
            value. The return value from this procedure is returned as
            the value of the <progident>case</progident> expression.
          </p>
	</sect3>
	<sect3>
	  <title>Throw</title>
	  <p>
	    The <progident>throw</progident> form is used to raise an
	    exception. It performs a non-local control flow transfer
	    to the most recent (nearest temporally enclosing)
	    <progident>try</progident> block, with the effect that the
	    thrown exception value is received by the corresponding
	    <progident>catch</progident> block as described above.
	    The <progident>throw</progident> expression has no return
	    value type. The form:
	  </p>
	  <literallayout>
(throw <em>e</em>)</literallayout>
	  <p>
            throws the exception computed by the expression
            <progident><em>e</em></progident>, which must be an
            expression of type <progident>exception</progident> or of
            some concrete exception type. The latter case permits
            the locally bound identifier in a discriminated catch
            block to be passed directly to throw so that a
            pre-existing exception can be re-thrown without allocating
            new storage.
	  </p>
	</sect3>
      </sect2>
    </sect1>
    <sect1>
      <title>Locations</title>
      <p>
        <font color="blue">This section is a work in progress, but it
        is as accurate as I (shap) can currently make it. Corrections,
        comments, identification of omissions, and so forth are
        welcome.</font>
      </p>
      <p>
        BitC is a language supporting mutation. Because of this, a
        specification of the type system and expression evaluation
        semantics of BitC does not entirely account for how the
        behavior of <progident>set!</progident> interacts with the
        behavior of accessor expressions such as
        <progident>a[i]</progident>,
        <progident>member</progident>, <progident>deref</progident>,
        and expressions consisting of a single identifier.  In
        particular, the characterization of
        <progident>set!</progident> as
      </p>
        <literallayout>
(set! <em>e<sub>1</sub> e<sub>2</sub></em>)</literallayout>
      <p indent="no">
        does not account for how
        <progident><em>e<sub>1</sub></em></progident> can be mutated
        in place, because the language specification (to this point)
        does not distinguish between expressions that generate new
        values (in the sense of values that occupy new storage) and
        expressions that return pre-existing values. To address this,
        we present here an informal characterization of locations in BitC.
      </p>
      <sect2>
        <title>Expressions Involving Locations</title>
        <p>
          The following expressions accept locations (addresses of
          cells) in the indicated positions, and return locations as
          their result:
        </p>
        <literallayout>
<em>id</em>
<em>loc</em>[<em>ndx</em>]
(member <em>loc</em> <em>ident</em>)
(deref <em>e</em>)</literallayout>
        <p indent="no">
          in addition, the <progident>set!</progident> form requires a
          location as its first argument, and returns the unit value.
        </p>
        <literallayout>
(set! <em>loc</em> <em>e</em>)</literallayout>
      </sect2>
      <sect2>
        <title>Implicit Value Extraction</title>
        <p>
          When a value of location type appears in any context
          expecting an expression, the location is implicitly
          dereferenced to give the expected value as a result.  The
          ``value extraction rule'' applies both to return values and
          to applications, with the consequence that ``bare''
          locations can never escape their binding frame in either the
          upward or downward directions. Only those forms identified
          explicitly above as accepting and returning locations are
          exceptions to the value extraction rule.
        </p>
        <p>
          For example, in the expression:
        </p>
        <literallayout>
(let ((a b)) ...)</literallayout>
        <p indent="no">
          the expression <progident>b</progident> evaluates (internally)
          to a location, but it is then discovered to appear in a
          binding context requiring an expression, so the value at that
          location is returned instead. Similarly, the expression
          <progident>a</progident> evaluates (internally) to a
          location, allowing it to be initialized in place.
        </p>
        <p>
        </p>
      </sect2>
      <sect2>
        <title>Generalized Accessors</title>
        <note>
          <p>
            This section describes a possible <em>future</em>
            enhancement to the language. It is considered
            experimental, and it is possible that it will never be
            implemented at all.
          </p>
        </note>
        <p>
          It is customary for programs that introduce ``collection''
          types to provide operations for both insertion and
          lookup. It would be exceedingly convenient if the lookup
          operation could be used to support efficient access as well,
          for example:
        </p>
        <literallayout>
(btree-insert bt key some-obj)
(btree-lookup bt key).field</literallayout>
        <p indent="no">
          That is, it is sometimes appropriate for the lookup function
          could return a location.
        </p>
        <p>
          This cannot be supported for local objects, but it is
          possible for the type system to successfully infer the
          distinction between local object locations and global
          object locations. In this case, we could relax the value
          extraction rule so that it would <em>not</em> apply to
          return values, with the effect that we could write an
          accessor function such as:
        </p>
<literallayout>
(def (4th-elem vec)
  vec[4])
4th-elem: (fn ((vector 'a word))
              (location 'a))</literallayout>
        <p indent="no">
          Given such an accessor function, it would even be possible
          to write:
        </p>
        <literallayout>
(set! (4th-elem vec) 5)</literallayout>
        <p>
          If introduced, this feature would need to be handled with
          care. It would be all too easy for a binary tree's lookup
          handler to return the internal node structure, with the
          effect that external code could modify the stored key ``in
          place,'' violating the integrity of the binary tree. Because
          of this risk, it is unclear whether the type
          <progident>(location&nbsp;T)</progident> should ever be
          inferred automatically.
        </p>
      </sect2>
    </sect1>
    <sect1 id="Interfaces">
      <title>Interfaces</title>
      <p>
        BitC recognizes two kinds of compilation units: interfaces and
        modules.  An interface contains a public set of definitions
        and declarations.  From the perspective of an importer, it
        describes the identifiers that are published by one or more
        providing bodies of code. From the implementor perspective, an
        interface describes a set of declarations that must be
        exported by some providing module. Interfaces provide the only
        means by which functions and types may be shared across
        multiple units of compilation.
      </p>
      <p>
        A module contains a private set of definitions and
        delarations. In most cases, these are not visible outside of
        the scope of the module. The exception is when a module
        imports some interface and also declares explicitly that it
        provides definitions for one or more public declarations of
        that interface.
      </p>
      <sect2>
        <title>Specifying an Interface</title>
        <p>
          An interface unit of compilation consists of a
          <progident>bitc version</progident> form followed by a
          single <progident>interface</progident> form. The
          <progident>interface</progident> form wraps a sequence of
          imports, aliases, definitions, and declarations that
          describe the public identifiers associated with that
          interface. For example, the interface:
        </p>
        <literallayout>
interface sample {
  (def x 1) ; constant definition
  (union (list 'a):boxed
    nil
    (cons 'a (list 'a)))
  (struct (tree-of 'a):boxed)
  (proclaim y : int32))
  (struct S :opaque (int32 i))
}</literallayout>
        <p indent="no">
          Defines a constant <progident>x</progident> with value
          <progident>1</progident>, defines the now-familiar list
          type, declares that <progident>tree-of</progident> is an
          opaque reference type defined in some (unspecified) source
          unit of compilation, and that <progident>y</progident> is a
          value of type <progident>int32</progident> declared in some
          (unspecified) source unit of compilation.
        </p>
        <p>
          Note that the declaration of <progident>tree-of</progident>
          provided by this interface is incomplete and therefore
          opaque. Because <progident>tree-of</progident> is a
          reference type, clients of this interface can declare
          variables and arguments of type
          <progident>tree-of</progident>, but cannot instantiate them
          because no function returning type
          <progident>tree-of</progident> is exposed by this interface.
        </p>
        <p>
          Note further that <progident>val-type</progident> is both
          incomplete and undeclarable, because it is a value
          type. Clients may declare arguments of type
        </p>
        <literallayout>
(ref sample.value-type)</literallayout>
        <p indent="no">
          but not of type <progident>value-type</progident>, because
          the size of <progident>value-type</progident> is not
          revealed.
        </p>
      </sect2>
      <sect2>
        <title>Importing an Interface, Aliasing</title>
        <p>
          In order to use the identifiers supplied by an interface,
          the client unit of compilation must first import those
          identifiers using a top-level <progident>import</progident>
          form. There are three such forms.  It is a compile-time
          error if any local identifier bound by an
          <progident>import</progident> is already bound.
        </p>
        <sect3>
          <title>Hygienic Import</title>
          <p>
            The syntax of the hygienic import form is:
          </p>
          <literallayout>
(import <em>if-name</em> as <em>local-name</em>)</literallayout>
          <p indent="no">
            where <progident><em>if-name</em></progident> is an
            interface name and
            <progident><em>local-name</em></progident> is an identifier
            to be bound in the current scope. If
            <progident><em>pubName</em></progident> is a name published by
            <progident>TheInterface</progident>, then after executing
          </p>
          <literallayout>
(import TheInterface as myName)</literallayout>
          <p indent="no">
            it is legal to write
            <progident>myName.<em>pubName</em></progident> at any
            identifier use occurrence. This is referred to as a
            <term>hygienic alias</term>. Hygienic aliases may appear
            in any use occurrence where an identifier might ordinarily
            appear. When a hygienic alias names a provided symbol, the
            hygienic alias may also appear as the defined
            identifier of a top-level definition. Hygienic aliases may
            <em>not</em> appear in the defined position of a
            <em>local</em> definition.
          </p>
          <p>
            Hygienic import preserves a strong distinction between the
            namespace of the imported interface and the local namespace
            of the importing unit of compilation. This is appropriate
            when importing interfaces that are not fully mature, or for
            which the possibility of future name collisions as a result
            of interface evolution must be defended against.
          </p>
        </sect3>
        <sect3>
          <title>Qualified Import</title>
          <p>
            The qualified import syntax imports <em>selected</em>
            public identifiers from a specified interface. The
            selected identifiers are aliased (after optional
            re-naming) in the top-level namespace of the importing
            unit of compilation. The syntax of this form is:
          </p>
          <literallayout>
(import <em>if-name</em> <em>ident-or-remap</em><sup>+</sup>)</literallayout>
          <p>
            where <em>ident-of-remap</em> is either some identifier
            published by the imported interface or it is:
          </p>
          <literallayout>
(<em>pubName</em> as <em>localName</em>)</literallayout>
          <p indent="no">
            If a single identifier is given, the local alias is bound
            using the public name. If the ``as'' variant is given, the
            local alias is bound under the specified local name
            instead.
          </p>
          <p>
            It is a compile-time error to form more than one top-level
            alias in a single unit of compilation for the same public
            name in a given interface.
          </p>
        </sect3>
        <sect3>
          <title>Promiscuous Import</title>
          <p>
            The promiscuous import form imports all public identifiers
            from the imported interface
            that do not already have
            top-level aliases in the importing unit of compilation.
            The syntax of this form is:
          </p>
          <literallayout>
(import <em>if-name</em>)</literallayout>
          <p indent="no">
            This form does not support identifier re-naming on import.
            Name collisions resulting from import can, if necessary,
            be managed by first performing a qualified import that
            re-maps the colliding public name, and then performing a
            promiscuous import to import the remainder of the interface.
          </p>
        </sect3>
        <sect3>
          <title>Compile-Time Import Resolution</title>
          <p>
            To locate the source representation of an imported
            interface, the compiler shall attempt to locate a file
            <progident><em>name</em>.bitc</progident>, where
            <progident><em>name</em></progident> is the identifier used
            to name the corresponding interface. The default search path
            used for this resolution is not defined by this standard,
            but shall provide a resolution for every interface specified
            in the language definition. It is permissable for a compiler
            to implement some or all of the default search path
            internally, without reference to any external file name
            space.
          </p>
          <p>
            Every file-based compilation environment for BitC shall
            provide a command-line option <progident>-I</progident> that
            enables the build environment to append directories to the
            interface search path.
          </p>
        </sect3>
        <sect3>
          <title>Error Reporting</title>
          <p>
            When reporting errors, a conforming BitC compiler should
            <em>always</em> report the defining name of the type or
            variable. It may <em>optionally</em> report the alias
            (use) name by which the type or value was referenced. Only
            defining names should be exposed for resolution by the
            linker. For identifiers defined or declared within an
            interface, the defining name is the fully qualified name
            of the identifier with respect to its interface. For all
            other identifiers, the defining name is the one that
            appears in the defining form.
          </p>
          <p>
            The BitC interface system provides primarily for separate
            compilation and name hiding. In contrast to the module system
            of Standard ML <cite ref="macqueen1984modules"/>, BitC interfaces
            are purely a tool for namespace control.
          </p>
        </sect3>
      </sect2>
      <sect2 id="provide">
        <title>Providing an Interface</title>
        <p>
          A source unit of compilation can indicate that it provides
          definitions for one or more declarations of an interface by
          means of the <progident>provide</progident> declaration. The
          syntax of provide is:
        </p>
        <literallayout>
(provide <em>interface-name</em> <em>ident</em><sup>+</sup>)</literallayout>
        <p indent="no">
          Where each <progident><em>ident</em></progident> is an
          identifier proclaimed by the named interface. That is: the
          name as specified in the interface rather than any alias of
          that name that may have been locally bound.
        </p>
        <p>
          The effect of <progident>provide</progident> is to
          <em>authorize</em> the definition of the named
          identifiers. The definitions must then be defined by binding
          an arbitrarily selected local alias of the public identifier.
For example:
        </p>
        <literallayout>
bitc version "&BitcVersion;"
(import sample as ln)
(provide sample tree-of)

(struct (ln.tree-of 'a):boxed
  left : (optional
           (ln.tree-of 'a))
  right : (optional
            (ln.tree-of 'a))
  height
  value : 'a)</literallayout>
        <p indent="no">
          The requirement that an arbitrary alias be defined can
          result in strange appearances. The following alternative
          definition is equivalent in all respects to the one above:
          </p>
        <literallayout>
bitc version "&BitcVersion;"
(import sample as ln)
(provide sample tree-of)
(use (ln.tree-of as mumble))

(struct (mumble 'a):boxed
  left : (optional (mumble 'a))
  right : (optional (mumble 'a))
  height
  value : 'a)</literallayout>
        <p>
          It is <em>not</em> required that a single source unit of
          compilation provide the entirety of an interface. For
          sufficiently large interfaces (e.g. the standard BitC
          library), this would be impractical. However the flexibility
          to define an interface with a collection of independently
          compiled source units of compilation demands some means to
          prevent circular type and value declarations. Circular value
          definitions are precluded by the type-level definition
          observability rule
        </p>
      </sect2>
      <sect2>
        <title>The Reserved Interface <progident>bitc</progident></title>
        <p>
          The interface name ``bitc'' is reserved for use by the BitC
          implementation.
        </p>
      </sect2>
    </sect1>
    <sect1 id="Modules">
      <title>Source Modules</title>
      <p>
        A source unit of compilation consists of one or more
        modules. Each module consists of a
        <progident>module</progident> form containing an arbitrary
        sequence of imports, definitions, declarations, and use forms
        that are <em>not</em> <progident>interface</progident> forms.
      </p>
      <p>
        The module syntax is:
      </p>
        <literallayout>
module <em>module-name</em><sup>?</sup> <em>docstring</em><sup>?</sup> { <em>mod_form</em><sup>+</sup> }</literallayout>
      <p>
        A source module constitutes a scope.  Except for those
        definitions that are explicitly exported using
        <progident>provide</progident> (Section <xref ref="provide"/>),
        identifiers bound in a module are not visible in other source
        modules.
      </p>
    </sect1>
    <sect1>
      <title>Storage Model</title>
      <p>
        <font color="red"><em>This entire section had become hopelessly
        stale, and needs to be rewritten.</em></font>
      </p>
    </sect1>
    <sect1>
      <title>Pragmatics</title>
      <sect2>
        <title>Closure Construction</title>
        <p>
          BitC seeks to enable the crafting of programs that do not
          make unexpected use of the heap, and which can make use of
          <progident>lambda</progident> and
          <progident>letrec</progident> forms to describe rich
          [mutual] tail recursions. Becuase of this, it is necessary
          to state the <em>minimal</em> degree of closure analysis
          that every BitC compiler is required to perform when
          constructing closures, and more generally, the conditions
          under which closures will be formed at all.
        </p>
        <p>
          Closure
          construction proceeds in two phases. During the initial
          phase, free identifiers are added to the closure and the
          program is rewritten to heap-allocate closed values if that
          is necessary. During the second phase, a check is performed
          to determine whether the resulting closure is not actually
          necessary.
        </p>
        <p>
          <leadin>Phase 1</leadin> Given an identifier
          <progident>id</progident> appearing free in a
          <progident>lambda</progident> form <progident>L</progident>:
        </p>
        <ol>
          <li>
            <p>
              <leadin>Globals</leadin> If <progident>id</progident>
              resolves to a globally defined identifier, it will not
              be added to any closure record.
            </p>
          </li>
          <li>
            <p>
              <leadin>Closed Lambda Forms</leadin> If
              <progident>id:t</progident> is an immutably bound
              identifier whose initializing form is a
              <progident>lambda</progident> term (i.e. a literal
              <progident>lambda</progident>, not merely an expression
              returning a value of function type), and
              <progident>id</progident> appears in L <em>in
              non-applicative position</em>, then
              <progident>id</progident>, then a corresponding field of
              type T is added to the closure record, and this field is
              populated at closure construction time by a
              <em>copy</em> of <progident>id</progident>.
            </p>
          </li>
          <li>
            <p>
              <leadin>Shallow Immutables</leadin> If
              <progident>id:T</progident> is a locally bound
              identifier of shallow immutable type, then a
              corresponding field of type T is added to the closure
              record, and this field is populated at closure
              construction time by a <em>copy</em> of
              <progident>id</progident>.
            </p>
          </li>
          <li>
            <p>
              <leadin>Shallow Mutables</leadin> If
              <progident>id:T</progident> is a locally bound
              identifier of shallow mutable type, then the program
              must be rewritten in such a way as to heap-allocate
              <progident>id</progident>, thereby converting it into a
              deep mutable value that is shallow immutable. The
              resulting reference
              <progident>id:(ref&nbsp;T)</progident> is then closure
              converted as a shallow immutable identifier.
            </p>
          </li>
        </ol>
        <p>
          <leadin>Phase 2</leadin> If a closure record was created in
          phase 1, but all elements of that closure were added as a
          consequence of rule 2 (closed lambda forms), then no
          explicitly allocatd closure record is either required or
          permitted. All of the closed lambda forms can be represented
          using labels without any intervening heap-allocated
          procedure objects.
        </p>
        <p>
          Whether or not a closure record is fabricated for a given
          <progident>lambda</progident> form <progident>L</progident>,
          if an identifier <progident>id</progident> resolves to a
          closed lambda form, then any use-occurrence appearing in
          applicative position in <progident>L</progident> must be
          implemented by a call (or if tail recursive, jump) to the
          associated <progident>lambda</progident> form's
          <em>label</em> rather than proceeding through any procedure
          object that may have been allocated for
          <progident>id</progident>.
        </p>
      </sect2>
      <sect2 id="TailRecursion">
        <title>Tail Recursion</title>
        <p>
          BitC requires a limited form of tail recursion. We do not
          require fully proper tail recursion because this is
          difficult to accomplish efficiently in C, and we wish to
          preserve the ability to compile BitC programs into C for the
          sake of portability.
        </p>
        <p>
          <em>Definition:</em> Within a BitC form
          <progident>f</progident>, a form <progident>g</progident>
          occurs in <term>tail position</term> with respect to the
          form <progident>f</progident> if the evaluation of
          <progident>g</progident> is the final evaluation (and
          therefore the return value) computed by the form
          <progident>f</progident>. This definition is transitive. A
          structural consequence of this relationship is that the type
          of <progident>g</progident> is (copy compatible with) the
          type of <progident>f</progident>.
        </p>
        <p>
          An application of a function <progident>f</progident> is
          said to be <term>tail recursive</term> if (a) it appears in
          tail position with respect to the body of its most closely
          containing <progident>lambda</progident> body, and (b) it is
          implemented in such a way as to re-use its containing stack
          frame.
        </p>
        <p>
          The BitC specification <em>requires</em> that certain
          procedure calls appearing in tail position must be compiled
          using a tail-recursive implementation:
        </p>
        <ul>
          <li>
            <p>
              Within a <progident>letrec</progident>, calls to any
              function bound in the letrec that appear in tail position
              within some function bound by the
              <progident>letrec</progident> must be tail recursive.
            </p>
          </li>
          <li>
            <p>
              Within any function <progident>f</progident>, calls to
              <progident>f</progident> that appear in tail position
              w.r.t. the body of <progident>f</progident> must be tail
              recursive. This is actually a special case of the first
              rule.
            </p>
          </li>
        </ul>
        <p>
          These requirements apply only to function calls whose
          destination can be statically resolved by the compiler at
          compile time. A BitC compiler is permitted, but is not required,
          to implement other function calls tail recursively.
        </p>
      </sect2>
    </sect1>
  </subpart>
  <subpart>
    <title>Standard Prelude</title>
    <p>
      A range of types, type classes, and functions supporting
      operations on primary types are defined in the BitC standard prelude.
    </p>
    <p>
      <font color="red">This section needs to be defined.</font>
    </p>
    <p>
      The following types and values are defined in the BitC standard
      prelude. The compiler is free to implement some or all of these
      types internally, and is further free to rely on internal
      knowledge of these types within the implementation.
    </p>
    <sect1>
      <title>Foundational Types</title>
      <p>
        The prelude provides definitions for commonly used integral
        types. Under normal circumstances, the reader and pretty printer
        conspire to hide the fact that these types are union types.
      </p>
      <literallayout>
;; There is an open issue here: should
;; strings be primitive? Issue is unicode
;; character size and long strings.
; Strings:
;;(union string:unboxed (vector char))

; Pairs:
(struct (pair 'a 'b):unboxed 
  fst:'a snd:'b)

; Optional values:
(union (optional 'a):unboxed 
  none (some value:'a))

; Nullable pointers:
(forall ((ref-types 'a))
  (union
    (nullable 'a):unboxed 
     Null (non-null ptr:(ref 'a))))

; Homogeneous lists:
(union (list 'a) 
  nil
  (cons car:'a cdr:(list 'a)))

; Bignums
(union int:unboxed
  (fix f:(bitfield int32 31))
  (big b:(ref (bool, (vector word)))))</literallayout>
    </sect1>
    <sect1>
      <title>Foundational Type Classes</title>
      <p>
        The standard prelude provides a number of standard type
        classes:
      </p>
      <literallayout>
; Equality comparison by identity:
(trait (EqComparison 'a)
  eq : (fn ('a 'a) bool))

; Equality comparison by identity,
; with exceptional handling for
; numerics:
(trait (EqlComparison 'a)
  eql : (fn ('a 'a) bool))

; Generalized equality:
(trait (EqualityComparison 'a)
  == : (fn ('a 'a) bool)
  != : (fn ('a 'a) bool))

; Magnitude comparison
(forall ((EqualityComparison 'a))
  (trait (Ord 'a)
  &lt;  : (fn ('a 'a) bool)
  &lt;= : (fn ('a 'a) bool)))

; Checked arithmetic
(forall ((Ord 'a))
  (trait (Arith 'a)
    +: (fn ('a 'a) 'a)
    -: (fn ('a 'a) 'a)
    *: (fn ('a 'a) 'a)
    /: (fn ('a 'a) 'a)
    &lt;&lt;:(fn ('a word) 'a)
    &gt;&gt;:(fn ('a word) 'a)))

; Ring arithmetic
(forall ((Ord 'a))
  (trait (Ring 'a)
    R+: (fn ('a 'a) 'a)
    R-: (fn ('a 'a) 'a)
    R*: (fn ('a 'a) 'a)
    R/: (fn ('a 'a) 'a)
    R&lt;&lt;:(fn ('a word) 'a)
    R&gt;&gt;:(fn ('a word) 'a)))

; Sign transformations
(forall ((Ord 'a))
  (trait (Signed 'a)
    negate: (fn ('a) 'a)
    abs:    (fn ('a) 'a))</literallayout>
    </sect1>
  </subpart>
  <subpart>
    <title>Formal Specification</title>
    <sect1 id="grammar">
      <title>Grammar</title>
      <p>
        The section below gives the extended EBNF grammar for the BitC
        language, including derived forms. Non-terminals are shown in
        italics. Tokens are shown in regular face. The characters
        ``{'', ''}'', and ``|'', are quoted when appearing as
        tokens. When appearing as a superscript, the character ``*''
        indicates ``zero or more'' occurrences, the character ``+''
        indicates ``one or more'' occurrences, and the character ``?''
        indicates ``zero or one occurrences.'' These should be read as
        metasyntactic only when appearing in a superscript. Note that
        parenthesis are <em>not</em> metasyntactic in extended
        Backus-Nauer form, and should be read as single-character
        tokens.
      </p>
      <p>
        Within the EBNF productions below, the left and right
        parenthesis, period, colon, commma, and single quote
        characters should always be read as single character
        tokens. Spaces around these tokens have been omitted for the
        benefit of typeset readability.
      </p>
      <sect2>
        <title>Categorical Terminals</title>
        <p>
          The following categorical terminals are defined by the regular
          expressions given in the respective sections:
        </p>
        <deflist>
          <defli>
            <label><b>Id</b></label>
            <li>
              <p>
                Identifiers (Section&nbsp;<xref ref="identifiers"/>)
              </p>
            </li>
          </defli>
          <defli>
            <label><b>IntLit</b></label>
            <li>
              <p>
                Integer literals (Section&nbsp;<xref ref="intlit"/>)
              </p>
            </li>
          </defli>
          <defli>
            <label><b>FloatLit</b></label>
            <li>
              <p>
                Floating point literals (Section&nbsp;<xref ref="floatlit"/>)
              </p>
            </li>
          </defli>
          <defli>
            <label><b>CharLit</b></label>
            <li>
              <p>
                Character literals (Section&nbsp;<xref ref="charlit"/>)
              </p>
            </li>
          </defli>
          <defli>
            <label><b>StringLit</b></label>
            <li>
              <p>
                String literals (Section&nbsp;<xref ref="stringlit"/>)
              </p>
            </li>
          </defli>
        </deflist>
      </sect2>
      <sect2>
        <title>Interfaces, Units of Compilation</title>
<literallayout indent="no">
<em>start</em> ::= <em>version</em><sup>?</sup> <em>interface</em>
  | <em>version</em><sup>?</sup> <em>module</em><sup>+</sup>
  | <em>version</em><sup>?</sup> <em>implicit_module</em>
<em>ifname</em> ::= {Id.}<sup>*</sup> Id
<em>interface</em> ::=
  interface <em>ifname</em> <em>docstring</em><sup>?</sup> { <em>def</em><sup>+</sup>) }
<em>module</em> ::= 
  module <em>ifname</em><sup>?</sup> <em>docstring</em><sup>?</sup> { <em>mod_def</em><sup>+</sup> }
<em>mod_def</em> ::= <em>def</em> | <em>provide</em>
<em>implicit_module</em> ::= <em>mod_def</em><sup>+</sup>
<em>import</em> ::= (import <em>ifname</em> as Id)
<em>provide</em> ::= (provide Id <em>ifname</em> Id<sup>+</sup>)
<em>usedecl</em> ::=
    (use {Id.Id | (Id.Id as Id)}<sup>+</sup>)
<em>def</em> ::= <em>import</em>
  | <em>usedecl</em>
  | <em>typedef</em>
  | <em>typedecl</em>
  | <em>tcdef</em>
  | <em>instdef</em>
  | <em>valdef</em>
  | <em>proclaim</em>
  | <em>declare</em></literallayout>
      </sect2>
      <sect2>
        <title>Type Declaration and Definition</title>
        <p>
          The <progident>union</progident> and
          <progident>struct</progident> forms are semantically
          derivable from <progident>repr</progident> (or vice
          versa),<footnote>
            <p>
              This statement of semantic derivability ignores the
              Cardelli family of representation optimizations that are
              not currently expressable for
              <progident>repr</progident>, but it is intended to
              fully support control of these optimizations in future
              enhancements to the language.
            </p>
          </footnote>
          but for purposes of specifying typing it is more
          convenient to retain them and use the conventional typing
          definitions for product and union types.
        </p>
<literallayout indent="no">
<em>constraint</em> ::= <em>typapp</em> | <em>ident</em>
<em>typnm</em> ::= <em>ident</em>
  | (<em>ident</em> <em>tvar</em><sup>+</sup>)
  | (forall (<em>constraint</em><sup>+</sup>) <em>ident</em>)
  | (forall (<em>constraint</em><sup>+</sup>)
                  (<em>ident</em> <em>tvar</em><sup>+</sup>))
<em>val</em> ::= :unboxed | :boxed | :opaque
<em>typedef</em> ::=
    (struct <em>typnm</em> <em>val</em>
               <em>docstring</em><sup>?</sup>
               <em>declare</em><sup>+</sup> {<em>field</em>|<em>fill</em>}<sup>+</sup>)
  | (union <em>typnm</em> <em>val</em>
              <em>docstring</em><sup>?</sup>
              <em>declare</em><sup>+</sup> {<em>field</em>|<em>fill</em>}<sup>+</sup>)
  | (repr <em>typnm</em> <em>val</em>
             <em>docstring</em><sup>?</sup> (<em>reprbody</em>))
  | (exception <em>ident</em>
                  <em>docstring</em><sup>?</sup> <em>field</em><sup>*</sup>)
<em>field</em> ::= Id : <em>type</em>
  | (the <em>type</em> Id)
<em>fill</em> ::=
    (fill (bitfield <em>fixpttype</em> IntLit))
<em>reprbody</em> ::= (tag Id<sup>+</sup>)
  | <em>field</em>
  | <em>fill</em>
  | (case {(<em>tags</em> (<em>reprbody</em>))}<sup>+</sup>)
<em>tags</em> ::= Id | (Id<sup>+</sup>)
<em>typedecl</em> ::=
    (struct <em>typnm</em> <em>val</em>
               <em>docstring</em><sup>?</sup>
               {external Id<sup>?</sup>}<sup>?</sup>)
  | (union <em>typnm</em> <em>val</em>
               <em>docstring</em><sup>?</sup>
              {external Id<sup>?</sup>}<sup>?</sup>)
  | (repr <em>typnm</em> <em>val</em>
             <em>docstring</em><sup>?</sup>
             {external Id<sup>?</sup>}<sup>?</sup>)
<em>tcdef</em> ::=
    (trait <em>typnm</em> 
                  <em>docstring</em><sup>?</sup>
                  {(tyfn (<em>tvar</em><sup>+</sup>) <em>tvar</em>)}<sup>*</sup>
                  {<em>ident</em>:<em>fntype</em>}<sup>*</sup>)
<em>instdef</em> ::=
    (instance <em>qual_constraint</em>
                 <em>docstring</em><sup>?</sup> <em>expr</em><sup>+</sup>)
<em>qual_constraint</em> ::= <em>constraint</em>
  | (forall (<em>constraint</em><sup>+</sup>) <em>constraint</em>)</literallayout>
      </sect2>
      <sect2>
        <title>Value Declaration and Definition</title>
        <literallayout indent="no">
<em>valdef</em> ::=
    (def <em>defpattern</em> <em>docstring</em><sup>?</sup> <em>expr</em>)
  | (def (<em>ident</em> <em>bindingpattern</em><sup>?</sup>)
       <em>docstring</em><sup>?</sup>  <em>expr</em><sup>+</sup>)
<em>defpattern</em> ::= <em>ident</em>
  | <em>ident</em>:<em>qualtype</em>
  | (the <em>qualtype</em> <em>ident</em>)
  | ()
  | (pair <em>defpattern</em> <em>defpattern</em>)
  | ({<em>defpattern</em>,}<sup>+</sup> <em>defpattern</em>)
<em>bindingpattern</em> ::= <em>ident</em>
  | <em>ident</em>:<em>type</em>
  | (the <em>type</em> <em>ident</em>)
  | ()
  | (pair <em>defpattern</em> <em>defpattern</em>)
  | ({<em>defpattern</em>,}<sup>+</sup> <em>defpattern</em>)
<em>proclaim</em> ::=
    (proclaim <em>ident</em>:<em>qualtype</em>
              {external Id<sup>?</sup>}<sup>?</sup>)
    <em>; Note: external Id may include BitC</em>
    <em>; reserved words.</em>
<em>qualtype</em> ::= <em>type</em>
  | (forall (<em>constraint</em><sup>+</sup>) <em>type</em>)
  | <em>constraint</em>
  | (forall (<em>constraint</em><sup>+</sup>) <em>constraint</em>)
</literallayout>
      </sect2>
      <sect2>
        <title>Types</title>
        <p>
          Note that the pair type is semantically a derived form. It
          appears in the grammar solely because of the need to support
          pattern bindings and multiple return values.
        </p>
        <literallayout indent="no">
<em>tvar</em> ::= 'Id
<em>inttype</em> ::= int8 | int16 | int32 | int64
  | uint8 | uint16 | uint32 | uint64
<em><u>pairtype</u></em> ::= (pair <em>type</em> <em>type</em>)
  | ({<em>type</em>,}<sup>+</sup> <em>type</em>)
<em>type</em> ::= <em>ident</em>
  | <em>tvar</em>
  | () | bool | char | string | exception
  | <em>inttype</em>
  | float | double | quad
  | (bitfield <em>inttype</em> IntLit)
  | (boxed <em>type</em>)
  | (unboxed <em>type</em>)
  | (mutable <em>type</em>)
  | (fn (<em>type</em><sup>*</sup>) <em>type</em>)
  | <em><u>pairtype</u></em>
  | (array <em>type</em> IntLit)
  | (vector <em>type</em>)
  | (<em>ident</em> <em>type</em><sup>+</sup>)</literallayout>
      </sect2>
      <sect2>
        <title>Expressions</title>
        <literallayout indent="no">
<em>ident</em> ::= Id | Id.Id
<em>expr</em> ::= <em>eform</em>
  | (the <em>type</em> <em>eform</em>)
;; <em>eform permits</em> ident <em>via expr.id</em>
<em>eform</em> ::= Id
  | ()
  | <em>eform</em>.Id
  | (the <em>type</em> <em>eform</em>).Id
  | (pair <em>expr</em> <em>expr</em>)
  | (member <em>expr</em> Id)
  | <em>expr</em> [ <em>expr</em> ]
  | <em>expr</em> ^
  | (deref <em>expr</em>)
  | (suspend <em>ident</em> <em>expr</em>)
  | ({<em>expr</em>,}<sup>+</sup> <em>expr</em>)
  | (array <em>expr</em><sup>+</sup>)
  | (vector <em>expr</em><sup>+</sup>)
  | (MakeVector <em>expr</em> <em>expr</em>)
  | (begin <em>expr</em><sup>+</sup>)
  | (lambda (<em>bindingpattern</em><sup>*</sup>) <em>expr</em><sup>+</sup>)
  | (<em>expr</em> <em>expr</em><sup>*</sup>)
  | (if <em>expr</em> <em>expr</em> <em>expr</em>)
  | (and <em>expr</em><sup>+</sup>)
  | (or <em>expr</em><sup>+</sup>)
  | (set! <em>expr</em> <em>expr</em>)
  | (dup <em>expr</em>)
  | (cond ( {(<em>expr</em> <em>expr</em>)}<sup>*</sup>)
            (otherwise <em>expr</em>))
  <em>;; MAY NEED CASE</em>
  | (switch Id <em>expr</em>
            ( {(<em>switchtags</em> <em>expr_seq</em>)}<sup>*</sup>
              (otherwise <em>expr_seq</em>)))
  | (try <em>expr</em>
     (catch <em>Id</em> 
            {(<em>switchtags</em> <em>expr</em>)}<sup>*</sup> 
            (otherwise <em>expr</em>)<sup>?</sup>))
  | (throw <em>expr</em>)
  | (let ({(<em>bindingpattern</em> <em>expr</em>)}<sup>+</sup>)
      <em>expr</em>)
  | (letrec ({(<em>bindingpattern</em> <em>expr</em>)}<sup>+</sup>)
      <em>expr</em>)
  | (do ({(<em>bindingpattern</em> <em>expr</em> <em>expr</em>)}<sup>+</sup>)
      (<em>expr</em> <em>expr</em>)
      <em>expr</em>)
  | () | false | true | CharLit | StringLit
  | IntLit | FloatLit
<em>switchtags</em> ::= <em>ident</em> | (<em>ident</em><sup>+</sup>)
<!-- <em>expr</em> ::= Id -->
<!--   | <em>expr</em>.Id -->
</literallayout>

      </sect2>
      <sect2>
        <title>Miscellaneous</title>
        <literallayout indent="no">
<em>declare</em> ::=
    (declare {(<em>ident</em> <em>type</em>) | <em>ident</em>}<sup>+</sup>)
<em>docstring</em> := StringLit</literallayout>
      </sect2>
    </sect1>
  </subpart>
  <subpart>
    <title>Standard Library</title>
    <sect1>
      <title>BitC Standard Library</title>
      <p>
        <font color="red">This section needs badly to be completely
        revisited.</font>
      </p>
      <p>
	The BitC standard library is described as a set of groups. Each
	group gives a built-in function, a list of signatures supported
	by that built-in function, and a description of the operation of
	the function.
      </p>
      <sect2>
	<title>Arithmetic</title>
	<p>
	  BitC defines the built-in operators <progident>+</progident>,
	  <progident>-</progident>, <progident>*</progident>,
	  <progident>/</progident>, and <progident>%</progident>, with
	  the usual meanings of two's complement addition, subtraction,
	  multiplication, division and remainder for signed types, and
	  one's complement addition, subtraction, multiplication,
	  division, and remainder for unsigned types.
	</p>
	<p>
	  BitC also defines the build-in operators
	  <progident>bit-or</progident>, <progident>bit-xor</progident>,
	  and <progident>bit-and</progident>, with the usual meanings of
	  one's complement bit manipulation.
	</p>
	<p>
	  These operators are defined over the following signatures:
	</p>
	<table>
          <tbody>
            <tr>
              <td>int8 &cross; int8 &rarr; int8</td>
            </tr>
            <tr>
              <td>int16 &cross; int16 &rarr; int16</td>
            </tr>
            <tr>
              <td>int32 &cross; int32 &rarr; int32</td>
            </tr>
            <tr>
              <td>int64 &cross; int64 &rarr; int64</td>
            </tr>
            <tr>
              <td>uint8 &cross; uint8 &rarr; uint8</td>
            </tr>
            <tr>
              <td>uint16 &cross; uint16 &rarr; uint16</td>
            </tr>
            <tr>
              <td>uint32 &cross; uint32 &rarr; uint32</td>
            </tr>
            <tr>
              <td>uint64 &cross; uint64 &rarr; uint64</td>
            </tr>
          </tbody>
	</table>
	<p>
	  Unary minus is also supported over all integral types with the
	  usual meaning.
	</p>
      </sect2>
      <sect2>
	<title>Comparison</title>
	<p>
	  BitC defines the built-in comparison operators
	  <progident>&lt;</progident>, <progident>&lt;=</progident>
	  <progident>&gt;</progident> <progident>&gt;=</progident>
	  <progident>=</progident>, and <progident>!=</progident> with
	  the usual meanings of less than, less than or equal, greater
	  than, greater than or equal, equal, and not equal.
	</p>
	<p>
	  These operations are defined over the following signatures:
	</p>
	<table>
          <tbody>
            <tr>
              <td>char &cross; char &rarr; bool</td>
            </tr>
            <tr>
              <td>int8 &cross; int8 &rarr; bool</td>
            </tr>
            <tr>
              <td>int16 &cross; int16 &rarr; bool</td>
            </tr>
            <tr>
              <td>int32 &cross; int32 &rarr; bool</td>
            </tr>
            <tr>
              <td>int64 &cross; int64 &rarr; bool</td>
            </tr>
            <tr>
              <td>uint8 &cross; uint8 &rarr; bool</td>
            </tr>
            <tr>
              <td>uint16 &cross; uint16 &rarr; bool</td>
            </tr>
            <tr>
              <td>uint32 &cross; uint32 &rarr; bool</td>
            </tr>
            <tr>
              <td>uint64 &cross; uint64 &rarr; bool</td>
            </tr>
          </tbody>
	</table>
	<p>
	  The <progident>=</progident> and <progident>!=</progident>
	  operators are additionally defined over pointers of like
	  type. They perform structural equality (eq) and inequality.
	</p>
      </sect2>
    </sect1>
  </subpart>
  <sect1>
    <title>Verification Support</title>
    <p>
      In addition to its role as a means of expressing computation,
      BitC directly supports the expression of constraints on
      execution, and the expression of proof obligations concerning
      the results of computations. While the bulk of verification
      effort is performed in the BitC Prover, theorems and invariants
      also introduce requirements for compile-time static checking.
    </p>
    <p>
      Note that the phrase ``all possible variable instantiations'' is
      restricted to <em>legal</em> instantions as determined by the
      type checker. BitC is statically typed, and BitC functions and
      theorems are therefore defined only over their stated domains.
    </p>
    <sect2>
      <title>Axioms</title>
      <p>
	The <progident>defaxiom</progident> form introduces a term
	rewrite that is accepted as true by the BitC prover. The body
	of the axiom is a boolean expression that must always return
	<progident>true</progident> for all possible variable
	instantiations:
      </p>
      <literallayout>
(defaxiom <em>name</em> <em>truth-expr</em>)</literallayout>
    </sect2>
    <sect2>
      <title>Proof Obligations: Theorems</title>
      <p>
	The <progident>defthm</progident> form introduces a proof
	obligation that must be discharged by the BitC Prover. The
	body of a theorem is a boolean expression that is considered
	to be discharged if its result is <progident>true</progident>
	for all possible variable instantiations:
      </p>
      <literallayout>
(defthm <em>name</em> <em>truth-expr</em>)</literallayout>
    </sect2>
    <sect2>
      <title>Proof Obligations: Invariants and Suspensions</title>
      <p>
	The <progident>definvariant</progident> form introduces a
	proof obligation that must be discharged by the BitC Prover at
	all sequence points where it is not explicitly suspended. The
	body of an invariant is a boolean expression that is
	considered to be discharged if its result is
	<progident>true</progident> for all possible variable
	instantiations:
      </p>
      <literallayout>
(definvariant <em>name</em> <em>truth-expr</em>)</literallayout>
      <p>
        An invariant may be temporarily suspended by the
        <progident>suspend</progident> form:
      </p>
      <literallayout>
(suspend <em>name</em> <em>e</em>)</literallayout>
      <p indent="no">
        The logical effect of <progident>suspend</progident> is to
        advise the prover that the invariant given by
        <progident><em>name</em></progident> is not expected to hold
        within the scope of the <progident>suspend</progident> form.
      </p>
      <p>
        For program semantics purposes, <progident>suspend</progident>
        is a derived form:
      </p>
      <literallayout>
(suspend <em>name</em> <em>e</em>) =&gt;
(begin <em>e</em>)</literallayout>
    </sect2>
    <sect2>
      <title>Theories</title>
      <p>
        The <progident>deftheory</progident> form gathers a number of
        theorems into a single group for purposes of suspension:
      </p>
      <literallayout>
(deftheory <em>name</em> <em>thm<sub>1</sub></em> ... <em>thm<sub>n</sub></em>)</literallayout>
      <p indent="no">
        where each <progident><em>thm<sub>i</sub></em></progident> has been
        previously introduced by <progident>defthm</progident>.
      </p>
    </sect2>
    <sect2>
      <title>Suspending and Enabling</title>
      <p>
        For purposes of proof search management, theorems and theories
        may be disabled or enabled by the
        <progident>disable</progident> and
        <progident>enable</progident> forms:
      </p>
      <literallayout>
(disable <em>name<sub>1</sub></em> ... <em>name<sub>n</sub></em>)
(enable <em>name<sub>1</sub></em> ... <em>name<sub>n</sub></em>)</literallayout>
      <p indent="no">
        where each <progident><em>name<sub>i</sub></em></progident> has been
        previously introduced by <progident>defthm</progident> or
        <progident>deftheory</progident>.
      </p>
      <p>
        The effect of disablement is to render a theorem or group of
        theorems inactive for purposes of proof search.  Disabling or
        enabling remains in force until altered by a subsequent enable
        or disable or until the end of the containing lexical scope.
      </p>
    </sect2>
  </sect1>
  <sect1>
    <title>Acknowledgments</title>
    <p>
      We owe a significant debt to the help of Scott Smith of Johns
      Hopkins University. Scott's input has influenced our thinking
      about the BitC/L subset language. While BitC/L is not yet
      visible in the specification, some of the design decisions made
      here reflect constraints derived from BitC/L.
    </p>
    <p>
      Paritosh Shroff, also at Hopkins, spent a great deal of time
      helping us explore the implications, strengths, and weaknesses
      of the <progident>typecase</progident> construct that survived
      to version 0.8 of the specification and the ``match type''
      notion that was needed to support it. Beginning in version 0.9,
      we abandoned match types in favor of type classes. This decision
      was greatly assisted by the input of Mark Jones of the Oregon
      Graduate Institute.
    </p>
    <nocite ref="jones73thesis"/>
    <nocite ref="wirth1988pascal"/>    
  </sect1>
  <bibliography>
    <bibentry label="ansi1999c">
      &mdash;: American National Standard for Information Systems,
	Programming Language C ANSI X3.159-1999, 2000.
    </bibentry>
    <bibentry label="ieee1985std754">
      &mdash;: <doctitle>IEEE Standard for Binary Floating-Point
      Arithmetic</doctitle>, 1985, ANSI/IEEE Standard 754-1985.
    </bibentry>
    <bibentry label="ieee1987std854">
      &mdash;: <doctitle>IEEE Standard for Radix-Independent
      Floating-Point Arithmetic</doctitle>, 1987, ANSI/IEEE Standard
      854-1987.
    </bibentry>
    <bibentry label="garrigue2004value">
      Jacques Garrigue. ``Relaxing the Value Restriction.''
      <doctitle>Proc. International Symposium on Functional and Logic
      Programming</doctitle>. 2004.
    </bibentry>
    <bibentry label="jones73thesis">
      Anita K. Jones. <doctitle>Protection in Programmed
      Systems</doctitle>, Doctoral Dissertation, Department of
      Computer Science, Carnegie-Mellon University, June 1973.
    </bibentry>
    <bibentry label="jones2000tcfndepend">
      Mark Jones. ``Type Classes With Functional Dependencies.''
      <doctitle>Proc. 9th European Symposium on Programming</doctitle>
      (ESOP 2000). Berlin, Germany. March 2000. Springer-Verlag
      Lecture Notes in Computer Science 1782.
    </bibentry>
    <bibentry label="kaufmann00acl2">
      M. Kaufmann, J. S. Moore. <doctitle>Computer Aided Reasoning: An
      Approach</doctitle>, Kluwer Academic Publishers, 2000.
    </bibentry>
    <bibentry label="kelsey1998r5rs">
      Richard Kelsey, William Clinger, and Jonathan Rees (Ed.)
      <doctitle>Revised<sup>5</sup> Report on the Algorithmic Language
      Scheme</doctitle>,
      ACM SIGPLAN Notices, 33(<b>9</b>), pp 26&ndash;76, 1998.
    </bibentry>
    <bibentry label="macqueen1984modules">
      David MacQueen, ``Modules for Standard ML.''
      <doctitle>Proc. 1984 ACM Conference on LISP and Functional
      Programming</doctitle>, pp. 198&ndash;207, 1984.
    </bibentry>
    <bibentry label="milner1997definition">
      Robin Milner, Mads Tofte, Robert Harper, and David
      MacQueen. <doctitle>The Definition of Standard ML -
      Revised</doctitle>
      The MIT Press, May 1997.
    </bibentry>
    <bibentry label="diatchki2005representation">
      Iavor S. Diatchki, Mark P. Jones, and Rebekah Leslie.
      ``High- level Views on Low-level Representations.''
      <doctitle>Proc. 10th ACM Conference on Functional
        Programming</doctitle> pp. 168&ndash;179.
      September 2005.
    </bibentry>
    <bibentry label="shap1999fastcapsystem">
      J. S. Shapiro, J. M. Smith, and D. J. Farber. ``EROS, A Fast
      Capability System'' <doctitle>Proc. 17th ACM Symposium on Operating
      Systems Principles</doctitle>. Dec 1999, pp. 170&ndash;185. Kiawah
      Island Resort, SC, USA.
    </bibentry>
    <bibentry label="unicode410">
      Unicode Consortium. The Unicode Standard, version 4.1.0, defined
      by <doctitle>The Unicode Standard Version 4.0</doctitle>,
      Addison Wesley, 2003, ISBN 0-321-18578-1, as amended by
      <doctitle>Unicode 4.0.1</doctitle> and by <doctitle>Unicode
      4.1.0</doctitle>. <tt>http://www.unicode.org</tt>.
    </bibentry>
    <bibentry label="wirth1988pascal">
      N. Wirth and K. Jensen. <doctitle>Pascal: User Manual and
      Report</doctitle>, 3rd Edition, Springer-Verlag, 1988
    </bibentry>
  </bibliography>
  </article>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->
