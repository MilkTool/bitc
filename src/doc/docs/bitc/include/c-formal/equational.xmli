<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="eq-infer"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Type Inference</title> 
  <definition id="define_infer">
    <title>Type Inference</title> 
    <p>
      Type inference is a program
      transformation that accepts a program in which
      <progident>let</progident> expressions are not annotated
      with their kinds, and returns the same programs in which
      <progident>let</progident> expressions are annotated with
      their kinds and all expressions are annotated with their
      types.
    </p>
  </definition>
  <definition id="constraint-colection-ext-inf">
    <title>Constraint Collection over Inference Derivation</title>
    <p>
      Similar to 
      <btypes:TYPE>
	<defn tag="constraint-colection-ext-typ"/>
      </btypes:TYPE>, we write
      <btypes:TYPE>
	<spset>
	  <TEjudge name="i">
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <conclude>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </conclude>
	    <constrain>
	      <aCtset/>
	    </constrain>
	  </TEjudge>
	</spset>
      </btypes:TYPE> to denote the set of all constrained types and
      unconcstrained type variables used in the derivation of 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <spset>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <Unit/>
		    <unit/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <Empty/>
		</constrain>
	      </TEjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <id/>
		    <type/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset/>
		</constrain>
	      </TEjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <unin>
	      <spset>
		<gamma/>
		<store/>
		<type/>
		<aCtset/>
	      </spset>
	    </unin>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
    <p>
      Other cases are similar.
    </p>
  </definition>
  <definition id="infer-notation">
    <title>Notational Derivations</title>
    <p>
      We define the following derivations for notational convenience:
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	    <Sjudge name="sol">
	      <aSubMap/>
	      <leadsto>
		<aCtset/>
		<dCtset/>
	      </leadsto>
	    </Sjudge>
	    <Cst>
	      <assume>
		<aSubMap/>
	      </assume>
	      <set>
		<gamma/>
		<store/>
		<type/>
		<aCtset/>
	      </set>
	    </Cst>
	  </tyPre>
	  <tyConc>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </tyConc>
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	    <Sat>
	      <bCtset/>
	      <spset>
		<Subst>
		  <aSubMap/>
		  <TEjudge name="i">
		    <assume>
		      <gamma/>
		      <store/>
		    </assume>
		    <conclude>
		      <tqExpr>
			<aExpr/>
			<type/>
		      </tqExpr>
		    </conclude>
		    <constrain>
		      <aCtset/>
		    </constrain>
		  </TEjudge>
		</Subst>
	      </spset>
	    </Sat>
	  </tyPre>
	  <tyConc>
	    <TEjudge name="i">
	      <assume>
		<bCtset/>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </tyPre>
	  <tyConc>
	    <Sjudge>
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge name="*">
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	    <Cst>
	      <aSubMap/>
	      <set>
		<gamma/>
		<store/>
		<type/>
		<dCtset/>
	      </set>
	    </Cst>
	  </tyPre>
	  <tyConc>
	    <Sjudge name="*">
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	    <Cst>
	      <aSubMap/>
	      <set>
		<gamma/>
		<store/>
		<type/>
		<dCtset/>
	      </set>
	    </Cst>
	  </tyPre>
	  <tyConc>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
    </btypes:TYPE>
  </definition>
  <theorem id="unify-correct">
    <title>Correctness of Unification</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge name="sol">
	  <aSubMap/>
	  <leadsto>
	    <aCtset/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="unify-consistent">
    <title>Consistency of Unification</title>
    <p>
      If
      <btypes:TYPE>
	<CST>
	  <aCtset/>
	</CST>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Cst>
	  <assume/>
	  <Subst>
	    <aSubMap/>
	    <spset>
	      <aCtset/>
	    </spset>
	  </Subst>
	</Cst>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-satisfiable">
    <title>Satisfiability of Unified Constraints</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sat">
	  <scomp>
	    <aSubMap num="u"/>
	    <aSubMap num="s"/>
	  </scomp>
	  <leadsto>
	    <aCtset/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-principal">
    <title>Principality of Unified Types</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, where 
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> is a set of constraints obtained from the type
      inference algorithm, then
      <btypes:TYPE>
	<Forall/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sol">
	  <aSubMap num="s"/>
	  <leadsto>
	    <aCtset/>
	    <dCtset dash="'"/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>, we have
      <btypes:TYPE>
	<spEq>
	  <aSubMap num="u"/>
	  <aSubMap num="s"/>
	</spEq>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
 	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>. The interesting case is
      <btypes:TYPE>
	<unf>
	  <eq>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	    <Ptype/>
	  </eq>
	</unf>
      </btypes:TYPE>, in particular 
      <btypes:TYPE>
	<unf>
	  <eq>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	    <mbTop>
	      <tvar/>
	      <ptype dash="'"/>
	    </mbTop>
	  </eq>
	</unf>
      </btypes:TYPE>. This case is handled by noting that the
      inference algorithm only produces
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <ptype dash="'"/>
	</mbTop>
      </btypes:TYPE> types in the pair-selection rule, where
      <btypes:TYPE>
	<ptype dash="'"/>
      </btypes:TYPE> is of the form
      <btypes:TYPE>
	<pair>
	  <mbFull>
	    <tvar num="1"/>
	    <ptype num="1"/>
	  </mbFull>
	  <mbFull>
	    <tvar num="2"/>
	    <ptype num="2"/>
	  </mbFull>
	</pair>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-decidable">
    <title>Decidability of Unification</title>
    <p>
      A canonical derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>, where no two applications of the refelexive rule
      happen consequetively, halts forall
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>.
      That is,
      <btypes:TYPE>
	<Forall/>
	<aCtset/>
      </btypes:TYPE>,
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE> decidably either succeeds with
      <btypes:TYPE>
	<Pair>
	  <dCtset/>
	  <aSubMap/>
	</Pair>
      </btypes:TYPE> or fails with 
      <btypes:TYPE>
	<error/>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Let the <em>degree</em> of unification be defined as the tuple
      (number of 
      <btypes:TYPE>
	<tvar/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<lKind k="var"/>
      </btypes:TYPE> variables,
      number of MPC constaints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>, 
      the size of types within the equality constraints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>). 
      Now, the proof is by induction on the derivation of
      <btypes:TYPE>
 	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>, where we show that the degree of unification
      reduces in every recursive call.
    </p>
  </proof>
  <lemma>
    <title>Consistency of Inferred Types</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<CST>
	  <gamma/>
	  <store/>
	</CST>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<CST sp="yes">
	  <TEjudge name="i">
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <conclude>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </conclude>
	    <constrain>
	      <aCtset/>
	    </constrain>
	  </TEjudge>
	</CST>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>, using
      <btypes:TYPE>
	<lem tag="unify-consistent"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="subst-infer-cst">
    <title>Substitution Consistency over Inference Derivation</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Cst>
	  <assume>
	    <aSubMap/>
	  </assume>
	  <unin>
	    <set>
	      <gamma/>
	      <store/>
	      <type/>
	      <aCtset/>
	    </set>
	  </unin>
	</Cst>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Cst>
	  <assume>
	    <aSubMap/>
	  </assume>
	  <spset>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </spset>
	</Cst>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>, using
      <btypes:TYPE>
	<lem tag="unify-consistent"/>
      </btypes:TYPE>, and using the fact that we can assume
      <btypes:TYPE>
	<eq>
	  <inter>
	    <ftvs>
	      <aSubMap/>
	    </ftvs>
	    <ftvs>
	      <spset>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </spset>
	    </ftvs>
	  </inter>
	  <ftvs>
	    <gamma/>
	    <store/>
	    <type/>
	    <aCtset/>
	  </ftvs>
	</eq>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="infer_soundness">
    <title>Soundness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> then
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From the premise 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<bCtset/>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE>
	  of the theorem, using 
	  <btypes:TYPE>
	    <defn tag="infer-notation"/>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we obtain:
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Cst>
		  <aSubMap/>
		  <set>
		    <gamma/>
		    <store/>
		    <type/>
		    <aCtset/>
		  </set>
		</Cst>
	      </btypes:TYPE>.
	      Using
	      <btypes:TYPE>
		<lem tag="subst-infer-cst"/>
	      </btypes:TYPE>, this can be written as
	      <btypes:TYPE>
		<Cst>
		  <aSubMap/>
		  <spset>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr/>
			  <type/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </spset>
		</Cst>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <spset>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr/>
			  <type/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </spset>
		</models>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sat>
		  <bCtset/>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <TEjudge name="i">
			<assume>
			  <gamma/>
			  <store/>
			</assume>
			<conclude>
			  <tqExpr>
			    <aExpr/>
			    <type/>
			  </tqExpr>
			</conclude>
			<constrain>
			  <aCtset/>
			</constrain>
		      </TEjudge>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
	<p>
	  Now, we proceed by case analysis on the last step of the
	  derivation. 
	</p>
      </li>
      <li>
	<p>
	  Cases I-unit, I-Bool, I-Hloc and I-Sloc are trivial 
	</p>
      </li>
      <li>
	<p>
	  Case I-Id: In this case, we have
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <gamma/>
		  <id/>
		  <TS>
		    <tvars name="alpha"/>
		    <type num="x"/>
		    <dCtset num="x"/>
		  </TS>
		</mapsto>
		<eq>
		  <aSubMap num="x"/>
		  <plural>
		    <SubMap>
		      <tvar name="alpha"/>
		      <tvar name="beta"/>
		    </SubMap>
		  </plural>
		</eq>
		<models name="new">
		  <assume/>
		  <tvars name="beta"/>
		</models>
	      </tyPre>
	      <tyConc>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <id/>
		      <Subst>
			<aSubMap num="x"/>
			<type num="x"/>
		      </Subst>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <Subst>
		      <aSubMap num="x"/>
		      <dCtset num="x"/>
		    </Subst>
		  </constrain>
		</TEjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Proof folows from cases&nbsp;(1.b and 1.c) using T-ID rule
	  and the fact that variable replacement is always consistent.
	</p>
      </li>
      <li>
	<p>
	  Case I-Lambda: 
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <TEjudge name="i">
		      <assume>
			<extend>
			  <gamma/>
			  <mapping>
			    <id/>
			    <mbFull>
			      <tvar name="beta"/>
			      <tvar name="alpha"/>
			    </mbFull>
			  </mapping>
			</extend>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="r"/>
			  <type num="r"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		    <models name="new">
		      <assume/>
		      <grouping>
			<tvar name="alpha"/>
			<tvar name="beta"/>
			<tvar name="beta" dash="'"/>
			<tvar name="gamma"/>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </grouping>
		    </models>
		  </tyPre>
		  <tyConc>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <lambda>
			    <id/>
			    <aExpr num="r"/>
			  </lambda>
			  <fn>		
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="alpha"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="delta"/>
			    </mbFull>
			  </fn>
			</tqExpr>
		      </conclude>
		      <constrain>
			<unin>
			  <aCtset/>
			  <set>
			    <eq>
			      <type num="r"/>
			      <mbFull>
				<tvar name="gamma"/>
				<tvar name="delta"/>
			      </mbFull>
			    </eq>
			  </set>
			</unin>
		      </constrain>
		    </TEjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>
	    </btypes:TYPE>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1 and 4.a), by weakening, we have	
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<mbFull>
			  <tvar name="beta"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="r"/>
		      <type num="r"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>. 
	      Now, from induction hypothesis, we have
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<mbFull>
			  <tvar name="beta"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="r"/>
		    <type num="r"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.d), using weakening, we obtain
 	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <set>
		    <mbFull>
		      <tvar name="beta"/>
		      <tvar name="alpha"/>
		    </mbFull>
		    <mbFull>
		      <tvar name="beta" dash="'"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </set>
		</models>
	      </btypes:TYPE>. Now, from
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE> (property 3), we conclude that 
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="beta"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="beta" dash="'"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Similarly, we conclude that 
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma" dash="'"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.b) and the constraint
 	      <btypes:TYPE>
		<eq>
		  <type num="r"/>
		  <mbFull>
		    <tvar name="gamma"/>
		    <tvar name="delta"/>
		  </mbFull>
		</eq>
	      </btypes:TYPE>, we obtain
 	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <type num="r"/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Now, using case&nbsp;(4.c), we obtain
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <type num="r"/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma" dash="'"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.b, 4.c and 4.d) and 
	      the T-Lambda rule, we obtain
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <lambda>
		      <id/>
		      <aExpr num="r"/>
		    </lambda>
		    <fn>		
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="alpha"/>
		      </mbFull>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </mbFull>
		    </fn>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Finally, using this with case&nbsp;(1), we conclude that
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <lambda>
		      <id/>
		      <aExpr num="r"/>
		    </lambda>
		    <fn>		
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="alpha"/>
		      </mbFull>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </mbFull>
		    </fn>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case I-App:
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="1"/>
			  <type num="1"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset num="1"/>                  
		      </constrain>
		    </TEjudge>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="2"/>
			  <type num="2"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset num="2"/>                  
		      </constrain>
		    </TEjudge>
		  </tyPre>
		  <tyPre>
		    <models name="new">
		      <assume/>
		      <grouping>
			<tvar name="alpha"/>
			<tvar name="beta"/>
			<tvar name="beta" dash="'"/>
			<tvar name="gamma"/>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
			<tvar name="epsiv"/>
		      </grouping>
		    </models>
		  </tyPre>
		  <tyConc>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>                 
			  <mbFull>
			    <tvar name="epsiv"/>
			    <tvar name="gamma"/>			
			  </mbFull>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>
	    </btypes:TYPE>
	    <p>
	      where,
	      <br/>
	      <btypes:TYPE>
		<eq>
		  <aCtset/>
		  <unin>
		    <aCtset num="1"/>
		    <aCtset num="2"/>
		    <set>
		      <eq>
			<type num="1"/>
			<mbFull>
			  <tvar name="alpha"/>
			  <fn>
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="beta"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="gamma"/>
			    </mbFull>
			  </fn>
			</mbFull>
		      </eq>
		      <eq>
			<type num="2"/>
			<mbFull>
			  <tvar name="delta"/>
			  <tvar name="beta"/>
			</mbFull>
		      </eq>
		    </set>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Using weakening on case&nbsp;(1), we obtain
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge name="sol">
		      <aSubMap/>
		      <leadsto>
			<aCtset num="1"/>
			<dCtset num="1"/>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <Sjudge name="sol">
		      <aSubMap/>
		      <leadsto>
			<aCtset num="2"/>
			<dCtset num="2"/>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <spset>
			<TEjudge name="i">
			  <assume>
			    <gamma/>
			    <store/>
			  </assume>
			  <conclude>
			    <tqExpr>
			      <aExpr num="1"/>
			      <type num="1"/>
			    </tqExpr>
			  </conclude>
			  <constrain>
			    <aCtset num="1"/>
			  </constrain>
			</TEjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE> and
		  <br/>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <spset>
			<TEjudge name="i">
			  <assume>
			    <gamma/>
			    <store/>
			  </assume>
			  <conclude>
			    <tqExpr>
			      <aExpr num="2"/>
			      <type num="2"/>
			    </tqExpr>
			  </conclude>
			  <constrain>
			    <aCtset num="2"/>
			  </constrain>
			</TEjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <spset>
			<Subst>
			  <aSubMap/>
			  <TEjudge name="i">
			    <assume>
			      <gamma/>
			      <store/>
			    </assume>
			    <conclude>
			      <tqExpr>
				<aExpr num="1"/>
				<type num="1"/>
			      </tqExpr>
			    </conclude>
			    <constrain>
			      <aCtset num="1"/>
			    </constrain>
			  </TEjudge>
			</Subst>
		      </spset>
		    </Sat>
		  </btypes:TYPE> and
		  <br/>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <spset>
			<Subst>
			  <aSubMap/>
			  <TEjudge name="i">
			    <assume>
			      <gamma/>
			      <store/>
			    </assume>
			    <conclude>
			      <tqExpr>
				<aExpr num="2"/>
				<type num="2"/>
			      </tqExpr>
			    </conclude>
			    <constrain>
			      <aCtset num="2"/>
			    </constrain>
			  </TEjudge>
			</Subst>
		      </spset>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(5.a and 5.b), we obtain
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="1"/>
		      <type num="1"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset num="1"/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="2"/>
		      <type num="2"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset num="2"/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(5.c) and induction hypothesis, we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="1"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="1"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Note that since
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<eq>
		  <aCtset/>
		  <unin>
		    <aCtset num="1"/>
		    <aCtset num="2"/>
		    <set>
		      <eq>
			<type num="1"/>
			<mbFull>
			  <tvar name="alpha"/>
			  <fn>
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="beta"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="gamma"/>
			    </mbFull>
			  </fn>
			</mbFull>
		      </eq>
		      <eq>
			<type num="2"/>
			<mbFull>
			  <tvar name="delta"/>
			  <tvar name="beta"/>
			</mbFull>
		      </eq>
		    </set>
		  </unin>
		</eq>
	      </btypes:TYPE>,
	      we have
	      <btypes:TYPE>
		<eq>
		  <dCtset/>
		  <unin>
		    <dCtset num="1"/>
		    <dCtset num="2"/>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.b) and the constraint
	      <btypes:TYPE>
		<eq>
		  <type num="1"/>
		  <mbFull>
		    <tvar name="alpha"/>
		    <fn>
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="beta"/>
		      </mbFull>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="gamma"/>
		      </mbFull>
		    </fn>
		  </mbFull>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="alpha"/>
		      <fn>
			<mbFull>
			  <tvar name="beta" dash="'"/>
			  <tvar name="beta"/>
			</mbFull>
			<mbFull>
			  <tvar name="gamma" dash="'"/>
			  <tvar name="gamma"/>
			</mbFull>
		      </fn>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Since
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="1"/>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="alpha"/>
			<fn>
			  <mbFull>
			    <tvar name="beta" dash="'"/>
			    <tvar name="beta"/>
			  </mbFull>
			  <mbFull>
			    <tvar name="gamma" dash="'"/>
			    <tvar name="gamma"/>
			  </mbFull>
			</fn>
		      </mbFull>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>.
	      From case&nbsp;(1.d) and
	      <btypes:TYPE>
		<lem tag="T-msm_eq_ms"/>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq br="yes">
		  <minz>
		    <Subst>
		    <aSubMap/>
		      <mbFull>
			<tvar name="alpha"/>
			<fn>
			  <mbFull>
			    <tvar name="beta" dash="'"/>
			    <tvar name="beta"/>
			  </mbFull>
			  <mbFull>
			    <tvar name="gamma" dash="'"/>
			    <tvar name="gamma"/>
			  </mbFull>
			</fn>
		      </mbFull>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<mbFull>
			  <tvar name="alpha"/>
			  <fn>
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="beta"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="gamma"/>
			    </mbFull>
			  </fn>
			</mbFull>
		      </minz>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>.
	      Further, we have
	      <btypes:TYPE>
		<eq br="yes">
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<fn>
			  <mbFull>
			    <tvar name="beta" dash="'"/>
			    <tvar name="beta"/>
			  </mbFull>
			  <mbFull>
			    <tvar name="gamma" dash="'"/>
			    <tvar name="gamma"/>
			  </mbFull>
			</fn>
		      </minz>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <fn>
			<mbFull>
			  <tvar name="beta" dash="'"/>
			  <tvar name="beta"/>
			</mbFull>
			<mbFull>
			  <tvar name="gamma" dash="'"/>
			  <tvar name="gamma"/>
			</mbFull>
		      </fn>
		    </Subst>
		  </minz>
		  <fn>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="beta"/>
		      </mbFull>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="gamma"/>
		      </mbFull>
		    </Subst>
		  </fn>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(5.f and 5.g), we have
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <fn>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="beta"/>
		      </mbFull>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="gamma"/>
		      </mbFull>
		    </Subst>
		  </fn>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, using the constraint 
	      <btypes:TYPE>
		<eq>
		  <type num="2"/>
		  <mbFull>
		    <tvar name="delta"/>
		    <tvar name="beta"/>
		  </mbFull>
		</eq>
	      </btypes:TYPE>, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="delta"/>
			<tvar name="beta"/>
		      </mbFull>
		    </Subst>
		  </minz>		      
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, using the constraint 
	      <btypes:TYPE>
		<eq>
		  <type num="2"/>
		  <mbFull>
		    <tvar name="delta"/>
		    <tvar name="beta"/>
		  </mbFull>
		</eq>
	      </btypes:TYPE>, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="delta"/>
			<tvar name="beta"/>
		      </mbFull>
		    </Subst>
		  </minz>		      
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.d), using weakening, we obtain
 	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <set>
		    <mbFull>
		      <tvar name="gamma" dash="'"/>
		      <tvar name="gamma"/>
		    </mbFull>
		    <mbFull>
		      <tvar name="epsiv"/>
		      <tvar name="gamma"/>
		    </mbFull>
		  </set>
		</models>
	      </btypes:TYPE>. Now, from
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE> (property 4), we conclude that 
 	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="gamma"/>
		      </mbFull>
		    </Subst>
		  </maxz>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="epsiv"/>
		      <tvar name="gamma"/>
		    </mbFull>
		  </Subst>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(5.d, 5.h, 5.i and 5.k) 
	      and the T-App rule, we conclude that
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </apply>
		    <mbFull>
		      <tvar name="epsiv"/>
		      <tvar name="gamma"/>			
		    </mbFull>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Finally, using this with case&nbsp;(1), we conclude that
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </apply>
		    <mbFull>
		      <tvar name="epsiv"/>
		      <tvar name="gamma"/>			
		    </mbFull>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case I-Let-Exp: In this case, we have:
	</p>
	<btypes:TYPE>
	  <tyRule name=""> 
	    <tyPre>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset num="1"/>                  
		</constrain>
	      </TEjudge>
	      <neq>
		<aExpr num="1"/>
		<vExp/>
	      </neq>
	    </tyPre>
	    <tyPre>
	      <TEjudge name="i">
		<assume>
		  <extend>
		    <gamma/>
		    <mapping>
		      <id/>
		      <mbFull>
			<tvar name="alpha"/>
			<tvar name="beta"/>
		      </mbFull>
		    </mapping>
		  </extend>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset num="2"/>
		</constrain>
	      </TEjudge>
	      <models name="new">
		<assume/>
		<grouping>
		  <tvar name="alpha"/>
		  <tvar name="beta"/>
		  <tvar name="gamma"/>
		  <lKind k="var"/>
		</grouping>
	      </models>
	    </tyPre>
	    <tyConc>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <let kind="k">
		      <id/>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </let>
		    <type num="2"/>
		  </tqExpr>
		</conclude>
		<constrain>        
		  <aCtset/>
		</constrain>
	      </TEjudge>
	    </tyConc>
	  </tyRule>        
	</btypes:TYPE>
	<p>
	  where 
	  <btypes:TYPE>
	    <eq>
	      <aCtset/>
	      <unin>
		<aCtset num="1"/>
		<set>
		  <eq>
		    <type num="1"/>
		    <mbFull>
		      <tvar name="gamma"/>
		      <tvar name="beta"/>
		    </mbFull>
		  </eq>
		  <eq>
		    <lKind k="var"/>
		    <lKind k="mono"/>
		  </eq>
		</set>
		<aCtset num="2"/>
	      </unin>
	    </eq>
	  </btypes:TYPE>.
	</p>
	<p>
	  Proof is similar to the I-App case, proof follows from
	  induction hypothesis using the T-Let-M rule, case&nbsp;(1)
	  and  <btypes:TYPE>
	    <lem tag="T-SSubstitution"/>
	  </btypes:TYPE> (property 4).
	</p>
      </li>
      <li>
	<p>
	  Case I-Let-Val:
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have:
	    </p>
	    <btypes:TYPE>
	      <tyRule> 
		<tyPre>
		  <TEjudge name="i">
		    <assume>
		      <gamma/>
		      <store/>
		    </assume>
		    <conclude>
		      <tqExpr>
			<vExp/>
			<type num="1"/>
		      </tqExpr>
		    </conclude>
		    <constrain>
		      <aCtset num="1"/>                  
		    </constrain>
		  </TEjudge>
		  <eq>
		    <aCtset num="1" dash="'"/>
		    <unin>
		      <aCtset num="1"/>
		      <set>
			<eq>
			  <type num="1"/>
			  <mbFull>
			    <tvar name="gamma"/>
			    <tvar name="beta"/>
			  </mbFull>
			</eq>
		      </set>
		    </unin>
		  </eq>
		</tyPre>
		<tyPre>
		  <eq>
		    <unf>
		      <aCtset num="1" dash="'"/>
		    </unf>
		    <Pair>
		      <dCtset num="u"/>
		      <aSubMap num="u"/>
		    </Pair>
		  </eq>
		  <eq>
		    <dCtset num="s"/>
		    <unin>
		      <dCtset num="u"/>
		      <set>
			<pcst>
			  <id/>
			  <lKind k="var"/>
			  <type num="s"/>
			</pcst>
		      </set>
		    </unin>
		  </eq>
		</tyPre>
		<tyPre>
		  <eq>
		    <type num="s"/>
		    <Subst>
		      <aSubMap num="u"/>
		      <mbFull>
			<tvar name="delta"/>
			<tvar name="beta"/>
		      </mbFull>
		    </Subst>
		  </eq>
		  <eq>
		    <set>
		      <tvars name="alpha"/>
		    </set>
		    <diff>
		      <ftvs>
			<type num="s"/>
			<dCtset num="s"/>
		      </ftvs>
		      <ftvs>
			<Subst>
			  <aSubMap num="u"/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap num="u"/>
			  <store/>
			</Subst>
		      </ftvs>
		    </diff>
		  </eq>
		</tyPre>
		<tyPre>
		  <TEjudge name="i">
		    <assume>
		      <extend>
			<gamma/>
			<mapping>
			  <id/>
			  <TS>
			    <tvars/>
			    <type num="s"/>
			    <dCtset num="s"/>
			  </TS>
			</mapping>
		      </extend>
		      <store/>
		    </assume>
		    <conclude>
		      <tqExpr>
			<aExpr/>
			<type num="2"/>
		      </tqExpr>
		    </conclude>
		    <constrain>
		      <aCtset num="2"/>
		    </constrain>
		  </TEjudge>
		  <models name="new">
		    <assume/>
		    <grouping>
		      <tvar name="beta"/>
		      <tvar name="gamma"/>
		      <tvar name="delta"/>
		      <tvars name="epsiv"/>
		      <lKind k="var"/>
		    </grouping>
		  </models>
		</tyPre>
		<tyConc>
		  <TEjudge name="i">
		    <assume>
		      <gamma/>
		      <store/>
		    </assume>
		    <conclude>
		      <tqExpr>
			<let kind="k">
			  <id/>
			  <aExpr num="1"/>
			  <aExpr num="2"/>
			</let>
			<type num="2"/>
		      </tqExpr>
		    </conclude>
		    <constrain>        
		      <unin>
			<subst>
			  <aCtset num="1" dash="'"/>
			  <tvars name="alpha"/>
			  <tvars name="epsiv"/>
			</subst>
			<aCtset num="2"/>
		      </unin>
		    </constrain>
		  </TEjudge>
		</tyConc>
	      </tyRule>
	    </btypes:TYPE>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(7.a) and 
	      <btypes:TYPE>
		<thm tag="unify-correct"/>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap num="u"/>
		  <leadsto>
		    <aCtset dash="'"/>
		    <dCtset num="u"/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      By weakening on case&nbsp;(1.b), we have
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <subst>
		      <aCtset num="1" dash="'"/>
		      <tvars name="alpha"/>
		      <tvars name="epsiv"/>
		    </subst>
		    <dCtset num="1"/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset num="2"/>
		    <dCtset num="2"/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>
	      for some
	      <btypes:TYPE>
		<dCtset num="1"/>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<dCtset num="2"/>
	      </btypes:TYPE>.
	      Further,
	      <btypes:TYPE>
		<eq>
		  <dCtset/>
		  <unin>
		    <dCtset num="1"/>
		    <dCtset num="2"/>
		  </unin>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(7.c and 7.d), 
	      <btypes:TYPE>
		<thm tag="unify-principal"/>
	      </btypes:TYPE> and the fact that the variables
	      <btypes:TYPE>
		<tvars/>
	      </btypes:TYPE> are purely local to the derivation
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <vExp/>
		      <type num="1"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset num="1"/>                  
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<Exists/>
		<aSubMap dash="'"/>
	      </btypes:TYPE>
	      such that
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <spEq>
		      <aSubMap num="u"/>
		      <aSubMap dash="'"/>
		    </spEq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge name="sol">
		      <aSubMap dash="'"/>
		      <leadsto>
			<aCtset dash="'"/>
			<Subst>
			  <aSubMap dash="'"/>
			  <dCtset num="u"/>
			</Subst>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <TEjudge name="i">
		      <assume>
			<bCtset/>
			<aSubMap dash="'"/>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <vExp/>
			  <type num="1"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset num="1"/>                  
		      </constrain>
		    </TEjudge>
		  </btypes:TYPE>		  
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<gamma/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<gamma/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<store/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<store/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<type num="1"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="1"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<type num="s"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="s"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<dCtset num="s"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<dCtset num="s"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <set>
			<tvars name="alpha"/>
		      </set>
		      <diff>
			<ftvs>
			  <Subst>
			    <aSubMap/>
			    <type num="s"/>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <dCtset num="s"/>
			  </Subst>
			</ftvs>
			<ftvs>
			  <Subst>
			    <aSubMap dash="'"/>
			    <gamma/>
			  </Subst>
			  <Subst>
			    <aSubMap dash="'"/>
			    <store/>
			  </Subst>
			</ftvs>
		      </diff>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(7.d.iii) and induction hypothesis, 
	      we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap dash="'"/>
		    <dCtset num="u"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <vExp/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Due to case&nbsp;(7.d.iv), this can be written as
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="u"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <vExp/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Let
	      <btypes:TYPE>
		<eq>
		  <type num="1" dash="'"/>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="1"/>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>.
	      Evidently, 
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <type num="1" dash="'"/>
		</Msub>
	      </btypes:TYPE>.
	      using this in case&nbsp;(7.e), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="u"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <Msub>
		    <vExp/>
		    <type num="1" dash="'"/>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similar to the I-App case, using 
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE> (property 4), we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="s"/>
		  </Subst>
		  <type num="1" dash="'"/>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Evidently,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <dCtset/>
		  </Subst>
		  <unin>
		    <Subst>
		      <aSubMap/>
		      <dCtset num="u"/>
		    </Subst>
		    <set>
		      <pcst>
			<id/>
			<lKind k="var"/>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </pcst>
		    </set>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(7.d.v and 7.d.iv), we have
	      <btypes:TYPE>
		<eq>
		  <set>
		    <tvars name="alpha"/>
		  </set>
		  <diff>
		    <ftvs>
		      <Subst>
			<aSubMap/>
			<type num="s"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<dCtset num="s"/>
		      </Subst>
		    </ftvs>
		    <ftvs>
		      <Subst>
			<aSubMap/>
			<gamma/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<store/>
		      </Subst>
		    </ftvs>
		  </diff>
		</eq>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      From weakening on case&nbsp;(1) and induction
	      hypothesis, we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="2"/>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<TS>
			  <tvars/>
			  <type num="s"/>
			  <dCtset num="s"/>
			</TS>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Finally, from cases&nbsp;(7.f, 7.g, 7.h, 7.i, 7.j and
	      1), using the T-Let-MP rule, we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
 		  </assume>
		  <tqExpr>
		    <let>
		      <id/>
		      <vExp/>
		      <aExpr/>
		    </let>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
    </ol>
  </proof>
  <theorem id="infer_completeness">
    <title>Completeness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <aSubMap dash="'"/>
	  <aSubMap/>
	</supeq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<supeq>
	  <bCtset dash="'"/>
	  <bCtset/>
	</supeq>
      </btypes:TYPE> 
      such that 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <bCtset dash="'"/>
	    <aSubMap dash="'"/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <diff>
	    <dom>
	      <aSubMap dash="'"/>
	    </dom>
	    <dom>
	      <aSubMap/>
	    </dom>
	  </diff>
	  <diff>
	    <dom>
	      <aCtset dash="'"/>
	    </dom>
	    <dom>
	      <aCtset/>
	    </dom>
	  </diff>
	  <set>
	    <grouping>
	      <tvars/>
	      <ST/>
	      <tvar/>
	      <text content=" is a fresh variable used in "/>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset/>
		</constrain>
	      </TEjudge>
      	    </grouping>
	  </set>
	</eq>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.      
    </p>
    <ol>
      <li>
	<p>
	  From the premise
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE> of the theorem, using 
	  using 
	  <btypes:TYPE>
	    <defn tag="infer-notation"/>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <defn tag="consistent-typing"/>
	  </btypes:TYPE>, we obtain:
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>	      
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Cst>
		  <aSubMap/>
		  <set>
		    <gamma/>
		    <store/>
		    <type/>
		    <dCtset/>
		  </set>
		</Cst>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sat>
		  <bCtset/>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <dCtset/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<Subst>
			  <aSubMap/>
			  <aExpr/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
	We need to show that for some 
	<btypes:TYPE>
	  <aCtset/>
	</btypes:TYPE> and
	<btypes:TYPE>
	  <supeq>
	    <aSubMap dash="'"/>
	    <aSubMap/>
	  </supeq>
	</btypes:TYPE>,
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <dCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap dash="'"/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Cst>
		  <assume>
		    <aSubMap dash="'"/>
		  </assume>
		  <set>
		    <gamma/>
		    <store/>
		    <type/>
		    <aCtset/>
		  </set>
		</Cst>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sat>
		  <bCtset/>
		  <spset>
		    <Subst>
		      <aSubMap dash="'"/>
		      <TEjudge name="i">
			<assume>
			  <gamma/>
			  <store/>
			</assume>
			<conclude>
			  <tqExpr>
			    <aExpr/>
			    <type/>
			  </tqExpr>
			</conclude>
			<constrain>
			  <aCtset/>
			</constrain>
		      </TEjudge>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
	<p>
	  Now, we proceed by case analysis on the last step of the
	  derivation.
	</p>
      </li>
      <li>
	<p>
	  Cases T-Unit, T-Bool, T-Hloc, and T-Sloc are trivial.
	</p>
      </li>
      <li>
	<p>
	  Case T-ID:
	  In this case, we have:
	</p>
	<btypes:TYPE>
	  <tyRule>
	    <tyPre>
	      <mapsto>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<id/>
		<TS>
		  <tvars/>
		  <Subst>
		    <aSubMap/>
		    <type/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <dCtset/>
		  </Subst>
		</TS>
	      </mapsto>
	      <Cst>
		<aSubMap num="x"/>
		<set>
		  <Subst>
		    <aSubMap/>
		    <type/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <dCtset/>
		  </Subst>
		</set>
	      </Cst>
	    </tyPre>
	    <tyPre>
	      <eq>
		<dom>
		  <aSubMap num="x"/>
		</dom>
		<set>
		  <tvars/>
		</set>
	      </eq>
	    </tyPre>
	    <tyConc>
	      <TDjudge>
		<id/>
		<Subst>
		  <compose>
		    <aSubMap/>
		    <aSubMap num="x"/>
		  </compose>
		  <type/>
		</Subst>
		<Subst>
		  <compose>
		    <aSubMap/>
		    <aSubMap num="x"/>
		  </compose>
		  <dCtset/>
		</Subst>
	      </TDjudge>
	    </tyConc>
	  </tyRule>        
	</btypes:TYPE>	
	<p>
	  Without change in meaning, we can write
	  <btypes:TYPE>
	    <mapsto>
	      <gamma/>
	      <id/>
	      <TS>
		<tvars name="gamma"/>
		<type/>
		<dCtset/>
	      </TS>
	    </mapsto>
	  </btypes:TYPE>.
	  Now, we can write:
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <gamma/>
		  <id/>
		  <TS>
		    <tvars name="gamma"/>
		    <type/>
		    <dCtset/>
		  </TS>
		</mapsto>
		<eq>
		  <aSubMap name="y"/>
		  <plural>
		    <SubMap>
		      <tvar name="gamma"/>
		      <tvar name="alpha"/>
		    </SubMap>
		  </plural>
		</eq>
		<models name="new">
		  <assume/>
		  <tvars name="alpha"/>
		</models>
	      </tyPre>
	      <tyConc>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <id/>
		      <Subst>
			<aSubMap num="y"/>
			<type/>
		      </Subst>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <Subst>
		      <aSubMap num="y"/>
		      <dCtset/>
		    </Subst>
		  </constrain>
		</TEjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Let
	  <btypes:TYPE>
	    <eq>
	      <aSubMap dash="'"/>
	      <compose>
		<aSubMap/>
		<aSubMap num="x"/>
	      </compose>
	    </eq>
	  </btypes:TYPE>. 
	  The result now follows from I-Id rule and case&nbsp;(1.c).
	</p>
      </li>
      <li>
	<p>
	  Case T-Lambda:
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <dCtset/>
			</Subst>
			<extend>
			  <Subst>
			    <aSubMap/>
			    <gamma/>
			  </Subst>
			  <mapping>
			    <id/>
			    <Subst>
			      <aSubMap/>
			      <type num="1"/>
			    </Subst>
			  </mapping>
			</extend>
			<store/>
		      </assume>
		      <tqExpr>
			<aExpr/>
			<Subst>
			  <aSubMap/>
			  <type num="2"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </tyPre>
		  <tyPre>
		    <eq under="minz">
		      <Subst>
			<aSubMap/>
			<type num="1"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="1" dash="'"/>
		      </Subst>
		    </eq>
		    <eq under="minz">
		      <Subst>
			<aSubMap/>
			<type num="2"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="2" dash="'"/>
		      </Subst>
		    </eq>
		  </tyPre>
		  <tyConc>
		    <TDjudge>
		      <lambda>
			<id/>
			<aExpr/>
		      </lambda>
		      <Subst>
			<aSubMap/>
			<fn>
			  <type num="1" dash="'"/>
			  <type num="2" dash="'"/>
			</fn>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<dCtset/>
		      </Subst>
		    </TDjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>
	    </btypes:TYPE>
	  </li>
	  <li>
	    <p>
	      By induction hypothesis, we have, for some
	      <btypes:TYPE>
		<aSubMap dash="''"/>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<bCtset dash="''"/>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<subeq>
		  <bCtset/>
		  <bCtset dash="''"/>
		</subeq>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<spEq>
		  <aSubMap/>
		  <aSubMap dash="''"/>
		</spEq>
	      </btypes:TYPE>, 
	      we have
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <TEjudge name="i">
		      <assume>
			<bCtset dash="'"/>
			<aSubMap dash="'"/>
			<extend>
			  <gamma/>
			  <mapping>
			    <id/>
			    <type num="1"/>
			  </mapping>
			</extend>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr/>
			  <type num="2"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge name="sat">
		      <aSubMap/>
		      <leadsto>
			<aCtset/>
			<dCtset/>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      We pick 
	      <btypes:TYPE>
		<aSubMap dash="'"/>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<eq>
		  <aSubMap dash="'"/>
		  <compose>
		    <aSubMap dash="''"/>
		    <aSubMap num="new"/>
		  </compose>
		</eq>
	      </btypes:TYPE>, where
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aSubMap name="new"/>
		      </dom>
		      <set>
			<tvar name="alpha"/>
			<tvar name="beta"/>
			<tvar name="beta" dash="'"/>
			<tvar name="gamma"/>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </set>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<mbFull>
			  <tvar name="beta"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="1"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<mbFull>
			  <tvar name="gamma"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="2"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<mbFull>
			  <tvar name="beta" dash="'"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="1" dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>, possible due to
		  <btypes:TYPE>
		    <eq under="minz">
		      <Subst>
			<aSubMap/>
			<type num="1"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="1" dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<mbFull>
			  <tvar name="gamma"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="2"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>,
		  possible due to <btypes:TYPE>
		    <eq under="minz">
		      <Subst>
			<aSubMap/>
			<type num="2"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="2" dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Evidently,
	      <btypes:TYPE>
		<Sjudge name="sat">
		  <aSubMap dash="'"/>
		  <leadsto>
		    <unin>
		      <aCtset/>
		      <set>
			<eq>
			  <type/>
			  <mbFull>
			    <tvar name="gamma"/>
			    <tvar name="delta"/>
			  </mbFull>
			</eq>
		      </set>
		    </unin>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We also extend
	      <btypes:TYPE>
		<bCtset dash="''"/>
	      </btypes:TYPE> to 
	      <btypes:TYPE>
		<bCtset dash="'"/>
	      </btypes:TYPE> with entries for new type variables. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, using I-Lambda rule and case&nbsp;(1.c), we obtain
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset dash="'"/>
		    <aSubMap dash="'"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <lambda>
			<id/>
			<aExpr/>
		      </lambda>
		      <fn>		
			<mbFull>
			  <tvar name="beta" dash="'"/>
			  <tvar name="alpha"/>
			</mbFull>
			<mbFull>
			  <tvar name="gamma" dash="'"/>
			  <tvar name="delta"/>
			</mbFull>
		      </fn>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <dCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>	  
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <theorem id="infer_soundness2">
    <title>Soundness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <aSubMap/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> then
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_soundness"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<lem tag="maybe-cst-properties"/>
      </btypes:TYPE> (property 3).
    </p>
  </proof>
  <theorem id="type_chekability">
    <title>Type Chekability</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset num="u"/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Exists/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sat">
	  <aSubMap num="s"/>
	  <leadsto>
	    <dCtset num="u"/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Subst>
	  <scomp>
	    <aSubMap num="u"/>
	    <aSubMap num="s"/>
	  </scomp>
	  <aExpr/>
	</Subst>
      </btypes:TYPE> is canonical, and
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <scomp>
	      <aSubMap num="u"/>
	      <aSubMap num="s"/>
	    </scomp>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_soundness2"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<thm tag="unify-satisfiable"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="infer_completeness2">
    <title>Completeness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <aSubMap dash="'"/>
	  <aSubMap/>
	</supeq>
      </btypes:TYPE> 
      such that 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <aSubMap dash="'"/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_completeness"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<lem tag="maybe-cst-properties"/>
      </btypes:TYPE> (property 4).
    </p>
  </proof>
  </sect1>
