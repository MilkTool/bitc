<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="eq-infer"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Type Inference</title> 
  <p>
    <leadin>Equational Presentation</leadin>
  </p>
  <btypes:TYPE>        
    <grammar>
      <bnf desc="Types">
	<type/>
	<alternatives>
	  <tvar name="alpha"/>
	  <unit/>
	  <bool/>
	  <fn M="yes"><type/><type/></fn>                  
	</alternatives>
      </bnf>
      <bnfc desc="">
	<alternatives>
	  <ref><type/></ref>
	  <mutable><type/></mutable>
	</alternatives>
      </bnfc>
      <bnf desc="Constr. Type">
	<aCtype/>
	<alternatives>
	  <type/>
	  <ctype>
	    <type/>
	    <aCtset/>
	  </ctype>
	</alternatives>
      </bnf>
      <bnf desc="Type Scheme">          
	<aTS/>
	<alternatives>
	  <aCtype/>
	  <forall>                    
	    <tvar name="alpha"/>
	    <aTS/>
	  </forall>
	</alternatives>
      </bnf>
      <bnf desc="Constraints">
	<constraint/>
	<alternatives>
	  <eq>
	    <type/>
	    <type/>
	  </eq>
	  <ceq>
	    <type/>
	    <type/> 
	  </ceq>
	  <Tsub>
	    <type/>
	    <type/> 
	  </Tsub>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type/>
	  </Pcst>
	</alternatives>
      </bnf>
      <bnf desc="Constraint Sets">
	<aCtset/>
	<alternatives>
	  <Empty/>
	  <set>
	    <plural>
	      <constraint/>
	    </plural>
	  </set>
	  <unin>
	    <aCtset/>
	    <aCtset/>
	  </unin>
	</alternatives>            
      </bnf>
      <bnf desc="Substitutions">            
	<aSubMap/>            
	<alternatives>
	  <EmptySubst/>
	  <SubMap>
	    <tvar name="alpha"/>
	    <type/>
	  </SubMap>
	  <SubMap>
	    <lKind k="var"/>
	    <lKind/>
	  </SubMap>
	  <compose>
	    <aSubMap/>
	    <aSubMap/>
	  </compose>
	</alternatives>
      </bnf>
    </grammar>
  </btypes:TYPE>
  <p>
    The application of a substitution
    <btypes:TYPE>
      <aSubMap/>
    </btypes:TYPE> on X is written as
    <btypes:TYPE>
      <Subst>
	<aSubMap/>
	<text content="X"/>
      </Subst>
    </btypes:TYPE>. 
    As a matter of notational convenience, we write:
    <btypes:TYPE>
      <aSubMap num="a.b"/> 
    </btypes:TYPE> to mean
    <btypes:TYPE>
      <compose>
	<aSubMap num="a"/> 
	<aSubMap num="b"/> 
      </compose>
    </btypes:TYPE>. Note that
    <btypes:TYPE>
      <eq>
	<Subst>
	  <aSubMap num="a.b"/> 
	  <text content="x"/>
	</Subst>
	<Subst>
	  <compose>
	    <aSubMap num="a"/> 
	    <aSubMap num="b"/> 
	  </compose>
	  <text content="x"/>
	</Subst>
	<Subst>
	  <aSubMap num="a"/> 
	  <Subst>
	    <aSubMap num="b"/>                 
	    <text content="x"/>
	  </Subst>
	</Subst>
	<Subst>
	  <aSubMap num="b"/>                 
	  <Subst>
	    <aSubMap num="a"/> 
	    <text content="x"/>
	  </Subst>
	</Subst>
      </eq>
    </btypes:TYPE>.        
  </p>
  <p>
    <leadin>Translations:</leadin>
    <br/>
    <btypes:TYPE>
      <Forall>
	<operator symbol="odot"/>
      </Forall>
      <text content=", "/>
      <leadsto>
	<DBrac>
	  <op symbol="odot">
	    <type num="1"/>
	    <type num="2"/>
	    <textit content=" ... "/>
	    <type num="n"/>	      
	  </op>
	</DBrac>
	<DBrac>
	  <collection>
	    <op symbol="odot">
	      <type num="1"/>
	      <type num="2"/>
	    </op>
	    <textit content=" ... "/>
	    <op symbol="odot">
	      <type num="n-1"/>	      
	      <type num="n"/>
	    </op>
	  </collection>
	</DBrac>
      </leadsto>
      <br/>
      <leadsto>
	<DBrac>
	  <eq>
	    <type num="1"/>
	    <type num="2"/>
	  </eq>
	</DBrac>
	<DBrac>
	  <collection>
	    <Tsub>
	      <type num="1"/>
	      <type num="2"/>
	    </Tsub>
	    <Tsub>
	      <type num="2"/>
	      <type num="1"/>
	    </Tsub>	      
	  </collection>
	</DBrac>
      </leadsto>	
      <br/>
      <leadsto>
	<DBrac>
	  <ceq via="alpha">
	    <type num="1"/>
	    <type num="2"/>
	  </ceq>
	</DBrac>
	<DBrac>
	  <collection>
	    <Tsub>
	      <type num="1"/>
	      <tvar name="alpha"/>
	    </Tsub>	      
	    <Tsub>
	      <type num="2"/>
	      <tvar name="alpha"/>
	    </Tsub>
	  </collection>
	</DBrac>
      </leadsto>		
      <br/>
      <leadsto>
	<DBrac>
	  <unf ac="yes">
	    <aCtset/>
	  </unf>
	</DBrac>
	<DBrac>
	  <collection>
	    <unf>
	      <aCtset/>
	    </unf>
	    <pred name="acyclic">
	      <aCtset/>
	    </pred>	      
	  </collection>
	</DBrac>
      </leadsto>
      <br/>
      <leadsto>
	<DBrac>
	  <unf cl="yes">
	    <aCtset/>
	  </unf>
	</DBrac>
	<DBrac>
	  <unf>
	    <TransClose>
	      <paren>
		<aCtset/>
	      </paren>
	    </TransClose>
	  </unf>
	</DBrac>
      </leadsto>
    </btypes:TYPE>
  </p>
  <definition id="meta">      
    <title>Meta Constructors</title>      
    <p>
      <btypes:TYPE>
	<floor>
	  <type/>
	</floor>
      </btypes:TYPE>
      and 
      <btypes:TYPE>
	<ceil>
	  <type/>
	</ceil>
      </btypes:TYPE>
      are "meta-constructors" which (respectively) minimize and
      maximize the mutability of a type, but are interpreted
      lazily. The meta-constructors are idempotent. 
    </p>
  </definition>
  <p>
    Note that in our type system, we have restricted meta types to be
    syntactically present only as part of function types.
  </p>
  <definition id="special">      
    <title>Specialization</title>
    <p>
      We write
      <btypes:TYPE>
	<spEq>
	  <type num="1"/>
	  <type num="2"/>
	</spEq>
      </btypes:TYPE>, that is, 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> is a specialization of (or less general than)
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      iff  
      <btypes:TYPE>
	<Exists>
	  <aSubMap/>
	</Exists>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<eq>
	  <type num="1"/>
	  <Subst>
	    <aSubMap/>
	    <type num="2"/>
	  </Subst>
	</eq>
      </btypes:TYPE>.
      We write 
      <btypes:TYPE>
	<genEq>
	  <type num="1"/>
	  <type num="2"/>
	</genEq> 
      </btypes:TYPE>, that is, 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> is more general than
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<spEq>
	  <type num="2"/>
	  <type num="1"/>
	</spEq> 
      </btypes:TYPE>.
    </p>
    <p>
      We write
      <btypes:TYPE>
	<spEq>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</spEq>
      </btypes:TYPE>
      iff  
      <btypes:TYPE>
	<Exists>
	  <aSubMap/>
	</Exists>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<eq>
	  <aSubMap num="1"/>
	  <compose>
	    <aSubMap/>
	    <aSubMap num="2"/>
	  </compose>
	</eq>
      </btypes:TYPE>.
      We write 
      <btypes:TYPE>
	<genEq>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</genEq> 
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<spEq>
	  <aSubMap num="2"/>
	  <aSubMap num="1"/>
	</spEq> 
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="pcst">      
    <title>Meta Polymorphic Constraints (MPC)</title>      
    <p>
      The constraint 
      <btypes:TYPE>
	<Pcst>
	  <lKind/>
	  <type/>
	  <type dash="'"/>
	</Pcst>
      </btypes:TYPE>, where
      <btypes:TYPE>
	<spEq>
	  <type dash="'"/>
	  <type/>
	</spEq>
      </btypes:TYPE>, is used to express types that are polymorphic
      <em>over</em> polymorphism and mutability. 
    </p>
  </definition>
  <definition id="pcst-subst">      
    <title>Substitution over MPCs</title>      
    <p>
      Substitution over an MPC is defined as:
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap/>
	    <Pcst>
	      <lKind/>
	      <type/>
	      <type dash="'"/>
	    </Pcst>
	  </Subst>
	  <Pcst>
	    <Subst>
	      <aSubMap/>                
	      <lKind/>
	    </Subst>
	    <type/>              
	    <Subst>
	      <aSubMap/>
	      <type dash="'"/>
	    </Subst>
	  </Pcst>
	</eq>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="pcst-sat">      
    <title>MPC Satisfaction</title>      
    <p>
      A substitution 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> satisfies the set of constraints
      <btypes:TYPE>
	<set>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type num="1"/>
	  </Pcst>
	  <unspecified/>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type num="n"/>
	  </Pcst>
	</set>
      </btypes:TYPE> if and only if:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind/>
	      </Subst>
	      <lKind k="mono"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <unspecified/>
	      <Subst>
		<aSubMap/>
		<type num="n"/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>, or
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind/>
	      </Subst>
	      <lKind k="poly"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <collection>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="1"/>
		</Subst>
	      </pred>
	      <unspecified/>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="n"/>
		</Subst>
	      </pred>
	    </collection>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="ext-ftvs">
    <title>FTVs (Extension)</title>
    <p>
      We enhance the definition of 
      <btypes:TYPE>
	<ftvs>
	  <unspecified/>
	</ftvs>
      </btypes:TYPE> in 
      <btypes:TYPE>
	<defn tag="ftvs"/>
      </btypes:TYPE> as follows:
    </p>
    <example>
      <p>
 	<btypes:TYPE>
	  <unspecified/>
	  <br/>
	  <eq>
	    <ftvs>
	      <fn M="yes">
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <eq>
		<type num="1"/>
		<type num="2"/>
	      </eq>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <ceq>
		<type num="1"/>
		<type num="2"/>
	      </ceq>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <Tsub>
		<type num="1"/>
		<type num="2"/>
	      </Tsub>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <Pcst>
		<lKind/>
		<type num="1"/>
		<type num="2"/>
	      </Pcst>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <aCtset/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<constraint num="i"/>
	      </ftvs>
	    </Unin>
	  </eq> 
	  <text content=", "/>
	  <Forall/>
	  <in>
	    <constraint num="i"/>
	    <aCtset/>
	  </in>
	  <br/>
	  <eq>
	    <ftvs>
	      <aCtype/>
	    </ftvs>
	    <unin>
	      <ftvs>
		<type/>
	      </ftvs>
	      <ftvs>
		<aCtset/>
	      </ftvs>                  
	    </unin>
	  </eq>
	  <text content=", where "/>
	  <eq>
	    <aCtype/>
	    <ctype>
	      <type/>
	      <aCtset/>
	    </ctype>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <aTS/>
	    </ftvs>
	    <unin>
	      <ftvs>
		<tvars name="alpha"/>
	      </ftvs>
	      <ftvs>
		<aCtype/>
	      </ftvs>                  
	    </unin>
	  </eq>
	  <text content=", where "/>
	  <eq>
	    <aTS/>
	    <forall>
	      <tvars name="alpha"/>
	      <aCtype/>
	    </forall>
	  </eq>
	</btypes:TYPE>
      </p>
    </example>
  </definition>
  <definition id="stvs-eq">
    <title>Shallow Type Variables</title>
    <p>
      The set of type variables embedded in a type up to a 
      reference/function boundary. 
    </p>
    <p>
      <btypes:TYPE>
	<fnxn name="stv">
	  <tvar name="alpha"/>
	  <set>
	    <tvar name="alpha"/>
	  </set>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <unit/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <bool/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <fn>
	    <type/>
	    <type dash="'"/>
	  </fn>
	  <Empty/>
	</fnxn>          
	<br/>
	<fnxn name="stv">
	  <ref>
	    <type/>
	  </ref>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <mutable>
	    <type/>
	  </mutable>
	  <pred name="stv">
	    <type/>
	  </pred>
	</fnxn>
	<br/>
      </btypes:TYPE>
    </p>
  </definition>    
  <definition id="dtvs-eq">
    <title>Deep Type Variables</title>
    <p>
      The set of type variables embedded in a type up to a 
      function boundary. 
    </p>
    <p>        
      <btypes:TYPE>
	<fnxn name="dtv">
	  <tvar name="alpha"/>
	  <set>
	    <tvar name="alpha"/>
	  </set>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <unit/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <bool/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <fn>
	    <type/>
	    <type dash="'"/>
	  </fn>
	  <Empty/>
	</fnxn>          
	<br/>
	<fnxn name="dtv">
	  <mutable>
	    <type/>
	  </mutable>
	  <pred name="dtv">
	    <type/>
	  </pred>		
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <ref>
	    <type/>
	  </ref>
	  <pred name="dtv">
	    <type/>
	  </pred>		
	</fnxn>
      </btypes:TYPE>
    </p>
  </definition>
  <definition id="TransClose">
    <title>Transitive Closure of Constraint Sets</title>
    <p>
      A closure operation
      <btypes:TYPE>
	<TransClose>
	  <aCtset/> 
	</TransClose>
      </btypes:TYPE>
      on a constraint set 
      <btypes:TYPE>
	<aCtset/> 
      </btypes:TYPE> produces an equivalent set of constraints in
      which all transitive relationships are explicitely added.
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Exists>
	      <type num="1"/>
	      <type num="2"/>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <in>
	      <Tsub>
		<type num="1"/>
		<type num="2"/>
	      </Tsub>
	      <aCtset/>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <in>
	      <Tsub>
		<type num="2"/>
		<type num="3"/>
	      </Tsub>
	      <aCtset/>
	    </in>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <notin>
	      <Tsub>
		<type num="1"/>
		<type num="3"/>
	      </Tsub>
	      <aCtset/>
	    </notin>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <eq>
	      <TransClose>
		<aCtset/> 
	      </TransClose>
	      <TransClose>
		<paren>
		  <unin>
		    <set>
		      <Tsub>
			<type num="1"/>
			<type num="3"/>
		      </Tsub>
		    </set>                      
		    <aCtset/>
		  </unin>
		</paren>
	      </TransClose>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  Otherwise,
	  <btypes:TYPE>
	    <eq>
	      <TransClose>
		<aCtset/>
	      </TransClose>
	      <aCtset/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <p>
    <leadin>Eager-Unification Based Presentation</leadin>
  </p>
  <btypes:TYPE>        
    <grammar>
      <bnf desc="Base Types">
	<sType/>
	<alternatives>
	  <tvar name="alpha"/>
	  <unit/>
	  <bool/>
	  <fn M="yes"><type/><type/></fn>                  
	</alternatives>
      </bnf>
      <bnfc desc="">
	<alternatives>
	  <ref><type/></ref>
	  <mutable><type/></mutable>
	  <pair><type/><type/></pair>
	</alternatives>
      </bnfc>
      <bnf desc="Top-Maybe">
	<pType/>
	<alternatives>
	  <sType/>
	  <mbpair>
	    <sType/>
	    <sType/>
	  </mbpair>
	</alternatives>
      </bnf>
      <bnf desc="Types">
	<type/>
	<alternatives>
	  <pType/>
	  <MBPAIR>
	    <pType/>
	    <sType/>
	  </MBPAIR>
	</alternatives>
      </bnf>
      <bnf desc="Type Scheme">          
	<aTS/>
	<alternatives>
	  <ctype>
	    <type/>
	    <aCtset/>
	  </ctype>
	  <forall>                    
 	    <tvars name="alpha"/>
	    <ctype>
	      <type/>
	      <aCtset/>
	    </ctype>
	  </forall>
	</alternatives>
      </bnf>
      <bnf desc="Constraints">
	<constraint/>
	<alternatives>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type/>
	  </Pcst>
	</alternatives>
      </bnf>
      <bnf desc="Constraint Sets">
	<aCtset/>
	<alternatives>
	  <Empty/>
	  <set>
	    <plural>
	      <constraint/>
	    </plural>
	  </set>
	  <unin>
	    <aCtset/>
	    <aCtset/>
	  </unin>
	</alternatives>            
      </bnf>
      <bnf desc="Substitutions">            
	<aSubMap/>            
	<alternatives>
	  <EmptySubst/>
	  <SubMap>
	    <tvar name="alpha"/>
	    <type/>
	  </SubMap>
	  <SubMap>
	    <lKind k="var"/>
	    <lKind/>
	  </SubMap>
	  <compose>
	    <aSubMap/>
	    <aSubMap/>
	  </compose>
	</alternatives>
      </bnf>
    </grammar>
  </btypes:TYPE>
    <definition id="incMB">      
    <title>Increase Mutability Permissiveness</title>      
    <p> 
      The operators
      <btypes:TYPE><incrMBop/></btypes:TYPE> increases the maye-ness
      of a type, and is defined as below. Here, 
      <btypes:TYPE>
	<models name="new">
	  <assume/>
	  <tvar name="beta"/>
	</models>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <incMB>
	      <MBPAIR>
		<tvar name="alpha"/>
		<sType/>
	      </MBPAIR>
	    </incMB>
	  </lhs>
	  <rhs>
	    <MBPAIR>
	      <tvar name="beta"/>
	      <sType/>
	    </MBPAIR>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <incMB>
	      <MBPAIR>
		<pType/>
		<sType/>
	      </MBPAIR>
	    </incMB>
	    <neq>
	      <pType/>
	      <tvar name="alpha"/>
	    </neq>
	  </lhs>
	  <rhs>
	    <incMB>
	      <pType/>
	    </incMB>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <incMB>
	      <mbpair>
		<tvar name="alpha"/>
		<sType/>
	      </mbpair>
	    </incMB>
	  </lhs>
	  <rhs>
	    <MBPAIR>
	      <tvar name="beta"/>
	      <sType/>
	    </MBPAIR>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <incMB>
	      <mbpair>
		<pType/>
		<sType/>
	      </mbpair>
	    </incMB>
	    <neq>
	      <pType/>
	      <tvar name="alpha"/>
	    </neq>
	  </lhs>
	  <rhs>
	    <incMB>
	      <pType/>
	    </incMB>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <incMB>
	      <sType/>
	    </incMB>
	  </lhs>
	  <rhs>
	    <MBPAIR>
	      <tvar name="beta"/>
	      <minz>
		<type/>
	      </minz>
	    </MBPAIR>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <!-- Renaming necessary -->
  <definition id="min2">      
    <title>
      <btypes:TYPE><minzOp/></btypes:TYPE> and
      <btypes:TYPE><minzTOp/></btypes:TYPE>
    </title>      
    <p> 
      We redefine <btypes:TYPE><minzOp/></btypes:TYPE> to
      deal with maybe types. We also define 
      <btypes:TYPE><minzTOp/></btypes:TYPE> to deal with 
      top-level mutability only.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <minz>
	      <tvar name="alpha"/>
	    </minz>
	  </lhs>
	  <rhs>
	    <tvar name="alpha"/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <unit/>
	    </minz>
	  </lhs>
	  <rhs>
	    <unit/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <bool/>
	    </minz>
	  </lhs>
	  <rhs>
	    <bool/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </minz>
	  </lhs>
	  <rhs>
	    <fn>
	      <type/>
	      <type dash="'"/>
	    </fn>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <ref>
		<type/>
	      </ref>
	    </minz>
	  </lhs>
	  <rhs>
	    <ref>
	      <type/>
	    </ref>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <mutable>
		<type/>
	      </mutable>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <type/>
	    </minz>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </minz>
	  </lhs>
	  <rhs>
	    <pair>
	      <minz>
		<type/>	
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </pair>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <mbpair>
		<tvar name="alpha"/>
		<sType/>
	      </mbpair>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <sType/>
	    </minz>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <mbpair>
		<sType/>
		<sType dash="'"/>
	      </mbpair>
	    </minz>
	    <grouping>
	      <neq>
		<sType/>
		<tvar name="alpha"/>
	      </neq>
	    </grouping>
	  </lhs>
	  <rhs>
	    <minz>
	      <sType dash="'"/>
	    </minz>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <MBPAIR>
		<tvar name="alpha"/>
		<sType/>
	      </MBPAIR>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <sType/>
	    </minz>
	  </rhs>
	</equation>
	<equation sep="4pt">
	  <lhs>
	    <minz>
	      <MBPAIR>
		<pType/>
		<sType/>
	      </MBPAIR>
	    </minz>
	    <grouping>
	      <neq>
		<pType/>
		<tvar name="alpha"/>
	      </neq>
	    </grouping>
	  </lhs>
	  <rhs>
	    <minz>
	      <pType/>
	    </minz>
	  </rhs>
	</equation>
	<!-- Second set starts here -->
	<equation>
	  <lhs>
	    <minzT>
	      <tvar name="alpha"/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <tvar name="alpha"/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <unit/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <unit/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <bool/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <bool/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </minzT>
	  </lhs>
	  <rhs>
	    <fn>
	      <type/>
	      <type dash="'"/>
	    </fn>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <ref>
		<type/>
	      </ref>
	    </minzT>
	  </lhs>
	  <rhs>
	    <ref>
	      <type/>
	    </ref>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <mutable>
		<type/>
	      </mutable>
	    </minzT>
	  </lhs>
	  <rhs>
	    <minzT>
	      <type/>
	    </minzT>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </minzT>
	  </lhs>
	  <rhs>
	    <pair>
	      <type/>	
	      <type dash="'"/>
	    </pair>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <mbpair>
		<tvar name="alpha"/>
		<sType/>
	      </mbpair>
	    </minzT>
	  </lhs>
	  <rhs>
	    <minzT>
	      <sType/>
	    </minzT>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <mbpair>
		<sType/>
		<sType dash="'"/>
	      </mbpair>
	    </minzT>
	    <grouping>
	      <neq>
		<sType/>
		<tvar name="alpha"/>
	      </neq>
	    </grouping>
	  </lhs>
	  <rhs>
	    <minzT>
	      <sType dash="'"/>
	    </minzT>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <MBPAIR>
		<tvar name="alpha"/>
		<sType/>
	      </MBPAIR>
	    </minzT>
	  </lhs>
	  <rhs>
	    <minzT>
	      <sType/>
	    </minzT>
	  </rhs>
	</equation>
	<equation sep="4pt">
	  <lhs>
	    <minzT>
	      <MBPAIR>
		<pType/>
		<sType/>
	      </MBPAIR>
	    </minzT>
	    <grouping>
	      <neq>
		<pType/>
		<tvar name="alpha"/>
	      </neq>
	    </grouping>
	  </lhs>
	  <rhs>
	    <minzT>
	      <pType/>
	    </minzT>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
<!--   <definition id="close"> -->
<!--     <title>Constraint Set Closure</title> -->
<!--     <p> -->
<!--       A closure operation -->
<!--       <btypes:TYPE> -->
<!-- 	<pred name="close"> -->
<!-- 	  <aCtset/>  -->
<!-- 	</pred> -->
<!--       </btypes:TYPE> -->
<!--       on a constraint set  -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset/>  -->
<!--       </btypes:TYPE> produces an equivalent set -->
<!--       of atomic constraints by using the copy coercion rules defined -->
<!--       in figure&nbsp;<xref ref="decl_rules"/> (note that this -->
<!--       conversion is total); and by explicitely adding all transitive -->
<!--       relationships. This conversion does not affect the MPCs in  -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset/>  -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <fnxn name="close"> -->
<!-- 	      <unin> -->
<!-- 		<set> -->
<!-- 		  <Tsub> -->
<!-- 		    <fn> -->
<!-- 		      <type num="1"/> -->
<!-- 		      <type num="2"/> -->
<!-- 		    </fn> -->
<!-- 		    <fn> -->
<!-- 		      <type num="1" dash="'"/> -->
<!-- 		      <type num="2" dash="'"/> -->
<!-- 		    </fn> -->
<!-- 		  </Tsub> -->
<!-- 		</set> -->
<!-- 		<aCtset/> -->
<!-- 	      </unin> -->
<!-- 	      <pred name="close"> -->
<!-- 		<unin> -->
<!-- 		  <aCtset/> -->
<!-- 		  <set> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="1"/> -->
<!-- 		      <type num="1" dash="'"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="2"/> -->
<!-- 		      <type num="2" dash="'"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="1" dash="'"/> -->
<!-- 		      <type num="1"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="2" dash="'"/> -->
<!-- 		      <type num="2"/> -->
<!-- 		    </Tsub> -->
<!-- 		  </set> -->
<!-- 		</unin> -->
<!-- 	      </pred> -->
<!-- 	    </fnxn> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <fnxn name="close"> -->
<!-- 	      <unin> -->
<!-- 		<set> -->
<!-- 		  <Tsub> -->
<!-- 		    <ref> -->
<!-- 		      <type/> -->
<!-- 		    </ref> -->
<!-- 		    <ref> -->
<!-- 		      <type dash="'"/> -->
<!-- 		    </ref> -->
<!-- 		  </Tsub> -->
<!-- 		</set> -->
<!-- 		<aCtset/> -->
<!-- 	      </unin> -->
<!-- 	      <pred name="close"> -->
<!-- 		<unin> -->
<!-- 		  <aCtset/> -->
<!-- 		  <set> -->
<!-- 		    <Tsub> -->
<!-- 		      <type/> -->
<!-- 		      <type dash="'"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type dash="'"/> -->
<!-- 		      <type/> -->
<!-- 		    </Tsub> -->
<!-- 		  </set> -->
<!-- 		</unin> -->
<!-- 	      </pred> -->
<!-- 	    </fnxn> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <fnxn name="close"> -->
<!-- 	      <unin> -->
<!-- 		<set> -->
<!-- 		  <Tsub> -->
<!-- 		    <mutable> -->
<!-- 		      <type/> -->
<!-- 		    </mutable> -->
<!-- 		    <mutable> -->
<!-- 		      <type dash="'"/> -->
<!-- 		    </mutable> -->
<!-- 		  </Tsub> -->
<!-- 		</set> -->
<!-- 		<aCtset/> -->
<!-- 	      </unin> -->
<!-- 	      <pred name="close"> -->
<!-- 		<unin> -->
<!-- 		  <aCtset/> -->
<!-- 		  <set> -->
<!-- 		    <Tsub> -->
<!-- 		      <type/> -->
<!-- 		      <type dash="'"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type dash="'"/> -->
<!-- 		      <type/> -->
<!-- 		    </Tsub> -->
<!-- 		  </set> -->
<!-- 		</unin> -->
<!-- 	      </pred> -->
<!-- 	    </fnxn> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <grouping> -->
<!-- 		<pred name="close"> -->
<!-- 		  <unin> -->
<!-- 		    <set> -->
<!-- 		      <Tsub> -->
<!-- 			<type num="1"/> -->
<!-- 			<type num="2"/> -->
<!-- 		      </Tsub> -->
<!-- 		      <Tsub> -->
<!-- 			<type num="2"/> -->
<!-- 			<type num="3"/> -->
<!-- 		      </Tsub> -->
<!-- 		    </set> -->
<!-- 		    <aCtset/> -->
<!-- 		  </unin> -->
<!-- 		</pred> -->
<!-- 		<space/> -->
<!-- 		<textit content="where"/> -->
<!-- 		<space/> -->
<!-- 		<notin> -->
<!-- 		  <Tsub> -->
<!-- 		    <type num="1"/> -->
<!-- 		    <type num="3"/> -->
<!-- 		  </Tsub> -->
<!-- 		  <aCtset/> -->
<!-- 		</notin> -->
<!-- 		<br/> -->
<!-- 	      </grouping> -->
<!-- 	      <pred name="close"> -->
<!-- 		<unin> -->
<!-- 		  <set> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="1"/> -->
<!-- 		      <type num="2"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="2"/> -->
<!-- 		      <type num="3"/> -->
<!-- 		    </Tsub> -->
<!-- 		    <Tsub> -->
<!-- 		      <type num="1"/> -->
<!-- 		      <type num="3"/> -->
<!-- 		    </Tsub> -->
<!-- 		  </set>                       -->
<!-- 		  <aCtset/> -->
<!-- 		</unin> -->
<!-- 	      </pred> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <grouping> -->
<!-- 		<pred name="close"> -->
<!-- 		  <aCtset/> -->
<!-- 		</pred> -->
<!-- 		<space/> -->
<!-- 		<textit content="where none of the above cases "/> -->
<!-- 		<textit content="are applicable"/> -->
<!-- 		<space/> -->
<!-- 	      </grouping> -->
<!-- 	      <aCtset/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </definition> -->
<!--   <definition id="normalized_ctset"> -->
<!--     <title>Normalization of Constraint Sets</title> -->
<!--     <p> -->
<!--       The normalization function -->
<!--       <btypes:TYPE> -->
<!-- 	<normalize> -->
<!-- 	  <aCtset/> -->
<!-- 	</normalize> -->
<!--       </btypes:TYPE> is used to obtain a normalized form of a -->
<!--       constraint set  -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset/> -->
<!--       </btypes:TYPE> by re-writing it only in terms of closed -->
<!--       subtype constraints and MPCs. -->
<!--     </p> -->
<!--     <p> -->
<!--       <btypes:TYPE> -->
<!-- 	<eq>               -->
<!-- 	  <normalize> -->
<!-- 	    <aCtset/> -->
<!-- 	  </normalize> -->
<!-- 	  <pred name="close"> -->
<!-- 	    <aCtset dash="'"/> -->
<!-- 	  </pred> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE> -->
<!--       where -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset dash="'"/> -->
<!--       </btypes:TYPE> -->
<!--       is obtained from -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset/> -->
<!--       </btypes:TYPE> using the normalizing translations: -->
<!--     </p> -->
<!--     <ul> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <leadsto> -->
<!-- 	      <DBrac> -->
<!-- 		<eq> -->
<!-- 		  <type num="1"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</eq> -->
<!-- 	      </DBrac> -->
<!-- 	      <DBrac> -->
<!-- 		<collection> -->
<!-- 		  <Tsub> -->
<!-- 		    <type num="1"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </Tsub> -->
<!-- 		  <Tsub> -->
<!-- 		    <type num="2"/> -->
<!-- 		    <type num="1"/> -->
<!-- 		  </Tsub>	       -->
<!-- 		</collection> -->
<!-- 	      </DBrac> -->
<!-- 	    </leadsto>	 -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <leadsto> -->
<!-- 	      <DBrac> -->
<!-- 		<ceq via="alpha"> -->
<!-- 		  <type num="1"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</ceq> -->
<!-- 	      </DBrac> -->
<!-- 	      <DBrac> -->
<!-- 		<collection> -->
<!-- 		  <Tsub> -->
<!-- 		    <type num="1"/> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		  </Tsub>	       -->
<!-- 		  <Tsub> -->
<!-- 		    <type num="2"/> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		  </Tsub> -->
<!-- 		</collection> -->
<!-- 	      </DBrac> -->
<!-- 	    </leadsto> -->
<!-- 	  </btypes:TYPE>             -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ul> -->
<!--   </definition> -->
<!--   <definition id="sat"> -->
<!--     <title>Constraint Satisfiability</title> -->
<!--     <p> -->
<!--       A Substitution  -->
<!--       <btypes:TYPE> -->
<!-- 	<aSubMap/> -->
<!--       </btypes:TYPE> -->
<!--       satisfies a constraint set -->
<!--       <btypes:TYPE> -->
<!-- 	<aCtset/> -->
<!--       </btypes:TYPE>, written -->
<!--       <btypes:TYPE> -->
<!-- 	<models name="sat"> -->
<!-- 	  <aSubMap/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!--       </btypes:TYPE> -->
<!--       iff -->
<!--       <btypes:TYPE> -->
<!-- 	<normalize> -->
<!-- 	  <Subst> -->
<!-- 	    <aSubMap/> -->
<!-- 	    <aCtset/> -->
<!-- 	  </Subst> -->
<!-- 	</normalize> -->
<!--       </btypes:TYPE> -->
<!--       consists only of tautologies (trivially). -->
<!--     </p> -->
<!--   </definition> -->
<!--   <definition id="ca"> -->
<!--     <title>Consistency and Acyclicity</title>  -->
<!--     <btypes:TYPE> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <grouping> -->
<!-- 	      <Exists> -->
<!-- 		<aSubMap/> -->
<!-- 	      </Exists> -->
<!-- 	      <text content=" such that "/> -->
<!-- 	      <models name="sat"> -->
<!-- 		<aSubMap/> -->
<!-- 		<aCtset/> -->
<!-- 	      </models> -->
<!-- 	    </grouping> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <models name="cst"> -->
<!-- 	      <assume/> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <grouping> -->
<!-- 	      <Forall/> -->
<!-- 	      <SubMap> -->
<!-- 		<tvar name="alpha"/> -->
<!-- 		<type/> -->
<!-- 	      </SubMap> -->
<!-- 	      <text content=" and "/> -->
<!-- 	      <SubMap> -->
<!-- 		<tvar name="beta"/> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </SubMap> -->
<!-- 	      <text content=" in "/> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <text content=", "/> -->
<!-- 	      <neq> -->
<!-- 		<tvar name="alpha"/> -->
<!-- 		<tvar name="beta"/> -->
<!-- 	      </neq> -->
<!-- 	    </grouping> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <models name="cst"> -->
<!-- 	      <assume/> -->
<!-- 	      <aSubMap/> -->
<!-- 	    </models> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <grouping> -->
<!-- 	      <Forall/> -->
<!-- 	      <in> -->
<!-- 		<grouping> -->
<!-- 		  <Tsub> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		    <type/> -->
<!-- 		  </Tsub> -->
<!-- 		  <text content=" or "/> -->
<!-- 		  <Tsub> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		    <type/> -->
<!-- 		  </Tsub> -->
<!-- 		</grouping> -->
<!-- 		<normalize> -->
<!-- 		  <aCtset/> -->
<!-- 		</normalize> -->
<!-- 	      </in>                 -->
<!-- 	      <text content=", "/> -->
<!-- 	      <OR> -->
<!-- 		<paren> -->
<!-- 		  <eq> -->
<!-- 		    <type/> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		  </eq> -->
<!-- 		</paren> -->
<!-- 		<paren> -->
<!-- 		  <eq> -->
<!-- 		    <type/> -->
<!-- 		    <mutable> -->
<!-- 		      <tvar name="alpha"/> -->
<!-- 		    </mutable> -->
<!-- 		  </eq> -->
<!-- 		</paren> -->
<!-- 		<paren> -->
<!-- 		  <notin> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		    <type/> -->
<!-- 		  </notin> -->
<!-- 		</paren> -->
<!-- 	      </OR> -->
<!-- 	    </grouping> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <models name="acy"> -->
<!-- 	      <assume/> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre/> -->
<!-- 	  <tyConc> -->
<!-- 	    <models name="acy"> -->
<!-- 	      <assume/> -->
<!-- 	      <EmptySubst/> -->
<!-- 	    </models> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <eq> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <compose> -->
<!-- 		<SubMap> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		  <type/> -->
<!-- 		</SubMap> -->
<!-- 		<aSubMap dash="'"/> -->
<!-- 	      </compose> -->
<!-- 	    </eq> -->
<!-- 	    <notin> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <type/> -->
<!-- 	    </notin> -->
<!-- 	    <models name="acy"> -->
<!-- 	      <assume/> -->
<!-- 	      <Subst> -->
<!-- 		<SubMap> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		  <type/> -->
<!-- 		</SubMap> -->
<!-- 		<aSubMap dash="'"/> -->
<!-- 	      </Subst> -->
<!-- 	    </models> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <models name="acy"> -->
<!-- 	      <assume/> -->
<!-- 	      <aSubMap/> -->
<!-- 	    </models> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <models name="cst">    -->
<!-- 	      <assume/> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models>  	     -->
<!-- 	    <models name="acy">    -->
<!-- 	      <assume/> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models>  	    	     -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc>  -->
<!-- 	    <models name="ca">    -->
<!-- 	      <assume/> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models>   -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <models name="cst">    -->
<!-- 	      <assume/> -->
<!-- 	      <aSubMap/> -->
<!-- 	    </models>  	     -->
<!-- 	    <models name="acy">    -->
<!-- 	      <assume/> -->
<!-- 	      <aSubMap/> -->
<!-- 	    </models>  	    	     -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc>  -->
<!-- 	    <models name="ca">    -->
<!-- 	      <assume/> -->
<!-- 	      <aSubMap/> -->
<!-- 	    </models>   -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--     </btypes:TYPE> -->
<!--   </definition> -->
<!--   <definition id="canonical-ctr-types"> -->
<!--     <title>Canonical forms of Solvable Entities</title> -->
<!--     <p> -->
<!--       For any  -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <solvable/> -->
<!-- 	  <collection> -->
<!-- 	    <type/> -->
<!-- 	    <aExpr/> -->
<!-- 	    <grouping> -->
<!-- 	      <text content=" or "/> -->
<!-- 	      <store/> -->
<!-- 	    </grouping> -->
<!-- 	  </collection> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE>, -->
<!--       we write  -->
<!--       <btypes:TYPE> -->
<!-- 	<canonical> -->
<!-- 	  <solvable/> -->
<!-- 	</canonical> -->
<!--       </btypes:TYPE> to represent the entity in which all -->
<!--       meta-constructors in (posibly embedded types) are fully -->
<!--       interpreted. -->
<!--     </p> -->
<!--     <p> -->
<!--       For any  -->
<!--       <btypes:TYPE> -->
<!-- 	<gamma/> -->
<!--       </btypes:TYPE> such that if -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <aCtset/> -->
<!-- 	  <Unin> -->
<!-- 	    <aCtset num="i"/> -->
<!-- 	  </Unin> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE>,  -->
<!--       <btypes:TYPE> -->
<!-- 	<Forall/> -->
<!-- 	<in> -->
<!-- 	  <mapping> -->
<!-- 	    <id/> -->
<!-- 	    <forall> -->
<!-- 	      <tvars name="alpha"/> -->
<!-- 	      <ctype> -->
<!-- 		<type num="i"/> -->
<!-- 		<aCtset num="i"/> -->
<!-- 	      </ctype> -->
<!-- 	    </forall> -->
<!-- 	  </mapping> -->
<!-- 	  <gamma/> -->
<!-- 	</in> -->
<!--       </btypes:TYPE>, and -->
<!--       <btypes:TYPE> -->
<!-- 	<models name="sat"> -->
<!-- 	  <assume> -->
<!-- 	    <EmptySubst/> -->
<!-- 	  </assume> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!--       </btypes:TYPE>, -->
<!--       we write  -->
<!--       <btypes:TYPE> -->
<!-- 	<canonical> -->
<!-- 	  <solvable/> -->
<!-- 	</canonical> -->
<!--       </btypes:TYPE> to represent the entity in which (1) all -->
<!--       meta-constructors in the embedded types are fully -->
<!--       interpreted, and (2) the (tautological) constraints embedded -->
<!--       within   -->
<!--       <btypes:TYPE> -->
<!-- 	<gamma/> -->
<!--       </btypes:TYPE> are removed to obtain an equivalent -->
<!--       unconstrained entity. -->
<!--     </p> -->
<!--   </definition>     -->
<!--   <p> -->
<!--     For example, if  -->
<!--     <btypes:TYPE> -->
<!--       <eq> -->
<!-- 	<type/> -->
<!-- 	<fn M="yes"> -->
<!-- 	  <mutable> -->
<!-- 	    <unit/> -->
<!-- 	  </mutable> -->
<!-- 	  <bool/> -->
<!-- 	</fn> -->
<!--       </eq> -->
<!--     </btypes:TYPE>, then -->
<!--     <btypes:TYPE> -->
<!--       <eq> -->
<!-- 	<canonical> -->
<!-- 	  <type/> -->
<!-- 	</canonical> -->
<!-- 	<fn> -->
<!-- 	  <unit/> -->
<!-- 	  <mutable> -->
<!-- 	    <bool/> -->
<!-- 	  </mutable> -->
<!-- 	</fn> -->
<!--       </eq> -->
<!--     </btypes:TYPE>. If -->
<!--     <btypes:TYPE> -->
<!--       <eq> -->
<!-- 	<gamma/> -->
<!-- 	<mapping> -->
<!-- 	  <id/> -->
<!-- 	  <ctype> -->
<!-- 	    <unit/> -->
<!-- 	    <set> -->
<!-- 	      <Tsub> -->
<!-- 		<mutable> -->
<!-- 		  <unit/> -->
<!-- 		</mutable> -->
<!-- 		<unit/> -->
<!-- 	      </Tsub> -->
<!-- 	    </set> -->
<!-- 	  </ctype> -->
<!-- 	</mapping> -->
<!--       </eq> -->
<!--     </btypes:TYPE>, then -->
<!--     <btypes:TYPE> -->
<!--       <eq> -->
<!-- 	<canonical> -->
<!-- 	  <gamma/> -->
<!-- 	</canonical> -->
<!-- 	<mapping> -->
<!-- 	  <id/> -->
<!-- 	  <unit/> -->
<!-- 	</mapping> -->
<!--       </eq> -->
<!--     </btypes:TYPE>.  -->
<!--     That is, canonicalization obtains entities that are within the -->
<!--     language and type system defined in  -->
<!--     section&nbsp;<xref ref="language"/>. -->
<!--   </p> -->
<!--   <definition id="define_infer"> -->
<!--     <title>Type Inference</title>  -->
<!--     <p> -->
<!--       Type inference is a program -->
<!--       transformation that accepts a program in which -->
<!--       <progident>let</progident> expressions are not annotated -->
<!--       with their kinds, and returns the same programs in which -->
<!--       <progident>let</progident> expressions are annotated with -->
<!--       their kinds and all expressions are annotated with their -->
<!--       types. -->
<!--     </p> -->
<!--   </definition> -->
<!--   <p> -->
<!--     The equational type inference algorithm is as shown in -->
<!--     figure&nbsp;<xref ref="eq_infer"/>.  -->
<!--     The inference judgment  -->
<!--     <btypes:TYPE> -->
<!--       <TEjudge> -->
<!-- 	<assume> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	</assume> -->
<!-- 	<conclude> -->
<!-- 	  <tqExpr> -->
<!-- 	    <aExpr/> -->
<!-- 	    <type/> -->
<!-- 	  </tqExpr> -->
<!-- 	</conclude> -->
<!-- 	<constrain> -->
<!-- 	  <aCtset/> -->
<!-- 	</constrain> -->
<!--       </TEjudge> -->
<!--     </btypes:TYPE> -->
<!--     should be understood as: given the binding context -->
<!--     <btypes:TYPE><gamma/></btypes:TYPE> and the store typing -->
<!--     <btypes:TYPE><store/></btypes:TYPE>, we infer the type  -->
<!--     <btypes:TYPE><type/></btypes:TYPE> for the expression  -->
<!--     <btypes:TYPE><aExpr/></btypes:TYPE> under the constraints -->
<!--     <btypes:TYPE><aCtset/></btypes:TYPE>.  -->
<!--     The Unification algorithm is given in  -->
<!--     figure&nbsp;<xref ref="eq_unify"/> with some auxiliary -->
<!--     definitions and translations defined in  -->
<!--     figure&nbsp;<xref ref="eq_helper"/>.  -->
<!--     The unification algorithm takes in a set of constraints -->
<!--     <btypes:TYPE><aCtset/></btypes:TYPE> and either fails with an -->
<!--     error <btypes:TYPE><error/></btypes:TYPE>, or succeeds to  -->
<!--     result in a pair consisting of residual constraints -->
<!--     <btypes:TYPE><aCtset/></btypes:TYPE>  -->
<!--     (which should only contain constraints of the form: -->
<!--     <btypes:TYPE> -->
<!--       <Tsub> -->
<!-- 	<tvar name="alpha"/> -->
<!-- 	<type/> -->
<!--       </Tsub> -->
<!--       <text content=","/> -->
<!--       <space/> -->
<!--       <Tsub> -->
<!-- 	<type/> -->
<!-- 	<tvar name="alpha"/> -->
<!--       </Tsub> -->
<!--       <text content=", "/> -->
<!--       <space/> -->
<!--       (however, both of the cases a <= t and t <= a -->
<!--       cannot occur since it can be reduced) -->
<!--       <Pcst> -->
<!-- 	<lKind k="var"/> -->
<!-- 	<type/> -->
<!-- 	<type dash="'"/> -->
<!--       </Pcst> -->
<!--       <text content=", and"/> -->
<!--       <space/> -->
<!--       <Pcst> -->
<!-- 	<lKind k="poly"/> -->
<!-- 	<type num="g"/> -->
<!-- 	<type num="i"/> -->
<!--       </Pcst> -->
<!--       <text content=", where"/> -->
<!--       <space/> -->
<!--       <pred name="Immut"> -->
<!-- 	<type num="i"/> -->
<!--       </pred> -->
<!--       <text content=", and"/> -->
<!--       <space/> -->
<!--       <neq> -->
<!-- 	<pred name="dtv"> -->
<!-- 	  <type num="i"/> -->
<!-- 	</pred> -->
<!-- 	<Empty/> -->
<!--       </neq> -->
<!--       <text content="."/>             -->
<!--     </btypes:TYPE>) -->
<!--     and a list of -->
<!--     substitutions <btypes:TYPE><aSubMap/></btypes:TYPE> for the -->
<!--     constraints solved in this pass. -->
<!--   </p> -->
<!--   <p> -->
<!--     We use the following shorthand translations as a notational -->
<!--     convenience (the translation defined in section&nbsp;<xref -->
<!--       ref="type_system"/> is repeated here). -->
<!--   </p> -->
<!--   <ol> -->
<!--     <li> -->
<!--       <p> -->
<!-- 	<btypes:TYPE> -->
<!-- 	  <leadsto> -->
<!-- 	    <DBrac> -->
<!-- 	      <TDjudge sub="yes"> -->
<!-- 		<aExpr/> -->
<!-- 		<type/> -->
<!-- 	      </TDjudge> -->
<!-- 	    </DBrac> -->
<!-- 	    <DBrac> -->
<!-- 	      <collection> -->
<!-- 		<TDjudge> -->
<!-- 		  <aExpr/> -->
<!-- 		  <type dash="'"/> -->
<!-- 		</TDjudge> -->
<!-- 		<Tsub> -->
<!-- 		  <type/> -->
<!-- 		  <type dash="'"/> -->
<!-- 		</Tsub> -->
<!-- 	      </collection> -->
<!-- 	    </DBrac> -->
<!-- 	  </leadsto> -->
<!-- 	</btypes:TYPE> -->
<!--       </p> -->
<!--     </li> -->
<!--     <li> -->
<!--       <p> -->
<!-- 	<btypes:TYPE>               -->
<!-- 	  <leadsto> -->
<!-- 	    <DBrac>   -->
<!-- 	      <judge> -->
<!-- 		<precond> -->
<!-- 		  <aSubMap/> -->
<!-- 		</precond> -->
<!-- 		<assume> -->
<!-- 		  <gamma/> -->
<!-- 		  <store/> -->
<!-- 		</assume> -->
<!-- 		<conclude> -->
<!-- 		  <tqExpr> -->
<!-- 		    <aExpr/> -->
<!-- 		    <type/> -->
<!-- 		  </tqExpr> -->
<!-- 		</conclude> -->
<!-- 	      </judge> -->
<!-- 	    </DBrac> -->
<!-- 	    <DBrac>           -->
<!-- 	      <Sjudge> -->
<!-- 		<assume> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <gamma/> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <store/> -->
<!-- 		  </Subst> -->
<!-- 		</assume> -->
<!-- 		<tqExpr> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <aExpr/> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <type/> -->
<!-- 		  </Subst> -->
<!-- 		</tqExpr> -->
<!-- 	      </Sjudge> -->
<!-- 	    </DBrac> -->
<!-- 	  </leadsto> -->
<!-- 	</btypes:TYPE> -->
<!--       </p> -->
<!--     </li> -->
<!--     <li> -->
<!--       <p> -->
<!-- 	<btypes:TYPE> -->
<!-- 	  <leadsto> -->
<!-- 	    <DBrac>           -->
<!-- 	      <Djudge> -->
<!-- 		<aSubMap/> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 		<aExpr/> -->
<!-- 		<type/> -->
<!-- 	      </Djudge> -->
<!-- 	    </DBrac> -->
<!-- 	    <DBrac>           -->
<!-- 	      <Sjudge> -->
<!-- 		<assume> -->
<!-- 		  <canonical> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <gamma/> -->
<!-- 		    </Subst> -->
<!-- 		  </canonical> -->
<!-- 		  <canonical> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <store/> -->
<!-- 		    </Subst> -->
<!-- 		  </canonical> -->
<!-- 		</assume> -->
<!-- 		<tqExpr> -->
<!-- 		  <canonical> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <aExpr/> -->
<!-- 		    </Subst> -->
<!-- 		  </canonical> -->
<!-- 		  <canonical> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type/> -->
<!-- 		    </Subst> -->
<!-- 		  </canonical> -->
<!-- 		</tqExpr> -->
<!-- 	      </Sjudge> -->
<!-- 	    </DBrac> -->
<!-- 	  </leadsto> -->
<!-- 	</btypes:TYPE> -->
<!--       </p> -->
<!--     </li> -->
<!--     <li> -->
<!--       <p> -->
<!-- 	<btypes:TYPE> -->
<!-- 	  <leadsto> -->
<!-- 	    <DBrac>  -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<set> -->
<!-- 		  <unspecified/> -->
<!-- 		</set> -->
<!-- 	      </Subst> -->
<!-- 	    </DBrac> -->
<!-- 	    <DBrac>           -->
<!-- 	      <Subst>                 -->
<!-- 		<aSubMap/> -->
<!-- 		<grouping> -->
<!-- 		  <set> -->
<!-- 		    <unspecified/> -->
<!-- 		  </set> -->
<!-- 		</grouping> -->
<!-- 	      </Subst> -->
<!-- 	    </DBrac> -->
<!-- 	  </leadsto> -->
<!-- 	</btypes:TYPE> -->
<!--       </p> -->
<!--     </li> -->
<!--   </ol> -->
<!--   <lemma id="cst-implies-sat"> -->
<!--     <title>Consistency Implies Satisfiability</title> -->
<!--     <p> -->
<!--       If  -->
<!--       <btypes:TYPE> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!--       </btypes:TYPE>, then -->
<!--       <btypes:TYPE> -->
<!-- 	<Exists> -->
<!-- 	  <aSubMap/> -->
<!-- 	</Exists> -->
<!--       </btypes:TYPE> such that -->
<!--       <btypes:TYPE> -->
<!-- 	<models name="sat"> -->
<!-- 	  <aSubMap/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       By inversion of the constraint consistency relationship in  -->
<!--       <btypes:TYPE> -->
<!-- 	<defn tag="ca"/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </proof> -->
<!--   <theorem id="eq-unify-correct"> -->
<!--     <title>Correctness of Unification</title> -->
<!--     <p> -->
<!--       If: -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <unf> -->
<!-- 	    <aCtset/> -->
<!-- 	  </unf> -->
<!-- 	  <Pair> -->
<!-- 	    <aCtset dash="'"/> -->
<!-- 	    <aSubMap num="u"/> -->
<!-- 	  </Pair> -->
<!-- 	</eq> -->
<!-- 	<text content=", then"/> -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Forall> -->
<!-- 	      <aSubMap num="s"/> -->
<!-- 	    </Forall> -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<aSubMap num="s"/> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset dash="'"/> -->
<!-- 	    </models> -->
<!-- 	    <text content=", "/> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<scomp> -->
<!-- 		  <aSubMap num="s"/> -->
<!-- 		  <aSubMap num="u"/> -->
<!-- 		</scomp> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <aSubMap num="s"/> -->
<!-- 	    </Exists> -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<aSubMap num="s"/> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset dash="'"/> -->
<!-- 	    </models> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </theorem>   -->
<!--   <theorem id="eq-unify-complete"> -->
<!--     <title>Principality of Unification</title> -->
<!--     <p> -->
<!--       The unification algorithm produces most general -->
<!--       substitutions, and fails only when the  -->
<!--       constaint set is inconsistent.  -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <unf> -->
<!-- 		<aCtset/> -->
<!-- 	      </unf> -->
<!-- 	      <Pair> -->
<!-- 		<aCtset dash="'"/> -->
<!-- 		<aSubMap num="u"/> -->
<!-- 	      </Pair> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> then, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Forall> -->
<!-- 	      <aSubMap num="s"/> -->
<!-- 	    </Forall> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<aSubMap num="s"/> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models> -->
<!-- 	  </btypes:TYPE>,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <aSubMap num="s" dash="'"/> -->
<!-- 	    </Exists> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aSubMap num="s"/> -->
<!-- 	      <compose> -->
<!-- 		<aSubMap num="u"/> -->
<!-- 		<aSubMap num="s" dash="'"/> -->
<!-- 	      </compose> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<aSubMap num="s" dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset dash="'"/> -->
<!-- 	    </models> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <unf> -->
<!-- 		<aCtset/> -->
<!-- 	      </unf> -->
<!-- 	      <error/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> then,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Not> -->
<!-- 	      <Exists/> -->
<!-- 	    </Not> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <models name="sat">  -->
<!-- 	      <assume> -->
<!-- 		<aSubMap/> -->
<!-- 	      </assume> -->
<!-- 	      <aCtset/> -->
<!-- 	    </models> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </theorem> -->
<!--   <theorem id="eq-unify-decidable"> -->
<!--     <title>Decidability of Unification</title> -->
<!--     <p> -->
<!--       The unification algorithm -->
<!--       <btypes:TYPE> -->
<!-- 	<unf> -->
<!-- 	  <aCtset/> -->
<!-- 	</unf> -->
<!-- 	<text content=" computes to some "/> -->
<!-- 	<Pair> -->
<!-- 	  <aCtset dash="'"/> -->
<!-- 	  <aSubMap/> -->
<!-- 	</Pair> -->
<!-- 	<text content=" or fails with "/> -->
<!-- 	<error/> -->
<!-- 	<text content=" decidably in a finite number of steps."/> -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--   </theorem> -->
<!--   <theorem id="eq-infer-sound"> -->
<!--     <title>Soundness of Type Inference</title> -->
<!--     <p> -->
<!--       If: -->
<!--       <btypes:TYPE> -->
<!-- 	<TEjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <conclude> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	  </conclude> -->
<!-- 	  <constrain> -->
<!-- 	    <aCtset/> -->
<!-- 	  </constrain> -->
<!-- 	</TEjudge> -->
<!--       </btypes:TYPE>, then -->
<!--       <btypes:TYPE> -->
<!-- 	<Forall>	 -->
<!-- 	  <aSubMap/> -->
<!-- 	</Forall> -->
<!--       </btypes:TYPE> such that  -->
<!--       <btypes:TYPE> -->
<!-- 	<models name="sat">  -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!--       </btypes:TYPE>,  -->
<!--       <btypes:TYPE> -->
<!-- 	<Exists>	 -->
<!-- 	  <aCtset dash="'"/> -->
<!-- 	</Exists> -->
<!--       </btypes:TYPE> such that  -->
<!--       <btypes:TYPE> -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset dash="'"/> -->
<!-- 	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <gamma/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!-- 	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <store/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!--  	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <aExpr/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!--  	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <type/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!-- 	</Cjudge> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
<!--   <proof> -->
<!--     <p> -->
<!--       By induction on the derivation of  -->
<!--       <btypes:TYPE> -->
<!-- 	<TEjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <conclude> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	  </conclude> -->
<!-- 	  <constrain> -->
<!-- 	    <aCtset/> -->
<!-- 	  </constrain> -->
<!-- 	</TEjudge> -->
<!--       </btypes:TYPE>. We proceed by case analysis on the last step. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li id="eqs_base"> -->
<!-- 	<p> -->
<!-- 	  Cases E-Unit, E-True. E-False, E-Hloc, and E-Sloc are trivial.  -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li id="eqs_id"> -->
<!-- 	<p> -->
<!-- 	  Case E-Id: -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </proof> -->
<!--   <theorem id="eq-infer-complete"> -->
<!--     <title>Completeness of Type Inference</title> -->
<!--     <p> -->
<!--       If: -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!-- 	<text content=", then "/> -->
<!-- 	<Exists> -->
<!-- 	  <aSubMap/> -->
<!-- 	</Exists> -->
<!-- 	<text content=" such that "/> -->
<!-- 	<TEjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma dash="'"/> -->
<!-- 	    <store dash="'"/> -->
<!-- 	  </assume> -->
<!-- 	  <conclude> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </tqExpr> -->
<!-- 	  </conclude> -->
<!-- 	  <constrain> -->
<!-- 	    <aCtset/> -->
<!-- 	  </constrain> -->
<!-- 	</TEjudge> -->
<!-- 	<text content=", "/> -->
<!-- 	<models name="sat"> -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!-- 	<text content=", "/> -->
<!-- 	<eq> -->
<!-- 	  <gamma/> -->
<!-- 	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <gamma dash="'"/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!-- 	</eq> -->
<!-- 	<text content=", "/> -->
<!-- 	<eq> -->
<!-- 	  <store/> -->
<!-- 	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <store dash="'"/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!-- 	</eq> -->
<!-- 	<text content=" and "/> -->
<!-- 	<eq> -->
<!-- 	  <type/> -->
<!-- 	  <canonical> -->
<!-- 	    <Subst> -->
<!-- 	      <aSubMap/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </Subst> -->
<!-- 	  </canonical> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
  </sect1>
