<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="eq-infer"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Type Inference</title> 
  <definition id="define_infer">
    <title>Type Inference</title> 
    <p>
      Type inference is a program
      transformation that accepts a program in which
      <progident>let</progident> expressions are not annotated
      with their kinds, and returns the same programs in which
      <progident>let</progident> expressions are annotated with
      their kinds and all expressions are annotated with their
      types.
    </p>
  </definition>
  <definition id="constraint-colection-ext-inf">
    <title>Constraint Collection over Inference Derivation</title>
    <p>
      Similar to 
      <btypes:TYPE>
	<defn tag="constraint-colection-ext-typ"/>
      </btypes:TYPE>, we write
      <btypes:TYPE>
	<spset>
	  <TEjudge name="i">
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <conclude>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </conclude>
	    <constrain>
	      <aCtset/>
	    </constrain>
	  </TEjudge>
	</spset>
      </btypes:TYPE> to denote the set of all constrained types and
      unconcstrained type variables used in the derivation of 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <spset>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <Unit/>
		    <unit/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <Empty/>
		</constrain>
	      </TEjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <id/>
		    <type/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset/>
		</constrain>
	      </TEjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <unin>
	      <spset>
		<gamma/>
		<store/>
		<type/>
		<aCtset/>
	      </spset>
	    </unin>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
    <p>
      Other cases are similar.
    </p>
  </definition>
  <definition id="infer-notation">
    <title>Notational Derivations</title>
    <p>
      We define the following derivations for notational convenience:
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	    <Sjudge name="sol">
	      <aSubMap/>
	      <leadsto>
		<aCtset/>
		<dCtset/>
	      </leadsto>
	    </Sjudge>
	    <Cst>
	      <assume>
		<aSubMap/>
	      </assume>
	      <set>
		<gamma/>
		<store/>
		<type/>
		<aCtset/>
	      </set>
	    </Cst>
	  </tyPre>
	  <tyConc>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </tyConc>
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <TEjudge name="i">
	      <assume>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	    <Sat>
	      <bCtset/>
	      <Subst>
		<aSubMap/>
		<spset>
		  <TEjudge name="i">
		    <assume>
		      <gamma/>
		      <store/>
		    </assume>
		    <conclude>
		      <tqExpr>
			<aExpr/>
			<type/>
		      </tqExpr>
		    </conclude>
		    <constrain>
		      <aCtset/>
		    </constrain>
		  </TEjudge>
		</spset>
	      </Subst>
	    </Sat>
	  </tyPre>
	  <tyConc>
	    <TEjudge name="i">
	      <assume>
		<bCtset/>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<dCtset/>
	      </constrain>
	    </TEjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </tyPre>
	  <tyConc>
	    <Sjudge>
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge name="*">
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </tyPre>
	  <tyConc>
	    <Sjudge name="*">
	      <assume>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<Subst>
		  <aSubMap/>
		  <aExpr/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </tyPre>
	  <tyConc>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<aSubMap/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </tyConc>                
	</tyRule>
      </Hrules>
    </btypes:TYPE>
  </definition>
  <theorem id="unify-correct">
    <title>Correctness of Unification</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge name="sol">
	  <aSubMap/>
	  <leadsto>
	    <aCtset/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="unify-consistent">
    <title>Consistency of Unification</title>
    <p>
      If
      <btypes:TYPE>
	<CST>
	  <aCtset/>
	</CST>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Cst>
	  <assume/>
	  <Subst>
	    <aSubMap/>
	    <spset>
	      <aCtset/>
	    </spset>
	  </Subst>
	</Cst>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-satisfiable">
    <title>Satisfiability of Unified Constraints</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sat">
	  <scomp>
	    <aSubMap num="u"/>
	    <aSubMap num="s"/>
	  </scomp>
	  <leadsto>
	    <aCtset/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-principal">
    <title>Principality of Unified Types</title>
    <p>
      If
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, where 
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> is a set of constraints obtained from the type
      inference algorithm, then
      <btypes:TYPE>
	<Forall/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sol">
	  <aSubMap num="s"/>
	  <leadsto>
	    <aCtset/>
	    <dCtset dash="'"/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>, we have
      <btypes:TYPE>
	<supeq>
	  <aSubMap num="s"/>
	  <aSubMap num="u"/>
	</supeq>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
 	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>. The interesting case is
      <btypes:TYPE>
	<unf>
	  <eq>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	    <Ptype/>
	  </eq>
	</unf>
      </btypes:TYPE>, in particular 
      <btypes:TYPE>
	<unf>
	  <eq>
	    <mbFull>
	      <stype/>
	      <ptype/>
	    </mbFull>
	    <mbTop>
	      <tvar/>
	      <ptype dash="'"/>
	    </mbTop>
	  </eq>
	</unf>
      </btypes:TYPE>. This case is handled by noting that the
      inference algorithm only produces
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <ptype dash="'"/>
	</mbTop>
      </btypes:TYPE> types in the pair-selection rule, where
      <btypes:TYPE>
	<ptype dash="'"/>
      </btypes:TYPE> is of the form
      <btypes:TYPE>
	<pair>
	  <mbFull>
	    <tvar num="1"/>
	    <ptype num="1"/>
	  </mbFull>
	  <mbFull>
	    <tvar num="2"/>
	    <ptype num="2"/>
	  </mbFull>
	</pair>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="unify-decidable">
    <title>Decidability of Unification</title>
    <p>
      A canonical derivation of
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>, where no two applications of the refelexive rule
      happen consequetively, halts forall
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>.
      That is,
      <btypes:TYPE>
	<Forall/>
	<aCtset/>
      </btypes:TYPE>,
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE> decidably either succeeds with
      <btypes:TYPE>
	<Pair>
	  <dCtset/>
	  <aSubMap/>
	</Pair>
      </btypes:TYPE> or fails with 
      <btypes:TYPE>
	<error/>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Let the <em>degree</em> of unification be defined as the tuple
      (number of 
      <btypes:TYPE>
	<tvar/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<lKind k="var"/>
      </btypes:TYPE> variables,
      number of MPC constaints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>, 
      the size of types within the equality constraints in
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>). 
      Now, the proof is by induction on the derivation of
      <btypes:TYPE>
 	<unf>
	  <aCtset/>
	</unf>
      </btypes:TYPE>, where we show that the degree of unification
      reduces in every recursive call.
    </p>
  </proof>
  <lemma>
    <title>Consistency of Inferred Types</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<CST>
	  <gamma/>
	  <store/>
	</CST>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<CST sp="yes">
	  <TEjudge name="i">
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <conclude>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </conclude>
	    <constrain>
	      <aCtset/>
	    </constrain>
	  </TEjudge>
	</CST>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>, using
      <btypes:TYPE>
	<lem tag="unify-consistent"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="subst-infer-cst">
    <title>Substitution Consistency over Inference Derivation</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Cst>
	  <assume>
	    <aSubMap/>
	  </assume>
	  <unin>
	    <set>
	      <gamma/>
	      <store/>
	      <type/>
	      <aCtset/>
	    </set>
	  </unin>
	</Cst>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Cst>
	  <assume>
	    <aSubMap/>
	  </assume>
	  <spset>
	    <TEjudge name="i">
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </spset>
	</Cst>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>, using
      <btypes:TYPE>
	<lem tag="unify-consistent"/>
      </btypes:TYPE>, and using the fact that we can assume
      <btypes:TYPE>
	<eq>
	  <inter>
	    <ftvs>
	      <aSubMap/>
	    </ftvs>
	    <ftvs>
	      <spset>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </spset>
	    </ftvs>
	  </inter>
	  <ftvs>
	    <gamma/>
	    <store/>
	    <type/>
	    <aCtset/>
	  </ftvs>
	</eq>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="infer_soundness">
    <title>Soundness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> then
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From the premise 
	  <btypes:TYPE>
	    <TEjudge name="i">
	      <assume>
		<bCtset/>
		<aSubMap/>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <constrain>
		<aCtset/>
	      </constrain>
	    </TEjudge>
	  </btypes:TYPE>
	  of the theorem, using 
	  <btypes:TYPE>
	    <defn tag="infer-notation"/>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we obtain:
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr/>
		      <type/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Cst>
		  <aSubMap/>
		  <set>
		    <gamma/>
		    <store/>
		    <type/>
		    <aCtset/>
		  </set>
		</Cst>
	      </btypes:TYPE>.
	      Using
	      <btypes:TYPE>
		<lem tag="subst-infer-cst"/>
	      </btypes:TYPE>, this can be written as
	      <btypes:TYPE>
		<Cst>
		  <aSubMap/>
		  <spset>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr/>
			  <type/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </spset>
		</Cst>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <spset>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr/>
			  <type/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </spset>
		</models>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Sat>
		  <bCtset/>
		  <Subst>
		    <aSubMap/>
		    <spset>
		      <TEjudge name="i">
			<assume>
			  <gamma/>
			  <store/>
			</assume>
			<conclude>
			  <tqExpr>
			    <aExpr/>
			    <type/>
			  </tqExpr>
			</conclude>
			<constrain>
			  <aCtset/>
			</constrain>
		      </TEjudge>
		    </spset>
		  </Subst>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
	<p>
	  Now, we proceed by case analysis on the last step of the
	  derivation. 
	</p>
      </li>
      <li>
	<p>
	  Cases I-unit, I-Bool, I-Hloc and I-Sloc are trivial 
	</p>
      </li>
      <li>
	<p>
	  Case I-Id: In this case, we have
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <gamma/>
		  <id/>
		  <TS>
		    <tvars name="alpha"/>
		    <type num="x"/>
		    <dCtset num="x"/>
		  </TS>
		</mapsto>
		<eq>
		  <aSubMap num="x"/>
		  <plural>
		    <SubMap>
		      <tvar name="alpha"/>
		      <tvar name="beta"/>
		    </SubMap>
		  </plural>
		</eq>
		<models name="new">
		  <assume/>
		  <tvars name="beta"/>
		</models>
	      </tyPre>
	      <tyConc>
		<TEjudge name="i">
		  <assume>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <id/>
		      <Subst>
			<aSubMap num="x"/>
			<type num="x"/>
		      </Subst>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <Subst>
		      <aSubMap num="x"/>
		      <dCtset num="x"/>
		    </Subst>
		  </constrain>
		</TEjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Proof folows from cases&nbsp;(1.b and 1.c) using T-ID rule
	  and the fact that variable replacement is always consistent.
	</p>
      </li>
      <li>
	<p>
	  Case I-Lambda: 
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <TEjudge name="i">
		      <assume>
			<extend>
			  <gamma/>
			  <mapping>
			    <id/>
			    <mbFull>
			      <tvar name="beta"/>
			      <tvar name="alpha"/>
			    </mbFull>
			  </mapping>
			</extend>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="r"/>
			  <type num="r"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		    <models name="new">
		      <assume/>
		      <grouping>
			<tvar name="alpha"/>
			<tvar name="beta"/>
			<tvar name="beta" dash="'"/>
			<tvar name="gamma"/>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </grouping>
		    </models>
		  </tyPre>
		  <tyConc>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <lambda>
			    <id/>
			    <aExpr num="r"/>
			  </lambda>
			  <fn>		
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="alpha"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="delta"/>
			    </mbFull>
			  </fn>
			</tqExpr>
		      </conclude>
		      <constrain>
			<unin>
			  <aCtset/>
			  <set>
			    <eq>
			      <type num="r"/>
			      <mbFull>
				<tvar name="gamma"/>
				<tvar name="delta"/>
			      </mbFull>
			    </eq>
			  </set>
			</unin>
		      </constrain>
		    </TEjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>
	    </btypes:TYPE>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1 and 4.a), by weakening, we have	
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<mbFull>
			  <tvar name="beta"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="r"/>
		      <type num="r"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>. 
	      Now, from induction hypothesis, we have
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<mbFull>
			  <tvar name="beta"/>
			  <tvar name="alpha"/>
			</mbFull>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="r"/>
		    <type num="r"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.d), using weakening, we obtain
 	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <set>
		    <mbFull>
		      <tvar name="beta"/>
		      <tvar name="alpha"/>
		    </mbFull>
		    <mbFull>
		      <tvar name="beta" dash="'"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </set>
		</models>
	      </btypes:TYPE>. Now, from
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE> (property 3), we conclude that 
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="beta"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="beta" dash="'"/>
		      <tvar name="alpha"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Similarly, we conclude that 
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma" dash="'"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.b) and the constraint
 	      <btypes:TYPE>
		<eq>
		  <type num="r"/>
		  <mbFull>
		    <tvar name="gamma"/>
		    <tvar name="delta"/>
		  </mbFull>
		</eq>
	      </btypes:TYPE>, we obtain
 	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <type num="r"/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Now, using case&nbsp;(4.c), we obtain
 	      <btypes:TYPE>
		<eq under="minz">
		  <Subst>
		    <aSubMap/>
		    <type num="r"/>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <mbFull>
		      <tvar name="gamma" dash="'"/>
		      <tvar name="delta"/>
		    </mbFull>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.b, 4.c and 4.d) and 
	      the T-Lambda rule, we obtain
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <lambda>
		      <id/>
		      <aExpr num="r"/>
		    </lambda>
		    <fn>		
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="alpha"/>
		      </mbFull>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </mbFull>
		    </fn>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Finally, using this with case&nbsp;(1), we conclude that
 	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <lambda>
		      <id/>
		      <aExpr num="r"/>
		    </lambda>
		    <fn>		
		      <mbFull>
			<tvar name="beta" dash="'"/>
			<tvar name="alpha"/>
		      </mbFull>
		      <mbFull>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
		      </mbFull>
		    </fn>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case I-App:
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="1"/>
			  <type num="1"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset num="1"/>                  
		      </constrain>
		    </TEjudge>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <aExpr num="2"/>
			  <type num="2"/>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset num="2"/>                  
		      </constrain>
		    </TEjudge>
		  </tyPre>
		  <tyPre>
		    <models name="new">
		      <assume/>
		      <grouping>
			<tvar name="alpha"/>
			<tvar name="beta"/>
			<tvar name="beta" dash="'"/>
			<tvar name="gamma"/>
			<tvar name="gamma" dash="'"/>
			<tvar name="delta"/>
			<tvar name="epsiv"/>
		      </grouping>
		    </models>
		  </tyPre>
		  <tyConc>
		    <TEjudge name="i">
		      <assume>
			<gamma/>
			<store/>
		      </assume>
		      <conclude>
			<tqExpr>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>                 
			  <mbFull>
			    <tvar name="epsiv"/>
			    <tvar name="gamma"/>			
			  </mbFull>
			</tqExpr>
		      </conclude>
		      <constrain>
			<aCtset/>
		      </constrain>
		    </TEjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>
	    </btypes:TYPE>
	    <p>
	      where,
	      <br/>
	      <btypes:TYPE>
		<eq>
		  <aCtset/>
		  <unin>
		    <aCtset num="1"/>
		    <aCtset num="2"/>
		    <set>
		      <eq>
			<type num="1"/>
			<mbFull>
			  <tvar name="alpha"/>
			  <fn>
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="beta"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="gamma"/>
			    </mbFull>
			  </fn>
			</mbFull>
		      </eq>
		      <eq>
			<type num="2"/>
			<mbFull>
			  <tvar name="delta"/>
			  <tvar name="beta"/>
			</mbFull>
		      </eq>
		    </set>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Using weakening on case&nbsp;(1), we obtain
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge name="sol">
		      <aSubMap/>
		      <leadsto>
			<aCtset num="1"/>
			<dCtset num="1"/>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <Sjudge name="sol">
		      <aSubMap/>
		      <leadsto>
			<aCtset num="2"/>
			<dCtset num="2"/>
		      </leadsto>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <spset>
			<TEjudge name="i">
			  <assume>
			    <gamma/>
			    <store/>
			  </assume>
			  <conclude>
			    <tqExpr>
			      <aExpr num="1"/>
			      <type num="1"/>
			    </tqExpr>
			  </conclude>
			  <constrain>
			    <aCtset num="1"/>
			  </constrain>
			</TEjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE> and
		  <br/>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <spset>
			<TEjudge name="i">
			  <assume>
			    <gamma/>
			    <store/>
			  </assume>
			  <conclude>
			    <tqExpr>
			      <aExpr num="2"/>
			      <type num="2"/>
			    </tqExpr>
			  </conclude>
			  <constrain>
			    <aCtset num="2"/>
			  </constrain>
			</TEjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TEjudge name="i">
			    <assume>
			      <gamma/>
			      <store/>
			    </assume>
			    <conclude>
			      <tqExpr>
				<aExpr num="1"/>
				<type num="1"/>
			      </tqExpr>
			    </conclude>
			    <constrain>
			      <aCtset num="1"/>
			    </constrain>
			  </TEjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE> and
		  <br/>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TEjudge name="i">
			    <assume>
			      <gamma/>
			      <store/>
			    </assume>
			    <conclude>
			      <tqExpr>
				<aExpr num="2"/>
				<type num="2"/>
			      </tqExpr>
			    </conclude>
			    <constrain>
			      <aCtset num="2"/>
			    </constrain>
			  </TEjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(5.a and 5.b), we obtain
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="1"/>
		      <type num="1"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset num="1"/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<TEjudge name="i">
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <gamma/>
		    <store/>
		  </assume>
		  <conclude>
		    <tqExpr>
		      <aExpr num="2"/>
		      <type num="2"/>
		    </tqExpr>
		  </conclude>
		  <constrain>
		    <aCtset num="2"/>
		  </constrain>
		</TEjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(5.c) and induction hypothesis, we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="1"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <aSubMap/>
		    <dCtset num="1"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Note that since
	      <btypes:TYPE>
		<Sjudge name="sol">
		  <aSubMap/>
		  <leadsto>
		    <aCtset/>
		    <dCtset/>
		  </leadsto>
		</Sjudge>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<eq>
		  <aCtset/>
		  <unin>
		    <aCtset num="1"/>
		    <aCtset num="2"/>
		    <set>
		      <eq>
			<type num="1"/>
			<mbFull>
			  <tvar name="alpha"/>
			  <fn>
			    <mbFull>
			      <tvar name="beta" dash="'"/>
			      <tvar name="beta"/>
			    </mbFull>
			    <mbFull>
			      <tvar name="gamma" dash="'"/>
			      <tvar name="gamma"/>
			    </mbFull>
			  </fn>
			</mbFull>
		      </eq>
		      <eq>
			<type num="2"/>
			<mbFull>
			  <tvar name="delta"/>
			  <tvar name="beta"/>
			</mbFull>
		      </eq>
		    </set>
		  </unin>
		</eq>
	      </btypes:TYPE>,
	      we have
	      <btypes:TYPE>
		<eq>
		  <dCtset/>
		  <unin>
		    <dCtset num="1"/>
		    <dCtset num="2"/>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <!-- <li>
	  <p>
	</p>
	</li> -->
	</ol>
      </li>
    </ol>
  </proof>
  <theorem id="infer_completeness">
    <title>Completeness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <aSubMap dash="'"/>
	  <aSubMap/>
	</supeq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<supeq>
	  <bCtset dash="'"/>
	  <bCtset/>
	</supeq>
      </btypes:TYPE> 
      such that 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <bCtset dash="'"/>
	    <aSubMap dash="'"/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <diff>
	    <dom>
	      <aSubMap dash="'"/>
	    </dom>
	    <dom>
	      <aSubMap/>
	    </dom>
	  </diff>
	  <diff>
	    <dom>
	      <aCtset dash="'"/>
	    </dom>
	    <dom>
	      <aCtset/>
	    </dom>
	  </diff>
	  <set>
	    <grouping>
	      <tvars/>
	      <ST/>
	      <tvar/>
	      <text content=" is a fresh variable used in "/>
	      <TEjudge name="i">
		<assume>
		  <gamma/>
		  <store/>
		</assume>
		<conclude>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</conclude>
		<constrain>
		  <aCtset/>
		</constrain>
	      </TEjudge>
      	    </grouping>
	  </set>
	</eq>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.      
    </p>
  </proof>
  <theorem id="infer_soundness2">
    <title>Soundness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <aSubMap/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> then
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_soundness"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<lem tag="maybe-cst-properties"/>
      </btypes:TYPE> (property 3).
    </p>
  </proof>
  <theorem id="type_chekability">
    <title>Type Chekability</title>
    <p>
      If 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <dCtset num="u"/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Exists/>
	<aSubMap num="s"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="sat">
	  <aSubMap num="s"/>
	  <leadsto>
	    <dCtset num="u"/>
	    <dCtset/>
	  </leadsto>
	</Sjudge>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Subst>
	  <scomp>
	    <aSubMap num="u"/>
	    <aSubMap num="s"/>
	  </scomp>
	  <aExpr/>
	</Subst>
      </btypes:TYPE> is canonical, and
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <scomp>
	      <aSubMap num="u"/>
	      <aSubMap num="s"/>
	    </scomp>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_soundness2"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<thm tag="unify-satisfiable"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <theorem id="infer_completeness2">
    <title>Completeness of Type Inference</title>
    <p>
      If 
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <aSubMap/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <aSubMap dash="'"/>
	  <aSubMap/>
	</supeq>
      </btypes:TYPE> 
      such that 
      <btypes:TYPE>
	<TEjudge name="i">
	  <assume>
	    <aSubMap dash="'"/>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <dCtset/>
	  </constrain>
	</TEjudge>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<thm tag="infer_completeness"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<lem tag="maybe-cst-properties"/>
      </btypes:TYPE> (property 4).
    </p>
  </proof>
  </sect1>
