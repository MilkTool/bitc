<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="declarative_types"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Declarative Type System</title>
  <definition id="constraint-colection-ext">
    <title>Constraint Collection over Type Derivation</title>
    <p>
      We write
      <btypes:TYPE>
	<spset>
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</spset>
      </btypes:TYPE> to denote the set of all maybe types used in the
      derivation of 
      <btypes:TYPE>
	<spset>
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</spset>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<id/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <rhs>
		<gamma/>
		<store/>
		<type/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </rhs>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<Unit/>
		<unit/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<true/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<false/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<hLoc/>
		<ref>
		  <type/>
		</ref>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<sLoc/>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<lambda>
		  <id/>
		  <aExpr/>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <Sjudge>
		<assume>
		  <extend>
		    <gamma/>
		    <mapping>
		      <id/>
		      <type num="1"/>
		    </mapping>
		  </extend>
		  <store/>
		</assume>
		<tqExpr>
		  <aExpr/>
		  <type num="2"/>
		</tqExpr>
	      </Sjudge>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<apply>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</apply>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <TDjudge>
		<aExpr num="1"/>
		<type num="1"/>
	      </TDjudge>
	    </spset>
	  </rhs>
	</equation>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<TDjudge Msub="yes">
		  <aExpr num="2"/>
		  <type num="2"/>
		</TDjudge>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<type num="a"/>
		<type num="r"/>
		<type/>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
      </VEqns>
    </btypes:TYPE>
    <p>
      Other cases are similar.
    </p>
  </definition>
  <definition id="consistent-typing">
    <title>Consistent Type Derivation</title>
    <p>
      We say that
      <btypes:TYPE>
	<TDjudge name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, is a consistent type derivation if
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>
    </p>
  </definition>
  <definition id="stack-heap-typing">
    <title>Stack and Heap Typing</title>
    <p>
      A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
      <btypes:TYPE><stack/></btypes:TYPE> are said to be <em>well
	typed</em> with respect to a binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and store typing
      <btypes:TYPE><store/></btypes:TYPE>, and written
      <btypes:TYPE>
	<TDjudge>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge>
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge> 
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge>
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Similarly, we write
      <btypes:TYPE>
	<TDjudge name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="*">
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="*">
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="valid-lval">
    <title>Valid Lvalues</title>
    <p>
      We say that an lvalue
      <btypes:TYPE>
	<lVal/>
      </btypes:TYPE> is valid with respect to a stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE> and heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, written
      <btypes:TYPE>
	<Sjudge name="v">
	  <assume>
	    <plus>
	      <heap/>
	      <stack/>
	    </plus>
	  </assume>
	  <lVal/>
	</Sjudge>
      </btypes:TYPE> if one of the following conditions hold for some
      <btypes:TYPE>
	<path/>
      </btypes:TYPE>:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </definition>
  <lemma id="T-inversion">
    <title>Inversion of Typing Relation</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <Unit/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <true/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <false/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <hLoc/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <lambda>
		<id/>
		<aExpr/>
	      </lambda>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </fn>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>
		    <type num="1" dash="'"/>
		  </mapping>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type num="2" dash="'"/>
	      </tqExpr>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <deref>
		<aExpr/>
	      </deref>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of typing relation.
    </p>
  </proof>
  <lemma id="T-sub-inversion">
    <title>Inversion of Copy Coercion</title>
    <p>
      For any type
      <btypes:TYPE>
	<ptype/>
	<text content=" and "/>
	<tvar/>
      </btypes:TYPE>, let
      <btypes:TYPE>
	<eq>
	  <pred name="Q">
	    <ptype/>
	  </pred>
	  <set>
	    <ptype/>
	    <mutable>
	      <ptype/>
	    </mutable>
	    <mbTop>
	      <tvar/>
	      <ptype/>
	    </mbTop>
	    <mbTop>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbTop>
	    <mbFull>
	      <tvar/>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	  </set>
	</eq>
      </btypes:TYPE>. Then,
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <bool/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<bool/>
	      </pred>
	    </in>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <unit/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<unit/>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<ref>
		  <type dash="'"/>
		</ref>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </pred>
	    </in>
	    <text content=", such that "/>
	    <Msub>
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </Msub>
	    <text content=" and "/>	    
	    <Msub>
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </Msub>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <mutable>
		<ptype dash="'"/>
	      </mutable>
	    </eq>	      
	    <text content=", such that "/>
	    <Msub>
 	      <ptype dash="'"/>
	      <ptype/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the copy coercion derivation.
    </p>
  </proof>
  <lemma id="T-canonical">
    <title>Canonical Forms</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <unit/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Unit/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <bool/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is either "/>
	    <true/>
	    <text content=" or "/>
	    <false/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <ref>
		<type/>
	      </ref>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <hLoc/>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <lambda>
	      <id/>
	      <aExpr/>
	    </lambda>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Pair>
	      <aVal num="1"/>
	      <aVal num="2"/>
	    </Pair>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By inspecting the possibilities for the derivation of
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <p>
      According to the grammar of the language 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, values can be of one of the following forms:
      <btypes:TYPE>
	<collection>
	  <Unit/>
	  <true/> 
	  <false/>
	  <hLoc/>
	  <lambda>
	    <id/>
	    <aExpr/>
	  </lambda>
	  <Pair>
	    <aVal/>
	    <aVal/>
	  </Pair>
	</collection>
      </btypes:TYPE>
    </p>
    <p>
      Consider the case (2), where
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <bool/>
	</TDjudge>
      </btypes:TYPE>. That is,
      <btypes:TYPE>
	<TDjudge>
	  <aVal/>
	  <type/>
	</TDjudge>
	<text content=" and "/>
	<Msub>
	  <type/>
	  <bool/>
	</Msub>
      </btypes:TYPE>.
      From 
      <btypes:TYPE>
	<lem tag="T-sub-inversion"/>
      </btypes:TYPE> (inversion of copy-coercion), we know that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <pred name="Q">
	    <bool/>
	  </pred>
	</in>
      </btypes:TYPE>. 
      <btypes:TYPE>
	<text content=" That is, for some "/>
	<tvar/>
	<text content=", the type "/>
	<type/>
	<text content=" equals one of: "/>
	<collection or="yes">
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	  <mbTop>
	    <tvar/>
	    <bool/>
	  </mbTop>
	  <mbTop>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbTop>
	  <mbFull>
	    <tvar/>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	</collection>
      </btypes:TYPE>.
      If
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <bool/>
	</eq>
      </btypes:TYPE>, it is clear that the final rule in the
      derivation must be T-True, or T-False. A derivation with these
      rules is only possible if 
      <btypes:TYPE>
 	<eq>
	  <aVal/>
	  <true/>
	</eq>
	<text content=" or "/>
 	<eq>
	  <aVal/>
	  <false/>
	</eq>
      </btypes:TYPE>.
      Further, the cases like 
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE>
      cannot happen because there is no rule that
      derives a mutable/maybe type for a value.
    </p>
    <p>
      Other cases of the lemma are similar.
    </p>
  </proof>
  <lemma id="T-progress">
    <title>Progress</title>
    <p>
      <btypes:TYPE>
	<text content="If "/>
	<aExpr/>
	<text content=" is a closed, well typed term, "/>
	<text content="that is, "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" for some "/>
	<type/>
	<text content=" and "/>
	<store/>
	<text content=", given any heap "/>
	<heap/>
	<text content=" and stack "/>
	<stack/>
	<text content=" such that "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
	<text content=", "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content=" If "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	    <text content=", then "/>
	    <aExpr/>
	    <text content=" is either a valid lvalue "/>
	    <text content="(that is, "/>
	    <eq>
	      <aExpr/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	    <text content=") or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a value "/>
	    <aVal/>
	    <text content=" or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
	  (Values) Result is immediate for right execution, and
	  cannot happen for left execution.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id: cannot happen. 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id/>
	    </eq>
	  </btypes:TYPE> is not a closed term.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Immediate for left execution. Right
	  execution and can always continue with E-Rval rule as the
	  stack is well typed
	  (<btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-App: Only right execution is possible, no application is well
	  typed as an lvalue. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<type num="1"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE> is not a value, execution can continue via
	  the E-App1# due to induction hypothesis. Similarly, if 
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-App2#. 
	  Now, consider the case when both
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" and "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  are values. Since we know that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>, from 
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms) we conclude that 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is of the form
	  <btypes:TYPE>
	    <lambda>
	      <id/>
	      <aExpr dash="'"/>
	    </lambda>
	  </btypes:TYPE>. Now, we can take the step E-App.
	</p>
      </li>
      <li>
	<p>
	  Case T-If: Similar to T-App, only right execution is
	  permitted.
	</p>
      </li>
      <li>
	<p>
	  Case T-Set: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<mutable>
		  <ptype/>
		</mutable>
	      </Msub>
	    </Sjudge>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<ptype/>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  not an lvalue, since we have
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>
	  we can take E-:=lhs# by induction hypothesis.
	  Similarly, if
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-:=rhs#.
	</p>
	<p>
	  Finally, we consider the case where
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <eq>
	      <aExpr num="2"/>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>.
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>	    
	  should be one of
	  <btypes:TYPE>
	    <collection or = "yes">
	      <sLoc/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	      <deref>
		<hLoc/>
	      </deref>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </collection>
	  </btypes:TYPE>.
	  Now, we proceed by induction on the length of
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <sLoc/>
		</eq>
	      </btypes:TYPE>. We know from induction hypothesis
	      that that 
	      <btypes:TYPE>
		<Sjudge name="v">
		  <assume>
		    <heap/>
		    <stack/>
		  </assume>
		  <sLoc/>
		</Sjudge>
	      </btypes:TYPE> and from 
	      <btypes:TYPE>
		<defn tag="valid-lval"/>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<in>
		  <sLoc/>
		  <dom>
		    <stack/>
		  </dom>
		</in>
	      </btypes:TYPE>. Now, execution can continue
	      with E-:Stack.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <deref>
		    <hLoc/>
		  </deref>
		</eq>
	      </btypes:TYPE>, the execution can continue with step	    
	      E:-Heap.
	    </p>
	  </li>
	  <li>
	    <p>
	      Assume (by hypothesis) that the execution can continue for 
	      some 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1" dash="'"/>
		  <select>
		    <sLoc/>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, let
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <sLoc/>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We know that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aExpr num="1"/>
		    <mutable>
		      <ptype/>
		    </mutable>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
		<text content=" and "/>
		<Msub>
		  <type num="1"/>
		  <mutable>
		    <ptype/>
		  </mutable>
		</Msub>
	      </btypes:TYPE>.
	      That is,
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <select>
		      <fst>
			<sLoc/>
		      </fst>
		      <path/>
		    </select>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. 
	      The first two steps of this derivation must be 
	      T-Sloc and T-Fst.
	      From the assumption of T-Fst rule, we must have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <sLoc/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE> for some type
	      <btypes:TYPE>
		<type num="2"/>
	      </btypes:TYPE>.
	      Now, from the assumption of T-Sloc rule, we must have
	      <btypes:TYPE>
		<Msub>
		  <mapsto>
		    <store/>
		    <sLoc/>
		  </mapsto>
		  <pair>
		    <type num="1"/>
		    <type num="2"/>
		  </pair>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, if 
	      <btypes:TYPE>
		<mapsto>
		  <stack/>
		  <sLoc/>
		  <aVal/>
		</mapsto>
	      </btypes:TYPE>, 
	      since we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr >
		    <stack/>
		    <heap/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>, 
	      we conclude that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aVal/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(f) and
	      <btypes:TYPE>
		<lem tag="T-sub-inversion"/>
	      </btypes:TYPE> (inversion of copy-coercion), we conclude
	      that 
	      <btypes:TYPE>
		<eq>
		  <aVal/>
		  <Pair>
		    <aVal num="1"/>
		    <aVal num="2"/>
		  </Pair>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(c and g), we conclude that the
	      execution can continue using the E:-S.1 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <sLoc/>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      the execution can continue using E:-S.2 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similar to the above induction, we can show that if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <deref>
			<hLoc/>
		      </deref>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H1 rule, and if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <deref>
			<hLoc/>
		      </deref>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H2 rule.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Dup: Only right execution is
	  permitted, and can take E-Dup# or E-Dup as
	  applicable.
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr num="1"/>
	      </deref>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  Execution can take EL-^# or E-^# as
	  applicable if
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is a value, then, from
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms), we conclude that 
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <hLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	  Now, since this is an lvalue, we are done in the case of
	  left execution. In the case of right execution, we can
	  take step E-^.
	</p>
      </li>
      <li>
	<p>
	  Case T-Pair: Similar to case T-Dup
	</p>
      </li>
      <li>
	<p>
	  Case T-Fst, Case T-Snd: Similar to case T-Deref.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="m">
		<id/>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </let>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, we can take E-Let-M.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-P: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="p">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, the execution can take E-Let-P.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-Weakening">
    <title>Weakening</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>,
      then
      <btypes:TYPE>
	<Forall/>
	<supeq>
	  <gamma dash="'"/>
	  <gamma/>
	</supeq>
	<text content=" and "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=", "/>
	<Sjudge>
	  <assume>
	    <gamma dash="'"/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-Subtype-properties">
    <title>Properties of Copy Coercion</title>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <type/>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <type/>
		  </maxz>
		  <type dash="'"/>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <type/>
		  </maxz>
		  <maxz>
		    <type dash="'"/>
		  </maxz>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type/>
		  </minz>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type/>
 	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
 	      <type num="2"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Forall/> -->
<!-- 		<approx> -->
<!-- 		  <type num="1" dash="'"/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</approx> -->
<!-- 	      </btypes:TYPE>, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type num="1" dash="'"/> -->
<!-- 		  <minz> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </minz> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Forall/> -->
<!-- 		<approx> -->
<!-- 		  <type num="2" dash="'"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</approx> -->
<!-- 	      </btypes:TYPE>, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <maxz> -->
<!-- 		    <type num="1"/> -->
<!-- 		  </maxz> -->
<!-- 		  <type num="2" dash="'"/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <mutable> -->
<!-- 		<ptype/> -->
<!-- 	      </mutable> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Forall/> -->
<!-- 	    <approx> -->
<!-- 	      <type dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </approx> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type dash="'"/> -->
<!-- 	      <mutable> -->
<!-- 		<minz> -->
<!-- 		  <ptype/> -->
<!-- 		</minz> -->
<!-- 	      </mutable> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
    </ol>
  </lemma>
  <proof>
    <p>
      Property 1: By straightforward induction on the derivation of
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE>.
    </p>
    <p>
      Property 2: By construction of 
      <btypes:TYPE>
	<type num="3"/>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From property 1.d above, we have
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	  Similarly, we have
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	  Therefore,
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Let us pick
	  <btypes:TYPE>
	    <type num="3"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq>
	      <type num="3"/>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From S-Refl rule in 
	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>. From this using property 1.a, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <minz>
		<type num="1"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE>.
	  From case&nbsp;(2), we can write this as
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	  Similarly, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
    <p>
      Property 3: Similar to Property 2.
    </p>
<!--     <p> -->
<!--       Property 4: By straightforward induction on the derivation of -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <type num="1"/> -->
<!-- 	  <type num="2"/> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <p> -->
<!--       Property 5: We know that  -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <type/> -->
<!-- 	  <mutable> -->
<!-- 	    <ptype/> -->
<!-- 	  </mutable> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>.  -->
<!--       From  -->
<!--       <btypes:TYPE> -->
<!-- 	<lem tag="T-sub-inversion"/> -->
<!--       </btypes:TYPE>, we conclude that   -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <type/> -->
<!-- 	  <mutable> -->
<!-- 	    <ptype num="1"/> -->
<!-- 	  </mutable> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE> -->
<!--       such that -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <ptype num="1"/> -->
<!-- 	  <ptype/> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. -->
<!--       Using property&nbsp;2 with respect to  -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <ptype num="1"/> -->
<!-- 	  <ptype/> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>, we have -->
<!--       <btypes:TYPE> -->
<!-- 	<Forall/> -->
<!-- 	<approx> -->
<!-- 	  <ptype num="1" dash="'"/> -->
<!-- 	  <ptype num="1"/> -->
<!-- 	</approx> -->
<!--       </btypes:TYPE>, -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <ptype num="1" dash="'"/> -->
<!-- 	  <minz> -->
<!-- 	    <ptype/> -->
<!-- 	  </minz> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. -->
<!--       Now, from S-Mut rule, we obtain -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <mutable> -->
<!-- 	    <ptype num="1" dash="'"/> -->
<!-- 	  </mutable> -->
<!-- 	  <mutable> -->
<!-- 	    <minz> -->
<!-- 	      <ptype/> -->
<!-- 	    </minz> -->
<!-- 	  </mutable> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. This is equivalent to saying -->
<!--       <btypes:TYPE> -->
<!-- 	<Forall/> -->
<!-- 	<approx> -->
<!-- 	  <type dash="'"/> -->
<!-- 	  <type/> -->
<!-- 	</approx> -->
<!--       </btypes:TYPE>, -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <type dash="'"/> -->
<!-- 	  <minz> -->
<!-- 	    <ptype/> -->
<!-- 	  </minz> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
  </proof>
<!--   <lemma id="norm-subst-compose">
    <title>Multiple Substitution Canonicalization</title>
    <p>
      COMMENT: Only S1 needs to be idempotent in this case
      If
      <btypes:TYPE>
	<mutex>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <ftvs>
	    <aSubMap num="1"/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>, 
      then, 
      <br/>
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <Subst>
		<aSubMap num="1"/>
		<type/>
	      </Subst>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <aSubMap num="2"/>
	    </Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the structure of 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>. The only interesting cases are
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</eq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbFull>
	    <tvar/>
	    <ptype/>
	  </mbFull>
	</eq>
      </btypes:TYPE>.
      We only show that proof for
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</eq>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  By induction hypothesis, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="1"/>
		<Subst>
		  <aSubMap num="2"/>
		  <Subst>
		    <aSubMap num="1"/>
		    <ptype/>
		  </Subst>
		</Subst>
	      </Subst>
	      <Subst>
		<aSubMap num="1"/>
		<Subst>
		  <aSubMap num="2"/>
		  <ptype/>
		</Subst>
	      </Subst>
	      <Subst>
		<Subst>
		  <aSubMap num="1"/>
		  <aSubMap num="2"/>
		</Subst>
		<Subst>
		  <aSubMap num="1"/>
		  <ptype/>
		</Subst>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </notin>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="2"/>
	      </dom>
	    </notin>
	  </btypes:TYPE>, the result follows from 
	  induction hypothesis.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <in>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </in>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      Since
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		  <ftvs>
		    <aSubMap num="1"/>
		  </ftvs>
		</mutex>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		</notin>
	      </btypes:TYPE>.
	      Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="2"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <mbTop>
		    <tvar/>	
		    <Subst>
		      <aSubMap num="2"/>
		      <ptype/>
		    </Subst>
		  </mbTop>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Further, since
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		  <ftvs>
		    <aSubMap num="1"/>
		  </ftvs>
		</mutex>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <dom>
		      <aSubMap num="2"/>
		    </dom>
		    <ftvs>
		      <range>
			<aSubMap num="1"/>
		      </range>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>. Therefore, if
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>, then
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="2"/>
		    <ptype num="1"/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <tvar name="beta"/>
		</eq>
	      </btypes:TYPE>. Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <mbTop>
		    <tvar name="beta"/>
		    <Subst>
		      <aSubMap num="1"/>
		      <ptype/>
		    </Subst>
		  </mbTop>
		</eq>
	      </btypes:TYPE>.
	    </p>
	    <ol>		
	      <li>
		<p>
		  Due to case&nbsp;(3.b), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<tvar name="beta"/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>. This, along with case&nbsp;(3.c) 
		  gives us
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Due to the idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap num="1"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <ptype/>
			    </Subst>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Now, the result follows from induction hypothesis.
		  From cases&nbsp;(1, 3.c.ii, 3.c.iii, and 3.c.iv),
		  we have 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
		<text content=" | "/>
		<neq>
		  <ptype num="1"/>
		  <tvar name="beta"/>
		</neq>
	      </btypes:TYPE>. Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>
	      (ref: substitution rules in 
	      figure&nbsp;<xref ref="subst_rules"/>).
	    </p>
	    <ol>		
	      <li>
		<p>
		  Due to case&nbsp;(3.b), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<ptype num="1"/>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>. This, along with case&nbsp;(3.d) 
		  gives us
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(3.d.1), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>
		  Due to the idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap num="1"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <ptype/>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		  Therefore,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <ptype/>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Due to case&nbsp;(3.a), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <Subst>
			    <aSubMap num="2"/>
			    <ptype/>
			  </Subst>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>
		  (ref: substitution rules in 
		  figure&nbsp;<xref ref="subst_rules"/>).
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(3.d.ii, 3.d.iii, and 3.d.iv),
		  we have 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <in>
	      <tvar/>
	      <dom>
		<aSubMap num="2"/>
	      </dom>
	    </in>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </notin>
	  </btypes:TYPE>. The proof for this case is similar to
	  case&nbsp;(3). However, in this case, it is possible
	  that
	  <btypes:TYPE>
	    <neq>
	      <inter>
		<dom>
		  <aSubMap num="1"/>
		</dom>
		<ftvs>
		  <range>
		    <aSubMap num="2"/>
		  </range>
		</ftvs>
	      </inter>
	      <Empty/>
	    </neq>
	  </btypes:TYPE>, which leads a further level of case analysis.
	</p>
      </li>
    </ol>
  </proof> -->
  <lemma id="T-SSubstitution">
    <title>Subtype Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <set>
	    <type num="1"/>
	    <type num="2"/>
	  </set>
	</models>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Msub>
	  <Subst>
	    <aSubMap/>
	    <type num="1"/>
	  </Subst>
	  <minz>
	    <Subst>
	      <aSubMap/>
	      <type num="2"/>
	    </Subst>
	  </minz>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Msub>
	  <maxz>
	    <Subst>
	      <aSubMap/>
	      <type num="1"/>
	    </Subst>
	  </maxz>
	  <Subst>
	    <aSubMap/>
	    <type num="2"/>
	  </Subst>
	</Msub>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      Follows from
      <btypes:TYPE>
	<lem tag="T-Subtype-properties"/>
      </btypes:TYPE>
      and
      <btypes:TYPE>
	<lem tag="T-sub-min"/>
      </btypes:TYPE>.
    </p>
  </proof>
<!--   <proof> -->
<!--     <p> -->
<!--       By induction on the derivation of  -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <type num="1"/> -->
<!-- 	  <type num="2"/> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. We give the proof for the first property only, -->
<!--       the second property is similarly proved. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Refl is trivial. Cases S-Trans follows from induction -->
<!-- 	  hypothesis. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Fn: Here,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="a"/> -->
<!-- 		<type num="r"/> -->
<!-- 	      </fn> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="a" dash="'"/> -->
<!-- 		<type num="r" dash="'"/> -->
<!-- 	      </fn> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>, and we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <fn> -->
<!-- 		<type num="a"/> -->
<!-- 		<type num="r"/> -->
<!-- 	      </fn> -->
<!-- 	      <fn> -->
<!-- 		<type num="a" dash="'"/> -->
<!-- 		<type num="r" dash="'"/> -->
<!-- 	      </fn> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From the assumptions of this derivation of -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <fn> -->
<!-- 		    <type num="a"/> -->
<!-- 		    <type num="r"/> -->
<!-- 		  </fn> -->
<!-- 		  <fn> -->
<!-- 		    <type num="a" dash="'"/> -->
<!-- 		    <type num="r" dash="'"/> -->
<!-- 		  </fn> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>, we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type num="a"/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type num="a" dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <type num="r"/> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <type num="r" dash="'"/> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Therefore, we must have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minz> -->
<!-- 		      <type num="a"/> -->
<!-- 		    </minz> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minz> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		    </minz> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <maxz> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </maxz> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <maxz> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </maxz> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Further, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minz> -->
<!-- 			<type num="a"/> -->
<!-- 		      </minz> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minz> -->
<!-- 			<type num="a" dash="'"/> -->
<!-- 		      </minz> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <maxz> -->
<!-- 			<type num="r"/> -->
<!-- 		      </maxz> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <maxz> -->
<!-- 			<type num="r" dash="'"/> -->
<!-- 		      </maxz> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(2.c) and  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lem tag="T-msm_eq_ms"/> -->
<!-- 	      </btypes:TYPE>, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="a"/> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(2.d) and S-Fn rule, we conclude that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="a"/> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </fn> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </fn> -->
<!-- 		  </Subst> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>	       -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Pair: Follows from induction hypothesis, and the fact -->
<!-- 	  that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type num="1"/> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type num="2"/> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> implies -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<pair> -->
<!-- 		  <type num="1"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</pair> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <pair> -->
<!-- 		    <type num="1"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </pair> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Mut: Cannot happen for first property (follows from -->
<!-- 	  induction hypothesis for the second property). -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-MT1: There are two sub-cases to consider: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <in> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <dom> -->
<!-- 		<aSubMap/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <notin> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <dom> -->
<!-- 		<aSubMap/> -->
<!-- 	      </dom> -->
<!-- 	    </notin> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Suppose -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<notin> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		  <dom> -->
<!-- 		    <aSubMap/> -->
<!-- 		  </dom> -->
<!-- 		</notin> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      That is, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		  </Subst> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>.  -->
<!-- 	      We know that  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <stype/> -->
<!-- 		  </minzT> -->
<!-- 		  <type/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Therefore, we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minzT> -->
<!-- 		      <stype/> -->
<!-- 		    </minzT> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <type/> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and further -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minzT> -->
<!-- 			<stype/> -->
<!-- 		      </minzT> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(5.a) and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lem tag="T-msm_eq_ms"/> -->
<!-- 	      </btypes:TYPE>, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <stype/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!-- 	<p> -->
<!-- 	  Since a substitution on strcturally equal types must preserve -->
<!-- 	  equality, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<minz> -->
<!-- 		  <stype/> -->
<!-- 		</minz> -->
<!-- 	      </Subst> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type/> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  Otherwise,  -->
<!-- 	  It must be true that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<stype/> -->
<!-- 	      </Subst> -->
<!-- 	      <stype dash="'"/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> for some base type  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype dash="'"/> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  because otherwise, the substitution will -->
<!-- 	  violate the grammar within the type -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <mbTop> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<stype/> -->
<!-- 	      </Subst> -->
<!-- 	    </mbTop> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Given this, we can conclude that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	      <stype dash="''"/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> for some type -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype dash="''"/> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  By induction hypothesis, we know that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Now, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <maxzT> -->
<!-- 	      <stype/> -->
<!-- 	    </maxzT> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  is equal to  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype/> -->
<!-- 	  </btypes:TYPE> or -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <mutable> -->
<!-- 	      <stype/> -->
<!-- 	    </mutable> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Since  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype/> -->
<!-- 	  </btypes:TYPE> is not a maybe type,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <maxzT> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <stype/> -->
<!-- 		</Subst> -->
<!-- 	      </maxzT> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. Therefore, we have, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <maxzT> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <stype/> -->
<!-- 		</Subst> -->
<!-- 	      </maxzT> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. The result is obtainable from S-MT1 rule. -->
<!-- 	  Let -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <stype num="1"/> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<Msub> -->
<!-- 		  <maxzT> -->
<!-- 		    <stype/> -->
<!-- 		  </maxzT> -->
<!-- 		</Msub> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <stype num="2"/> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Since we have  -->
	  
<!-- 	  By inspecting the copy coercion rules, we determine that in -->
<!-- 	  order for the relationship  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <stype num="1"/> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE> to hold,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <minz> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type/> -->
<!-- 	      </Subst> -->
<!-- 	    </minz> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </proof> -->
  <lemma id="T-Renaming">
    <title>Type Renaming</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <aSubMap/>
	  <plural>
	    <SubMap>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </SubMap>
	  </plural>
	</eq>
      </btypes:TYPE>, where,
      <btypes:TYPE>
	<mutex>
	  <set>
	    <tvars name="beta"/>
	  </set>
	  <ftvs>
	    <gamma/>
	    <store/>
	    <type/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <Subst>
	      <aSubMap/>
	      <gamma/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <store/>
	    </Subst>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <Subst>
	      <aSubMap/>
	      <type/>
	    </Subst>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of 
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
  </proof>
  <!--   <lemma id="cst-streangthening-gen">
    <title><font color="blue">Strengthening of Consistency</font></title>
    If:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <CST>
	      <solvables num="b"/>
	    </CST>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <subeq>
	      <set>
		<solvables num="a"/>
	      </set>
	      <set>
		<solvables num="b"/>
	      </set>
	    </subeq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Cst>
	      <assume/>
	      <Subst>
		<aSubMap/>
 		<set>
		  <solvables num="a"/>
		</set>
	      </Subst>
	    </Cst>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <subeq>
	      <inter>
		<dom>
		  <aSubMap/>
		</dom>
		<ftvs>
		  <solvables num="b"/>
		</ftvs>
	      </inter>
	      <ftvs>
		<solvables num="a"/>
	      </ftvs>
	    </subeq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <subeq>
	      <inter>
		<ftvs>
		  <range>
		    <aSubMap/>
		  </range>
		</ftvs>
		<ftvs>
		  <solvables num="b"/>
		</ftvs>
	      </inter>
	      <ftvs>
		<solvables num="a"/>
	      </ftvs>
	    </subeq>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Cst>
	  <assume/>
	  <Subst>
	    <aSubMap/>
	    <set>
	      <solvables num="b"/>
	    </set>
	  </Subst>
	</Cst>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <Forall/>
	    <in>
	      <mbTop>
		<tvar/>
		<ptype num="sb"/>
	      </mbTop>
	      <Subst>
		<aSubMap/>
		<solvables num="b"/>
	      </Subst>
	    </in>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Forall/>
	    <in>
	      <mbTop>
		<tvar/>
		<ptype num="sb" dash="'"/>
	      </mbTop>
	      <Subst>
		<aSubMap/>
		<solvables num="b"/>
	      </Subst>
	    </in>
	  </btypes:TYPE>, we could have any of the following possibilities:
	</p>
	<ol>
	  <li>
	    <p>
	      Case
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <ftvs>
		    <range>
		      <aSubMap/>
		    </range>
		  </ftvs>
		</notin>
	      </btypes:TYPE>:
	    </p>
	    <ol>
	      <li>
		<p>
		  In this case,
		  <btypes:TYPE>
		    <Exists/>
		    <in>
		      <mbTop>
			<tvar/>
			<ptype num="s"/>
		      </mbTop>
		      <solvables num="b"/>
		    </in>
		    <text content=" and "/>
		    <in>
		      <mbTop>
			<tvar/>
			<ptype num="s" dash="'"/>
		      </mbTop>
		      <solvables num="b"/>
		    </in>
		    <text content=" | "/>
		    <eq>
		      <ptype num="sb"/>
		      <Subst>
			<aSubMap/>
			<ptype num="b"/>
		      </Subst>
		    </eq>
		    <text content=" and "/>
		    <eq>
		      <ptype num="sb" dash="'"/>
		      <Subst>
			<aSubMap/>
			<ptype num="b" dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		  We have:
		  <btypes:TYPE>
		    <eq under="minzT">
		      <type num="1"/>
		      <type num="2"/>
		    </eq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="1"/>
		      <type num="2"/>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
    </ol>
  </proof> -->
  <lemma id="Consistency-Propagation-1">
    <title>Consistency of Substitution over Type Derivation</title>
    <p>
      If
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<Cst>
	  <aSubMap/>
	  <set>
	    <gamma/>
	    <store/>
	    <type/>
	  </set>
	</Cst>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Cst>
	  <aSubMap/>
	  <spset>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</Cst>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. 
    </p>
    <ol>
      <li>
	<p>
	  At any step of the derivation, let
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> be a type used in the derivation such that 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <gamma/>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <store/>
	    </in>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <type/>
	    </in>
	  </btypes:TYPE> do not (necessarily) hold. For example, 
	  <btypes:TYPE>
	    <type dash="'"/>
	  </btypes:TYPE> in T-ID, 
	  <btypes:TYPE>
	    <fn>
	      <type num="a"/>
	      <type num="r"/>
	    </fn>
	  </btypes:TYPE> in T-APP, or the type obtained by any
	  sub-derivation (for some sub-expression).
	</p>
      </li>
      <li>
	<p>
	  Through a suitable renaming of variables, and using
	  <btypes:TYPE>
	    <lem tag="T-Renaming"/>
	  </btypes:TYPE>, we can ensure
	  <btypes:TYPE>
	    <subeq>
	      <inter>
		<dom>
		  <aSubMap/>
		</dom>
		<ftvs>
		  <type num="s"/>
		</ftvs>
	      </inter>
	      <ftvs>
		<gamma/>
		<store/>
		<type/>
	      </ftvs>
	    </subeq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  We want to show
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>.
	  Therefore, we proceed by induction on the structure of 
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE>. The only interesting cases are
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case 
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE>:
	</p>
	<ol>
	  <li>
	    <p>
	      By induction hypothesis, we have
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <ptype/>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<in>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</in>
	      </btypes:TYPE>:
	    </p>
	    <ol>
	      <li>
		<p>
		  Due to the assumption 
		  <btypes:TYPE>
		    <CST sp="yes">
		      <TDjudge>
			<aExpr/>
			<type/>
		      </TDjudge>
		    </CST>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <defn tag="maybe-consistent"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <Exists/>
		    <in>
		      <mbTop>
			<tvar/>
			<ptype dash="'"/>
		      </mbTop>
		      <collection or="yes">
			<gamma/>
			<store/>
			<type/>
		      </collection>
		    </in>
		  </btypes:TYPE> such that
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype/>
		      <ptype dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From the assumption
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
		      </set>
		    </models>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <ptype dash="'"/>
		    </models>
		  </btypes:TYPE>.
		  From this, case&nbsp;(4.a) and
		  <btypes:TYPE>
		    <lem tag="Cst-additive"/>
		  </btypes:TYPE> (aggregation), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<ptype/>
			<ptype dash="'"/>
		      </set>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(4.b.i and 4.b.ii), and
		  <btypes:TYPE>
		    <lem tag="T-sub-min"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	      <li>
		<p>
		  From the assumption
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
		      </set>
		    </models>
		  </btypes:TYPE>, case&nbsp;(4.b.i), and	  
		  <btypes:TYPE>
		    <defn tag="subst-consistent"/>
		  </btypes:TYPE>, we know that 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>, for some 
		  <btypes:TYPE>
		    <tvar name="beta"/>
		  </btypes:TYPE>, or
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <ptype dash="''"/>
		    </eq>
		  </btypes:TYPE>, such that 
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype dash="''"/>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. Using case&nbsp;(4.b.iii), we can
		  write this as
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <ptype/>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</notin>
	      </btypes:TYPE>, then, we know that
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <dom>
		    <aSubMap/>
		  </dom>
		</notin>
	      </btypes:TYPE>, and therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar/>
		  </Subst>
		  <tvar/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
	<p>
	  Therefore, in all cases, for some
	  <btypes:TYPE>
	    <tvar name="beta"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <tvar name="beta"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minzT">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>:
	  Similar to the previous case, we conclude that
	  for some
	  <btypes:TYPE>
	    <stype dash="'"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <stype dash="'"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minz">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From cases&nbsp;(4 and 5), and 
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we conclude that
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>. 
	</p>
      </li>
      <li>
	<p>
	  By repeating the same argument over all types
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> used in the derivation of
	  <btypes:TYPE>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>, we finally obtain
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <spset>
		<TDjudge>
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </spset>
	    </models>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="Composistion-Rearrange">
    <title>Composition Consistency</title>
    <p>
      If:
    </p>
    <p>
      <btypes:TYPE>
	<models name="cst">
	  <assume>
	    <aSubMap num="1"/>
	  </assume>
	  <type/>
	</models>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<models name="cst">
	  <assume>
	    <aSubMap num="2"/>
	  </assume>
	  <type/>
	</models>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<models name="cst">
	  <assume>
	    <aSubMap num="1"/>
	  </assume>
	  <Subst>
	    <aSubMap num="2"/>
	    <type/>
	  </Subst>
	</models>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<mutex>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <ftvs>
	    <aSubMap num="1"/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>,
    </p>
    <p>
      Then, 
      <btypes:TYPE>
	<Exists/>
	<eq>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE> such that:
    </p>
    <p>
      <btypes:TYPE>
	<eq>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <dom>
	    <aSubMap num="2" dash="'"/>
	  </dom>
	</eq>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="2" dash="'"/>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<models name="cst">
	  <assume>
	    <aSubMap num="2" dash="'"/>
	  </assume>
	  <Subst>
	    <aSubMap num="1"/>
	    <type/>
	  </Subst>
	</models>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By construction of
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE>.
      Let
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> be an idempotent substitution equivalent to 
      <btypes:TYPE>
	<compose>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</compose>
      </btypes:TYPE>.
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE> can be choosen as a part of 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> that contains substitutions only for
      <btypes:TYPE>
	<dom>
	  <aSubMap num="2"/>
	</dom>
      </btypes:TYPE>.
      <!-- NOTE: NOTE: Here, we will have
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <aSubMap num="2" dash="'"/>
	  </Subst>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE>,
      REMEMBER: This is for reference only. Substitution on 
      substitutions was removed. That must be re-introduced
      if this like is un-commented. -->
    </p>
  </proof>
  <lemma id="T-TSubstitution">
    <title>Type Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, 
      then for any substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE>
      such that
      <btypes:TYPE>
	<models name="cst">
	  <assume>
	    <aSubMap/>
	  </assume>
	  <spset>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</models>
      </btypes:TYPE>,
      <btypes:TYPE>
	<CST>
	  <Subst>
	    <aSubMap/>
	    <gamma/>
	  </Subst>
	  <Subst>
	    <aSubMap/>
	    <store/>
	  </Subst>
	  <Subst>
	    <aSubMap/>
	    <type/>
	  </Subst>
	</CST>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<mutex>
	  <ftvs>
	    <aSubMap/>
	  </ftvs>
	  <pred name="gtv">
	    <gamma/>
	  </pred>
	</mutex>
      </btypes:TYPE>, we have
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <Subst>
	      <aSubMap/>
	      <gamma/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <store/>
	    </Subst>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <Subst>
	      <aSubMap/>
	      <type/>
	    </Subst>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. We proceed by case analysis on the last step of
      the derivation.
    </p>
    <ol>
      <li>
	<p>
	  Cases T-Unit, T-True, T-False, T-Hloc and T-Sloc are trivial.
	</p>
      </li>
      <li>
	<p>
	  Case T-ID:
	</p>
	<ol>
	  <li>
	    <p>
	      We have
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>	
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma/>
			  <id/>
			  <TS>
			    <tvars/>
			    <type num="i"/>
			  </TS>
			</mapsto>
			<eq>
			  <aSubMap num="n"/>
			  <plural>
			    <SubMap>
			      <tvar/>
			      <type dash="'"/>
			    </SubMap>
			  </plural>
			</eq>
			<models name="cst">
			  <assume>
			    <aSubMap num="n"/>
			  </assume>
			  <type num="i"/>
			</models>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <id/>
			  <Subst>
			    <aSubMap num="n"/>
			    <type num="i"/>
			  </Subst>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>      
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <CST sp="yes">
		      <TDjudge>
			<id/>
			<Subst>
			  <aSubMap num="n"/>
			  <type num="i"/>
			</Subst>
		      </TDjudge>
		    </CST>
		  </btypes:TYPE>		      
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <spset>
			<TDjudge>
			  <id/>
			  <Subst>
			    <aSubMap num="n"/>
			    <type num="i"/>
			  </Subst>
			</TDjudge>
		      </spset>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <type/>
		      <Subst>
			<aSubMap num="n"/>
			<type num="i"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Since 
	      <btypes:TYPE>
		<mutex>
		  <ftvs>
		    <aSubMap/>
		  </ftvs>
		  <pred name="gtv">
		    <gamma/>
		  </pred>
		</mutex>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		    <set>
		      <tvars/>
		    </set>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	      Since
	      <btypes:TYPE>
		<eq>
		  <dom>
		    <aSubMap num="n"/>
		  </dom>
		  <set>
		    <tvars/>
		  </set>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <dom>
		      <aSubMap num="n"/>
		    </dom>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a.i and 2.b), we have
	      <btypes:TYPE>	
		<mapsto>
		  <Subst>
		    <aSubMap/>
		    <gamma/>
		  </Subst>
		  <id/>
		  <TS>
		    <tvars/>
		    <Subst>
		      <aSubMap/>
		      <type num="i"/>
		    </Subst>
		  </TS>
		</mapsto>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(2.a.iii) and 
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), and case&nbsp;(2.a.i), 
	      we have:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <type num="i"/>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap num="n"/>
		      </assume>
		      <type num="i"/>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <Subst>
			<aSubMap num="n"/>
			<type num="i"/>
		      </Subst>
		    </models>
		  </btypes:TYPE>.	      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.d.i, 2.d.ii, 2.d.iii, and 2.b), 
	      and
	      <btypes:TYPE>
		<lem tag="Composistion-Rearrange"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<Exists/>
		<aSubMap num="m"/>
	      </btypes:TYPE> such that:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aSubMap num="m"/>
		      </dom>
		      <dom>
			<aSubMap num="n"/>
		      </dom>
		    </eq>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="m"/>
		      <plural>
			<SubMap>
			  <tvar/>
			  <type dash="''"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		      <Subst>
			<sSubMap/>
			<Subst>
			  <aSubMap num="n"/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>		
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap num="m"/>
		      <Subst>
			<aSubMap/>
			<type num="i"/>
		      </Subst>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.c, 2.e.i and 2.e,iii), and the T-ID rule
	      we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <Subst>
		      <aSubMap num="m"/>
		      <Subst>
			<aSubMap/>
			<type num="i"/>
		      </Subst>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.g and 2.e.ii), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: Follows from induction hypothesis, using the 
	  T-Lambda rule.
	</p>
      </li>
      <li>
	<p>
	  Case T-App: 
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have:
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<TDjudge>
			  <aExpr num="1"/>
			  <type num="1"/>
			</TDjudge>
			<Msub>
			  <type num="1"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</Msub>
		      </tyPre>
		      <tyPre>
			<TDjudge Msub="yes">
			  <aExpr num="2"/>
			  <type num="2"/>
			</TDjudge>
			<Msub>
			  <type num="2"/>
			  <minz>
			    <type num="a"/>
			  </minz>
			</Msub>
			<Msub>
			  <maxz>
			    <type num="r"/>
			  </maxz>
			  <type/>
			</Msub>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <set>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </set>
		    </models>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <CST>
		      <gamma/>
		      <store/>
		      <type/>
		    </CST>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      By induction hypothesis, we have:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="1"/>
			<Subst>
			  <aSubMap/>
			  <type num="1"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="2"/>
			<Subst>
			  <aSubMap/>
			  <type num="2"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
    </ol>
  </proof>
  <lemma id="T-VSubstitution">
    <title>Value Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<TS>
		  <tvars/>
		  <type num="v"/>
		</TS>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", "/>
	<TDjudge name="*">
	  <aVal/>
	  <type num="v"/>
	</TDjudge>
	<text content=" and "/>
	<!-- This predicate is necessary since the pair rule can
	derive mutable types for pair of values (v,v) and the
	substitution can go wrong if performed on the lhs of
	an assignment. This predicate effectively rules out
	substitution on the lhs of an assignment.--> 
	<pred name="Immut">
	  <type num="v"/>
	</pred>
	<text content=", then "/>
	<Sjudge name="*">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<aTS/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
      We proceed by case analysis on the final step of the
      derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id name="y"/>
	    </eq>
	    <text content=", where "/>
	    <in>
	      <id name="y"/>
	      <extend>
		<gamma/>
		<id/>
		<aTS/>
	      </extend>
	    </in>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<neq>
		  <eq>
		    <aExpr/>
		    <id name="y"/>
		  </eq>
		  <id name="x"/>
		</neq>
	      </btypes:TYPE>, then,
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>.
	      and the desired result
	      <btypes:TYPE>
		<TDjudge name="*">
		  <id name="y"/>
		  <type/>
		</TDjudge>
	      </btypes:TYPE>
	      is immediate from the assumtion
	      <btypes:TYPE>
		<Sjudge name="*">
		  <assume>
		    <extend>
		      <gamma/>
		      <tqExpr>
			<id/>
			<TS>
			  <tvars/>
			  <type num="v"/>
			</TS>
		      </tqExpr>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<eq>
		  <aExpr/>
		  <id name="x"/>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <aVal/>
		</eq>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<eq>
		  <type/>
		  <Subst>
		    <aSubMap/>
		    <type num="v"/>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Let
	      <btypes:TYPE>
		<eq>
		  <gamma dash="'"/>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <TS>
			<tvars/>
			<type num="v"/>
		      </TS>
		    </tqExpr>
		  </extend>
		</eq>
	      </btypes:TYPE>.
	      By inversion of the 
	      <btypes:TYPE>
		<judgeOp name="*"/>
	      </btypes:TYPE> judgement using
	      <btypes:TYPE>
		<defn tag="consistent-typing"/>
	      </btypes:TYPE>, we have:
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules rowsep="4pt" colsep="1">
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma dash="'"/>
			  <id name="y"/>
			  <TS>
			    <tvars/>
			    <type num="v"/>
			  </TS>
			</mapsto>
			<eq>
			  <aSubMap/>
			  <plural>
			    <SubMap>
			      <tvar/>
			      <type dash="'"/>
			    </SubMap>
			  </plural>
			</eq>
			<models name="cst">
			  <assume>
			    <aSubMap/>
			  </assume>
			  <type num="v"/>
			</models>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>        
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <assume/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <TDjudge>
		      <aVal/>
		      <type num="v"/>
		    </TDjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <assume/>
		      <spset>
			<TDjudge>
			  <aVal/>
			  <type num="v"/>
			</TDjudge>
		      </spset>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	    <p>
	      We need to show that 
	      <btypes:TYPE>
		<TDjudge name="*">
		  <aVal/>
		  <Subst>
		    <aSubMap/>
		    <type num="v"/>
		  </Subst>
		</TDjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We can assume that 
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<gamma/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<gamma/>
		      </Subst>
		      <gamma/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<store/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<store/>
		      </Subst>
		      <store/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <ftvs>
			<aSubMap/>
		      </ftvs>
		      <pred name="gtv">
			<gamma/>
		      </pred>
		    </mutex>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	    <p>
	      This can always be made to hold by suitable renaming of
	      variables and using 
	      <btypes:TYPE>
		<lem tag="T-Renaming"/>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, we proceed by induction on the structure of 
	      <btypes:TYPE>
		<aVal/>
	      </btypes:TYPE>.
	    </p>
	    <ol>
	      <li>
		<p>
		  Cases 
		  <btypes:TYPE>
		    <eq>
		      <aVal/>
		      <collection and="yes">
			<Unit/>
			<true/>
			<false/>
			<hLoc/>
		      </collection>
		    </eq>
		  </btypes:TYPE> are trivial.
		</p>
	      </li>
	      <li>
		<p>
		  Case
		  <btypes:TYPE>
		    <eq>
		      <aVal/>
		      <lambda>
			<id name="z"/>
			<aExpr dash="'"/>
		      </lambda>
		    </eq>
		  </btypes:TYPE>:
		</p>
		<ol>
		  <li>
		    <p>
		      Since the language
		      <btypes:TYPE>
			<language/>
		      </btypes:TYPE> does not support recursive bindings,
		      we can assume that
		      <btypes:TYPE>
			<eq>
			  <subst>
			    <aExpr dash="'"/>
			    <aVal/>
			    <id/>
			  </subst>
			  <aExpr dash="'"/>
			</eq>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      From cases&nbsp;(1.b.ii and 1.d.ii.A), we have
		      <btypes:TYPE>
			<TDjudge>
			  <lambda>
			    <id name="z"/>
			    <aExpr dash="'"/>
			  </lambda>
			  <type num="v"/>
			</TDjudge>
		      </btypes:TYPE>.
		      Now, using
		      <btypes:TYPE>
			<lem tag="T-inversion"/>
		      </btypes:TYPE>
		      (inversion of typing relationship), we conclude that 
		      <btypes:TYPE>
			<eq>
			  <type num="v"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</eq>
		      </btypes:TYPE> such that
		      <btypes:TYPE>
			<Sjudge>
			  <assume>
			    <extend>
			      <gamma/>
			      <tqExpr>
				<id name="z"/>
				<type num="a"/>
			      </tqExpr>
			    </extend>
			    <store/>
			  </assume>
			  <tqExpr>
			    <aExpr dash="'"/>
			    <type num="r"/>
			  </tqExpr>
			</Sjudge>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      From cases&nbsp;(1.b.iii and 1.d.ii.A), we have
		      <btypes:TYPE>
			<CST sp="true">
			  <TDjudge>
			    <lambda>
			      <id name="z"/>
			      <aExpr dash="'"/>
			    </lambda>
			    <type num="v"/>
			  </TDjudge>
			</CST>
		      </btypes:TYPE>.
		      Using
		      <btypes:TYPE>
			<defn tag="maybe-consistent"/>
		      </btypes:TYPE>,
		      it is evident that
		      <btypes:TYPE>
			<CST sp="yes">
			  <Sjudge>
			    <assume>
			      <extend>
				<gamma/>
				<tqExpr>
				  <id name="z"/>
				  <type num="a"/>
				</tqExpr>
			      </extend>
			      <store/>
			    </assume>
			    <tqExpr>
			      <aExpr dash="'"/>
			      <type num="r"/>
			    </tqExpr>
			  </Sjudge>
			</CST>
		      </btypes:TYPE>, since this is the previous step
		      of the derivation.
		    </p>
		  </li>
		  <li>
		    <p>
		      From cases&nbsp;(1.b.ii.B and 1.b.ii.C) and
		      <btypes:TYPE>
			<defn tag="consistent-typing"/>
		      </btypes:TYPE>, we obtain
		      <btypes:TYPE>
			<Sjudge name="*">
			  <assume>
			    <extend>
			      <gamma/>
			      <tqExpr>
				<id name="z"/>
				<type num="a"/>
			      </tqExpr>
			    </extend>
			    <store/>
			  </assume>
			  <tqExpr>
			    <aExpr dash="'"/>
			    <type num="r"/>
			  </tqExpr>
			</Sjudge>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      We know that 
		      <btypes:TYPE>
			<models name="cst">
			  <assume>
			    <aSubMap/>
			  </assume>
			  <type num="v"/>
			</models>
		      </btypes:TYPE>. That is,
		      <btypes:TYPE>
			<models name="cst">
			<assume>
			  <aSubMap/>
			</assume>
			<fn>
			  <type num="a"/>
			    <type num="r"/>
			  </fn>
			</models>
		      </btypes:TYPE>. 
		      Due to cases&nbsp;(1.c.i and 1.c.ii), we can
		      write this as:
		      <btypes:TYPE>
			<models name="cst">
			  <assume>
			    <aSubMap/>
			  </assume>
			  <set>
			    <gamma/>
			    <store/>
			    <fn>
			      <type num="a"/>
			      <type num="r"/>
			    </fn>
			  </set>
			</models>
		      </btypes:TYPE>. 
		      This can further be re-written as:
		      <btypes:TYPE>
			<models name="cst">
			  <assume>
			    <aSubMap/>
			  </assume>
			  <set>
			    <paren>
			      <extend>
				<gamma/>
				<tqExpr>
				  <id name="z"/>
				  <type num="a"/>
				</tqExpr>
			      </extend>
			    </paren>
			    <store/>
			    <type num="r"/>
			  </set>
			</models>
		      </btypes:TYPE>. 
		    </p>
		  </li>
		  <li>
		    <p>
		      Using cases&nbsp;(1.d.ii.C and 1.d.ii.E) and
		      <btypes:TYPE>
			<lem tag="Consistency-Propagation-1"/>
		      </btypes:TYPE>, we obtain
		      <btypes:TYPE>
			<models name="cst">
			  <assume>
			    <aSubMap/>
			  </assume>
			  <spset>
			    <Sjudge>
			      <assume>
				<extend>
				  <gamma/>
				  <tqExpr>
				    <id name="z"/>
				    <type num="a"/>
				  </tqExpr>
				</extend>
				<store/>
			      </assume>
			      <tqExpr>
				<aExpr dash="'"/>
				<type num="r"/>
			      </tqExpr>
			    </Sjudge>
			  </spset>
			</models>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      From case&nbsp;(1.b.ii) and 
		      <btypes:TYPE>
			<lem tag="Cst-Weakening"/>
		      </btypes:TYPE> (weakening), we obtain
		      <btypes:TYPE>
			<CST>
			  <gamma/>
			  <store/>
			  <Subst>
			    <aSubMap/>
			    <type num="v"/>
			  </Subst>
			</CST>
		      </btypes:TYPE>. Using cases&nbsp;(1.c.i, 1.c.ii,
		      and 1.d.ii.B), this can be written as
		      <btypes:TYPE>
			<CST>
			  <Subst>
			    <aSubMap/>
			    <gamma/>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <store/>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <fn>
			      <type num="a"/>
			      <type num="r"/>
			    </fn>
			  </Subst>
			</CST>
		      </btypes:TYPE>, which can be re-arranged as
		      <btypes:TYPE>
			<CST>
			  <Subst>
			    <aSubMap/>
			    <extend>
			      <gamma/>
			      <tqExpr>
				<id name="z"/>
				<type num="a"/>
			      </tqExpr>
			    </extend>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <store/>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <type num="r"/>
			  </Subst>
			</CST>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      Using cases&nbsp;(1.d.ii.D, 1.d.ii.F, 1.d.ii.G, and 1.c.iii) and
		      <btypes:TYPE>
			<lem tag="T-TSubstitution"/>
		      </btypes:TYPE> (Type Substitution), we obtain
		      <btypes:TYPE>
			<Sjudge name="*">
			  <assume>
			    <Subst>
			      <aSubMap/>
			      <extend>
				<gamma/>
				<tqExpr>
				  <id name="z"/>
				  <type num="a"/>
				</tqExpr>
			      </extend>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr dash="'"/>
			    <Subst>
			      <aSubMap/>
			      <type num="r"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </btypes:TYPE>.
		      That is:
		      <btypes:TYPE>
			<Sjudge name="*">
			  <assume>
			    <extend>
			      <Subst>
				<aSubMap/>
				<gamma/>
			      </Subst>
			      <tqExpr>
				<id name="z"/>
				<Subst>
				  <aSubMap/>
				  <type num="a"/>
				</Subst>
			      </tqExpr>
			    </extend>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr dash="'"/>
			    <Subst>
			      <aSubMap/>
			      <type num="r"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      Using cases&nbsp;(1.c.i and 1.c.ii), we can
		      re-write case&nbsp;(1.d.ii.H) as:
		      <btypes:TYPE>
			<Sjudge name="*">
			  <assume>
			    <extend>
			      <gamma/>
			      <tqExpr>
				<id name="z"/>
				<Subst>
				  <aSubMap/>
				  <type num="a"/>
				</Subst>
			      </tqExpr>
			    </extend>
			    <store/>
			  </assume>
			  <tqExpr>
			    <aExpr dash="'"/>
			    <Subst>
			      <aSubMap/>
			      <type num="r"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </btypes:TYPE>.
		    </p>
		  </li>
		  <li>
		    <p>
		      Now, from case&nbsp;(1.d.ii.I) and T-Lambda rule, we obtain
		      <btypes:TYPE>
			<TDjudge>
			  <lambda>
			    <id name="z"/>
			    <aExpr dash="'"/>
			  </lambda>
			  <fn>
			    <Subst>
			      <aSubMap/>
			      <type num="a"/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <type num="r"/>
			    </Subst>
			  </fn>
			</TDjudge>
		      </btypes:TYPE>.
		      Since
		      <btypes:TYPE>
			<eq>
			  <fn>
			    <Subst>
			      <aSubMap/>
			      <type num="a"/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <type num="r"/>
			    </Subst>
			  </fn>
			  <Subst>
			    <aSubMap/>
			    <fn>
			      <type num="a"/>
			      <type num="r"/>
			    </fn>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <type num="v"/>
			  </Subst>
			</eq>
		      </btypes:TYPE>, we obtain
		      <btypes:TYPE>
			<TDjudge>
			  <lambda>
			    <id name="z"/>
			    <aExpr dash="'"/>
			  </lambda>
			  <Subst>
			    <aSubMap/>
			    <type num="v"/>
			  </Subst>
			</TDjudge>
		      </btypes:TYPE>.
		      Using
		      <btypes:TYPE>
			<defn tag="consistent-typing"/>
		      </btypes:TYPE> (lambda derivation clause
		      introduces no new types into the set),
		      we conclude that
		      <btypes:TYPE>
			<CST>
			  <TDjudge>
			    <lambda>
			      <id name="z"/>
			      <aExpr dash="'"/>
			    </lambda>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </TDjudge>
			</CST>
		      </btypes:TYPE>, and therefore,
		      <btypes:TYPE>
			<TDjudge name="*">
			  <lambda>
			    <id name="z"/>
			    <aExpr dash="'"/>
			  </lambda>
			  <Subst>
			    <aSubMap/>
			    <type num="v"/>
			  </Subst>
			</TDjudge>
		      </btypes:TYPE>
		    </p>
		  </li>
		</ol>
	      </li>
	      <li>
		<p>
		  Case
		  <btypes:TYPE>
		    <eq>
		      <aVal/>
		      <Pair>
			<aVal num="1"/>
			<aVal num="2"/>
		      </Pair>
		    </eq>
		  </btypes:TYPE>:
		  Follows from induction hypothesis, and T-Pair rule.
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lambda>
		<id name="y"/>
		<aExpr dash="'"/>
	      </lambda>
	    </eq>
	    <text content=", and "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </eq>
	    
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <aTS/>
		  </tqExpr>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
	<p>
	  We can assume that
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	  Since it is clear that the type
	  <btypes:TYPE>
	    <type num="1"/>
	  </btypes:TYPE>
	  of
	  <btypes:TYPE>
	    <id name="y"/>
	  </btypes:TYPE>
	  can either use variables already in
	  <btypes:TYPE>
	    <gamma/>
	  </btypes:TYPE>
	  or fresh type variables, we know that
	  <btypes:TYPE>
	    <eq>
	      <inter>
		<ftvs>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <type num="1"/>
		    </tqExpr>
		  </extend>
		</ftvs>
		<ftvs>
		  <aTS/>
		</ftvs>
	      </inter>
	      <Empty/>
	    </eq>
	  </btypes:TYPE>.
	  Thus, by weakening lemma, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  , and, by induction hypothesis,
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr dash="'"/>
		  <id/>
		  <aVal/>
		</subst>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	  Finally, by the T-Lambda rule, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<lambda>
		  <id name="y"/>
		  <paren>
		    <subst>
		      <aExpr dash="'"/>
		      <id/>
		      <aVal/>
		    </subst>
		  </paren>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and thus,
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <lambda>
		    <id name="y"/>
		    <aExpr dash="'"/>
		  </lambda>
		  <id/>
		  <aVal/>
		</subst>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, which is the desired result.
	</p>
      </li>
      <li>
	<p>
	  T-Set case is similar, except that the substitution
	  cannot happen on the LHS of an assignment, since we do
	  not perform substitution of mutable values.
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-LSubstitution">
    <title>Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type num="x"/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <gamma/>
	    <extend>
	      <store/>
	      <mapping>
		<sLoc/>
		<type num="x"/>
	      </mapping>
	    </extend>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, similar to lemma <xref
	ref="T-VSubstitution"/>.
    </p>
  </proof>
<!--   <lemma id="T-sh-safety"> -->
<!--     <title>Stack and Heap Assignment</title> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<hLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="Similarly, if "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and  "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       Immediate from the definition of stack and heap typing. -->
<!--     </p> -->
  <!--   </proof> -->
  <lemma id="T-preservation">
    <title>Preservation</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<TDjudge name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> then,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <Msub>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>, and 
	  <!-- This cannot be replaced directly with an Msub at the
	  derivation as the type `t' is obtained from a previous
	  derivation, and can be a mutable one -->
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>. We proceed by the case analysis of the final
      step.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot
	  happen.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE>.
	</p>
	<btypes:TYPE>
	  <Hrules rowsep="4pt" colsep="1">
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <store/>
		  <sLoc/>
		  <type/>
		</mapsto>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <sLoc/>
		  <type/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<levalOp/> 
	      </btypes:TYPE> None Applicable.
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-Rval:
	    </p>
	    <btypes:TYPE>
	      <Hrules rowsep="4pt" colsep="1">
		<opRule>
		  <opPre>
		    <mapsto>
		      <stack/>            
		      <sLoc/>
		      <aVal/>
		    </mapsto>
		  </opPre>
		  <opConc>
		    <eval>
		      <opState>
			<stack/>
			<heap/>
			<sLoc/>
		      </opState>
		      <opState>
			<stack/>
			<heap/>
			<aVal/>
		      </opState>
		    </eval>
		  </opConc>
		</opRule>
	      </Hrules>
	    </btypes:TYPE>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aExpr dash="'"/>
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <aVal/>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <heap dash="'"/>
		      <heap/>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>
		    <eq>
		      <stack dash="'"/>
		      <stack/>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From 
		  <btypes:TYPE>
		    <TDjudge name="*">
		      <plus>
			<heap/>
			<stack/>
		      </plus>
		    </TDjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <defn tag="stack-heap-typing"/>
		  </btypes:TYPE> (Stack and Heap Typing), we have
		  <btypes:TYPE>
		    <TDjudge Msub="yes" name="*">
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <type/>
		    </TDjudge>
		  </btypes:TYPE>. 
		  That is,
		  <btypes:TYPE>
		    <TDjudge Msub="yes" name="*">
		      <aVal/>
		      <type/>
		    </TDjudge>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-App: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <apply> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </apply> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="2"/> -->
<!-- 		<type num="0"/> -->
<!-- 	      </fn> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	    <text content = " where "/> -->
<!-- 	    <eq> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <minz> -->
<!-- 		<type num="2" dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq>                 -->
<!-- 	    <eq> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <maxz> -->
<!-- 		<type num="0" dash="'"/> -->
<!-- 	      </maxz> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p>               -->
<!-- 	  This cannot happen for left execution.  -->
<!-- 	  For right execution, we proceed by further case -->
<!-- 	  analysis of the applicable execution rules for -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App1#: -->
<!-- 	      We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <apply> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		  </apply> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      By induction hypothesis, we have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="2"/> -->
<!-- 		      <type num="0"/> -->
<!-- 		    </fn>      -->
<!-- 		  </Msub>                  -->
<!-- 		</Sjudge>                     -->
<!-- 		<text content=" for some "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      One of the assumptions of the T-App rule states that  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<TDjudge Msub="yes"> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</TDjudge> -->
<!-- 	      </btypes:TYPE>, and by weakening lemma, we have,  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </Msub> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. Finally, by the T-App rule, we -->
<!-- 	      conclude that -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<tqExpr> -->
<!-- 		  <paren> -->
<!-- 		    <apply> -->
<!-- 		      <aExpr num="1" dash="'"/>                         -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </apply> -->
<!-- 		  </paren> -->
<!-- 		  <type/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App2#: Similar to the previous -->
<!-- 	      sub-case.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App: We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <lambda> -->
<!-- 		    <id/> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		  </lambda> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <subst> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <id/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </subst> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <extend> -->
<!-- 		      <stack/> -->
<!-- 		      <mapping> -->
<!-- 			<sLoc/> -->
<!-- 			<aVal/> -->
<!-- 		      </mapping> -->
<!-- 		    </extend> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      By the inversion lemma for  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lambda> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="0"/> -->
<!-- 		</lambda> -->
<!-- 	      </btypes:TYPE> we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <extend> -->
<!-- 		      <gamma> -->
<!-- 			<id/> -->
<!-- 			<type num="2" dash="'"/> -->
<!-- 		      </gamma> -->
<!-- 		      <store/> -->
<!-- 		    </extend> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Further from location substitution lemma, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <subst> -->
<!-- 		      <aExpr num="0"/> -->
<!-- 		      <id/> -->
<!-- 		      <sLoc/> -->
<!-- 		    </subst> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 		<text content=" where "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<tqExpr> -->
<!-- 		  <mapsto> -->
<!-- 		    <store/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </mapsto> -->
<!-- 		  <type num="2" dash="'"/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Thus, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type num="0" dash="'"/> -->
<!-- 		</Msub> -->
<!-- 		<text content=" and "/> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Therefore, it is clear that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>.                   -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Set: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <assign> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </assign> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <mutable> -->
<!-- 		<type/> -->
<!-- 	      </mutable> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <Sjudge name="lval"> -->
<!-- 	      <assume/>                   -->
<!-- 	      <aExpr num="1"/>                   -->
<!-- 	    </Sjudge>                 -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  If the step taken is E-:=#lhs or E-:=#rhs, -->
<!-- 	  the result follows from the induction hypothesis and -->
<!-- 	  T-Set rule (as in the case of T-App).                -->
<!-- 	  If the step taken is E-:=Stack or E-:=Heap, the -->
<!-- 	  result follows from the stack and heap assignment lemma. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Deref: We have:  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <deref> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </deref> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <ref> -->
<!-- 		<type/> -->
<!-- 	      </ref>                   -->
<!-- 	    </TDjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  If the step taken is EL-^# or E-^#, -->
<!-- 	  the result follows from induction hypothesis and T-Deref -->
<!-- 	  rule.  -->
<!-- 	  If the step taken is E-^ (right execution only)  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <aExpr dash="'"/>                   -->
<!-- 	  </btypes:TYPE> is a value, and from canonical forms -->
<!-- 	  lemma, we know that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <hLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <in> -->
<!-- 	      <hLoc/> -->
<!-- 	      <dom> -->
<!-- 		<store/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  and the result follows from the fact that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-P: Right execution only. We have: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <paren> -->
<!-- 		<let kind="p"> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		</let> -->
<!-- 	      </paren> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/>                 -->
<!-- 	      <type num="1"/>                 -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge name="gen"> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 		<aExpr num="1"/> -->
<!-- 	      </assume>                 -->
<!-- 	      <GEN> -->
<!-- 		<type/> -->
<!-- 		<aTS/> -->
<!-- 	      </GEN> -->
<!-- 	    </Sjudge>       -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<extend> -->
<!-- 		  <gamma/> -->
<!-- 		  <mapping> -->
<!-- 		    <id/>                       -->
<!-- 		    <aTS/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<store/> -->
<!-- 	      </assume>                 -->
<!-- 	      <tqExpr> -->
<!-- 		<aExpr num="2"/> -->
<!-- 		<type num="2"/> -->
<!-- 	      </tqExpr>                 -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  There are two sub-cases to consider: -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take step E-Let#,                    -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      and  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aExpr num="1" dash="'"/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 		<text content=". If "/>                     -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      It is clear that  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE> implies -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1" dash="'"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>.                      -->
<!-- 	      Now, the result follows -->
<!-- 	      from the induction hypothesis and the E-Let-P rule. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take the step E-Let-P,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aVal/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      Since  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<tqExpr> -->
<!-- 		  <id/> -->
<!-- 		  <aTS/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      has a polymorphic type,  -->
<!-- 	      (that is, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aTS/> -->
<!-- 		  <forall> -->
<!-- 		    <tvars name="alpha"/> -->
<!-- 		    <type name="s"/> -->
<!-- 		  </forall> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>) -->
<!-- 	      we know that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Immut"> -->
<!-- 		  <type/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Also, from canonical forms lemma, all values have -->
<!-- 	      an immutable type. Therefore,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <type/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. Now, the result follows from -->
<!-- 	      value substitution lemma.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol>             -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-M: Similar to T-Let-P, except that we should -->
<!-- 	  always use the GEN-EXPANSIVE rule during generalization, -->
<!-- 	  and use the location substitution lemma instead of  -->
<!-- 	  the value substitution lemma -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Cases T-If, T-Dup are similar.   -->
<!-- 	</p> -->
<!--       </li> -->
    </ol>
  </proof>
<!--   <definition id="stuck_state"> -->
<!--     <title>Stuck State</title> -->
<!--     <p> -->
<!--       A system state  -->
<!--       <btypes:TYPE> -->
<!-- 	<opState> -->
<!-- 	  <stack/> -->
<!-- 	  <heap/> -->
<!-- 	  <aExpr/> -->
<!-- 	</opState> -->
<!--       </btypes:TYPE> -->
<!--       is said to be <term>stuck</term> if -->
<!--       <btypes:TYPE> -->
<!-- 	<neq> -->
<!-- 	  <aExpr/> -->
<!-- 	  <aVal/> -->
<!-- 	</neq> -->
<!--       </btypes:TYPE> -->
<!--       and there are no  -->
<!--       <btypes:TYPE> -->
<!-- 	<stack dash="'"/> -->
<!-- 	<text content=", "/> -->
<!-- 	<heap dash="'"/> -->
<!-- 	<text content=", and "/> -->
<!-- 	<aExpr dash="'"/> -->
<!--       </btypes:TYPE>    -->
<!--       such that  -->
<!--       <btypes:TYPE> -->
<!-- 	<eval> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </definition>       -->
<!--   <theorem id="T-soundness"> -->
<!--     <title>Type Soundness</title> -->
<!--     <p> -->
<!--       If  -->
<!--       <btypes:TYPE> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <Empty/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <tqExpr> -->
<!-- 	    <aExpr/> -->
<!-- 	    <type/> -->
<!-- 	  </tqExpr> -->
<!-- 	</Sjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=" and "/> -->
<!-- 	<eval many="yes"> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!-- 	<text content=" then "/> -->
<!-- 	<opState> -->
<!-- 	  <stack dash="'"/> -->
<!-- 	  <heap dash="'"/> -->
<!-- 	  <aExpr dash="'"/> -->
<!-- 	</opState> -->
<!-- 	<text content=" is not stuck."/>             -->
<!--       </btypes:TYPE> -->
<!--       That is, execution of a well typed expression cannot lead to -->
<!--       a stuck state. Here,  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE > represents the  -->
<!--       reflexive-transitive-closure of  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
<!--   <proof> -->
<!--     <p> -->
<!--       By straightforward induction on the length of    -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE>. If  -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <aExpr/> -->
<!-- 	  <aVal/> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE>, proof is immediate. Otherwise, from  -->
<!--       Lemma&nbsp;<xref ref="T-progress"/> (Progress), -->
<!--       we know that we can take at least one step forward. Further, -->
<!--       from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation), -->
<!--       we know that a (left/right) execution of a well -->
<!--       typed expression in with respect to a well typed stack and heap -->
<!--       will always result in another well typed expression, stack -->
<!--       and heap. Proof now follows from induction hypothesis.   -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="C-progress"> -->
<!--     <title>Progress</title> -->
<!--     <p> -->
<!--       <btypes:TYPE> -->
<!-- 	<text content="If "/> -->
<!-- 	<aExpr/> -->
<!-- 	<text content=" is a closed, well typed term, "/>  -->
<!-- 	<text content="that is, "/>  -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <Empty/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=" for some "/>  -->
<!-- 	<type/>  -->
<!-- 	<text content=", "/>  -->
<!-- 	<aCtset/> -->
<!-- 	<text content=", "/>  -->
<!-- 	<store/> -->
<!-- 	<text content=", and if "/>  -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!-- 	<text content=", then, given any heap "/>  -->
<!-- 	<heap/> -->
<!-- 	<text content=" and stack "/>  -->
<!-- 	<stack/> -->
<!-- 	<text content=" such that "/>  -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=", "/>             -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content=" If "/>                 -->
<!-- 	    <Sjudge name="lval"> -->
<!-- 	      <assume/> -->
<!-- 	      <aExpr/> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=", then "/>               -->
<!-- 	    <aExpr/> -->
<!-- 	    <text content=" is either a valid lvalue "/>  -->
<!-- 	    <lVal/> -->
<!-- 	    <text content=" (that is, "/> -->
<!-- 	    <eq> -->
<!-- 	      <lVal/> -->
<!-- 	      <sLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", "/> -->
<!-- 	    <in> -->
<!-- 	      <sLoc/> -->
<!-- 	      <dom> -->
<!-- 		<stack/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	    <text content=" or "/>  -->
<!-- 	    <eq> -->
<!-- 	      <lVal/> -->
<!-- 	      <deref> -->
<!-- 		<hLoc/> -->
<!-- 	      </deref> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", "/> -->
<!-- 	    <in> -->
<!-- 	      <hLoc/> -->
<!-- 	      <dom> -->
<!-- 		<heap/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	    <text content=") or else "/> -->
<!-- 	    <Exists> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <stack dash="'"/> -->
<!-- 	      <heap dash="'"/> -->
<!-- 	    </Exists> -->
<!-- 	    <text content=" such that:"/>                -->
<!-- 	    <leval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </leval> -->
<!-- 	    <text content="."/>    -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p>               -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <aExpr/> -->
<!-- 	    <text content=" is a value "/>  -->
<!-- 	    <aVal/> -->
<!-- 	    <text content=" or else "/>  -->
<!-- 	    <Exists> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <stack dash="'"/> -->
<!-- 	      <heap dash="'"/> -->
<!-- 	    </Exists> -->
<!-- 	    <text content=" such that "/>                -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <lemma id="C-preservation"> -->
<!--     <title>Preservation</title> -->
<!--     <p> -->
<!--       <btypes:TYPE>           -->
<!-- 	<text content="If "/> -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=", "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!-- 	<text content=", and "/> -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=", then, "/>     -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <leval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </leval> -->
<!-- 	    <text content=", then, there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq> -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Cjudge> -->
<!-- 	      <aCtset/> -->
<!-- 	      <gamma/> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </Cjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge num="*"> -->
<!-- 	      <assume> -->
<!-- 		<aCtset/> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE>               -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE>           -->
<!-- 	    <text content="If "/> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	    <text content=", there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq>                 -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Cjudge> -->
<!-- 	      <aCtset/> -->
<!-- 	      <gamma/> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </Cjudge> -->
<!-- 	    <text content=",  "/> -->
<!-- 	    <Sjudge num="*"> -->
<!-- 	      <assume> -->
<!-- 		<aCtset/> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <theorem id="C-soundness"> -->
<!--     <title>Type Soundness</title> -->
<!--     <p> -->
<!--       If  -->
<!--       <btypes:TYPE> -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <Empty/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=" and "/> -->
<!-- 	<eval many="yes"> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!-- 	<text content=" then "/> -->
<!-- 	<opState> -->
<!-- 	  <stack dash="'"/> -->
<!-- 	  <heap dash="'"/> -->
<!-- 	  <aExpr dash="'"/> -->
<!-- 	</opState> -->
<!-- 	<text content=" is not stuck."/>             -->
<!--       </btypes:TYPE> -->
<!--       That is, execution of a well typed expression cannot lead to -->
<!--       a stuck state. Here,  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE > represents the  -->
<!--       reflexive-transitive-closure of  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
  </sect1>
<!--   <lemma id="cann-derivation"> -->
<!--     <title>Canonical Type Derivation</title> -->
<!--     <p> -->
<!--       If -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!--       </btypes:TYPE> -->
<!--       and -->
<!--       <btypes:TYPE> -->
<!-- 	<CST> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <type/> -->
<!-- 	</CST> -->
<!--       </btypes:TYPE>, then -->
<!--       <btypes:TYPE> -->
<!-- 	<Exists> -->
<!-- 	  <approx> -->
<!-- 	    <type dash="'"/> -->
<!-- 	    <type/> -->
<!-- 	  </approx> -->
<!-- 	</Exists> -->
<!--       </btypes:TYPE> such that -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!--       </btypes:TYPE> -->

<!--       <btypes:TYPE> -->
<!-- 	<CST> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <type/> -->
<!-- 	</CST> -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--   </lemma> -->
<!--   <lemma id="T-Subtype-properties"> -->
<!--     <title>Properties of Copy Coercion</title> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type/> -->
<!-- 		  <minz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <maxz> -->
<!-- 		    <type/> -->
<!-- 		  </maxz> -->
<!-- 		  <type dash="'"/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <type/> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!--  	      <type num="2"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Exists> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!--  	      <type num="2"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Exists> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       Property 1: By straightforward induction on the copy-coercion -->
<!--       derivation, and using -->
<!--       <btypes:TYPE> -->
<!-- 	<defn tag="maybe-consistent"/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <p> -->
<!--       Property 2: By construction of  -->
<!--       <btypes:TYPE> -->
<!-- 	<type num="3"/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From 	   -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <lem tag="Cst-Weakening"/> -->
<!-- 	  </btypes:TYPE> (weakening), we have  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>.  -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From the above case, and property 1.d above, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Similarly, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From cases&nbsp;(2 and 3), we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Let us pick -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <type num="3"/> -->
<!-- 	  </btypes:TYPE> such that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  It is evident that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From S-Refl rule in  -->
<!-- 	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. From this, and the fact that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, using property 1.a, we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  From case&nbsp;(5), we can write this as -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Similarly, we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--     <p> -->
<!--       Property 3: Similar to Property 2. -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="cann-derivation-subst"> -->
<!--     <title>Canonical Derivation under Substitution</title> -->
<!--     <p> -->
<!--       If -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <set> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	    <type/> -->
<!-- 	  </set> -->
<!-- 	</models> -->
<!-- 	<text content=", then "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <DBrac> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	  </DBrac> -->
<!--  	</models> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--     </p> -->
<!--   </proof> -->
