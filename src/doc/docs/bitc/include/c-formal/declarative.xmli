<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="declarative_types"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Declarative Type System</title>
  <definition id="canonical-expressions">
    <title>Canonical Expressions</title>
    <p>
      We say that an expression 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> is canonical if
      all <progident>let</progident> expressions in
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> are annotated with one of the 
      kinds
      <btypes:TYPE>
	<lKind k="mono"/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<lKind k="poly"/>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="weakened-type-derivation">
    <title>Weakened Type Derivation</title>
    <p>
      We write 
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> 
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	  <dCtset dash="'"/>
	</TDjudge>
      </btypes:TYPE> for some
      <btypes:TYPE>
	<subeq>
	  <dCtset dash="'"/>
	  <dCtset/>
	</subeq>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="constraint-colection-ext-typ">
    <title>Constraint Collection over Type Derivation</title>
    <p>
      We write
      <btypes:TYPE>
	<spset>
	  <TDjudge D="yes">
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</spset>
      </btypes:TYPE> to denote the set of all constrained types and
      unconstrained type variables used in the derivation of 
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<id/>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<Unit/>
		<unit/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<true/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<false/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<hLoc/>
		<ref>
		  <type/>
		</ref>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<sLoc/>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	      <dCtset/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<lambda>
		  <id/>
		  <aExpr/>
		</lambda>
		<fn>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</fn>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <Sjudge>
		<assume>
		  <dCtset/>
		  <extend>
		    <gamma/>
		    <mapping>
		      <id/>
		      <type num="1"/>
		    </mapping>
		  </extend>
		  <store/>
		</assume>
		<tqExpr>
		  <aExpr/>
		  <type num="2"/>
		</tqExpr>
	      </Sjudge>
	    </spset>
	  </rhs>
	</equation>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge D="yes">
		<apply>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</apply>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <TDjudge D="yes">
		<aExpr num="1"/>
		<type num="1"/>
	      </TDjudge>
	    </spset>
	  </rhs>
	</equation>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<TDjudge D="yes">
		  <aExpr num="2"/>
		  <type num="2"/>
		</TDjudge>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<type num="a"/>
		<type num="r"/>
		<type/>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
      </VEqns>
    </btypes:TYPE>
    <p>
      Other cases are similar. We write:
      <br/>
      <btypes:TYPE>
	<eq>
	  <spset>
	    <TDjudge name="s" D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	  <spset>
	    <TDjudge name="s">
	      <aExpr/>
	      <type/>
	      <dCtset dash="'"/>
	    </TDjudge>
	    <dCtset/>
	  </spset>
	</eq>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="consistent-typing">
    <title>Consistent Type Derivation</title>
    <p>
      We say that
      <btypes:TYPE>
	<TDjudge D="yes" cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, is a consistent type derivation under the
      constraint set 
      <btypes:TYPE>
	<bCtset/>
      </btypes:TYPE>
      if
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Sat>
	  <bCtset/>
	  <spset>
	    <TDjudge D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</Sat>
      </btypes:TYPE>.
    </p>
    <p>
      Similarly, we write
      <btypes:TYPE>
	<TDjudge name="s" D="yes" cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>
      if
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Sat>
	  <bCtset/>
	  <spset>
	    <TDjudge name="s" D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</Sat>
      </btypes:TYPE>.
    </p>
    <p>
      We say that
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, is a consistent type derivation if
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge name="s" D="yes">
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="stack-heap-typing">
    <title>Stack and Heap Typing</title>
    <p>
      A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
      <btypes:TYPE><stack/></btypes:TYPE> are said to be <em>well
	typed</em> with respect to a binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and store typing
      <btypes:TYPE><store/></btypes:TYPE>, and written
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="s" D="yes">
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge> 
	    <text content=" such that "/>
	    <eq under="minz">
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge name="s" D="yes">
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <eq under="minz">
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Similarly, we define
      <btypes:TYPE>
	<TDjudge name="s" D="yes" cst="yes">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE>
    </p>
  </definition>
  <definition id="valid-lval">
    <title>Valid Lvalues</title>
    <p>
      We say that an lvalue
      <btypes:TYPE>
	<lVal/>
      </btypes:TYPE> is valid with respect to a stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE> and heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, written
      <btypes:TYPE>
	<Sjudge name="v">
	  <assume>
	    <plus>
	      <heap/>
	      <stack/>
	    </plus>
	  </assume>
	  <lVal/>
	</Sjudge>
      </btypes:TYPE> if one of the following conditions hold for some
      <btypes:TYPE>
	<path/>
      </btypes:TYPE>:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </definition>
  <lemma id="T-inversion">
    <title>Inversion of Typing Relation</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <Unit/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <true/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <false/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <hLoc/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <lambda>
		<id/>
		<aExpr/>
	      </lambda>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </fn>
	    </eq>
	    <text content=", such that "/>
	    <Sjudge>
	      <assume>
		<dCtset/>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>
		    <type num="1"/>
		  </mapping>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	    <text content=" and "/>
	    <eq under="minz">
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </eq>
	    <text content=" and "/>
	    <eq under="minz">
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes">
	      <deref>
		<aExpr/>
	      </deref>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aExpr/>
	      <ref>
		<type/>
	      </ref>
	    </TDjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of typing relation.
    </p>
  </proof>
  <lemma id="T-sub-inversion">
    <title>Inversion of Copy Coercion</title>
    <p>
      For any type
      <btypes:TYPE>
	<ptype/>
	<text content=" and "/>
	<tvar/>
      </btypes:TYPE>, let
      <btypes:TYPE>
	<eq>
	  <pred name="Q">
	    <ptype/>
	  </pred>
	  <set>
	    <ptype/>
	    <mutable>
	      <ptype/>
	    </mutable>
	    <mbTop>
	      <tvar/>
	      <ptype/>
	    </mbTop>
	    <mbTop>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbTop>
	    <mbFull>
	      <tvar/>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	  </set>
	</eq>
      </btypes:TYPE>. Then,
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <bool/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<bool/>
	      </pred>
	    </in>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <unit/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<unit/>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<ref>
		  <type dash="'"/>
		</ref>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </pred>
	    </in>
	    <text content=", such that "/>
	    <Msub>
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </Msub>
	    <text content=" and "/>	    
	    <Msub>
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </Msub>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <mutable>
		<ptype dash="'"/>
	      </mutable>
	    </eq>	      
	    <text content=", such that "/>
	    <Msub>
 	      <ptype dash="'"/>
	      <ptype/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the copy coercion derivation.
    </p>
  </proof>
  <lemma id="T-canonical">
    <title>Canonical Forms</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aVal/>
	      <unit/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Unit/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aVal/>
	      <bool/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is either "/>
	    <true/>
	    <text content=" or "/>
	    <false/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aVal/>
	      <ref>
		<type/>
	      </ref>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <hLoc/>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aVal/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <lambda>
	      <id/>
	      <aExpr/>
	    </lambda>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge name="s" D="yes" Msub="yes">
	      <aVal/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Pair>
	      <aVal num="1"/>
	      <aVal num="2"/>
	    </Pair>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By inspecting the possibilities for the derivation of
      <btypes:TYPE>
	<TDjudge name="s" D="yes" Msub="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <p>
      According to the grammar of the language 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, values can be of one of the following forms:
      <btypes:TYPE>
	<collection>
	  <Unit/>
	  <true/> 
	  <false/>
	  <hLoc/>
	  <lambda>
	    <id/>
	    <aExpr/>
	  </lambda>
	  <Pair>
	    <aVal/>
	    <aVal/>
	  </Pair>
	</collection>
      </btypes:TYPE>
    </p>
    <p>
      Consider the case (2), where
      <btypes:TYPE>
	<TDjudge name="s" D="yes" Msub="yes">
	  <aVal/>
	  <bool/>
	</TDjudge>
      </btypes:TYPE>. That is,
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
	<text content=" and "/>
	<Msub>
	  <type/>
	  <bool/>
	</Msub>
      </btypes:TYPE>.
      From 
      <btypes:TYPE>
	<lem tag="T-sub-inversion"/>
      </btypes:TYPE> (inversion of copy-coercion), we know that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <pred name="Q">
	    <bool/>
	  </pred>
	</in>
      </btypes:TYPE>. 
      <btypes:TYPE>
	<text content=" That is, for some "/>
	<tvar/>
	<text content=", the type "/>
	<type/>
	<text content=" equals one of: "/>
	<collection or="yes">
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	  <mbTop>
	    <tvar/>
	    <bool/>
	  </mbTop>
	  <mbTop>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbTop>
	  <mbFull>
	    <tvar/>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	</collection>
      </btypes:TYPE>.
      If
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <bool/>
	</eq>
      </btypes:TYPE>, it is clear that the final rule in the
      derivation must be T-Bool. A derivation with these
      rules is only possible if 
      <btypes:TYPE>
 	<eq>
	  <aVal/>
	  <bVal/>
	</eq>
      </btypes:TYPE>. That is,
      <btypes:TYPE>
 	<eq>
	  <aVal/>
	  <true/>
	</eq>
	<text content=" or "/>
 	<eq>
	  <aVal/>
	  <false/>
	</eq>
      </btypes:TYPE>.
      Further, the cases like 
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE>
      cannot happen because there is no rule that
      derives a mutable/maybe type for a value.
    </p>
    <p>
      Other cases of the lemma are similar.
    </p>
  </proof>
  <theorem id="T-progress">
    <title>Progress</title>
    <p>
      If
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      is a closed well typed canonical expresssion,
      that is, 
      <btypes:TYPE>
	<Sjudge name="s">
	  <assume>
	    <dCtset/>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE> for some
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, given any heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE> and stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge name="s">
	  <assume>
	    <dCtset/>
	    <Empty/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
      </btypes:TYPE>,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE>
	  is either a valid lvalue (that is,
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lVal/>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	  </btypes:TYPE>) or else
	  <btypes:TYPE>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE> is a value
	  <btypes:TYPE>
	    <aVal/>
	  </btypes:TYPE> or else
	  <btypes:TYPE>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </theorem>
  <proof>
    <p>
      By induction on the type derivation.
      <btypes:TYPE>
	<Sjudge name="s">
	  <assume>
	    <dCtset/>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  Case T-Unit, T-Bool, T-Hloc, T-Lambda:
	  (Values) Result is immediate for right execution, and
	  cannot happen for left execution.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id: cannot happen. 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id/>
	    </eq>
	  </btypes:TYPE> is not a closed term.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Immediate for left execution. Right
	  execution and can always continue with E-Rval rule as the
	  stack is well typed
	  (<btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-App: Only right execution is possible, no application is well
	  typed as an lvalue. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	    <text content=", "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<type num="1"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE> is not a value, execution can continue via
	  the E-# (Right context redex) due to induction
	  hypothesis. Similarly, if  
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can again take E-#. 
	  Now, consider the case when both
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" and "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  are values. Since we know that
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<dCtset num="1"/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>, from 
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms) we conclude that 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is of the form
	  <btypes:TYPE>
	    <lambda>
	      <id/>
	      <aExpr dash="'"/>
	    </lambda>
	  </btypes:TYPE>. Now, we can take the step E-App.
	</p>
      </li>
      <li>
	<p>
	  Case T-If: Similar to T-App, only right execution is
	  permitted.
	</p>
      </li>
      <li>
	<p>
	  Case T-Set: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	    <text content=", "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<mutable>
		  <ptype/>
		</mutable>
	      </Msub>
	    </Sjudge>
	    <text content=", "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<ptype/>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  not an lvalue, since we have
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>
	  we can take E-L# by induction hypothesis.
	  Similarly, if
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-#.
	</p>
	<p>
	  Finally, we consider the case where
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <eq>
	      <aExpr num="2"/>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>.
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>	    
	  should be one of
	  <btypes:TYPE>
	    <collection or = "yes">
	      <sLoc/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	      <deref>
		<hLoc/>
	      </deref>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </collection>
	  </btypes:TYPE>.
	  Now, we proceed by induction on the length of
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <sLoc/>
		</eq>
	      </btypes:TYPE>. We know from induction hypothesis
	      that that 
	      <btypes:TYPE>
		<Sjudge name="v">
		  <assume>
		    <heap/>
		    <stack/>
		  </assume>
		  <sLoc/>
		</Sjudge>
	      </btypes:TYPE> and from 
	      <btypes:TYPE>
		<defn tag="valid-lval"/>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<in>
		  <sLoc/>
		  <dom>
		    <stack/>
		  </dom>
		</in>
	      </btypes:TYPE>. Now, execution can continue
	      with E-:=Stack.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <deref>
		    <hLoc/>
		  </deref>
		</eq>
	      </btypes:TYPE>, the execution can continue with step	    
	      E-:=Heap.
	    </p>
	  </li>
	  <li>
	    <p>
	      Assume (by hypothesis) that the execution can continue for 
	      some 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1" dash="'"/>
		  <select>
		    <sLoc/>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, let
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <sLoc/>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We know that 
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aExpr num="1"/>
		    <mutable>
		      <ptype/>
		    </mutable>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
		<text content=" and "/>
		<Msub>
		  <type num="1"/>
		  <mutable>
		    <ptype/>
		  </mutable>
		</Msub>
	      </btypes:TYPE>.
	      That is,
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <select>
		      <fst>
			<sLoc/>
		      </fst>
		      <path/>
		    </select>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. 
	      The first two steps of this derivation must be 
	      T-Sloc and T-Sel.
	      From the assumption of T-Sel rule, we must have
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <sLoc/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE> for some type
	      <btypes:TYPE>
		<type num="2"/>
	      </btypes:TYPE>.
	      Now, from the assumption of T-Sloc rule, we must have
	      <btypes:TYPE>
		<Msub>
		  <mapsto>
		    <store/>
		    <sLoc/>
		  </mapsto>
		  <pair>
		    <type num="1"/>
		    <type num="2"/>
		  </pair>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, if 
	      <btypes:TYPE>
		<mapsto>
		  <stack/>
		  <sLoc/>
		  <aVal/>
		</mapsto>
	      </btypes:TYPE>, 
	      since we have
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr >
		    <stack/>
		    <heap/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>, 
	      we conclude that 
	      <btypes:TYPE>
		<Sjudge name="s">
		  <assume>
		    <dCtset/>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aVal/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(f) and
	      <btypes:TYPE>
		<lem tag="T-sub-inversion"/>
	      </btypes:TYPE> (inversion of copy-coercion), we conclude
	      that 
	      <btypes:TYPE>
		<eq>
		  <aVal/>
		  <Pair>
		    <aVal num="1"/>
		    <aVal num="2"/>
		  </Pair>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(c and g), we conclude that the
	      execution can continue using the E-:=S.p rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <sLoc/>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      the execution can again continue using E-:=S.p rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similar to the above induction, we can show that if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <ith>
		      <deref>
			<hLoc/>
		      </deref>
		    </ith>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E-:=H.p rule.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Dup: Only right execution is
	  permitted, and can take E-# or E-Dup as
	  applicable.
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr num="1"/>
	      </deref>
	    </eq>
	    <text content=", and "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  Execution can take EL-^# or E-# as
	  applicable if
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is a value, then, from
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms), we conclude that 
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <hLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	  Now, since this is an lvalue, we are done in the case of
	  left execution. In the case of right execution, we can
	  take step E-^.
	</p>
      </li>
      <li>
	<p>
	  Case T-Pair: Similar to case T-Dup
	</p>
      </li>
      <li>
	<p>
	  Case T-Sel: Similar to case T-Deref.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="m">
		<id/>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </let>
	    </eq>
	    <text content=", "/>
	    <Sjudge name="s">
	      <assume>
		<dCtset/>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-#.
	  Otherwise, we can take E-Let-M.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-MP: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="x">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Sjudge name="s">
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-#.
	  Otherwise, the execution can take E-Let-P if
	  <btypes:TYPE>
	    <eq>
	      <lKind/>
	      <lKind k="poly"/>
	    </eq>
	  </btypes:TYPE> or E-Let-M if
	  <btypes:TYPE>
	    <eq>
	      <lKind/>
	      <lKind k="mono"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-Weakening">
    <title>Weakening</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>,
      then
      <btypes:TYPE>
	<Forall/>
	<supeq>
	  <gamma dash="'"/>
	  <gamma/>
	</supeq>
	<text content=" and "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=", "/>
	<Sjudge>
	  <assume>
	    <dCtset/>
	    <gamma dash="'"/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
    <p>
      If
      <btypes:TYPE>
	<TDjudge name="s" D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>,
      then
      <btypes:TYPE>
	<Forall/>
	<supeq>
	  <gamma dash="'"/>
	  <gamma/>
	</supeq>
	<text content=", "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=" and "/>
	<supeq>
	  <dCtset dash="'"/>
	  <dCtset/>
	</supeq>
	<text content=", "/>
	<Sjudge>
	  <assume>
	    <dCtset dash="'"/>
	    <gamma dash="'"/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-Subtype-properties">
    <title>Properties of Copy Coercion</title>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <type/>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</Msub>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <type/>
		  </maxz>
		  <type dash="'"/>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <type/>
		  </maxz>
		  <maxz>
		    <type dash="'"/>
		  </maxz>
		</eq>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type/>
		  </minz>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eq>
	      <maxz>
		<type/>
	      </maxz>
	      <maxz>
		<type dash="'"/>
	      </maxz>
	    </eq>
	  </btypes:TYPE>
	  or equivalently 
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Msub>
	      <maxz>
		<type/>
	      </maxz>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type/>
 	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
 	      <type num="2"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Property 1 and 2: By straightforward induction on the derivation of
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE>.
    </p>
    <p>
      Property 3: By construction of 
      <btypes:TYPE>
	<type num="3"/>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From property 1.b above, we have
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="1"/>
	    </eq>
	  </btypes:TYPE>.
	  Similarly, we have
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="2"/>
	    </eq>
	  </btypes:TYPE>.
	  Therefore,
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Let us pick
	  <btypes:TYPE>
	    <type num="3"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq>
	      <type num="3"/>
	      <eq under="minz">
		<type/>
		<type num="1"/>
		<type num="2"/>
	      </eq>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From S-Refl rule in 
	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>. From this using property 1.a, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <minz>
		<type num="1"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE>.
	  From case&nbsp;(2), we can write this as
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	  Similarly, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
    <p>
      Property 4: Similar to Property 3.
    </p>
  </proof>
  <lemma id="T-SSubstitution">
    <title>Subtype Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <set>
	    <type num="1"/>
	    <type num="2"/>
	  </set>
	</models>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Msub>
	  <Subst>
	    <aSubMap/>
	    <type num="1"/>
	  </Subst>
	  <minz>
	    <Subst>
	      <aSubMap/>
	      <type num="2"/>
	    </Subst>
	  </minz>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Msub>
	  <maxz>
	    <Subst>
	      <aSubMap/>
	      <type num="1"/>
	    </Subst>
	  </maxz>
	  <Subst>
	    <aSubMap/>
	    <type num="2"/>
	  </Subst>
	</Msub>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By using
      <btypes:TYPE>
	<lem tag="T-Subtype-properties"/>
      </btypes:TYPE> (properties 1 and 2)
      and
      <btypes:TYPE>
	<lem tag="T-sub-min"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-Renaming">
    <title>Type Renaming</title>
    <p>
      For any substitution
      <btypes:TYPE>
	<eq>
	  <aSubMap/>
	  <plural>
	    <SubMap>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </SubMap>
	  </plural>
	</eq>
      </btypes:TYPE> where
      <btypes:TYPE>
	<mutex>
	  <set>
	    <tvars name="beta"/>
	  </set>
	  <ftvs>
	    <gamma/>
	    <store/>
	    <type/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <TDjudge D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE> 
	  then
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <TDjudge D="yes" cst="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE> 
	  then
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <bCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <dCtset/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of 
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<TDjudge D="yes" cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="Consistency-Propagation">
    <title>Consistency of Substitution over Type Derivation</title>
    <p>
      If
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge D="yes">
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <set>
	    <gamma/>
	    <store/>
	    <type/>
	    <dCtset/>
	  </set>
	</models>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <spset>
	    <TDjudge D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</models>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. 
    </p>
    <ol>
      <li>
	<p>
	  At any step of the derivation, let
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> be a type used in the derivation such that 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <gamma/>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <store/>
	    </in>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <type/>
	    </in>
	  </btypes:TYPE> do not (necessarily) hold. For example, 
	  <btypes:TYPE>
	    <type num="1"/>
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <type num="2"/>
	  </btypes:TYPE> in T-Lambda, 
	  <btypes:TYPE>
	    <fn>
	      <type num="a"/>
	      <type num="r"/>
	    </fn>
	  </btypes:TYPE> in T-App, or the type obtained by any
	  sub-derivation (for some sub-expression).
	</p>
      </li>
      <li>
	<p>
	  Through a suitable renaming of variables, and using
	  <btypes:TYPE>
	    <lem tag="T-Renaming"/>
	  </btypes:TYPE>, we can ensure
	  <btypes:TYPE>
	    <subeq>
	      <inter>
		<dom>
		  <aSubMap/>
		</dom>
		<ftvs>
		  <type num="s"/>
		</ftvs>
	      </inter>
	      <ftvs>
		<gamma/>
		<store/>
		<type/>
	      </ftvs>
	    </subeq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  We want to show
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>.
	  Therefore, we proceed by induction on the structure of 
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE>. The only interesting cases are
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case 
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE>:
	</p>
	<ol>
	  <li>
	    <p>
	      By induction hypothesis, we have
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <ptype/>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<in>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</in>
	      </btypes:TYPE>:
	    </p>
	    <ol>
	      <li>
		<p>
		  Due to the premise 
		  <btypes:TYPE>
		    <CST sp="yes">
		      <TDjudge D="yes">
			<aExpr/>
			<type/>
		      </TDjudge>
		    </CST>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <defn tag="maybe-consistent"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <Exists/>
		    <in>
		      <mbTop>
			<tvar/>
			<ptype dash="'"/>
		      </mbTop>
		      <collection or="yes">
			<gamma/>
			<store/>
			<type/>
		      </collection>
		    </in>
		  </btypes:TYPE> such that
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype/>
		      <ptype dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From the premise
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
			<dCtset/>
		      </set>
		    </models>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <ptype dash="'"/>
		    </models>
		  </btypes:TYPE>.
		  From this, case&nbsp;(4.a) and
		  <btypes:TYPE>
		    <lem tag="Cst-additive"/>
		  </btypes:TYPE> (aggregation), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<ptype/>
			<ptype dash="'"/>
		      </set>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(4.b.i and 4.b.ii), and
		  <btypes:TYPE>
		    <lem tag="T-sub-min"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	      <li>
		<p>
		  From the premise
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
		      </set>
		    </models>
		  </btypes:TYPE>, case&nbsp;(4.b.i), and	  
		  <btypes:TYPE>
		    <defn tag="subst-consistent"/>
		  </btypes:TYPE>, we know that 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>, for some 
		  <btypes:TYPE>
		    <tvar name="beta"/>
		  </btypes:TYPE>, or
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <ptype dash="''"/>
		    </eq>
		  </btypes:TYPE>, such that 
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype dash="''"/>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. Using case&nbsp;(4.b.iii), we can
		  write this as
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <ptype dash="''"/>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</notin>
	      </btypes:TYPE>, then, we know that
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <dom>
		    <aSubMap/>
		  </dom>
		</notin>
	      </btypes:TYPE>, and therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar/>
		  </Subst>
		  <tvar/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
	<p>
	  Therefore, in all cases, for some
	  <btypes:TYPE>
	    <tvar name="beta"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <tvar name="beta"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minzT">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>:
	  Similar to the previous case, we conclude that
	  for some
	  <btypes:TYPE>
	    <stype dash="'"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <stype dash="'"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minz">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From cases&nbsp;(4 and 5), and 
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we conclude that
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>. 
	</p>
      </li>
      <li>
	<p>
	  By repeating the same argument over all types
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> used in the derivation of
	  <btypes:TYPE>
	    <TDjudge D="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>, we finally obtain
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <spset>
		<TDjudge D="yes">
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </spset>
	    </models>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="Composistion-Rearrange">
    <title>Composition Consistency</title>
    <p>
      If:
    </p>
    <p>
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="1"/>
	  <set>
	    <type/>
	  </set>
	</Cst>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="2"/>
	  <set>
	    <type/>
	  </set>
	</Cst>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="1"/>
	  <set>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </set>
	</Cst>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<mutex>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <ftvs>
	    <aSubMap num="1"/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>,
    </p>
    <p>
      Then, 
      <btypes:TYPE>
	<Exists/>
	<eq>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE> such that:
    </p>
    <p>
      <btypes:TYPE>
	<eq>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <dom>
	    <aSubMap num="2" dash="'"/>
	  </dom>
	</eq>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="2" dash="'"/>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="2" dash="'"/>
	  <set>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </set>
	</Cst>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By construction of
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE>.
      Let
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> be an idempotent substitution equivalent to 
      <btypes:TYPE>
	<compose>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</compose>
      </btypes:TYPE>.
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE> can be choosen as a part of 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> that contains substitutions only for
      <btypes:TYPE>
	<dom>
	  <aSubMap num="2"/>
	</dom>
      </btypes:TYPE>.
      <!-- NOTE: NOTE: Here, we will have
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <aSubMap num="2" dash="'"/>
	  </Subst>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE>,
      REMEMBER: This is for reference only. Substitution on 
      substitutions was removed. That must be re-introduced
      if this like is un-commented. -->
    </p>
  </proof>
  <lemma id="T-TSubstitution">
    <title>Type Substitution</title>
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <TDjudge D="yes" cst="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <models name="cst">
	      <assume>
		<aSubMap/>
	      </assume>
	      <spset>
		<TDjudge D="yes">
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </spset>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Sat>
	      <Subst>
		<aSubMap/>
		<bCtset/>
	      </Subst>
	      <Subst>
		<aSubMap/>
		<spset>
		  <TDjudge D="yes">
		    <aExpr/>
		    <type/>
		  </TDjudge>
		</spset>
	      </Subst>
	    </Sat>	      
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <Subst>
	      <aSubMap/>
	      <bCtset/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <dCtset/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <gamma/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <store/>
	    </Subst>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <Subst>
	      <aSubMap/>
	      <type/>
	    </Subst>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TDjudge D="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. We proceed by case analysis on the last step of
      the derivation.
      Let
      <btypes:TYPE>
	<eq>
	  <bCtset num="s"/>
	  <Subst>
	    <aSubMap/>
	    <bCtset/>
	  </Subst>
	</eq>
      </btypes:TYPE>.
      <em>
	Need to fix the proof for 
	<btypes:TYPE>
	  <dCtset/>
	</btypes:TYPE> introduction.
      </em>
    </p>
    <ol>
      <li>
	<p>
	  Cases T-Unit, T-Bool, T-Hloc and T-Sloc are trivial.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id:
	</p>
	<ol>
	  <li>
	    <p>
	      We have
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>	
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma/>
			  <id/>
			  <TS>
			    <tvars/>
			    <type num="x"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap num="x"/>
			  <set>
			    <type num="x"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap/>
			  </dom>
			  <set>
			    <tvars/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <id/>
			  <Subst>
			    <aSubMap num="x"/>
			    <type num="x"/>
			  </Subst>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>      
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aExpr/>
		      <id/>
		    </eq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <eq>
		      <type/>
		      <Subst>
			<aSubMap num="x"/>
			<type num="x"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <spset>
			<TDjudge D="yes">
			  <id/>
			  <Subst>
			    <aSubMap num="x"/>
			    <type num="x"/>
			  </Subst>
			</TDjudge>
		      </spset>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset num="s"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TDjudge D="yes">
			    <id/>
			    <Subst>
			      <aSubMap num="x"/>
			      <type num="x"/>
			    </Subst>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>		      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From premise&nbsp;(4), we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		    <set>
		      <tvars/>
		    </set>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	      Since
	      <btypes:TYPE>
		<eq>
		  <dom>
		    <aSubMap num="x"/>
		  </dom>
		  <set>
		    <tvars/>
		  </set>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <dom>
		      <aSubMap num="x"/>
		    </dom>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a.i and 2.b), we have
	      <btypes:TYPE>	
		<mapsto>
		  <Subst>
		    <aSubMap/>
		    <gamma/>
		  </Subst>
		  <id/>
		  <TS>
		    <tvars/>
		    <Subst>
		      <aSubMap/>
		      <type num="x"/>
		    </Subst>
		  </TS>
		</mapsto>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  From 	
		  <btypes:TYPE>
		    <defn tag="constraint-colection-ext-typ"/>
		  </btypes:TYPE>, we have
		  <btypes:TYPE>
		    <eq>
		      <spset>
			<TDjudge D="yes">
			  <id/>
			  <type/>
			</TDjudge>
		      </spset>
		      <spset>
			<gamma/>
			<store/>
			<type num="x"/>
			<type/>
		      </spset>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(2.a.iii and 2.d.i) and 
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we have
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <set>
			<type num="x"/>
		      </set>
		    </models>
		  </btypes:TYPE>.
		  Again using case&nbsp;(2.a.iv), we obtain
		  <btypes:TYPE>
		    <Sat>
		      <bCtset num="s"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="x"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>, which implies
		  <btypes:TYPE>
		    <CST sp="yes">
		      <Subst>
			<aSubMap/>
			<type num="x"/>
		      </Subst>
		    </CST>
		  </btypes:TYPE>.
		  Now using 
		  <btypes:TYPE>
		    <defn tag="subst-consistent"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<type num="x"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(2.a.i), we have
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap num="x"/>
		      <set>
			<type num="x"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similar to case (2.d.ii), we obtain
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<Subst>
			  <aSubMap num="x"/>
			  <type num="x"/>
			</Subst>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.d.i, 2.d.ii, 2.d.iii, and 2.b), 
	      and
	      <btypes:TYPE>
		<lem tag="Composistion-Rearrange"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<Exists/>
		<aSubMap num="m"/>
	      </btypes:TYPE> such that:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aSubMap num="m"/>
		      </dom>
		      <dom>
			<aSubMap num="x"/>
		      </dom>
		      <set>
			<tvars/>
		      </set>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="x"/>
			</Subst>
		      </Subst>
		      <Subst>
			<sSubMap/>
			<Subst>
			  <aSubMap num="x"/>
			  <type num="x"/>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="x"/>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>		
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap num="m"/>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="x"/>
			</Subst>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.c, 2.e.i and 2.e,iii), and the T-Id rule
	      we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap num="m"/>
		      <Subst>
			<aSubMap/>
			<type num="x"/>
		      </Subst>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.f and 2.e.ii), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From 	
	      <btypes:TYPE>
		<defn tag="constraint-colection-ext-typ"/>
	      </btypes:TYPE>, we have:
	      <btypes:TYPE>
		<eq>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<id/>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="x"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		</eq>
	      </btypes:TYPE>.
	      Clearly, 
	      <btypes:TYPE>
		<subeq>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="x"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <spset>
			<gamma/>
			<store/>
			<type num="x"/>
			<type/>
		      </spset>
		    </Subst>
		  </spset>
		</subeq>
	      </btypes:TYPE>.	      
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a.iv and 2.d.i), we have
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <Subst>
		    <aSubMap/>
		    <spset>
		      <gamma/>
		      <store/>
		      <type num="x"/>
		      <type/>
		    </spset>
		  </Subst>
		</Sat>
	      </btypes:TYPE>. Now, from 
	      <btypes:TYPE>
		<lem tag="maybe-cst-properties"/>
	      </btypes:TYPE> (property-3), we obtain
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <spset>
			<gamma/>
			<store/>
			<type num="x"/>
			<type/>
		      </spset>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE>.	      
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, from cases&nbsp;(3.i and 3.h) and
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we obtain
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="x"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE> and therefore
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<id/>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Finally, from cases&nbsp;(2.g and 2.j) and
	      <btypes:TYPE>
		<defn tag="consistent-typing"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <bCtset/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: Follows from induction hypothesis, using
	  <btypes:TYPE>
	    <lem tag="T-sub-min"/>
	  </btypes:TYPE> and the T-Lambda rule.
	</p>
      </li>
      <li>
	<p>
	  Case T-App: 
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have:
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<TDjudge>
			  <aExpr num="1"/>
			  <type num="1"/>
			</TDjudge>
			<Msub>
			  <type num="1"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</Msub>
		      </tyPre>
		      <tyPre>
			<TDjudge Msub="yes">
			  <aExpr num="2"/>
			  <type num="2"/>
			</TDjudge>
			<Msub>
			  <type num="2"/>
			  <minz>
			    <type num="a"/>
			  </minz>
			</Msub>
			<Msub>
			  <maxz>
			    <type num="r"/>
			  </maxz>
			  <type/>
			</Msub>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <spset>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </spset>
		    </models>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap/>
			<bCtset/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TDjudge>
			    <apply>
			      <aExpr num="1"/>
			      <aExpr num="2"/>
			    </apply>
			    <type/>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      By induction hypothesis (by using case&nbsp;(4.a.i), 
	      weakening on cases&nbsp;(4.a.ii and 4.a.iii), and
	      premise&nbsp;(4)), we have:
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset num="s"/>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <Subst>
		      <aSubMap/>
		      <type num="1"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset num="s"/>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <Subst>
		      <aSubMap/>
		      <type num="2"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. That is,
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="1"/>
			<Subst>
			  <aSubMap/>
			  <type num="1"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset num="s"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <Subst>
			      <aSubMap/>
			      <gamma/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr num="1"/>
			    <Subst>
			      <aSubMap/>
			      <type num="1"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="2"/>
			<Subst>
			  <aSubMap/>
			  <type num="2"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset num="s"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <Subst>
			      <aSubMap/>
			      <gamma/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr num="2"/>
			    <Subst>
			      <aSubMap/>
			      <type num="2"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(4.a.i), we have
	      <btypes:TYPE>
		<Msub>
		  <type num="1"/>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		</Msub>
	      </btypes:TYPE>. Using weakening on case&nbsp;(4.a.ii)
	      and 
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE>, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <fn>
			<type num="a"/>
			<type num="r"/>
		      </fn>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <fn>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="r"/>
		    </Subst>
		  </fn>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>. 
	      Using weakening on case&nbsp;(4.a.ii)
	      and 
	      <btypes:TYPE>
		<lem tag="T-msm_eq_ms"/>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>. 
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, we obtain
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <type num="r"/>
		    </Subst>
		  </maxz>
		  <Subst>
		    <aSubMap/>
		    <type/>
		  </Subst>
		</Msub>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.b.i, 4.b.ii, 4.c, 4.d and 4.e) and
	      using T-App rule, we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="1"/>
		    </apply>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Using weakening on case&nbsp;(4.a.ii), we obtain
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		  <type/>
		</Sat>
	      </btypes:TYPE>. Using this and cases&nbsp;(4.b.ii
	      and 4.b.iv), and 
	      <btypes:TYPE>
		<lem tag="Cst-additive"/>
	      </btypes:TYPE> (aggregation), along with 
	      <btypes:TYPE>
		<defn tag="constraint-colection-ext-typ"/>
	      </btypes:TYPE> (constraint collection), we conclude that 
	      <btypes:TYPE>
		<Sat>
		  <bCtset num="s"/>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<apply>
			  <aExpr num="1"/>
			  <aExpr num="2"/>
			</apply>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		</Sat>
	      </btypes:TYPE>	      
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.f and 4.g), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <bCtset/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </apply>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>	      	      
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Let-P: In this case, we have
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<TDjudge Msub="yes">
		  <vExp/>
		  <type/>
		</TDjudge>
		<pred name="Immut">
		  <type/>
		</pred>
		<eq>
		  <set>
		    <tvars name="alpha"/>
		  </set>
		  <diff>
		    <ftvs>
		      <type/>
		    </ftvs>
		    <ftvs>
		      <gamma/>
		      <store/>
		    </ftvs>
		  </diff>
		</eq>
	      </tyPre>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<TS>
			  <tvars/>
			  <type/>
			</TS>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type dash="'"/>
		  </tqExpr>
		</Sjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <paren>
		    <let kind="p">
		      <id/>
		      <vExp/>
		      <aExpr/>
		    </let>
		  </paren>
		  <type dash="'"/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Proof is similar to T-App case. Without loss of generality,
	  we can assume that
	  <btypes:TYPE>
	    <mutex>
	      <ftvs>
		<aSubMap/>
	      </ftvs>
	      <set>
		<tvars/>
	      </set>
	    </mutex>
	  </btypes:TYPE> since type schemes are equal under 
	  <btypes:TYPE>
	    <tvar name="alpha"/>
	  </btypes:TYPE>-renaming of generalized variables.
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-VSubstitution">
    <title>Value Substitution</title>
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<dCtset/>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <TS>
		      <tvars/>
		      <ctype>
			<type num="v"/>
			<dCtset num="v"/>
		      </ctype>
		    </TS>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <TDjudge cst="yes">
	      <aVal/>
	      <type num="v"/>
	      <dCtset num="v"/>
	    </TDjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <pred name="Immut">
	      <type num="v"/>
	    </pred>
	  </btypes:TYPE>
	  <!-- This predicate is necessary since the pair rule can
	  derive mutable types for pair of values (v,v) and the
	  substitution can go wrong if performed on the lhs of
	  an assignment. This predicate effectively rules out
	  substitution on the lhs of an assignment, unless within a
	  dereferenced expression --> 	
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <bCtset dash="'"/>
	  <bCtset/>
	</supeq>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset dash="'"/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>    
  </lemma>
  <proof>
    <p>
      By induction on the type derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<TS>
		  <tvars/>
		  <type num="v"/>
		</TS>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
      We proceed by case analysis on the final step of the
      derivation.
      <em>
	Need to fix the proof for 
	<btypes:TYPE>
	  <dCtset/>
	</btypes:TYPE> introduction.
      </em>
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id name="y"/>
	    </eq>
	    <text content=", where "/>
	    <in>
	      <id name="y"/>
	      <extend>
		<gamma/>
		<id/>
		<aTS/>
	      </extend>
	    </in>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<neq>
		  <eq>
		    <aExpr/>
		    <id name="y"/>
		  </eq>
		  <id name="x"/>
		</neq>
	      </btypes:TYPE>, then,
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>.
	      and the desired result
	      <btypes:TYPE>
		<TDjudge cst="yes">
		  <id name="y"/>
		  <type/>
		</TDjudge>
	      </btypes:TYPE>
	      is immediate from the assumtion
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <extend>
		      <gamma/>
		      <tqExpr>
			<id/>
			<TS>
			  <tvars/>
			  <type num="v"/>
			</TS>
		      </tqExpr>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<eq>
		  <aExpr/>
		  <id name="x"/>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <aVal/>
		</eq>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<eq>
		  <type/>
		  <Subst>
		    <aSubMap/>
		    <type num="v"/>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Let
	      <btypes:TYPE>
		<eq>
		  <gamma dash="'"/>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <TS>
			<tvars/>
			<type num="v"/>
		      </TS>
		    </tqExpr>
		  </extend>
		</eq>
	      </btypes:TYPE>.
	      In this case, we have
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma dash="'"/>
			  <id name="y"/>
			  <TS>
			    <tvars/>
			    <type num="v"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap/>
			  <set>
			    <type num="v"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap/>
			  </dom>
			  <set>
			    <tvars/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>        
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <TDjudge cst="yes">
		      <aVal/>
		      <type num="v"/>
		    </TDjudge>
		  </btypes:TYPE>. That is,
		</p>
		<ol>
		  <li>
		    <p>
		      <btypes:TYPE>
			<TDjudge>
			  <aVal/>
			  <type num="v"/>
			</TDjudge>
		      </btypes:TYPE>
		    </p>
		  </li>
		  <li>
		    <p>
		      <btypes:TYPE>
			<Sat>
			  <bCtset/>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="v"/>
			    </TDjudge>
			  </spset>
			</Sat>
		      </btypes:TYPE>
		    </p>
		  </li>
		</ol>
	      </li>
	    </ol>
	    <p>
	      We need to show that 
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <bCtset dash="'"/>
		  <bCtset/>
		</supeq>
		<ST/>
		<Sjudge>
		  <assume>
		    <bCtset dash="'"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap/>
		      <type num="v"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Without loss of generality, we can assume that 
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<gamma/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<gamma/>
		      </Subst>
		      <gamma/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<store/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<store/>
		      </Subst>
		      <store/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <ftvs>
			<aSubMap/>
		      </ftvs>
		      <pred name="gtv">
			<gamma/>
		      </pred>
		    </mutex>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE> 
		    <ftvs>
		      <range>
			<aSubMap/>
		      </range>
		    </ftvs>
		  </btypes:TYPE> consists of type variables in
		  <btypes:TYPE> 
		    <diff>
		      <ftvs>
			<gamma/>
			<store/>
			<type num="v"/>
		      </ftvs>
		      <set>
			<tvars/>
		      </set>
		    </diff>
		  </btypes:TYPE> or fresh type variables.
		</p>
		<p>
		  The above properties can always be made to
		  hold by suitable renaming of variables and using 
		  <btypes:TYPE>
		    <lem tag="T-Renaming"/>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>. 
		  <br/>
		  This is because, due to renamability of variables, we have
		  <btypes:TYPE>
		    <eq>
		      <inter>
			<ftvs>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="v"/>
			    </TDjudge>
			  </spset>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </inter>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </eq>
		  </btypes:TYPE> , and any 
		  <btypes:TYPE> 
		    <subeq>
		      <set>
			<tvars name="beta"/>
		      </set>
		      <set>
			<tvars/>
		      </set>
		    </subeq>
		    <ST/>
		    <notin>
		      <tvar name="beta"/>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </notin>
		  </btypes:TYPE> can be ignored.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.b.i and 1.b.ii) we can say that
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <bCtset num="big"/>
		  <bCtset/>
		</supeq>
		<ST/>
		<Sat>
		  <bCtset num="big"/>
		  <Subst>
		    <aSubMap/>
		    <spset>
		      <type num="v"/>
		    </spset>
		  </Subst>
		</Sat>
	      </btypes:TYPE>.
	      This is because:
	    </p>
	    <ol>
	      <li>
		<p>
		  From case&nbsp;(1.b.i) we have
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<type num="v"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		  From this, using
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <Cst>
		      <assume/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(1.b.ii) and
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="v"/>
			</Subst>
		      </set>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Since 
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="v"/>
			</Subst>
		      </set>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </subeq>
		  </btypes:TYPE>, using case&nbsp;(1.i) and
		  <btypes:TYPE>
		    <lem tag="maybe-cst-properties"/>
		  </btypes:TYPE> (property-4), we conclude that 
		  <btypes:TYPE>
		    <Exists/>
		    <supeq>
		      <bCtset num="big"/>
		      <bCtset/>
		    </supeq>
		    <ST/>
		    <Sat>
		      <bCtset num="big"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Forall/>
		<in>
		  <grouping>
		    <Tceq>
		      <tvar name="beta"/>
		      <ptype/>
		    </Tceq>
		    <text content=" or "/>
		    <ceq>
		      <tvar name="beta"/>
		      <ptype/>
		    </ceq>
		  </grouping>
		  <bCtset/>
		</in>
		<ST/>
		<notin>
		  <tvar name="beta"/>
		  <set>
		    <tvars/>
		  </set>
		</notin>
	      </btypes:TYPE>, 
	      <btypes:TYPE>
		<mutex>
		  <ftvs>
		    <ptype/>
		  </ftvs>
		  <set>
		    <tvars/>
		  </set>
		</mutex>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      Otherwise, due to case&nbsp;(1.d), 
	      <btypes:TYPE>
		<Exists/>
		<in>
		  <grouping>
		    <Tceq>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		    </Tceq>
		    <text content=" or "/>
		    <ceq>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		    </ceq>
		  </grouping>
		  <bCtset num="big"/>
		</in>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<neq>
		  <Subst>
		    <aSubMap/>
		    <ptype/>
		  </Subst>
		  <ptype/>
		</neq>
	      </btypes:TYPE>, which violates the restriction
	      <btypes:TYPE>
		<meta>
		  <bCtset num="big"/>
		</meta>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We can write
	      <btypes:TYPE>
		<eq>
		  <bCtset/>
		  <unin>
		    <bCtset num="e"/>
		    <bCtset num="t"/>
		    <bCtset num="a"/>
		    <bCtset num="r"/>
		  </unin>
		</eq>
	      </btypes:TYPE> where:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<bCtset num="e"/>
		      </dom>
		      <ftvs>
			<gamma/>
			<store/>
		      </ftvs>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<bCtset num="t"/>
		      </dom>
		      <diff>
			<ftvs>
			  <type num="v"/>
			</ftvs>
			<ftvs>
			  <gamma/>
			  <store/>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </diff>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<bCtset num="a"/>
		      </dom>
		      <set>
			<tvars/>
		      </set>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <dom>
			<bCtset num="e"/>
		      </dom>
		      <dom>
			<bCtset num="t"/>
		      </dom>
		      <dom>
			<bCtset num="a"/>
		      </dom>
		      <dom>
			<bCtset num="r"/>
		      </dom>
		    </mutex>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  Let 
 		  <btypes:TYPE>
		    <eq>
		      <bCtset num="et"/>
		      <unin>
			<bCtset num="e"/>
			<bCtset num="t"/>
		      </unin>
		    </eq>
		  </btypes:TYPE> and
 		  <btypes:TYPE>
		    <eq>
		      <bCtset num="ar"/>
		      <unin>
			<bCtset num="a"/>
			<bCtset num="r"/>
		      </unin>
		    </eq>
		  </btypes:TYPE> 
		</p>
	      </li>
	      <li>
		<p>
		  From case(1.f.i), weakening on (1.a.ii), and
		  <btypes:TYPE>
		    <lem tag="maybe-cst-properties"/>
		  </btypes:TYPE> (property-8), we have
		  <btypes:TYPE>
		    <subeq>
		      <ftvs>
			<range>
			  <bCtset num="e"/>
			</range>
		      </ftvs>
		      <ftvs>
			<gamma/>
			<store/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, using case&nbsp;(1.e), we conclude that 
		  <btypes:TYPE>
		    <subeq>
		      <ftvs>
			<range>
			  <bCtset num="t"/>
			</range>
		      </ftvs>
		      <diff>
			<ftvs>
			  <gamma/>
			  <store/>
			  <type num="v"/>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </diff>
		    </subeq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Therefore, we have
		  <btypes:TYPE>
		    <mutex>
		      <ftvs>
			<bCtset num="et"/>
		      </ftvs>
		      <dom>
			<bCtset num="at"/>
		      </dom>
		    </mutex>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Let 
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <set>
			<tvars name="beta"/>
		      </set>
		      <dom>
			<bCtset num="r"/>
		      </dom>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="a"/>
		      <plural>
			<SubMap>
			  <tvar name="alpha"/>
			  <tvar name="gamma"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <tvars name="gamma"/>
		  </btypes:TYPE> are new type variables.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="b"/>
		      <plural>
			<SubMap>
			  <tvar name="beta"/>
			  <tvar name="delta"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <tvars name="delta"/>
		  </btypes:TYPE> are new type variables.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="ab"/>
		      <compose>
			<aSubMap num="a"/>
			<aSubMap num="b"/>
		      </compose>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <bCtset num="ab"/>
		      <subst>
			<subst>
			  <bCtset/>
			  <tvars name="alpha"/>
			  <tvars name="gamma"/>
			</subst>
			<tvars name="beta"/>
			<tvars name="delta"/>
		      </subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
		<p>
		  Due to case&nbsp;(1.g), 
		  <btypes:TYPE>
		    <eq>
		      <bCtset num="ab"/>
		      <unin>
			<bCtset num="et"/>
			<bCtset num="ar" dash="'"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <eq>
		      <bCtset num="ar" dash="'"/>
		      <subst>
			<subst>
			  <bCtset num="ar"/>
			  <tvars name="alpha"/>
			  <tvars name="gamma"/>
			</subst>
			<tvars name="beta"/>
			<tvars name="delta"/>
		      </subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <type num="va"/>
		      <Subst>
			<aSubMap num="a"/>
			<type num="v"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>	
		    <eq>
		      <aSubMap dash="'"/>
		      <plural>
			<SubMap>
			  <tvar name="gamma"/>
			  <type num="s"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>	
		    <eq>
		      <aSubMap/>
		      <plural>
			<SubMap>
			  <tvar name="alpha"/>
			  <type num="s"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>
		</p>
		<p>
		  Note that 
 		  <btypes:TYPE>	
		    <Forall/>
		    <type num="s"/>
		  </btypes:TYPE> above,
 		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap num="ab"/>
			<type num="s"/>
		      </Subst>
		      <type num="s"/>
		    </eq>
		  </btypes:TYPE> due to case&nbsp;(1.c.iv).
		</p>
		<p>
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<gamma/>
		      </Subst>
		      <gamma/>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<store/>
		      </Subst>
		      <store/>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<type num="va"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="v"/>
		      </Subst>
		      <type/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  Let
		  <btypes:TYPE>
		    <eq>
		      <bCtset dash="'"/>
		      <unin>
			<bCtset/>
			<bCtset num="ab"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  This can be written as:<br/>
		  <btypes:TYPE>
		    <eq>
		      <bCtset dash="'"/>
		      <unin>
			<bCtset num="et"/>
			<bCtset num="ar"/>
			<bCtset num="et"/>
			<bCtset num="ar" dash="'"/>
		      </unin>
		      <unin>
			<bCtset/>
			<bCtset num="ar" dash="'"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Since 
		  <btypes:TYPE>
		    <dom>
		      <bCtset num="ar" dash="'"/>
		    </dom>
		  </btypes:TYPE> consists of new type variables,
		  we have
		  <btypes:TYPE>
		    <meta>
		      <bCtset dash="'"/>
		    </meta>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Further, since
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<bCtset/>
		      </Subst>
		      <bCtset/>
		    </eq>
		  </btypes:TYPE>, we have
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<bCtset dash="'"/>
		      </Subst>
		      <unin>
			<bCtset/>
			<Subst>
			  <aSubMap dash="'"/>
			  <bCtset num="ar" dash="'"/>
			</Subst>
		      </unin>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1.b.iii and 1.h) using
	      <btypes:TYPE>
		<lem tag="T-Renaming"/>
	      </btypes:TYPE> (renaming), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset num="ab"/>
		    <Subst>
		      <aSubMap num="ab"/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap num="ab"/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap num="ab"/>
		      <type num="v"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      From cases&nbsp;(1.f and 1.h), we can write this as
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset num="ab"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type num="va"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1.j, 1.i.i and 1.i.iii) and
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening) (property-5), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset dash="'"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type num="va"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, by applying variable renaming on 
	      case&nbsp;(1.b.i and 1.b.ii), we obtain
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma dash="'"/>
			  <id name="y"/>
			  <TS>
			    <tvars name="gamma"/>
			    <type num="va"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap/>
			  <set>
			    <type num="va"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap dash="'"/>
			  </dom>
			  <set>
			    <tvars name="gamma"/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap dash="'"/>
			      <type num="va"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>        
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset dash="'"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap dash="'"/>
			      <type num="va"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.l.i), we have
	      <btypes:TYPE>
		<Cst>
		  <aSubMap dash="'"/>
		  <set>
		    <type num="va"/>
		  </set>
		</Cst>
	      </btypes:TYPE>, which implies by weakening,
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <set>
		    <type num="va"/>
		  </set>
		</models>
	      </btypes:TYPE>, and further due to case&nbsp;(1.h.vii), 
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <set>
		    <gamma/>
		    <store/>
		    <type num="va"/>
		  </set>
		</models>
	      </btypes:TYPE>.
	      Case&nbsp;(1.h) implies
	      <btypes:TYPE>
		<CST sp="yes">
		  <TDjudge>
		    <aVal/>
		    <type num="va"/>
		  </TDjudge>
		</CST>
	      </btypes:TYPE>. Using these facts with
	      <btypes:TYPE>
		<lem tag="Consistency-Propagation"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <spset>
		    <TDjudge>
		      <aVal/>
		      <type num="va"/>
		    </TDjudge>
		  </spset>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  From case&nbsp;(1.l.i), similar to case&nbsp;(1.d), 
		  we conclude that 
		  <btypes:TYPE>
		    <Exists/>
		    <supeq>
		      <bCtset dash="''"/>
		      <bCtset dash="'"/>
		    </supeq>
		    <ST/>
		    <Sat>
		      <bCtset dash="''"/>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <type num="va"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		  Due to idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap dash="'"/>
		  </btypes:TYPE>, we can write this as
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap dash="'"/>
			<bCtset dash="''"/>
		      </Subst>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <type num="va"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  By weakening on case&nbsp;(1.k), we obtain
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<bCtset dash="''"/>
			<gamma/>
			<store/>
		      </assume>
		      <tqExpr>
			<aVal/>
			<type num="va"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>. This implies
		  <btypes:TYPE>
		    <Sat>
		      <bCtset dash="''"/>
		      <spset>
			<TDjudge>
			  <aVal/>
			  <type num="va"/>
			</TDjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  Evidently, 
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<type num="va"/>
		      </set>
		      <spset>
			<TDjudge>
			  <aVal/>
			  <type num="va"/>
			</TDjudge>
		      </spset>
		    </subeq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(1.c.v and 1.h.ii) we conclude that
		  <btypes:TYPE>
		    <subeq>
		      <dom>
			<aSubMap dash="'"/>
		      </dom>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>. This implies
		  <btypes:TYPE>
		    <subeq>
		      <inter>
			<dom>
			  <aSubMap dash="'"/>
			</dom>
			<ftvs>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="va"/>
			    </TDjudge>
			  </spset>
			</ftvs>
		      </inter>
		      <ftvs>
			<set>
			  <type num="v"/>
			</set>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(1.n.ii, 1.m, 1.n.iii, 1.n.i and
		  1.n.iv) and 
		  <btypes:TYPE>
		    <lem tag="cst-streangthening-cor"/>
		  </btypes:TYPE> (strengthening), we conclude that
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap dash="'"/>
			<bCtset dash="''"/>
		      </Subst>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <TDjudge>
			    <aVal/>
			    <type num="va"/>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Evidently,
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap dash="'"/>
		  </dom>
		  <pred name="gtv">
		    <gamma/>
		  </pred>
		</mutex>
	      </btypes:TYPE>. 
	      Now, from cases&nbsp;(1.n.ii, 1.m and 1.n.v) and
	      <btypes:TYPE>
		<lem tag="T-TSubstitution"/>
	      </btypes:TYPE> (type substitution), we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap dash="'"/>
		      <bCtset dash="''"/>
		    </Subst>
		    <Subst>
		      <aSubMap dash="'"/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap dash="'"/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap dash="'"/>
		      <type num="va"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      From case&nbsp;(1.h.vii), this can be written as
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap dash="'"/>
		      <bCtset dash="''"/>
		    </Subst>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, 
	      <btypes:TYPE>
		<eq>
		  <bCtset dash="''"/>
		  <unin>
		    <bCtset/>
		    <bCtset num="rest"/>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	      From case&nbsp;(1.i.iv), we have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap dash="'"/>
		    <bCtset dash="''"/>
		  </Subst>
		  <unin>
		    <bCtset/>
		    <Subst>
		      <aSubMap dash="'"/>
		      <bCtset num="rest"/>
		    </Subst>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	      Therefore, 
	      <btypes:TYPE>
		<supeq>
		  <Subst>
		    <aSubMap dash="'"/>
		    <bCtset dash="''"/>
		  </Subst>
		  <bCtset/>
		</supeq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: We have
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <extend>
		      <gamma/>
		      <mapping>
			<id name="x"/>
			<TS>
			  <tvars/>
			  <type num="v"/>
			</TS>
		      </mapping>
		      <mapping>
			<id name="y"/>
			<type num="1"/>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
		<eq under="minz">
		  <type num="1"/>
		  <type num="1" dash="'"/>
		</eq>
		<eq under="minz">
		  <type num="2"/>
		  <type num="2" dash="'"/>
		</eq>
	      </tyPre>
	      <tyConc>
		<Sjudge>
		  <assume>
		    <extend>
		      <gamma/>
		      <mapping>
			<id name="x"/>
			<TS>
			  <tvars/>
			  <type num="v"/>
			</TS>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <lambda>
		      <id/>
		      <aExpr/>
		    </lambda>
		    <fn>
		      <type num="1" dash="'"/>
		      <type num="2" dash="'"/>
		    </fn>
		  </tqExpr>
		</Sjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  We can assume that
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	  Now, the result follows from the induction hypothesis, and 
	  the T-Lambda rule.
	</p>
      </li>
      <li>
	<p>
	  Case T-App:  
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, writing
	      <btypes:TYPE>
		<eq>
		  <gamma dash="'"/>
		  <extend>
		    <gamma/>
		    <mapping>
		      <id name="x"/>
		      <TS>
			<tvars/>
			<type num="v"/>
		      </TS>
		    </mapping>
		  </extend>
		</eq>
	      </btypes:TYPE>, we have:
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <aExpr num="1"/>
			    <type num="1"/>
			  </tqExpr>
			</Sjudge>
			<Msub>
			  <type num="1"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</Msub>
		      </tyPre>
		      <tyPre>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <aExpr num="2"/>
			    <type num="2"/>
			  </tqExpr>
			</Sjudge>
			<Msub>
			  <type num="2"/>
			  <minz>
			    <type num="a"/>
			  </minz>
			</Msub>
			<Msub>
			  <maxz>
			    <type num="r"/>
			  </maxz>
			  <type/>
			</Msub>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <apply>
			      <aExpr num="1"/>
			      <aExpr num="2"/>
			    </apply>
			    <type/>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <apply>
			      <aExpr num="1"/>
			      <aExpr num="2"/>
			    </apply>
			    <type/>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(3.i) and weakening on case&nbsp;(3.ii),
	      we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Now, by induction hypothesis, we know that 
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <bCtset dash="'"/>
		  <bCtset/>
		</supeq>
		<ST/>
		<Sjudge>
		  <assume>
		    <bCtset dash="'"/>
 		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <subst>
		      <aExpr num="1"/>
		      <id/>
		      <aVal/>
		    </subst>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset/>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      By 		  
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset dash="'"/>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      Again, by induction hypothesis, we know that 
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <bCtset dash="''"/>
		  <bCtset dash="'"/>
		</supeq>
		<ST/>
		<Sjudge>
		  <assume>
		    <bCtset dash="''"/>
 		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <subst>
		      <aExpr num="2"/>
		      <id/>
		      <aVal/>
		    </subst>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(3.b) and
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset dash="''"/>
 		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <subst>
		      <aExpr num="1"/>
		      <id/>
		      <aVal/>
		    </subst>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Again by weakening wrt case&nbsp;(3.a.ii), we have
	      <btypes:TYPE>
		<Sat>
		  <bCtset dash="''"/>
		  <set>
		    <type num="a"/>
		    <type num="r"/>
		    <type/>
		  </set>
		</Sat>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(3.c and 3.d) and copy-coersion
	      relations in case&nbsp;(3.a.i), using the T-App rule
	      we obtain
	      <btypes:TYPE>
		<TDjudge>
		  <apply>
		    <subst>
		      <aExpr num="1"/>
		      <id/>
		      <aVal/>
		    </subst>
		    <subst>
		      <aExpr num="2"/>
		      <id/>
		      <aVal/>
		    </subst>
		  </apply>
		  <type/>
		</TDjudge>
	      </btypes:TYPE>.
	      Using cases&nbsp;(3.c, 3.d and 3.e) and
	      <btypes:TYPE>
		<defn tag="constraint-colection-ext-typ"/>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <bCtset dash="''"/>
 		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <apply>
		      <subst>
			<aExpr num="1"/>
			<id/>
			<aVal/>
		      </subst>
		      <subst>
			<aExpr num="2"/>
			<id/>
			<aVal/>
		      </subst>
		    </apply>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  T-Set case is to T-App. 
	  Premise&nbsp;(3) guarantees that the substitution
	  cannot happen on the LHS of an assignment except within a
	  dereferenced expression. 
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-VSubstitution2">
    <title>Corollary to Value Substitution</title>
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<bCtset/>
		<dCtset/>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <TS>
		      <tvars/>
		      <ctype>
			<type num="v"/>
			<unin>
			  <dCtset num="v"/>
			  <pcst>
			    <id/>
			    <lKind k="poly"/>
			    <type num="v"/>
			  </pcst>
			</unin>
		      </ctype>
		    </TS>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <TDjudge cst="yes">
	      <aVal/>
	      <type num="v"/>
	      <dCtset num="v"/>
	    </TDjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <models>
	      <assume/>
	      <dCtset/>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Exists/>
	<supeq>
	  <bCtset dash="'"/>
	  <bCtset/>
	</supeq>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset dash="'"/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>    
  </lemma>
  <proof>
    <p>
      Similar to 
      <btypes:TYPE>
	<lem tag="T-VSubstitution"/>
      </btypes:TYPE>.
      The premise
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE>      
      guarantees that
      <btypes:TYPE>
	<Forall/>
	<in>
	  <pcst>
	    <id/>
	    <lKind name="poly"/>
	    <type num="v" dash="'"/>
	  </pcst>
	  <dCtset/>
	</in>
      </btypes:TYPE>,
      <btypes:TYPE>
	<pred name="Immut">
	  <type num="v" dash="'"/>
	</pred>
      </btypes:TYPE>, which ensures that all instantiations 
      of
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> are immutable.
    </p>
  </proof>
  <lemma id="T-LSubstitution">
    <title>Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type num="x"/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <gamma/>
	    <extend>
	      <store/>
	      <mapping>
		<sLoc/>
		<type num="x"/>
	      </mapping>
	    </extend>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the type derivation of
      <btypes:TYPE>
	<Sjudge>
	  <aCtest/>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, similar to
      <btypes:TYPE>
	<lem tag="T-VSubstitution"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-LSubstitution2">
    <title>Corollary to Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<TS>
		  <tvars/>
		  <ctype>
		    <type num="v"/>
		    <unin>
		      <dCtset num="v"/>
		      <pcst>
			<id/>
			<lKind k="mono"/>
			<type num="v"/>
		      </pcst>
		    </unin>
		  </ctype>
		</TS>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
      and
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <gamma/>
	    <extend>
	      <store/>
	      <mapping>
		<sLoc/>
		<type num="x"/>
	      </mapping>
	    </extend>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      Similar to
      <btypes:TYPE>
	<lem tag="T-LSubstitution"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-sh-safety">
    <title>Stack and Heap Assignment Safety</title>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<extend>
		  <heap/>
		  <mapping>
		    <hLoc/>
		    <aVal/>
		  </mapping>
		</extend>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <eq under="minz">
	      <mapsto>
		<store/>
		<hLoc/>
	      </mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>,
	  then
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<extend>
		  <heap/>
		  <mapping>
		    <hLoc/>
		    <aVal dash="'"/>
		  </mapping>
		</extend>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<extend>
		  <stack/>
		  <mapping>
		    <sLoc/>
		    <aVal/>
		  </mapping>
		</extend>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <eq under="minz">
	      <mapsto>
		<store/>
		<sLoc/>
	      </mapsto>
	      <type/>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset/>
		<dCtset/>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<extend>
		  <stack/>
		  <mapping>
		    <sLoc/>
		    <aVal dash="'"/>
		  </mapping>
		</extend>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of stack and heap typing.
    </p>
  </proof>
  <theorem id="T-subject-reduction">
    <title>Subject Reduction</title>
    <p>
      For any canonical expression 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>, if
      <btypes:TYPE>
	<TDjudge name="s" D="yes" cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<TDjudge name="s" D="yes" cst="yes">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE>, then,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <supeq>
	      <bCtset dash="'"/>
	      <bCtset/>
	    </supeq>
	  </btypes:TYPE> 
	  such that
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset dash="'"/>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset dash="'"/>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <supeq>
	      <bCtset dash="'"/>
	      <bCtset/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset dash="'"/>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<bCtset dash="'"/>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE> and
	  <!-- Old: This cannot be replaced directly with an Msub at the
	  derivation as the type `t' is obtained from a previous
	  derivation, and can be a mutable one
	  New: We cannot just have a Msub relationship. See the 
	  case for E-App rule -->
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type dash="'"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>. We proceed by the case analysis of the final
      step.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id, T-Bool, T-Hloc, T-Lambda  cannot
	  happen.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/> 
	      <sLoc/>
	    </eq>
	  </btypes:TYPE>.
	  We have, for some 
	  <btypes:TYPE>
	    <subeq>
	      <dCtset dash="'"/>
	      <dCtset/>
	    </subeq>
	  </btypes:TYPE>,
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <store/>
		  <sLoc/>
		  <type/>
		</mapsto>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <sLoc/>
		  <type/>
		  <dCtset dash="'"/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-Rval:
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<opRule>
		  <opPre>
		    <mapsto>
		      <stack/>            
		      <sLoc/>
		      <aVal/>
		    </mapsto>
		  </opPre>
		  <opConc>
		    <eval>
		      <opState>
			<stack/>
			<heap/>
			<sLoc/>
		      </opState>
		      <opState>
			<stack/>
			<heap/>
			<aVal/>
		      </opState>
		    </eval>
		  </opConc>
		</opRule>
	      </Hrules>
	    </btypes:TYPE>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aExpr dash="'"/>
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <aVal/>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <heap dash="'"/>
		      <heap/>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>
		    <eq>
		      <stack dash="'"/>
		      <stack/>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From 
		  <btypes:TYPE>
		    <TDjudge name="s" D="yes" cst="yes">
		      <plus>
			<heap/>
			<stack/>
		      </plus>
		    </TDjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <defn tag="stack-heap-typing"/>
		  </btypes:TYPE> (Stack and Heap Typing), we have
		  <btypes:TYPE>
		    <TDjudge name="s" D="yes" cst="yes">
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <type dash="'"/>
		    </TDjudge>
		    <ST/>
		    <eq under="minz">
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <type dash="'"/>
		    </eq>
		  </btypes:TYPE>. 
		  That is,
		  <btypes:TYPE>
		    <TDjudge name="s" D="yes" cst="yes">
		      <aVal/>
		      <type dash="'"/>
		    </TDjudge>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <eq under="minz">
		      <type/>
		      <type dash="'"/>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-App:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	  </btypes:TYPE>. We have for some 
	  <btypes:TYPE>
	    <subeq>
	      <dCtset num="1"/>
	      <dCtset/>
	    </subeq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <subeq>
	      <dCtset num="2"/>
	      <dCtset/>
	    </subeq>
	  </btypes:TYPE>,
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <dCtset num="1"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
		<Msub>
		  <type num="1"/>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		</Msub>
	      </tyPre>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <dCtset num="2"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
		<Msub>
		  <type num="2"/>
		  <minz>
		    <type num="a"/>
		  </minz>
		</Msub>
		<Msub>
		  <maxz>
		    <type num="r"/>
		  </maxz>
		  <type/>
		</Msub>
	      </tyPre>
	      <tyConc>
		<Sjudge>
		  <assume>
		    <unin>
		      <dCtset num="1"/>
		      <dCtset num="2"/>
		    </unin>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </apply>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-# (1):
	    </p>
	    <btypes:TYPE>
	      <opRule>
		<opPre>
		  <eval>
		    <opState>
		      <stack/>
		      <heap/>            
		      <aExpr num="1"/>
		    </opState>
		    <opState>
		      <stack dash="'"/>
		      <heap dash="'"/>
		      <aExpr num="1" dash="'"/>
		    </opState>
		  </eval>
		</opPre>
		<opConc>
		  <eval>
		    <opState>
		      <stack/>
		      <heap/>
		      <apply>
			<aExpr num="1"/>
			<aExpr num="2"/>
		      </apply>
		    </opState>
		    <opState>
		      <stack dash="'"/>
		      <heap dash="'"/>
		      <apply>
			<aExpr num="1" dash="'"/>
			<aExpr num="2"/>
		      </apply>
		    </opState>
		  </eval>
		</opConc>
	      </opRule>
	    </btypes:TYPE>
	    <ol>
	      <li>
		<p>
		  By using
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening) on the assumptions of
		  T-App rule, we obtain
		  <btypes:TYPE>
		    <TDjudge name="s" D="yes" cst="yes">
		      <aExpr num="1"/>
		      <type num="1"/>
		    </TDjudge>
		  </btypes:TYPE>.
		  By induction hypothesis, we conclude that 
		  <btypes:TYPE>
		    <Exists/>
		    <supeq>
		      <store dash="'"/>
		      <store/>
		    </supeq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <supeq>
		      <bCtset dash="'"/>
		      <bCtset/>
		    </supeq>
		  </btypes:TYPE> such that
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset dash="'"/>
			<dCtset/>
			<gamma/>
			<store dash="'"/>
		      </assume>
		      <tqExpr>
			<aExpr num="1"/>
			<type num="1" dash="'"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset dash="'"/>
			<dCtset/>
			<gamma/>
			<store dash="'"/>
		      </assume>
		      <plus>
			<heap dash="'"/>
			<stack dash="'"/>
		      </plus>
		    </Sjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="1"/>
		      <type num="1" dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(3), we have
		  <btypes:TYPE>
		    <Msub>
		      <type num="1"/>
		      <fn>
			<type num="a"/>
			<type num="r"/>
		      </fn>
		    </Msub>
		  </btypes:TYPE>.
		  From case&nbsp;(3.a.i) we have
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="1"/>
		      <type num="1" dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		  Since
		  <btypes:TYPE>
		    <eq>
		      <fn>
			<type num="a"/>
			<type num="r"/>
		      </fn>
		      <minz>
			<fn>
			  <type num="a"/>
			  <type num="r"/>
			</fn>
		      </minz>
		    </eq>
		  </btypes:TYPE>, using 
		  <btypes:TYPE>
		    <lem tag="T-Subtype-properties"/>
		  </btypes:TYPE>, we conclude that
		  <btypes:TYPE>
		    <Msub>
		      <type num="1" dash="'"/>
		      <fn>
			<type num="a"/>
			<type num="r"/>
		      </fn>
		    </Msub>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Using weakening lemmas
		  <btypes:TYPE>
		    <lem tag="T-Weakening"/>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset dash="'"/>
			<dCtset/>
			<gamma/>
			<store dash="'"/>
		      </assume>
		      <tqExpr>
			<aExpr num="2"/>
			<type num="2"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(3), we already have
		  <btypes:TYPE>
		    <Msub>
		      <type num="2"/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Msub>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <Msub>
		      <maxz>
			<type num="r"/>
		      </maxz>
		      <type/>
		    </Msub>
		  </btypes:TYPE>. Clearly, these types are consistent
		  with respect to the weakened constraints set
		  <btypes:TYPE>
		    <bCtset dash="'"/>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Now, using the T-App rule and 
		  <btypes:TYPE>
		    <defn tag="constraint-colection-ext-typ"/>
		  </btypes:TYPE>, 
		  we obtain
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset dash="'"/>
			<dCtset/>
			<gamma/>
			<store dash="'"/>
		      </assume>
		      <tqExpr>
			<apply>
			  <aExpr num="1" dash="'"/>
			  <aExpr num="2"/>
			</apply>
			<type/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-# (2):
	    </p>
	    <btypes:TYPE>
	      <opRule>
		<opPre>
		  <eval>
		    <opState>
		      <stack/>
		      <heap/>            
		      <aExpr num="2"/>
		    </opState>
		    <opState>
		      <stack dash="'"/>
		      <heap dash="'"/>
		      <aExpr num="2" dash="'"/>
		    </opState>
		  </eval>
		</opPre>
		<opConc>
		  <eval>
		    <opState>
		      <stack/>
		      <heap/>
		      <apply>
			<aVal num="1"/>
			<aExpr num="2"/>
		      </apply>
		    </opState>
		    <opState>
		      <stack dash="'"/>
		      <heap dash="'"/>
		      <apply>
			<aVal num="1"/>
			<aExpr num="2" dash="'"/>
		      </apply>
		    </opState>
		  </eval>
		</opConc>
	      </opRule>
	    </btypes:TYPE>
	    <p>
	      Similar to E-# (1).
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-App:
	    </p>
	    <btypes:TYPE>
	      <opRule>
		<opPre>
		  <notin>
		    <sLoc/>
		    <dom>
		      <stack/>
		    </dom>
		  </notin>
		</opPre>
		<opConc>
		  <eval>
		    <opState>
		      <stack/>
		      <heap/>
		      <apply>
			<lambda>
			  <id/>
			  <aExpr num="x"/>
			</lambda>
			<aVal/>
		      </apply>
		    </opState>
		    <opState>
		      <extend>
			<stack/>
			<mapping>
			  <sLoc/>
			  <aVal/>
			</mapping>  
		      </extend>            
		      <heap/>
		      <subst>
			<aExpr num="x"/>
			<id/>
			<sLoc/>
		      </subst>
		    </opState>
		  </eval>
		</opConc>
	      </opRule>
	    </btypes:TYPE>
	    <ol>
	      <li>
		<p>
		  Re-writing case&nbsp;(3) for
		  <btypes:TYPE>
		    <eq>
		      <aExpr num="1"/>
		      <lambda>
			<id/>
			<aExpr num="x"/>
		      </lambda>
		    </eq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <eq>
		      <aExpr num="2"/>
		      <aVal/>
		    </eq>
		  </btypes:TYPE> and using 
		  <btypes:TYPE>
		    <lem tag="T-inversion"/>
		  </btypes:TYPE> (inversion of typing), we have, for
		  some
		  <btypes:TYPE>
		    <subeq>
		      <dCtset num="1"/>
		      <dCtset/>
		    </subeq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <subeq>
		      <dCtset num="2"/>
		      <dCtset/>
		    </subeq>
		  </btypes:TYPE>,
		</p>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<tyRule>
			  <tyPre>
			    <Sjudge>
			      <assume>
				<extend>
				  <dCtset num="1"/>
				  <gamma/>
				  <mapping>
				    <id/>
				    <type num="a" dash="'"/>
				  </mapping>
				</extend>
				<store/>
			      </assume>
			      <tqExpr>
				<aExpr num="x"/>
				<type num="r" dash="'"/>
			      </tqExpr>
			    </Sjudge>
			  </tyPre>
			  <tyPre>
			    <eq under="minz">
			      <type num="a"/>
			      <type num="a" dash="'"/>
			    </eq>
			    <eq under="minz">
			      <type num="r"/>
			      <type num="r" dash="'"/>
			    </eq>
			  </tyPre>
			  <tyConc>
			    <TDjudge>
			      <lambda>
				<id/>
				<aExpr num="x"/>
			      </lambda>
			      <fn>
				<type num="a"/>
				<type num="r"/>
			      </fn>
			      <dCtset num="1"/>
			    </TDjudge>
			  </tyConc>
			</tyRule>
			<TDjudge>
			  <aVal/>
			  <type num="2"/>
			  <dCtset num="2"/>
			</TDjudge>
		      </tyPre>
		      <tyPre>
			<Msub>
			  <type num="1"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</Msub>
			<Msub>
			  <type num="2"/>
			  <minz>
			    <type num="a"/>
			  </minz>
			</Msub>
			<Msub>
			  <maxz>
			    <type num="r"/>
			  </maxz>
			  <type/>
			</Msub>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <unin>
			      <dCtset num="1"/>
			      <dCtset num="2"/>
			    </unin>
			    <gamma/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <apply>
			      <lambda>
				<id/>
				<aExpr num="x"/>
			      </lambda>
			      <aVal/>
			    </apply>
			    <type/>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>
		</btypes:TYPE>
		<p>
		  We also have
		  <btypes:TYPE>
		    <Sat>
		      <bCtset/>
		      <spset>
			<Sjudge>
			  <assume>
			    <unin>
			      <dCtset num="1"/>
			      <dCtset num="2"/>
			    </unin>
			    <gamma/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <apply>
			      <lambda>
				<id/>
				<aExpr num="x"/>
			      </lambda>
			      <aVal/>
			    </apply>
			    <type/>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>.		  
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(3.c.i), using weakening, we obtain
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<bCtset/>
			<dCtset num="1"/>
			<extend>
			  <gamma/>
			  <mapping>
			    <id/>
			    <type num="a" dash="'"/>
			  </mapping>
			</extend>
			<store/>
		      </assume>
		      <tqExpr>
			<aExpr num="x"/>
			<type num="r" dash="'"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  Using case&nbsp;(3.c.ii) and 
		  <btypes:TYPE>
		    <lem tag="T-LSubstitution"/>
		  </btypes:TYPE> (location substitution), we obtain
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<bCtset/>
			<dCtset num="1"/>
			<gamma/>
			<extend>
			  <store/>
			  <mapping>
			    <sLoc/>
			    <type num="a" dash="'"/>
			  </mapping>
			</extend>
		      </assume>
		      <tqExpr>
			<subst>
			  <aExpr num="x"/>
			  <id/>
			  <sLoc/>
			</subst>
			<type num="r" dash="'"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE> and therefore,
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset/>
			<dCtset/>
			<gamma/>
			<extend>
			  <store/>
			  <mapping>
			    <sLoc/>
			    <type num="a" dash="'"/>
			  </mapping>
			</extend>
		      </assume>
		      <tqExpr>
			<subst>
			  <aExpr num="x"/>
			  <id/>
			  <sLoc/>
			</subst>
			<type num="r" dash="'"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From 
		  <btypes:TYPE>
		    <Msub>
		      <maxz>
			<type num="r"/>
		      </maxz>
		      <type/>
		    </Msub>
		  </btypes:TYPE>, using
		  <btypes:TYPE>
		    <lem tag="T-Subtype-properties"/>
		  </btypes:TYPE>, we conclude that
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="r"/>
		      <type/>
		    </eq>
		  </btypes:TYPE>.
		  We already have
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="r"/>
		      <type num="r" dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		  Therefore, we conclude that
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="r" dash="'"/>
		      <type/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  We have
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset/>
			<dCtset/>
			<gamma/>
			<store/>
		      </assume>
		      <tqExpr>
			<aVal/>
			<type num="2"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>.
		  From
		  <btypes:TYPE>
		    <Msub>
		      <type num="2"/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Msub>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="a"/>
		      <type num="2"/>
		    </eq>
		  </btypes:TYPE>.
		  From case&nbsp;(3.c.i), we have
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="a"/>
		      <type num="a" dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		  Therefore, we obtain
		  <btypes:TYPE>
		    <eq under="minz">
		      <type num="a" dash="'"/>
		      <type num="2"/>
		    </eq>
		  </btypes:TYPE>.
		  Using these facts along with the premise
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset/>
			<dCtset/>
			<gamma/>
			<store/>
		      </assume>
		      <plus>
			<heap/>
			<stack/>
		      </plus>
		    </Sjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <defn tag="stack-heap-typing"/>
		  </btypes:TYPE>, we conclude that
		  <btypes:TYPE>
		    <Sjudge name="s">
		      <assume>
			<bCtset/>
			<dCtset/>
			<gamma/>
			<extend>
			  <store/>
			  <mapping>
			    <sLoc/>
			    <type num="a" dash="'"/>
			  </mapping>
			</extend>
		      </assume>
		      <plus>
			<heap/>
			<extend>
			  <stack/>
			  <mapping>
			    <sLoc/>
			    <aVal/>
			  </mapping>  
			</extend>            
		      </plus>
		    </Sjudge>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Set:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	  </btypes:TYPE>
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<TDjudge>
		  <aExpr num="1"/>
		  <type num="1"/>
		  <dCtset num="1"/>
		</TDjudge>
		<Msub>
		  <type num="1"/>
		  <mutable>
		    <ptype/>
		  </mutable>
		</Msub>
	      </tyPre>
	      <tyPre>
		<TDjudge>
		  <aExpr num="2"/>
		  <type num="2"/>
		  <dCtset num="2"/>
		</TDjudge>
		<Msub>
		  <type num="2"/>
		  <ptype/>
		</Msub>
		<Sjudge name="lval">
		  <assume/>
		  <aExpr num="1"/>
		</Sjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <assign>
		    <aExpr num="1"/>
		    <aExpr num="2"/>
		  </assign>
		  <unit/>
		  <unin>
		    <dCtset num="1"/>
		    <dCtset num="2"/>
		  </unin>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Cases E-L# and E-# follow from induction
	  hypothesis, similar to the T-App case.
	  Cases E-:=Stack, E-:=Heap, E=:=S.p and E-:=H.p
	  follow from 
	  <btypes:TYPE>
	    <lem tag="T-sh-safety"/>
	  </btypes:TYPE> (stack and heap assignment safety).
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="m">
		<id/>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </let>
	    </eq>
	  </btypes:TYPE>
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<TDjudge>
		  <aExpr num="1"/>
		  <type num="1"/>
		  <dCtset num="1"/>
		</TDjudge>
		<Msub>
		  <type num="1"/>
		  <type dash="'"/>
		</Msub>
		<Msub>
		  <type/>
		  <type dash="'"/>
		</Msub>
	      </tyPre>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <extend>
		      <dCtset num="2"/>
		      <gamma/>
		      <mapping>
			<id/>
			<type/>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </tqExpr>
		</Sjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <paren>
		    <let kind="m">
		      <id/>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </let>
		  </paren>
		  <type num="2"/>
		  <unin>
		    <dCtset num="1"/>
		    <dCtset num="2"/>
		  </unin>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  The case E-# follows from induction hypothesis using the 
	  T-Let-M rule. The case E-Let-M follows from 
	  <btypes:TYPE>
	    <lem tag="T-LSubstitution"/>
	  </btypes:TYPE> (location substitution) similar to T-App.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-MP:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="p">
		<id/>
 		<vExp/>
		<aExpr/>
	      </let>
	    </eq>
	  </btypes:TYPE>
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<TDjudge>
		  <vExp/>
		  <type num="v"/>
		  <dCtset num="1"/>
		</TDjudge>
		<Msub>
		  <type num="v"/>
		  <type num="1"/>
		</Msub>
		<Msub>
		  <type/>
		  <type num="1"/>
		</Msub>
	      </tyPre>
	      <tyPre>
		<eq>
		  <dCtset dash="'"/>
		  <unin>
		    <dCtset num="1"/>
		    <set>
		      <pcst>
			<id/>
			<lKind/>
			<type/>
		      </pcst>
		    </set>
		  </unin>
		</eq>
		<eq>
		  <set>
		    <tvars name="alpha"/>
		  </set>
		  <diff>
		    <ftvs>
		      <type/>
		      <dCtset dash="'"/>
		    </ftvs>
		    <ftvs>
		      <gamma/>
		      <store/>
		    </ftvs>
		  </diff>
		</eq>
	      </tyPre>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <extend>
		      <dCtset num="2"/>
		      <gamma/>
		      <mapping>
			<id/>
			<TS>
			  <tvars/>
			  <ctype>
			    <type/>
			    <dCtset dash="'"/>
			  </ctype>
			</TS>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type dash="'"/>
		  </tqExpr>
		  <models name="new">
		    <assume/>
		    <tvars name="beta"/>
		  </models>
		</Sjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <paren>
		    <let kind="x">
		      <id/>
		      <vExp/>
		      <aExpr/>
		    </let>
		  </paren>
		  <type num="2"/>
		  <unin>
		    <subst>
		      <dCtset/>
		      <tvars name="alpha"/>
		      <tvars name="beta"/>
		    </subst>
		    <dCtset num="2"/>
		  </unin>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  The case E-# 
	  follows from induction hypothesis using the 
	  T-Let-P rule. This is because 
	  <btypes:TYPE>
	    <vExp/>
	  </btypes:TYPE> can only take E-# steps that only have leaf
	  derivations of E-Rval step E-Rval steps, which does not
	  change the constraint set 
	  <btypes:TYPE>
	    <dCtset num="1"/>
	  </btypes:TYPE> in the type derivation.
	  If 
	  <btypes:TYPE>
	    <eq>
	      <lKind/>
	      <lKind k="poly"/>
	    </eq>
	  </btypes:TYPE>, the case E-Let-P follows from 
	  <btypes:TYPE>
	    <lem tag="T-VSubstitution2"/>
	  </btypes:TYPE> (value substitution).
	  Otherwise, if 
	  <btypes:TYPE>
	    <eq>
	      <lKind/>
	      <lKind k="mono"/>
	    </eq>
	  </btypes:TYPE>, the case E-Let-M follows from 
	  <btypes:TYPE>
	    <lem tag="T-LSubstitution2"/>
	  </btypes:TYPE> (location substitution).
	  The case
	  <btypes:TYPE>
	    <eq>
	      <lKind/>
	      <lKind k="var"/>
	    </eq>
	  </btypes:TYPE> cannot happen since 
	  <btypes:TYPE>
	    <aExpr/>
	  </btypes:TYPE> is a canonical expression.
	</p>
      </li>
    </ol>
  </proof>
  <theorem id="T-preservation">
    <title>Preservation</title>
    <p>
      For any canonical expression 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>,      
      if
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE> then,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<dCtset/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type dash="'"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </theorem>
  <proof>
    <p>
      From
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<TDjudge D="yes" name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE>, using 
      <btypes:TYPE>
	<defn tag="consistent-typing"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<defn tag="maybe-consistent"/> 
      </btypes:TYPE>, we conclude that
      <btypes:TYPE>
	<Exists/>
	<bCtset num="d"/>
	<text content=" and "/>
	<bCtset num="sh"/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset num="d"/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <bCtset num="sh"/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
      </btypes:TYPE>.
      Since the only type variables that need to be used in common in
      both derivations are those that are present in
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, we can construct a 
      <btypes:TYPE>
	<bCtset/>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<supeq>
	  <bCtset/>
	  <bCtset num="d"/>
	</supeq>
      </btypes:TYPE>,
      <btypes:TYPE>
	<supeq>
	  <bCtset/>
	  <bCtset num="sh"/>
	</supeq>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<meta>
	  <bCtset/>
	</meta>
      </btypes:TYPE>.
      Now, by weakening, we have
      <btypes:TYPE>
	<Sjudge name="s">
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Sjudge name="s">
	  <assume>
	    <bCtset/>
	    <dCtset/>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
      </btypes:TYPE>.
      The result now follows from
      <btypes:TYPE>
	<thm tag="T-subject-reduction"/>
      </btypes:TYPE> (subject reduction).
    </p>
  </proof>
  <definition id="stuck_state">
    <title>Stuck State</title>
    <p>
      A system state
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      is said to be <term>stuck</term> if
      <btypes:TYPE>
	<neq>
	  <aExpr/>
	  <aVal/>
	</neq>
      </btypes:TYPE>
      and there are no
      <btypes:TYPE>
	<stack dash="'"/>
	<text content=", "/>
	<heap dash="'"/>
	<text content=", and "/>
	<aExpr dash="'"/>
      </btypes:TYPE>
      such that
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>.
    </p>
  </definition>
  <theorem id="T-soundness">
    <title>Type Soundness</title>
    <p>
      For any canonical expression 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>, if
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <dCtset/>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>,
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <dCtset/>
	    <Empty/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<models>
	  <assume/>
	  <dCtset/>
	</models>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<eval many="yes">
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      then
      <btypes:TYPE>
	<opState>
	  <stack dash="'"/>
	  <heap dash="'"/>
	  <aExpr dash="'"/>
	</opState>
      </btypes:TYPE> is not stuck.
      That is, execution of a closed, canonical, well typed expression
      cannot lead to a stuck state. Here,
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE > represents the
      reflexive-transitive-closure of
      <btypes:TYPE>
	<evalOp/>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By straightforward induction on the length of
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE>. If
      <btypes:TYPE>
	<eq>
	  <aExpr/>
	  <aVal/>
	</eq>
      </btypes:TYPE>, proof is immediate. Otherwise, from
      Lemma&nbsp;<xref ref="T-progress"/> (Progress),
      we know that we can take at least one step forward. Further,
      from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation),
      we know that a (left/right) execution of a well
      typed expression in with respect to a well typed stack and heap
      will always result in another well typed expression, stack
      and heap. Proof now follows from induction hypothesis.
    </p>
  </proof>
  </sect1>
