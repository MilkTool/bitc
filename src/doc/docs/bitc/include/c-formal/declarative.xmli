<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="declarative_types"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Declarative Type System</title>
  <definition id="val_res">
    <title>Value Restriction</title>
    <p>
      We define some definitions used in the enforcement of value
      restriction.
    </p>
    <example>
      <p>
	<btypes:TYPE>
	  <fnxn name="Value">
	    <aVal/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <id/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <hLoc/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <sLoc/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <dup>
	      <aExpr/>
	    </dup>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <deref>
	      <aExpr/>
	    </deref>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <eq>
	    <grouping>
	      <pred name="Value">
		<if>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		  <aExpr num="3"/>
		</if>
	      </pred>
	      <br/>
	    </grouping>
	    <AND>
	      <pred name="Value">
		<aExpr num="1"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="2"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="3"/>
	      </pred>
	    </AND>
	  </eq>
	  <br/>
	  <fnxn name="Value">
	    <Pair>
	      <aExpr num="1"/>
	      <aExpr num="2"/>
	    </Pair>
	    <AND>
	      <pred name="Value">
		<aExpr num="1"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="2"/>
	      </pred>
	    </AND>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <fst>
	      <aExpr/>
	    </fst>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <snd>
	      <aExpr/>
	    </snd>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <let>
	      <id/>
	      <aExpr num="1"/>
	      <aExpr num="2"/>
	    </let>
	    <AND>
	      <pred name="Value">
		<aExpr num="1"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="2"/>
	      </pred>
	    </AND>
	  </fnxn>
	  <br/>
	  <eq>
	    <grouping>
	      <pred name="Value">
		<aExpr/>
	      </pred>
	      <text content=" (otherwise) "/>
	    </grouping>
	    <FALSE/>
	  </eq>
	  <br/>
	  <br/>
	  <fnxn name="Expansive">
	    <aExpr/>
	    <NOT>
	      <pred name="Value">
		<aExpr/>
	      </pred>
	    </NOT>
	  </fnxn>
	</btypes:TYPE>
      </p>
    </example>
  </definition>
  <definition>
    <title>Stack and Heap Typing</title>
    <p>
      A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
      <btypes:TYPE><stack/></btypes:TYPE> are said to be <em>well
	typed</em> with respect to a binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and store typing
      <btypes:TYPE><store/></btypes:TYPE>, and written
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Msub>
		<mapsto><heap/><hLoc/></mapsto>
		<mapsto><store/><hLoc/></mapsto>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Msub>
		<mapsto><stack/><sLoc/></mapsto>
		<mapsto><store/><sLoc/></mapsto>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="valid-lval">
    <title>Valid Lvalues</title>
    <p>
      We say that an lvalue
      <btypes:TYPE>
	<lVal/>
      </btypes:TYPE> is valid with respect to a stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE> and heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, written
      <btypes:TYPE>
	<Sjudge name="v">
	  <assume>
	    <plus>
	      <heap/>
	      <stack/>
	    </plus>
	  </assume>
	  <lVal/>
	</Sjudge>
      </btypes:TYPE> if one of the following conditions hold for some
      <btypes:TYPE>
	<path/>
      </btypes:TYPE>:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </definition>
  <lemma id="T-inversion">
    <title>Inversion of Typing Relation</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <Unit/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <true/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <false/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <hLoc/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <lambda>
		<id/>
		<aExpr/>
	      </lambda>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </fn>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>
		    <type num="1"/>
		  </mapping>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <deref>
		<aExpr/>
	      </deref>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of typing relation.
    </p>
  </proof>
  <lemma id="T-sub-inversion">
    <title>Inversion of Copy Coercion</title>
    <p>
      For any type
      <btypes:TYPE>
	<pType/>
	<text content=" and "/>
	<tvar/>
      </btypes:TYPE>, let
      <btypes:TYPE>
	<eq>
	  <pred name="Q">
	    <pType/>
	  </pred>
	  <set>
	    <pType/>
	    <mutable>
	      <pType/>
	    </mutable>
	    <mbTop>
	      <tvar/>
	      <pType/>
	    </mbTop>
	    <mbTop>
	      <tvar/>
	      <mutable>
		<pType/>
	      </mutable>
	    </mbTop>
	    <mbFull>
	      <tvar/>
	      <pType/>
	    </mbFull>
	    <mbFull>
	      <tvar/>
	      <mutable>
		<pType/>
	      </mutable>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <pType/>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <mutable>
		<pType/>
	      </mutable>
	    </mbFull>
	  </set>
	</eq>
      </btypes:TYPE>. Then,
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <bool/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<bool/>
	      </pred>
	    </in>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <unit/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<unit/>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<ref>
		  <type dash="'"/>
		</ref>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<fn>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</fn>
	      </pred>
	    </in>
	    <text content=", where "/>
	    <eq>
	      <minz>
		<type num="1"/>
	      </minz>
	      <minz>
      		<type num="1" dash="'"/>
	      </minz>
	    </eq>      
	    <text content=" and "/>
	    <eq>
	      <maxz>
		<type num="2"/>
	      </maxz>
	      <maxz>
		<type num="2" dash="'"/>
	      </maxz>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </pred>
	    </in>
	    <text content=", such that "/>
	    <Msub>
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </Msub>
	    <text content=" and "/>	    
	    <Msub>
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the copy coercion derivation.
    </p>
  </proof>
  <lemma id="T-canonical">
    <title>Canonical Forms</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <unit/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Unit/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <bool/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is either "/>
	    <true/>
	    <text content=" or "/>
	    <false/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <ref>
		<type/>
	      </ref>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <hLoc/>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <lambda>
	      <id/>
	      <aExpr/>
	    </lambda>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <pair>
	      <aVal num="1"/>
	      <aVal num="2"/>
	    </pair>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By inspecting the possibilities for the derivation of
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <p>
      According to the grmmar of the language 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, values can be of one of the following forms:
      <btypes:TYPE>
	<collection>
	  <Unit/>
	  <true/> 
	  <false/>
	  <hLoc/>
	  <lambda>
	    <id/>
	    <aExpr/>
	  </lambda>
	  <Pair>
	    <aVal/>
	    <aVal/>
	  </Pair>
	</collection>
      </btypes:TYPE>
    </p>
    <p>
      Consider the case (2), where
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <bool/>
	</TDjudge>
      </btypes:TYPE>. That is,
      <btypes:TYPE>
	<TDjudge>
	  <aVal/>
	  <type/>
	</TDjudge>
	<text content=" and "/>
	<Msub>
	  <type/>
	  <bool/>
	</Msub>
      </btypes:TYPE>.
      From 
      <btypes:TYPE>
	<lem tag="T-sub-inversion"/>
      </btypes:TYPE> (inversion of copy-coercion), we know that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <pred name="Q">
	    <bool/>
	  </pred>
	</in>
      </btypes:TYPE>. 
      <btypes:TYPE>
	<text content=" That is, for some "/>
	<tvar/>
	<text content=", the type "/>
	<type/>
	<text content=" equals one of: "/>
	<collection or="yes">
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	  <mbTop>
	    <tvar/>
	    <bool/>
	  </mbTop>
	  <mbTop>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbTop>
	  <mbFull>
	    <tvar/>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	</collection>
      </btypes:TYPE>.
      If
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <bool/>
	</eq>
      </btypes:TYPE>, it is clear that the final rule in the
      derivation must be T-True, or T-False. A derivation with these
      rules is only possible if 
      <btypes:TYPE>
 	<eq>
	  <aVal/>
	  <true/>
	</eq>
	<text content=" or "/>
 	<eq>
	  <aVal/>
	  <false/>
	</eq>
      </btypes:TYPE>.
      Further, the cases like 
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE>
      cannot happen because there is no rule that
      derives a mutable/maybe type for a value.
    </p>
    <p>
      Other cases of the lemma are similar.
    </p>
  </proof>
  <lemma id="T-progress">
    <title>Progress</title>
    <p>
      <btypes:TYPE>
	<text content="If "/>
	<aExpr/>
	<text content=" is a closed, well typed term, "/>
	<text content="that is, "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" for some "/>
	<type/>
	<text content=" and "/>
	<store/>
	<text content=", given any heap "/>
	<heap/>
	<text content=" and stack "/>
	<stack/>
	<text content=" such that "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
	<text content=", "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content=" If "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	    <text content=", then "/>
	    <aExpr/>
	    <text content=" is either a valid lvalue "/>
	    <text content="(that is, "/>
	    <eq>
	      <aExpr/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	    <text content=") or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a value "/>
	    <aVal/>
	    <text content=" or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
	  (Values) Result is immediate for right execution, and
	  cannot happen for left execution.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id: cannot happen. 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id/>
	    </eq>
	  </btypes:TYPE> is not a closed term.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Immediate for left execution. Right
	  execution and can always continue with E-Rval rule as the
	  stack is well typed
	  (<btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-App: Only right execution is possible, no application is well
	  typed as an lvalue. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<type num="1"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE> is not a value, execution can continue via
	  the E-App1# due to induction hypothesis. Similarly, if 
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-App2#. 
	  Now, consider the case when both
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" and "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  are values. Since we know that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>, from 
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms) we conclude that 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is of the form
	  <btypes:TYPE>
	    <lambda>
	      <id/>
	      <aExpr dash="'"/>
	    </lambda>
	  </btypes:TYPE>. Now, we can take the step E-App.
	</p>
      </li>
      <li>
	<p>
	  Case T-If: Similar to T-App, only right execution is
	  permitted.
	</p>
      </li>
      <li>
	<p>
	  Case T-Set: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<mutable>
		  <pType/>
		</mutable>
	      </Msub>
	    </Sjudge>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<pType/>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  not an lvalue, since we have
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>
	  we can take E-:=lhs# by induction hypothesis.
	  Similarly, if
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-:=rhs#.
	</p>
	<p>
	  Finally, we consider the case where
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <eq>
	      <aExpr num="2"/>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>.
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>	    
	  should be one of
	  <btypes:TYPE>
	    <collection or = "yes">
	      <sLoc/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	      <deref>
		<hLoc/>
	      </deref>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </collection>
	  </btypes:TYPE>.
	  Now, we proceed by induction on the length of
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <sLoc/>
		</eq>
	      </btypes:TYPE>. We know from induction hypothesis
	      that that 
	      <btypes:TYPE>
		<Sjudge name="v">
		  <assume>
		    <heap/>
		    <stack/>
		  </assume>
		  <sLoc/>
		</Sjudge>
	      </btypes:TYPE> and from 
	      <btypes:TYPE>
		<defn tag="valid-lval"/>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<in>
		  <sLoc/>
		  <dom>
		    <stack/>
		  </dom>
		</in>
	      </btypes:TYPE>. Now, execution can continue
	      with E-:Stack.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <deref>
		    <hLoc/>
		  </deref>
		</eq>
	      </btypes:TYPE>, the execution can continue with step	    
	      E:-Heap.
	    </p>
	  </li>
	  <li>
	    <p>
	      Assume (by hypothesis) that the execution can continue for 
	      some 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1" dash="'"/>
		  <select>
		    <sLoc/>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, let
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <sLoc/>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We know that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aExpr num="1"/>
		    <mutable>
		      <pType/>
		    </mutable>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
		<text content=" and "/>
		<Msub>
		  <type num="1"/>
		  <mutable>
		    <pType/>
		  </mutable>
		</Msub>
	      </btypes:TYPE>.
	      That is,
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <select>
		      <fst>
			<sLoc/>
		      </fst>
		      <path/>
		    </select>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. 
	      The first two steps of this derivation must be 
	      T-Sloc and T-Fst.
	      From the assumption of T-Fst rule, we must have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <sLoc/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE> for some type
	      <btypes:TYPE>
		<type num="2"/>
	      </btypes:TYPE>.
	      Now, from the assumption of T-Sloc rule, we must have
	      <btypes:TYPE>
		<Msub>
		  <mapsto>
		    <store/>
		    <sLoc/>
		  </mapsto>
		  <pair>
		    <type num="1"/>
		    <type num="2"/>
		  </pair>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, if 
	      <btypes:TYPE>
		<mapsto>
		  <stack/>
		  <sLoc/>
		  <aVal/>
		</mapsto>
	      </btypes:TYPE>, 
	      since we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr >
		    <stack/>
		    <heap/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>, 
	      we conclude that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aVal/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(f) and
	      <btypes:TYPE>
		<lem tag="T-sub-inversion"/>
	      </btypes:TYPE> (inversion of copy-coercion), we conclude
	      that 
	      <btypes:TYPE>
		<eq>
		  <aVal/>
		  <Pair>
		    <aVal num="1"/>
		    <aVal num="2"/>
		  </Pair>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(c and g), we conclude that the
	      execution can continue using the E:-S.1 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <sLoc/>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      the execution can continue using E:-S.2 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similar to the above induction, we can show that if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <deref>
			<hLoc/>
		      </deref>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H1 rule, and if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <deref>
			<hLoc/>
		      </deref>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H2 rule.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Dup: Only right execution is
	  permitted, and can take E-Dup# or E-Dup as
	  applicable.
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr num="1"/>
	      </deref>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  Execution can take EL-^# or E-^# as
	  applicable if
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is a value, then, from
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms), we conclude that 
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <hLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	  Now, since this is an lvalue, we are done in the case of
	  left execution. In the case of right execution, we can
	  take step E-^.
	</p>
      </li>
      <li>
	<p>
	  Case T-Pair: Similar to case T-Dup
	</p>
      </li>
      <li>
	<p>
	  Case T-Fst, Case T-Snd: Similar to case T-Deref.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="m">
		<id/>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </let>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, we can take E-Let-M.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-P: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="p">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, the execution can take E-Let-P.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-Weakening">
    <title>Weakening</title>
    <p>
      We will write
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <GEN>
	      <type/>
	      <aTS/>
	    </GEN>
	  </tqExpr>
	</Sjudge>
	<text content=" as a shorthand for "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", and "/>
	<Sjudge name="gen">
	  <assume>
	    <gamma/>
	    <store/>
	    <aExpr/>
	  </assume>
	  <GEN>
	    <type/>
	    <aTS/>
	  </GEN>
	</Sjudge>
	<text content="."/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  then,
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <gamma dash="'"/>
		  <gamma/>
		</supeq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<GEN>
		  <type/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	    <text content=", "/>
	    <eq>
	      <aTS/>
	      <forall>
		<tvars name="alpha"/>
		<type/>
	      </forall>
	    </eq>
	  </btypes:TYPE>
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <gamma dash="'"/>
		  <gamma/>
		</supeq>
		<text content=" and "/>
		<eq>
		  <inter>
		    <ftvs>
		      <gamma dash="'"/>
		    </ftvs>
		    <ftvs>
		      <tvars name="alpha"/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <GEN>
		      <type/>
		      <aTS/>
		    </GEN>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
		<text content=" and "/>
		<eq>
		  <inter>
		    <ftvs>
		      <store dash="'"/>
		    </ftvs>
		    <ftvs>
		      <tvars name="alpha"/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <GEN>
		      <type/>
		      <aTS/>
		    </GEN>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Straightforward induction on the typing derivation.
    </p>
  </proof>
  <lemma id="Cst-Weakening">
    <title>Weakening of Consistency</title>
    <p>
      If
      <btypes:TYPE>
	<subeq>
	  <set>
	    <solvables num="2"/>
	  </set>
	  <set>
	    <solvables num="1"/>
	  </set>
	</subeq>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<in>
	  <type/>
	  <solvable/>
	</in>
      </btypes:TYPE>, then,      
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <CST>
	      <solvables num="1"/>
	    </CST>
	  </btypes:TYPE>
	  implies
	  <btypes:TYPE>
	    <CST>
	      <solvables num="2"/>
	    </CST>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <CST>
	      <solvable/>
	    </CST>
	  </btypes:TYPE>
	  implies
	  <btypes:TYPE>
	    <CST>
	      <type/>
	    </CST>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Forall>
	      <aSubMap/>
	    </Forall>
	  </btypes:TYPE>, 
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <set>
		<solvables num="1"/>
	      </set>
	    </models>
	  </btypes:TYPE>
	  implies
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <set>
		<solvables num="2"/>
	      </set>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Forall>
	      <aSubMap/>
	    </Forall>
	  </btypes:TYPE>, 
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <set>
		<solvable/>
	      </set>
	    </models>
	  </btypes:TYPE>
	  implies
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type/>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Evident from 
      <btypes:TYPE>
	<defn tag="maybe-consistent"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<defn tag="subst-consistent"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-Subtype-properties">
    <title>Properties of Copy Coercion</title>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type dash="'"/>
	    </CST>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <type/>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <type/>
		  </maxz>
		  <type dash="'"/>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <type/>
		  </maxz>
		  <maxz>
		    <type dash="'"/>
		  </maxz>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type/>
		  </minz>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	    </CST>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type/>
 	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	      <type num="3"/>
	    </CST>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	    </CST>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
 	      <type num="2"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	      <type num="3"/>
	    </CST>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Property 1: By straightforward induction on the copy-coercion
      derivation, and using
      <btypes:TYPE>
	<defn tag="maybe-consistent"/>
      </btypes:TYPE>.
    </p>
    <p>
      Property 2: By construction of 
      <btypes:TYPE>
	<type num="3"/>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From 	  
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	    </CST>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <lem tag="Cst-Weakening"/>
	  </btypes:TYPE> (weakening), we have 
	  <btypes:TYPE>
	    <CST>
	      <type num="1"/>
	      <type num="2"/>
	    </CST>
	  </btypes:TYPE>. 
	</p>
      </li>
      <li>
	<p>
	  From the above case, and property 1.d above, we have
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Similarly, we have
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From cases&nbsp;(2 and 3), we obtain
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Let us pick
	  <btypes:TYPE>
	    <type num="3"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq>
	      <type num="3"/>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type num="1"/>
	      </minz>
	      <minz>
		<type num="2"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	  It is evident that 
	  <btypes:TYPE>
	    <CST>
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	      <type num="3"/>
	    </CST>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From S-Refl rule in 
	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>. From this, and the fact that
	  <btypes:TYPE>
	    <CST>
	      <type num="1"/>
	    </CST>
	  </btypes:TYPE>, using property 1.a, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <minz>
		<type num="1"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE>.
	  From case&nbsp;(5), we can write this as
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Similarly, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
    <p>
      Property 3: Similar to Property 2.
    </p>
  </proof>
  <lemma id="T-msm_eq_ms">
    <title>Type Substitution Canonicalization</title>
    <p>
      For any type 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> and substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE>, we have:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <minz>
		    <type/>
		  </minz>
		</Subst>
	      </minz>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <maxz>
		    <type/>
		  </maxz>
		</Subst>
	      </minz>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <maxz>
		<Subst>
		  <aSubMap/>
		  <maxz>
		    <type/>
		  </maxz>
		</Subst>
	      </maxz>
	      <maxz>
		<Subst>
		  <aSubMap/>
		  <minz>
		    <type/>
		  </minz>
		</Subst>
	      </maxz>
	      <maxz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </maxz>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <minzT>
		<Subst>
		  <aSubMap/>
		  <minzT>
		    <type/>
		  </minzT>
		</Subst>
	      </minzT>
	      <minzT>
		<Subst>
		  <aSubMap/>
		  <maxzT>
		    <type/>
		  </maxzT>
		</Subst>
	      </minzT>
	      <minzT>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minzT>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <maxzT>
		<Subst>
		  <aSubMap/>
		  <maxzT>
		    <type/>
		  </maxzT>
		</Subst>
	      </maxzT>
	      <maxzT>
		<Subst>
		  <aSubMap/>
		  <minzT>
		    <type/>
		  </minzT>
		</Subst>
	      </maxzT>
	      <maxzT>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </maxzT>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the structure of 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>. The only interesting cases are
      <btypes:TYPE>
	<mbTop>
	  <sType dash="'"/>
	  <sType/>
	</mbTop>
      </btypes:TYPE> and
      <btypes:TYPE>
	<mbFull>
	  <pType/>
	  <sType/>
	</mbFull>
      </btypes:TYPE>. In these cases, the substitution into
      <btypes:TYPE>
	<sType dash="'"/>
      </btypes:TYPE> and
      <btypes:TYPE>
	<pType/>
      </btypes:TYPE> do not matter as they are disregarded by 
      <btypes:TYPE>
	<maxzOp/>
	<text content=" and "/>
	<minzOp/>
      </btypes:TYPE> functions. Similar is the case for the properties
      with respect to 
      <btypes:TYPE>
	<maxzTOp/>
	<text content=" and "/>
	<minzTOp/>
      </btypes:TYPE> opeartors.
    </p>
  </proof>
  <lemma id="norm-subst-compose">
    <title>Multiple Substitution Canonicalization</title>
    <p>
      <!-- Only S1 needs to be idempotent in this case -->
      If
      <btypes:TYPE>
	<eq>
	  <inter>
	    <dom>
	      <aSubMap num="2"/>
	    </dom>
	    <ftvs>
	      <aSubMap num="1"/>
	    </ftvs>
	  </inter>
	  <Empty/>
	</eq>
      </btypes:TYPE>, 
      then, 
      <br/>
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <Subst>
		<aSubMap num="1"/>
		<type/>
	      </Subst>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <aSubMap num="2"/>
	    </Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>
    </p>
    <proof>
      <p>
	By induction on the structure of 
	<btypes:TYPE>
	  <type/>
	</btypes:TYPE>. The only interesting cases are
	<btypes:TYPE>
	  <eq>
	    <type/>
	    <mbTop>
	      <tvar/>
	      <pType/>
	    </mbTop>
	  </eq>
	</btypes:TYPE> and
	<btypes:TYPE>
	  <eq>
	    <type/>
	    <mbFull>
	      <tvar/>
	      <pType/>
	    </mbFull>
	  </eq>
	</btypes:TYPE>.
	We only show that proof for
	<btypes:TYPE>
	  <eq>
	    <type/>
	    <mbTop>
	      <tvar/>
	      <pType/>
	    </mbTop>
	  </eq>
	</btypes:TYPE>.
      </p>
      <ol>
	<li>
	  <p>
	    By induction hypothesis, we have
	    <btypes:TYPE>
	      <eq>
		<Subst>
		  <aSubMap num="1"/>
		  <Subst>
		    <aSubMap num="2"/>
		    <Subst>
		      <aSubMap num="1"/>
		      <pType/>
		    </Subst>
		  </Subst>
		</Subst>
		<Subst>
		  <aSubMap num="1"/>
		  <Subst>
		    <aSubMap num="2"/>
		    <pType/>
		  </Subst>
		</Subst>
		<Subst>
		  <Subst>
		    <aSubMap num="1"/>
		    <aSubMap num="2"/>
		  </Subst>
		  <Subst>
		    <aSubMap num="1"/>
		    <pType/>
		  </Subst>
		</Subst>
	      </eq>
	    </btypes:TYPE>.
	  </p>
	</li>
	<li>
	  <p>
	    If
	    <btypes:TYPE>
	      <notin>
		<tvar/>
		<dom>
		  <aSubMap num="1"/>
		</dom>
	      </notin>
	    </btypes:TYPE> and
	    <btypes:TYPE>
	      <notin>
		<tvar/>
		<dom>
		  <aSubMap num="2"/>
		</dom>
	      </notin>
	    </btypes:TYPE>, the result follows from 
	    induction hypothesis.
	  </p>
	</li>
	<li>
	  <p>
	    If
	    <btypes:TYPE>
	      <in>
		<tvar/>
		<dom>
		  <aSubMap num="1"/>
		</dom>
	      </in>
	    </btypes:TYPE>, then,
	  </p>
	  <ol>
	    <li>
	      <p>
		Since
		<btypes:TYPE>
		  <eq>
		    <inter>
		      <dom>
			<aSubMap num="2"/>
		      </dom>
		      <ftvs>
			<aSubMap num="1"/>
		      </ftvs>
		    </inter>
		    <Empty/>
		  </eq>
		</btypes:TYPE>, we have
		<btypes:TYPE>
		  <notin>
		    <tvar/>
		    <dom>
		      <aSubMap num="2"/>
		    </dom>
		  </notin>
		</btypes:TYPE>.
		Therefore,
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="2"/>
		      <mbTop>
			<tvar/>
			<pType/>
		      </mbTop>
		    </Subst>
		    <mbTop>
		      <tvar/>	
		      <Subst>
			<aSubMap num="2"/>
			<pType/>
		      </Subst>
		    </mbTop>
		  </eq>
		</btypes:TYPE>
	      </p>
	    </li>
	    <li>
	      <p>
		Further, since
		<btypes:TYPE>
		  <eq>
		    <inter>
		      <dom>
			<aSubMap num="2"/>
		      </dom>
		      <ftvs>
			<aSubMap num="1"/>
		      </ftvs>
		    </inter>
		    <Empty/>
		  </eq>
		</btypes:TYPE>, we have
		<btypes:TYPE>
		  <eq>
		    <inter>
		      <dom>
			<aSubMap num="2"/>
		      </dom>
		      <ftvs>
			<range>
			  <aSubMap num="1"/>
			</range>
		      </ftvs>
		    </inter>
		    <Empty/>
		  </eq>
		</btypes:TYPE>. Therefore, if
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="1"/>
		      <tvar/>
		    </Subst>
		    <pType num="1"/>
		  </eq>
		</btypes:TYPE>, then
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="2"/>
		      <pType num="1"/>
		    </Subst>
		    <pType num="1"/>
		  </eq>
		</btypes:TYPE>.
	      </p>
	    </li>
	    <li>
	      <p>
		Suppose
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="1"/>
		      <tvar/>
		    </Subst>
		    <tvar name="beta"/>
		  </eq>
		</btypes:TYPE>. Therefore,
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="1"/>
		      <mbTop>
			<tvar/>
			<pType/>
		      </mbTop>
		    </Subst>
		    <mbTop>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap num="1"/>
			<pType/>
		      </Subst>
		    </mbTop>
		  </eq>
		</btypes:TYPE>.
	      </p>
	      <ol>		
		<li>
		  <p>
		    Due to case&nbsp;(3.b), 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="2"/>
			  <tvar name="beta"/>
			</Subst>
			<tvar name="beta"/>
		      </eq>
		    </btypes:TYPE>. This, along with case&nbsp;(3.c) 
		    gives us
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<mbTop>
			  <tvar name="beta"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <pType/>
			    </Subst>
			  </Subst>
			</mbTop>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Due to the idempotence of the substitution
		    <btypes:TYPE>
		      <aSubMap num="1"/>
		    </btypes:TYPE>,
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<mbTop>
			  <tvar name="beta"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <Subst>
			      <aSubMap num="2"/>
			      <Subst>
				<aSubMap num="1"/>
				<pType/>
			      </Subst>
			    </Subst>
			  </Subst>
			</mbTop>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Similarly, 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<mbTop>
			  <tvar name="beta"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <Subst>
			      <aSubMap num="2"/>
			      <pType/>
			    </Subst>
			  </Subst>
			</mbTop>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Similarly,
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<mbTop>
			  <tvar name="beta"/>
			  <Subst>
			    <Subst>
			      <aSubMap num="1"/>
			      <aSubMap num="2"/>
			    </Subst>
			    <Subst>
			      <aSubMap num="1"/>
			      <pType/>
			    </Subst>
			  </Subst>
			</mbTop>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Now, the result follows from induction hypothesis.
		    From cases&nbsp;(1, 3.c.ii, 3.c.iii, and 3.c.iv),
		    we have 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
	      </ol>
	    </li>
	    <li>
	      <p>
		Suppose
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="1"/>
		      <tvar/>
		    </Subst>
		    <pType num="1"/>
		  </eq>
		  <text content=" | "/>
		  <neq>
		    <pType num="1"/>
		    <tvar name="beta"/>
		  </neq>
		</btypes:TYPE>. Therefore,
		<btypes:TYPE>
		  <eq>
		    <Subst>
		      <aSubMap num="1"/>
		      <mbTop>
			<tvar/>
			<pType/>
		      </mbTop>
		    </Subst>
		    <pType num="1"/>
		  </eq>
		</btypes:TYPE>
		(ref: substitution rules in 
		figure&nbsp;<xref ref="subst_rules"/>).
	      </p>
	      <ol>		
		<li>
		  <p>
		    Due to case&nbsp;(3.b), 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="2"/>
			  <pType num="1"/>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>. This, along with case&nbsp;(3.d) 
		    gives us
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    From case&nbsp;(3.d.1), 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </eq>
		    </btypes:TYPE>
		    Due to the idempotence of the substitution
		    <btypes:TYPE>
		      <aSubMap num="1"/>
		    </btypes:TYPE>,
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <pType/>
			  </mbTop>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>.
		    Therefore,
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Similarly, 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <pType/>
			  </mbTop>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
		<li>
		  <p>
		    Due to case&nbsp;(3.a), 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <Subst>
			      <aSubMap num="2"/>
			      <pType/>
			    </Subst>
			  </mbTop>
			</Subst>
			<pType num="1"/>
		      </eq>
		    </btypes:TYPE>
		    (ref: substitution rules in 
		    figure&nbsp;<xref ref="subst_rules"/>).
		  </p>
		</li>
		<li>
		  <p>
		    From cases&nbsp;(3.d.ii, 3.d.iii, and 3.d.iv),
		    we have 
		    <btypes:TYPE>
		      <eq>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <mbTop>
				<tvar/>
				<pType/>
			      </mbTop>
			    </Subst>
			  </Subst>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <pType/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </eq>
		    </btypes:TYPE>.
		  </p>
		</li>
	      </ol>
	    </li>
	  </ol>
	</li>
	<li>
	  <p>
	    If
	    <btypes:TYPE>
	      <in>
		<tvar/>
		<dom>
		  <aSubMap num="2"/>
		</dom>
	      </in>
	    </btypes:TYPE>, then,
	    <btypes:TYPE>
	      <in>
		<tvar/>
		<dom>
		  <aSubMap num="1"/>
		</dom>
	      </in>
	    </btypes:TYPE>. The proof for this case is similar to
	    case&nbsp;(3). However, in this case, it is possible
	    that
	    <btypes:TYPE>
	      <neq>
		<inter>
		  <dom>
		    <aSubMap num="1"/>
		  </dom>
		  <ftvs>
		    <range>
		      <aSubMap num="2"/>
		    </range>
		  </ftvs>
		</inter>
		<Empty/>
	      </neq>
	    </btypes:TYPE>, which leads a further level of case analysis.
	  </p>
	</li>
      </ol>
    </proof>
  </lemma>
  <lemma id="T-SSubstitution">
    <title>Sub-Type Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
	<text content=", then for any substitution "/>
	<aSubMap/>
	<text content=" such that "/>
	<Cst>
	  <assume/>
	  <Subst>
	    <aSubMap/>
	    <set>
	      <type num="1"/>
	      <type num="2"/>
	    </set>
	  </Subst>
	</Cst>
      </btypes:TYPE>,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="2"/>
	      </Subst>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type num="2"/>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Msub>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <Subst>
		<aSubMap/>
		<type num="2"/>
	      </Subst>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <maxz>
		<Subst>
		  <aSubMap/>
		  <type num="1"/>
		</Subst>
	      </maxz>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Msub>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <Subst>
		<aSubMap/>
		<type num="2"/>
	      </Subst>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE>. We give the proof for the first property only,
      the second property is similarly proved.
    </p>
    <ol>
      <li>
	<p>
	  Case S-Refl is trivial. Cases S-Trans follows from induction
	  hypothesis.
	</p>
      </li>
      <li>
	<p>
	  Case S-Fn: Here, 
	  <btypes:TYPE>
	    <eq>
	      <type num="1"/>
	      <fn>
		<type num="a"/>
		<type num="r"/>
	      </fn>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <type num="2"/>
	      <fn>
		<type num="a" dash="'"/>
		<type num="r" dash="'"/>
	      </fn>
	    </eq>
	  </btypes:TYPE>, and we have
	  <btypes:TYPE>
	    <Msub>
	      <fn>
		<type num="a"/>
		<type num="r"/>
	      </fn>
	      <fn>
		<type num="a" dash="'"/>
		<type num="r" dash="'"/>
	      </fn>
	    </Msub>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      From the assumptions of this derivation of
	      <btypes:TYPE>
		<Msub>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		  <fn>
		    <type num="a" dash="'"/>
		    <type num="r" dash="'"/>
		  </fn>
		</Msub>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type num="a"/>
		  </minz>
		  <minz>
		    <type num="a" dash="'"/>
		  </minz>
		</eq>
	      </btypes:TYPE>, and
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <type num="r"/>
		  </maxz>
		  <maxz>
		    <type num="r" dash="'"/>
		  </maxz>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Therefore, we must have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <minz>
		      <type num="a"/>
		    </minz>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <minz>
		      <type num="a" dash="'"/>
		    </minz>
		  </Subst>
		</eq>
	      </btypes:TYPE>, and
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <maxz>
		      <type num="r"/>
		    </maxz>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <maxz>
		      <type num="r" dash="'"/>
		    </maxz>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Further, we can write:
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a" dash="'"/>
		      </minz>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>, and
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <maxz>
			<type num="r"/>
		      </maxz>
		    </Subst>
		  </maxz>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <maxz>
			<type num="r" dash="'"/>
		      </maxz>
		    </Subst>
		  </maxz>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(2.c) and 
	      <btypes:TYPE>
		<lem tag="T-msm_eq_ms"/>
	      </btypes:TYPE>, we can write:
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a" dash="'"/>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>, and
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <type num="r"/>
		    </Subst>
		  </maxz>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <type num="r" dash="'"/>
		    </Subst>
		  </maxz>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(2.d) and S-Fn rule, we conclude that
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <fn>
		      <type num="a"/>
		      <type num="r"/>
		    </fn>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <fn>
		      <type num="a" dash="'"/>
		      <type num="r" dash="'"/>
		    </fn>
		  </Subst>
		</Msub>
	      </btypes:TYPE>	      
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case S-Pair: Follows from induction hypothesis, and the fact
	  that
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type num="1"/>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="2"/>
	      </Subst>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type num="2"/>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE> implies
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<pair>
		  <type num="1"/>
		  <type num="2"/>
		</pair>
	      </Subst>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <pair>
		    <type num="1"/>
		    <type num="2"/>
		  </pair>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case S-Mut: Cannot happen for first property (follows from
	  induction hypothesis for the second property).
	</p>
      </li>
      <li>
	<p>
	  Case S-MT1: There are two sub-cases to consider:
	  <btypes:TYPE>
	    <in>
	      <tvar name="alpha"/>
	      <dom>
		<aSubMap/>
	      </dom>
	    </in>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <notin>
	      <tvar name="alpha"/>
	      <dom>
		<aSubMap/>
	      </dom>
	    </notin>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<notin>
		  <tvar name="alpha"/>
		  <dom>
		    <aSubMap/>
		  </dom>
		</notin>
	      </btypes:TYPE>.
	      That is,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar name="alpha"/>
		  </Subst>
		  <tvar name="alpha"/>
		</eq>
	      </btypes:TYPE>. 
	      We know that 
	      <btypes:TYPE>
		<eq>
		  <minzT>
		    <sType/>
		  </minzT>
		  <type/>
		</eq>
	      </btypes:TYPE>.
	      Therefore, we have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <minzT>
		      <sType/>
		    </minzT>
		  </Subst>
		  <Subst>
		    <aSubMap/>
		    <type/>
		  </Subst>
		</eq>
	      </btypes:TYPE>, and further
	      <btypes:TYPE>
		<eq>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <minzT>
			<sType/>
		      </minzT>
		    </Subst>
		  </minzT>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </minzT>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(5.a) and
	      <btypes:TYPE>
		<lem tag="T-msm_eq_ms"/>
	      </btypes:TYPE>, we can write:
	      <btypes:TYPE>
		<eq>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <sType/>
		    </Subst>
		  </minzT>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </minzT>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
	<p>
	  Since a substitution on strcturally equal types must preserve
	  equality, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<minz>
		  <sType/>
		</minz>
	      </Subst>
	      <Subst>
		<aSubMap/>
		<type/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
	<p>
	  Otherwise, 
	  It must be true that
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<sType/>
	      </Subst>
	      <sType dash="'"/>
	    </eq>
	  </btypes:TYPE> for some base type 
	  <btypes:TYPE>
	    <sType dash="'"/>
	  </btypes:TYPE>,
	  because otherwise, the substitution will
	  violate the grammar within the type
	  <btypes:TYPE>
	    <mbTop>
	      <tvar name="alpha"/>
	      <Subst>
		<aSubMap/>
		<sType/>
	      </Subst>
	    </mbTop>
	  </btypes:TYPE>.
	  Given this, we can conclude that 
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<maxzT>
		  <sType/>
		</maxzT>
	      </Subst>
	      <sType dash="''"/>
	    </eq>
	  </btypes:TYPE> for some type
	  <btypes:TYPE>
	    <sType dash="''"/>
	  </btypes:TYPE>.
	</p>
	<p>
	  By induction hypothesis, we know that
	  <btypes:TYPE>
	    <Msub>
	      <Subst>
		<aSubMap/>
		<maxzT>
		  <sType/>
		</maxzT>
	      </Subst>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minz>
	    </Msub>
	  </btypes:TYPE>.
	  Now,
	  <btypes:TYPE>
	    <maxzT>
	      <sType/>
	    </maxzT>
	  </btypes:TYPE>
	  is equal to 
	  <btypes:TYPE>
	    <sType/>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <mutable>
	      <sType/>
	    </mutable>
	  </btypes:TYPE>.
	  Since 
	  <btypes:TYPE>
	    <sType/>
	  </btypes:TYPE> is not a maybe type, 
	  <btypes:TYPE>
	    <eq>
	      <maxzT>
		<Subst>
		  <aSubMap/>
		  <sType/>
		</Subst>
	      </maxzT>
	      <Subst>
		<aSubMap/>
		<maxzT>
		  <sType/>
		</maxzT>
	      </Subst>
	    </eq>
	  </btypes:TYPE>. Therefore, we have,
	  <btypes:TYPE>
	    <Msub>
	      <maxzT>
		<Subst>
		  <aSubMap/>
		  <sType/>
		</Subst>
	      </maxzT>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minz>
	    </Msub>
	  </btypes:TYPE>. The result is obtainable from S-MT1 rule.
	  Let
	  <btypes:TYPE>
	    <eq>
	      <sType num="1"/>
	      <Subst>
		<aSubMap/>
		<Msub>
		  <maxzT>
		    <sType/>
		  </maxzT>
		</Msub>
	      </Subst>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <sType num="2"/>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	  Since we have 
	  
	  By inspecting the copy coercion rules, we determine that in
	  order for the relationship 
	  <btypes:TYPE>
	    <Msub>
	      <sType num="1"/>
	      <minz>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </minz>
	    </Msub>
	  </btypes:TYPE> to hold, 
	  <btypes:TYPE>
	    <minz>
	      <Subst>
		<aSubMap/>
		<type/>
	      </Subst>
	    </minz>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="subst-helper">
    <title>Type Substitution Helper</title>
    <!-- S needs to be idempotent in this case -->
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <inter>
		<dom>
		  <aSubMap num="i"/>
		</dom>
		<ftvs>
		  <aSubMap/>
		</ftvs>
	      </inter>
	      <Empty/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap num="i"/>
	      <type/>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <Subst>
		<aSubMap num="i"/>
		<type/>
	      </Subst>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      then, 
      <btypes:TYPE>
	<models name="cst">
	  <Subst>
	    <aSubMap/>
	    <aSubMap num="i"/>
	  </Subst>
	  <Subst>
	    <aSubMap/>
	    <type/>
	  </Subst>
	</models>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By case analysis on the possible outcomes of the substitutions.
    </p>
    <ol>
      <li>
	<p>
	  Let
	  <btypes:TYPE>
	    <eq>
	      <set>
		<tvars/>
	      </set>
	      <dom>
		<aSubMap num="i"/>
	      </dom>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Forall/>
	    <in>
	      <mbTop>
		<tvar name="beta"/>
		<pType num="s"/>
	      </mbTop>
	      <Subst>
		<aSubMap/>
		<type/>
	      </Subst>
	    </in>
	    <text content=" | "/>
	    <notin>
	      <tvar name="beta"/>
	      <set>
		<tvars/>
	      </set>
	    </notin>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="i"/>
		<tvar name="beta"/>
	      </Subst>
	      <tvar name="beta"/>
	    </eq>
	  </btypes:TYPE>, and further,
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<Subst>
		  <aSubMap/>
		  <aSubMap num="i"/>
		</Subst>
		<tvar name="beta"/>
	      </Subst>
	      <tvar name="beta"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Forall/>
	    <in>
	      <mbTop>
		<tvar name="beta"/>
		<pType num="s"/>
	      </mbTop>
	      <Subst>
		<aSubMap/>
		<type/>
	      </Subst>
	    </in>
	    <text content=" | "/>
	    <in>
	      <tvar name="beta"/>
	      <set>
		<tvars/>
	      </set>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <notin>
	      <tvar name="beta"/>
	      <ftvs>
		<range>
		  <aSubMap/>
		</range>
	      </ftvs>
	    </notin>
	  </btypes:TYPE> (as a consequence of
	  from assumption&nbsp;(1)).
	  Therefore, 
	  <btypes:TYPE>
	    <Exists/>
	    <pType/>
	    <text content=" | "/>
	    <eq>
	      <pType num="s"/>
	      <Subst>
		<aSubMap/>
		<pType/>
	      </Subst>
	    </eq>
	    <text content=" and "/>
	    <in>
	      <mbTop>
		<tvar name="beta"/>
		<pType/>
	      </mbTop>
	      <type/>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From assumption&nbsp;(2) and
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we conclude that for some
	  <btypes:TYPE>
	    <notin>
	      <tvar name="gamma"/>
	      <set>
		<tvars/>
	      </set>
	    </notin>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <pType num="i"/>
	  </btypes:TYPE>, 
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="i"/>
		<tvar name="beta"/>
	      </Subst>
	      <tvar name="gamma"/>
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="i"/>
		<tvar name="beta"/>
	      </Subst>
	      <pType num="i"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq>
	      <minzT>
		<pType num="i"/>
	      </minzT>
	      <minzT>
		<Subst>
		  <aSubMap num="i"/>
		  <pType/>
		</Subst>
	      </minzT>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Suppose that
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="i"/>
		<tvar name="beta"/>
	      </Subst>
	      <tvar name="gamma"/>
	    </eq>
	  </btypes:TYPE>. That is,
	  <btypes:TYPE>
	    <in>
	      <mbTop>
		<tvar name="gamma"/>
		<Subst>
		  <aSubMap num="i"/>
		  <pType/>
		</Subst>
	      </mbTop>
	      <Subst>
		<aSubMap num="i"/>
		<type/>
	      </Subst>
	    </in>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      From assumption&nbsp;(3) and
	      <btypes:TYPE>
		<defn tag="subst-consistent"/>
	      </btypes:TYPE>, we conclude that for some
	      <btypes:TYPE>
		<notin>
		  <tvar name="delta"/>
		  <set>
		    <tvars/>
		  </set>
		</notin>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<pType num="si"/>
	      </btypes:TYPE>, 
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar name="gamma"/>
		  </Subst>
		  <tvar name="delta"/>
		</eq>
	      </btypes:TYPE>, or
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar name="gamma"/>
		  </Subst>
		  <pType num="si"/>
		</eq>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<eq>
		  <minzT>
		    <pType num="si"/>
		  </minzT>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <Subst>
			<aSubMap num="i"/>
			<pType/>
		      </Subst>
		    </Subst>
		  </minzT>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar name="gamma"/>
		  </Subst>
		  <tvar name="delta"/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	    <ol>
	      <li>
		<p>
		  This case can be re-written as
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<Subst>
			  <aSubMap num="i"/>
			  <tvar name="beta"/>
			</Subst>
		      </Subst>
		      <tvar name="delta"/>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  From assumption&nbsp;(1), case&nbsp;(5.b.1) and
		  <btypes:TYPE>
		    <lem tag="norm-subst-compose"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap/>
			  <aSubMap num="i"/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <tvar name="beta"/>
			</Subst>
		      </Subst>
		      <tvar name="delta"/>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  Due to the idempotence of 
		  <btypes:TYPE>
		    <aSubMap/>
		  </btypes:TYPE> and the fact that
		  <btypes:TYPE>
		    <in>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap/>
			<type/>
		      </Subst>
		    </in>
		  </btypes:TYPE>, we conclude that
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar name="beta"/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(5.b.ii and 5.b.iii), we obtain
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap/>
			  <aSubMap num="i"/>
			</Subst>
			<tvar name="beta"/>
		      </Subst>
		      <tvar name="delta"/>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar name="gamma"/>
		  </Subst>
		  <pType num="si"/>
		</eq>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<eq>
		  <minzT>
		    <pType num="si"/>
		  </minzT>
		  <minzT>
		    <Subst>
		      <aSubMap/>
		      <Subst>
			<aSubMap num="i"/>
			<pType/>
		      </Subst>
		    </Subst>
		  </minzT>
		</eq>
	      </btypes:TYPE>.
	    </p>
	    <ol>
	      <li>
		<p>
		  This case can be written as
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<Subst>
			  <aSubMap num="i"/>
			  <tvar name="beta"/>
			</Subst>
		      </Subst>
		      <pType num="si"/>
		    </eq>
		  </btypes:TYPE>, and similar to case (5.b), 
		  we obtain 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap/>
			  <aSubMap num="i"/>
			</Subst>
			<tvar name="beta"/>
		      </Subst>
		      <pType num="si"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Using assumption&nbsp;(1) and 
		  <btypes:TYPE>
		    <lem tag="norm-subst-compose"/>
		  </btypes:TYPE>, we can re-write
		  <btypes:TYPE>
		    <eq>
		      <minzT>
			<pType num="si"/>
		      </minzT>
		      <minzT>
			<Subst>
			  <aSubMap/>
			  <Subst>
			    <aSubMap num="i"/>
			    <pType/>
			  </Subst>
			</Subst>
		      </minzT>
		    </eq>
		  </btypes:TYPE> as
		  <btypes:TYPE>
		    <eq>
		      <minzT>
			<pType num="si"/>
		      </minzT>
		      <minzT>
			<Subst>
			  <Subst>
			    <aSubMap/>
			    <aSubMap num="i"/>
			  </Subst>
			  <Subst>
			    <aSubMap/>
			    <pType/>
			  </Subst>
			</Subst>
		      </minzT>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Since
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<pType/>
		      </Subst>
		      <pType num="s"/>
		    </eq>
		  </btypes:TYPE>, case&nbsp;(5.c.ii) can be written as
		  <btypes:TYPE>
		    <eq>
		      <minzT>
			<pType num="si"/>
		      </minzT>
		      <minzT>
			<Subst>
			  <Subst>
			    <aSubMap/>
			    <aSubMap num="i"/>
			  </Subst>
			  <pType num="s"/>
			</Subst>
		      </minzT>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(5.c.i and 5.c.iii), we conclude
		  that 
		  <btypes:TYPE>
		    <eq>
		      <minzT>
			<Subst>
 			  <Subst>
			    <aSubMap/>
			    <aSubMap num="i"/>
			  </Subst>
			  <tvar name="beta"/>
			</Subst>
		      </minzT>
		      <minzT>
			<Subst>
			  <Subst>
			    <aSubMap/>
			    <aSubMap num="i"/>
			  </Subst>
			  <pType num="s"/>
			</Subst>
		      </minzT>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <!-- 	  <li> -->
      <!-- 	    <p> -->
      <!-- 	      Now, we need to show that  -->
      <!-- 	      <btypes:TYPE> -->
      <!-- 		<models name="cst"> -->
      <!-- 		  <assume> -->
      <!-- 		    <Subst> -->
      <!-- 		      <aSubMap/> -->
      <!-- 		      <aSubMap num="i"/> -->
      <!-- 		    </Subst> -->
      <!-- 		  </assume> -->
      <!-- 		  <Subst> -->
      <!-- 		    <aSubMap/> -->
      <!-- 		    <type/> -->
      <!-- 		  </Subst> -->
      <!-- 		</models> -->
      <!-- 	      </btypes:TYPE>. -->
      <!-- 	    </p> -->
      <!-- 	  </li> -->
    </ol>
  </proof>
  <lemma id="T-TSubstitution">
    <title>Type Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
	<text content=", then for any substitution "/>
	<aSubMap/>
	<text content=" such that "/>
	<models name="cst">
	  <assume>
	    <aSubMap/>
	  </assume>
	  <set>
	    <gamma/>
	    <store/>
	    <type/>
	  </set>
	</models>
	<text content=" and "/>
	<eq>
	  <inter>
	    <ftvs>
	      <aSubMap/>
	    </ftvs>
	    <pred name="gtv">
	      <gamma/>
	    </pred>
	  </inter>
	  <Empty/>
	</eq>
	<text content=", we have "/>
	<Sjudge>
	  <assume>
	    <Subst>
	      <aSubMap/>
	      <gamma/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <store/>
	    </Subst>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <Subst>
	      <aSubMap/>
	      <type/>
	    </Subst>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. We proceed by case analysis on the last step of
      the derivation.
    </p>
    <ol>
      <li>
	<p>
	  Cases T-Unit, T-True, T-False, T-Hloc and T-Sloc are trivial.
	</p>
      </li>
      <li>
	<p>
	  Case T-ID:
	</p>
	<ol>
	  <li>
	    <p>
	      We have
	    </p>
	    <btypes:TYPE>	
	      <Hrules>
		<tyRule>
		  <tyPre>
		    <mapsto>
		      <gamma/>
		      <id/>
		      <TS>
			<tvars/>
			<type/>
		      </TS>
		    </mapsto>
		    <eq>
		      <aSubMap num="n"/>
		      <plural>
			<SubMap>
			  <tvar/>
			  <type dash="'"/>
			</SubMap>
		      </plural>
		    </eq>
		    <models name="cst">
		      <assume>
			<aSubMap num="n"/>
		      </assume>
		      <type/>
		    </models>
		  </tyPre>
		  <tyConc>
		    <TDjudge>
		      <id/>
		      <Subst>
			<aSubMap num="n"/>
			<type/>
		      </Subst>
		    </TDjudge>
		  </tyConc>
		</tyRule>
	      </Hrules>      
	    </btypes:TYPE>
	  </li>
	  <li>
	    <p>
	      We also have
	      <btypes:TYPE>
		<models name="cst">
		  <assume>
		    <aSubMap/>
		  </assume>
		  <set>
		    <gamma/>
		    <store/>
		    <Subst>
		      <aSubMap num="n"/>
		      <type/>
		    </Subst>
		  </set>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Since 
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		    <pred name="gtv">
		      <gamma/>
		    </pred>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		    <set>
		      <tvars/>
		    </set>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a and 2.c), we have
	      <btypes:TYPE>	
		<mapsto>
		  <Subst>
		    <aSubMap/>
		    <gamma/>
		  </Subst>
		  <id/>
		  <TS>
		    <tvars/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </TS>
		</mapsto>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a and 2.c), we have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <aSubMap num="n"/>
		  </Subst>
		  <plural>
		    <SubMap>
		      <tvar/>
		      <Subst>
			<aSubMap/>
			<type dash="'"/>
		      </Subst>
		    </SubMap>
		  </plural>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(2.b) and 
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we have 
	      <btypes:TYPE>
		<models name="cst">
		  <assume>
		    <aSubMap/>
		  </assume>
		  <Subst>
		    <aSubMap num="n"/>
		    <type/>
		  </Subst>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Since 
	      <btypes:TYPE>
		<in>
		  <type/>
		  <gamma/>
		</in>
	      </btypes:TYPE>, 
	      from case&nbsp;(2.b) and 
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we have
	      <btypes:TYPE>
		<models name="cst">
		  <assume>
		    <aSubMap/>
		  </assume>
		  <type/>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
    </ol>
  </proof>
  <lemma id="T-VSubstitution">
    <title>Value Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<aTS/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" and "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <GEN>
	    <tqExpr>
	      <aVal/>
	      <type num="v"/>
	    </tqExpr>
	    <aTS/>
	  </GEN>
	</Sjudge>
	<text content=" then "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<aTS/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
      We proceed by case analysis on the final step of the
      derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id name="y"/>
	    </eq>
	    <text content=", where "/>
	    <in>
	      <id name="y"/>
	      <extend>
		<gamma/>
		<id/>
		<aTS/>
	      </extend>
	    </in>
	  </btypes:TYPE>.
	</p>
	<p>
	  There are two sub cases to consider. If
	  <btypes:TYPE>
	    <eq>
	      <id name="x"/>
	      <id name="y"/>
	    </eq>
	  </btypes:TYPE>,
	  then,
	  <btypes:TYPE>
	    <eq>
	      <subst>
		<id name="y"/>
		<id name="x"/>
		<aVal/>
	      </subst>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>,
	  and the result type
	  <btypes:TYPE>
	    <type/>
	  </btypes:TYPE> is an instantiation of the type scheme
	  <btypes:TYPE>
	    <aTS/>
	  </btypes:TYPE>.
	  One of the assumptions of the lemma states that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>. That is,
	  <btypes:TYPE>
	    <spEq>
	      <type/>
	      <aTS/>
	    </spEq>
	  </btypes:TYPE>, and we can infer any more-specific type
	  (and in particular the type being instantiated at the
	  T-Id rule) instead for this substitution of the
	  expression
	  <btypes:TYPE>
	    <aVal/>
	  </btypes:TYPE>.
	  Therefore, we have
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr/>
		  <id/>
		  <aVal/>
		</subst>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
	<p>
	  If
	  <btypes:TYPE>
	    <neq>
	      <id name="x"/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <eq>
	      <subst>
		<id name="y"/>
		<id name="x"/>
		<aVal/>
	      </subst>
	      <id name="y"/>
	    </eq>
	  </btypes:TYPE>,
	  and the result is immediate.
	</p>
      </li>
      <li>
	<p>
	  Case T-Lambda: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lambda>
		<id name="y"/>
		<aExpr dash="'"/>
	      </lambda>
	    </eq>
	    <text content=", and "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </eq>
	    
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <aTS/>
		  </tqExpr>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
	<p>
	  We can assume that
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	  Since it is clear that the type
	  <btypes:TYPE>
	    <type num="1"/>
	  </btypes:TYPE>
	  of
	  <btypes:TYPE>
	    <id name="y"/>
	  </btypes:TYPE>
	  can either use variables already in
	  <btypes:TYPE>
	    <gamma/>
	  </btypes:TYPE>
	  or fresh type variables, we know that
	  <btypes:TYPE>
	    <eq>
	      <inter>
		<ftvs>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <type num="1"/>
		    </tqExpr>
		  </extend>
		</ftvs>
		<ftvs>
		  <aTS/>
		</ftvs>
	      </inter>
	      <Empty/>
	    </eq>
	  </btypes:TYPE>.
	  Thus, by weakening lemma, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  , and, by induction hypothesis,
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr dash="'"/>
		  <id/>
		  <aVal/>
		</subst>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	  Finally, by the T-Lambda rule, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<lambda>
		  <id num="y"/>
		  <paren>
		    <subst>
		      <aExpr dash="'"/>
		      <id/>
		      <aVal/>
		    </subst>
		  </paren>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and thus
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <lambda>
		    <id num="y"/>
		    <aExpr dash="'"/>
		  </lambda>
		  <id/>
		  <aVal/>
		</subst>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, which is the desired result.
	</p>
      </li>
      <li>
	<p>
	  T-Set case is similar, except that the substitution
	  cannot happen on the LHS of an assignment, since we do
	  not perform substitution of mutable values.
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-LSubstitution">
    <title>Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type num="0"/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", and for some "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=", "/>
	<tqExpr>
	  <mapsto>
	    <store/>
	    <sLoc/>
	    <type num="0"/>
	  </mapsto>
	</tqExpr>
	<text content=", then "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, similar to lemma <xref
	ref="T-VSubstitution"/>.
    </p>
  </proof>
<!--   <lemma id="T-sh-safety"> -->
<!--     <title>Stack and Heap Assignment</title> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<hLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/>                -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="Similarly, if "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and  "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/>                  -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       Immediate from the definition of stack and heap typing. -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="T-preservation"> -->
<!--     <title>Preservation</title> -->
<!--     <p> -->
<!--       <btypes:TYPE>           -->
<!-- 	<text content="If "/> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <tqExpr> -->
<!-- 	    <aExpr/> -->
<!-- 	    <type/> -->
<!-- 	  </tqExpr> -->
<!-- 	</Sjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=" then, "/>     -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <leval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </leval> -->
<!-- 	    <text content=", then, there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq> -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <tqExpr> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 		<type/> -->
<!-- 	      </tqExpr>                     -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE>               -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE>           -->
<!-- 	    <text content="If "/> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	    <text content=", there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq>                 -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <Msub> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </Msub>                     -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=",  "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       By induction on the derivation of  -->
<!--       <btypes:TYPE> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <tqExpr> -->
<!-- 	    <aExpr/> -->
<!-- 	    <type/> -->
<!-- 	  </tqExpr> -->
<!-- 	</Sjudge> -->
<!--       </btypes:TYPE>. We proceed by the case analysis of the final -->
<!--       step.  -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot -->
<!-- 	  happen.  -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Sloc: Only right execution is applicable.  -->
<!-- 	  We have: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <sLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <tqExpr> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  The only applicable step is E-Rval, and we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <mapsto> -->
<!-- 		<stack/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  From the definition of stack typing, we have: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<stack/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>               -->
<!-- 	  and thus  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>               -->
<!-- 	  which implies -->
<!-- 	  <btypes:TYPE>               -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-App: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <apply> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </apply> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="2"/> -->
<!-- 		<type num="0"/> -->
<!-- 	      </fn> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	    <text content = " where "/> -->
<!-- 	    <eq> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <minz> -->
<!-- 		<type num="2" dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq>                 -->
<!-- 	    <eq> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <maxz> -->
<!-- 		<type num="0" dash="'"/> -->
<!-- 	      </maxz> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p>               -->
<!-- 	  This cannot happen for left execution.  -->
<!-- 	  For right execution, we proceed by further case -->
<!-- 	  analysis of the applicable execution rules for -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App1#: -->
<!-- 	      We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <apply> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		  </apply> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      By induction hypothesis, we have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="2"/> -->
<!-- 		      <type num="0"/> -->
<!-- 		    </fn>      -->
<!-- 		  </Msub>                  -->
<!-- 		</Sjudge>                     -->
<!-- 		<text content=" for some "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      One of the assumptions of the T-App rule states that  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<TDjudge Msub="yes"> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</TDjudge> -->
<!-- 	      </btypes:TYPE>, and by weakening lemma, we have,  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </Msub> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. Finally, by the T-App rule, we -->
<!-- 	      conclude that -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<tqExpr> -->
<!-- 		  <paren> -->
<!-- 		    <apply> -->
<!-- 		      <aExpr num="1" dash="'"/>                         -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </apply> -->
<!-- 		  </paren> -->
<!-- 		  <type/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App2#: Similar to the previous -->
<!-- 	      sub-case.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App: We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <lambda> -->
<!-- 		    <id/> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		  </lambda> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <subst> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <id/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </subst> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <extend> -->
<!-- 		      <stack/> -->
<!-- 		      <mapping> -->
<!-- 			<sLoc/> -->
<!-- 			<aVal/> -->
<!-- 		      </mapping> -->
<!-- 		    </extend> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      By the inversion lemma for  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lambda> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="0"/> -->
<!-- 		</lambda> -->
<!-- 	      </btypes:TYPE> we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <extend> -->
<!-- 		      <gamma> -->
<!-- 			<id/> -->
<!-- 			<type num="2" dash="'"/> -->
<!-- 		      </gamma> -->
<!-- 		      <store/> -->
<!-- 		    </extend> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Further from location substitution lemma, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <subst> -->
<!-- 		      <aExpr num="0"/> -->
<!-- 		      <id/> -->
<!-- 		      <sLoc/> -->
<!-- 		    </subst> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 		<text content=" where "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<tqExpr> -->
<!-- 		  <mapsto> -->
<!-- 		    <store/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </mapsto> -->
<!-- 		  <type num="2" dash="'"/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Thus, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type num="0" dash="'"/> -->
<!-- 		</Msub> -->
<!-- 		<text content=" and "/> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Therefore, it is clear that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>.                   -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Set: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <assign> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </assign> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <mutable> -->
<!-- 		<type/> -->
<!-- 	      </mutable> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <Sjudge name="lval"> -->
<!-- 	      <assume/>                   -->
<!-- 	      <aExpr num="1"/>                   -->
<!-- 	    </Sjudge>                 -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  If the step taken is E-:=#lhs or E-:=#rhs, -->
<!-- 	  the result follows from the induction hypothesis and -->
<!-- 	  T-Set rule (as in the case of T-App).                -->
<!-- 	  If the step taken is E-:=Stack or E-:=Heap, the -->
<!-- 	  result follows from the stack and heap assignment lemma. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Deref: We have:  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <deref> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </deref> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <ref> -->
<!-- 		<type/> -->
<!-- 	      </ref>                   -->
<!-- 	    </TDjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  If the step taken is EL-^# or E-^#, -->
<!-- 	  the result follows from induction hypothesis and T-Deref -->
<!-- 	  rule.  -->
<!-- 	  If the step taken is E-^ (right execution only)  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <aExpr dash="'"/>                   -->
<!-- 	  </btypes:TYPE> is a value, and from canonical forms -->
<!-- 	  lemma, we know that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <hLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <in> -->
<!-- 	      <hLoc/> -->
<!-- 	      <dom> -->
<!-- 		<store/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  and the result follows from the fact that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-P: Right execution only. We have: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <paren> -->
<!-- 		<let kind="p"> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		</let> -->
<!-- 	      </paren> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/>                 -->
<!-- 	      <type num="1"/>                 -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge name="gen"> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 		<aExpr num="1"/> -->
<!-- 	      </assume>                 -->
<!-- 	      <GEN> -->
<!-- 		<type/> -->
<!-- 		<aTS/> -->
<!-- 	      </GEN> -->
<!-- 	    </Sjudge>       -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<extend> -->
<!-- 		  <gamma/> -->
<!-- 		  <mapping> -->
<!-- 		    <id/>                       -->
<!-- 		    <aTS/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<store/> -->
<!-- 	      </assume>                 -->
<!-- 	      <tqExpr> -->
<!-- 		<aExpr num="2"/> -->
<!-- 		<type num="2"/> -->
<!-- 	      </tqExpr>                 -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  There are two sub-cases to consider: -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take step E-Let#,                    -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      and  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aExpr num="1" dash="'"/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 		<text content=". If "/>                     -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      It is clear that  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE> implies -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1" dash="'"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>.                      -->
<!-- 	      Now, the result follows -->
<!-- 	      from the induction hypothesis and the E-Let-P rule. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take the step E-Let-P,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aVal/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      Since  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<tqExpr> -->
<!-- 		  <id/> -->
<!-- 		  <aTS/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      has a polymorphic type,  -->
<!-- 	      (that is, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aTS/> -->
<!-- 		  <forall> -->
<!-- 		    <tvars name="alpha"/> -->
<!-- 		    <type name="s"/> -->
<!-- 		  </forall> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>) -->
<!-- 	      we know that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Immut"> -->
<!-- 		  <type/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Also, from canonical forms lemma, all values have -->
<!-- 	      an immutable type. Therefore,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <type/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. Now, the result follows from -->
<!-- 	      value substitution lemma.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol>             -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-M: Similar to T-Let-P, except that we should -->
<!-- 	  always use the GEN-EXPANSIVE rule during generalization, -->
<!-- 	  and use the location substitution lemma instead of  -->
<!-- 	  the value substitution lemma -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Cases T-If, T-Dup are similar.   -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </proof> -->
<!--   <definition id="stuck_state"> -->
<!--     <title>Stuck State</title> -->
<!--     <p> -->
<!--       A system state  -->
<!--       <btypes:TYPE> -->
<!-- 	<opState> -->
<!-- 	  <stack/> -->
<!-- 	  <heap/> -->
<!-- 	  <aExpr/> -->
<!-- 	</opState> -->
<!--       </btypes:TYPE> -->
<!--       is said to be <term>stuck</term> if -->
<!--       <btypes:TYPE> -->
<!-- 	<neq> -->
<!-- 	  <aExpr/> -->
<!-- 	  <aVal/> -->
<!-- 	</neq> -->
<!--       </btypes:TYPE> -->
<!--       and there are no  -->
<!--       <btypes:TYPE> -->
<!-- 	<stack dash="'"/> -->
<!-- 	<text content=", "/> -->
<!-- 	<heap dash="'"/> -->
<!-- 	<text content=", and "/> -->
<!-- 	<aExpr dash="'"/> -->
<!--       </btypes:TYPE>    -->
<!--       such that  -->
<!--       <btypes:TYPE> -->
<!-- 	<eval> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </definition>       -->
<!--   <theorem id="T-soundness"> -->
<!--     <title>Type Soundness</title> -->
<!--     <p> -->
<!--       If  -->
<!--       <btypes:TYPE> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <Empty/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <tqExpr> -->
<!-- 	    <aExpr/> -->
<!-- 	    <type/> -->
<!-- 	  </tqExpr> -->
<!-- 	</Sjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<Sjudge> -->
<!-- 	  <assume> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=" and "/> -->
<!-- 	<eval many="yes"> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!-- 	<text content=" then "/> -->
<!-- 	<opState> -->
<!-- 	  <stack dash="'"/> -->
<!-- 	  <heap dash="'"/> -->
<!-- 	  <aExpr dash="'"/> -->
<!-- 	</opState> -->
<!-- 	<text content=" is not stuck."/>             -->
<!--       </btypes:TYPE> -->
<!--       That is, execution of a well typed expression cannot lead to -->
<!--       a stuck state. Here,  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE > represents the  -->
<!--       reflexive-transitive-closure of  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
<!--   <proof> -->
<!--     <p> -->
<!--       By straightforward induction on the length of    -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE>. If  -->
<!--       <btypes:TYPE> -->
<!-- 	<eq> -->
<!-- 	  <aExpr/> -->
<!-- 	  <aVal/> -->
<!-- 	</eq> -->
<!--       </btypes:TYPE>, proof is immediate. Otherwise, from  -->
<!--       Lemma&nbsp;<xref ref="T-progress"/> (Progress), -->
<!--       we know that we can take at least one step forward. Further, -->
<!--       from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation), -->
<!--       we know that a (left/right) execution of a well -->
<!--       typed expression in with respect to a well typed stack and heap -->
<!--       will always result in another well typed expression, stack -->
<!--       and heap. Proof now follows from induction hypothesis.   -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="C-progress"> -->
<!--     <title>Progress</title> -->
<!--     <p> -->
<!--       <btypes:TYPE> -->
<!-- 	<text content="If "/> -->
<!-- 	<aExpr/> -->
<!-- 	<text content=" is a closed, well typed term, "/>  -->
<!-- 	<text content="that is, "/>  -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <Empty/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=" for some "/>  -->
<!-- 	<type/>  -->
<!-- 	<text content=", "/>  -->
<!-- 	<aCtset/> -->
<!-- 	<text content=", "/>  -->
<!-- 	<store/> -->
<!-- 	<text content=", and if "/>  -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!-- 	<text content=", then, given any heap "/>  -->
<!-- 	<heap/> -->
<!-- 	<text content=" and stack "/>  -->
<!-- 	<stack/> -->
<!-- 	<text content=" such that "/>  -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=", "/>             -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content=" If "/>                 -->
<!-- 	    <Sjudge name="lval"> -->
<!-- 	      <assume/> -->
<!-- 	      <aExpr/> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=", then "/>               -->
<!-- 	    <aExpr/> -->
<!-- 	    <text content=" is either a valid lvalue "/>  -->
<!-- 	    <lVal/> -->
<!-- 	    <text content=" (that is, "/> -->
<!-- 	    <eq> -->
<!-- 	      <lVal/> -->
<!-- 	      <sLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", "/> -->
<!-- 	    <in> -->
<!-- 	      <sLoc/> -->
<!-- 	      <dom> -->
<!-- 		<stack/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	    <text content=" or "/>  -->
<!-- 	    <eq> -->
<!-- 	      <lVal/> -->
<!-- 	      <deref> -->
<!-- 		<hLoc/> -->
<!-- 	      </deref> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", "/> -->
<!-- 	    <in> -->
<!-- 	      <hLoc/> -->
<!-- 	      <dom> -->
<!-- 		<heap/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	    <text content=") or else "/> -->
<!-- 	    <Exists> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <stack dash="'"/> -->
<!-- 	      <heap dash="'"/> -->
<!-- 	    </Exists> -->
<!-- 	    <text content=" such that:"/>                -->
<!-- 	    <leval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </leval> -->
<!-- 	    <text content="."/>    -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p>               -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <aExpr/> -->
<!-- 	    <text content=" is a value "/>  -->
<!-- 	    <aVal/> -->
<!-- 	    <text content=" or else "/>  -->
<!-- 	    <Exists> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <stack dash="'"/> -->
<!-- 	      <heap dash="'"/> -->
<!-- 	    </Exists> -->
<!-- 	    <text content=" such that "/>                -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <lemma id="C-preservation"> -->
<!--     <title>Preservation</title> -->
<!--     <p> -->
<!--       <btypes:TYPE>           -->
<!-- 	<text content="If "/> -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=", "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume/> -->
<!-- 	  <aCtset/> -->
<!-- 	</models> -->
<!-- 	<text content=", and "/> -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=", then, "/>     -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <leval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </leval> -->
<!-- 	    <text content=", then, there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq> -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Cjudge> -->
<!-- 	      <aCtset/> -->
<!-- 	      <gamma/> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </Cjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge num="*"> -->
<!-- 	      <assume> -->
<!-- 		<aCtset/> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE>               -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE>           -->
<!-- 	    <text content="If "/> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	    <text content=", there exists a "/> -->
<!-- 	    <supeq> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <store/> -->
<!-- 	    </supeq>                 -->
<!-- 	    <text content=" such that "/> -->
<!-- 	    <Cjudge> -->
<!-- 	      <aCtset/> -->
<!-- 	      <gamma/> -->
<!-- 	      <store dash="'"/> -->
<!-- 	      <aExpr dash="'"/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </Cjudge> -->
<!-- 	    <text content=",  "/> -->
<!-- 	    <Sjudge num="*"> -->
<!-- 	      <assume> -->
<!-- 		<aCtset/> -->
<!-- 		<gamma/> -->
<!-- 		<store dash="'"/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<stack dash="'"/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	    <text content="."/> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <theorem id="C-soundness"> -->
<!--     <title>Type Soundness</title> -->
<!--     <p> -->
<!--       If  -->
<!--       <btypes:TYPE> -->
<!-- 	<Cjudge> -->
<!-- 	  <aCtset/> -->
<!-- 	  <Empty/> -->
<!-- 	  <store/> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</Cjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<Sjudge num="*"> -->
<!-- 	  <assume> -->
<!-- 	    <aCtset/> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	  </assume> -->
<!-- 	  <plus> -->
<!-- 	    <heap/> -->
<!-- 	    <stack/> -->
<!-- 	  </plus> -->
<!-- 	</Sjudge>  -->
<!-- 	<text content=" and "/> -->
<!-- 	<eval many="yes"> -->
<!-- 	  <opState> -->
<!-- 	    <stack/> -->
<!-- 	    <heap/> -->
<!-- 	    <aExpr/> -->
<!-- 	  </opState> -->
<!-- 	  <opState> -->
<!-- 	    <stack dash="'"/> -->
<!-- 	    <heap dash="'"/> -->
<!-- 	    <aExpr dash="'"/> -->
<!-- 	  </opState> -->
<!-- 	</eval> -->
<!-- 	<text content=" then "/> -->
<!-- 	<opState> -->
<!-- 	  <stack dash="'"/> -->
<!-- 	  <heap dash="'"/> -->
<!-- 	  <aExpr dash="'"/> -->
<!-- 	</opState> -->
<!-- 	<text content=" is not stuck."/>             -->
<!--       </btypes:TYPE> -->
<!--       That is, execution of a well typed expression cannot lead to -->
<!--       a stuck state. Here,  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp many="yes"/> -->
<!--       </btypes:TYPE > represents the  -->
<!--       reflexive-transitive-closure of  -->
<!--       <btypes:TYPE> -->
<!-- 	<evalOp/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </theorem> -->
  </sect1>

