<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="declarative_types"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Declarative Type System</title>
  <definition id="constraint-colection-ext">
    <title>Constraint Collection over Type Derivation</title>
    <p>
      We write
      <btypes:TYPE>
	<spset>
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</spset>
      </btypes:TYPE> to denote the set of all maybe types used in the
      derivation of 
      <btypes:TYPE>
	<spset>
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</spset>
      </btypes:TYPE>.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<id/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	      <Subst>
		<aSubMap/>
		<type/>
	      </Subst>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<Unit/>
		<unit/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<true/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<false/>
		<bool/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<hLoc/>
		<ref>
		  <type/>
		</ref>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<sLoc/>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <gamma/>
	      <store/>
	      <type/>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<lambda>
		  <id/>
		  <aExpr/>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <Sjudge>
		<assume>
		  <extend>
		    <gamma/>
		    <mapping>
		      <id/>
		      <type num="1"/>
		    </mapping>
		  </extend>
		  <store/>
		</assume>
		<tqExpr>
		  <aExpr/>
		  <type num="2"/>
		</tqExpr>
	      </Sjudge>
	    </spset>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <spset>
	      <TDjudge>
		<apply>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</apply>
		<type/>
	      </TDjudge>
	    </spset>
	  </lhs>
	  <rhs>
	    <spset>
	      <TDjudge>
		<aExpr num="1"/>
		<type num="1"/>
	      </TDjudge>
	    </spset>
	  </rhs>
	</equation>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<TDjudge>
		  <aExpr num="2"/>
		  <type num="2"/>
		</TDjudge>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
	<eqn-cnt>
	  <rhs>
	    <unin>
	      <nothing/>
	      <spset>
		<type num="a"/>
		<type num="r"/>
		<type/>
	      </spset>
	    </unin>
	  </rhs>
	</eqn-cnt>
      </VEqns>
    </btypes:TYPE>
    <p>
      Other cases are similar.
    </p>
  </definition>
  <definition id="consistent-typing">
    <title>Consistent Type Derivation</title>
    <p>
      We say that
      <btypes:TYPE>
	<TDjudge cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, is a consistent type derivation under the
      constraint set 
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE>
      if
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Sat>
	  <aCtset/>
	  <spset>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</Sat>
      </btypes:TYPE>.
    </p>
    <p>
      We say that
      <btypes:TYPE>
	<TDjudge name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>, is a consistent type derivation if
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>
    </p>
  </definition>
  <definition id="stack-heap-typing">
    <title>Stack and Heap Typing</title>
    <p>
      A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
      <btypes:TYPE><stack/></btypes:TYPE> are said to be <em>well
	typed</em> with respect to a binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and store typing
      <btypes:TYPE><store/></btypes:TYPE>, and written
      <btypes:TYPE>
	<TDjudge>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge>
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge> 
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge>
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Similarly, we write
      <btypes:TYPE>
	<TDjudge cst="yes">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge cst="yes">
	      <mapsto><heap/><hLoc/></mapsto>
	      <type/>
	    </TDjudge> 
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><hLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <TDjudge cst="yes">
	      <mapsto><stack/><sLoc/></mapsto>
	      <type/>
	    </TDjudge>
	    <text content=" such that "/>
	    <Msub>
	      <mapsto><store/><sLoc/></mapsto>
	      <type/>
	    </Msub>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="valid-lval">
    <title>Valid Lvalues</title>
    <p>
      We say that an lvalue
      <btypes:TYPE>
	<lVal/>
      </btypes:TYPE> is valid with respect to a stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE> and heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, written
      <btypes:TYPE>
	<Sjudge name="v">
	  <assume>
	    <plus>
	      <heap/>
	      <stack/>
	    </plus>
	  </assume>
	  <lVal/>
	</Sjudge>
      </btypes:TYPE> if one of the following conditions hold for some
      <btypes:TYPE>
	<path/>
      </btypes:TYPE>:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <eq>
	      <lVal/>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </eq>
	  </btypes:TYPE>, where
	  <btypes:TYPE>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </definition>
  <lemma id="T-inversion">
    <title>Inversion of Typing Relation</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <Unit/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <true/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <false/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <hLoc/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <lambda>
		<id/>
		<aExpr/>
	      </lambda>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </fn>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>
		    <type num="1" dash="'"/>
		  </mapping>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type num="2" dash="'"/>
	      </tqExpr>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge>
	      <deref>
		<aExpr/>
	      </deref>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of typing relation.
    </p>
  </proof>
  <lemma id="T-sub-inversion">
    <title>Inversion of Copy Coercion</title>
    <p>
      For any type
      <btypes:TYPE>
	<ptype/>
	<text content=" and "/>
	<tvar/>
      </btypes:TYPE>, let
      <btypes:TYPE>
	<eq>
	  <pred name="Q">
	    <ptype/>
	  </pred>
	  <set>
	    <ptype/>
	    <mutable>
	      <ptype/>
	    </mutable>
	    <mbTop>
	      <tvar/>
	      <ptype/>
	    </mbTop>
	    <mbTop>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbTop>
	    <mbFull>
	      <tvar/>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <tvar/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <ptype/>
	    </mbFull>
	    <mbFull>
	      <mutable>
		<tvar/>
	      </mutable>
	      <mutable>
		<ptype/>
	      </mutable>
	    </mbFull>
	  </set>
	</eq>
      </btypes:TYPE>. Then,
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <bool/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<bool/>
	      </pred>
	    </in>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <unit/>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<unit/>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<ref>
		  <type dash="'"/>
		</ref>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </pred>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </Msub>
	    <text content=" then "/>
	    <in>
	      <type/>
	      <pred name="Q">
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </pred>
	    </in>
	    <text content=", such that "/>
	    <Msub>
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </Msub>
	    <text content=" and "/>	    
	    <Msub>
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Msub>
	      <type/>
	      <mutable>
		<ptype/>
	      </mutable>
	    </Msub>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <mutable>
		<ptype dash="'"/>
	      </mutable>
	    </eq>	      
	    <text content=", such that "/>
	    <Msub>
 	      <ptype dash="'"/>
	      <ptype/>
	    </Msub>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the copy coercion derivation.
    </p>
  </proof>
  <lemma id="T-canonical">
    <title>Canonical Forms</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <unit/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Unit/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <bool/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is either "/>
	    <true/>
	    <text content=" or "/>
	    <false/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <ref>
		<type/>
	      </ref>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <hLoc/>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <lambda>
	      <id/>
	      <aExpr/>
	    </lambda>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TDjudge Msub="yes">
	      <aVal/>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Pair>
	      <aVal num="1"/>
	      <aVal num="2"/>
	    </Pair>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By inspecting the possibilities for the derivation of
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <p>
      According to the grammar of the language 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, values can be of one of the following forms:
      <btypes:TYPE>
	<collection>
	  <Unit/>
	  <true/> 
	  <false/>
	  <hLoc/>
	  <lambda>
	    <id/>
	    <aExpr/>
	  </lambda>
	  <Pair>
	    <aVal/>
	    <aVal/>
	  </Pair>
	</collection>
      </btypes:TYPE>
    </p>
    <p>
      Consider the case (2), where
      <btypes:TYPE>
	<TDjudge Msub="yes">
	  <aVal/>
	  <bool/>
	</TDjudge>
      </btypes:TYPE>. That is,
      <btypes:TYPE>
	<TDjudge>
	  <aVal/>
	  <type/>
	</TDjudge>
	<text content=" and "/>
	<Msub>
	  <type/>
	  <bool/>
	</Msub>
      </btypes:TYPE>.
      From 
      <btypes:TYPE>
	<lem tag="T-sub-inversion"/>
      </btypes:TYPE> (inversion of copy-coercion), we know that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <pred name="Q">
	    <bool/>
	  </pred>
	</in>
      </btypes:TYPE>. 
      <btypes:TYPE>
	<text content=" That is, for some "/>
	<tvar/>
	<text content=", the type "/>
	<type/>
	<text content=" equals one of: "/>
	<collection or="yes">
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	  <mbTop>
	    <tvar/>
	    <bool/>
	  </mbTop>
	  <mbTop>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbTop>
	  <mbFull>
	    <tvar/>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <tvar/>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <bool/>
	  </mbFull>
	  <mbFull>
	    <mutable>
	      <tvar/>
	    </mutable>
	    <mutable>
	      <bool/>
	    </mutable>
	  </mbFull>
	</collection>
      </btypes:TYPE>.
      If
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <bool/>
	</eq>
      </btypes:TYPE>, it is clear that the final rule in the
      derivation must be T-True, or T-False. A derivation with these
      rules is only possible if 
      <btypes:TYPE>
 	<eq>
	  <aVal/>
	  <true/>
	</eq>
	<text content=" or "/>
 	<eq>
	  <aVal/>
	  <false/>
	</eq>
      </btypes:TYPE>.
      Further, the cases like 
      <btypes:TYPE>
 	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE>
      cannot happen because there is no rule that
      derives a mutable/maybe type for a value.
    </p>
    <p>
      Other cases of the lemma are similar.
    </p>
  </proof>
  <theorem id="T-progress">
    <title>Progress</title>
    <p>
      <btypes:TYPE>
	<text content="If "/>
	<aExpr/>
	<text content=" is a closed, well typed term, "/>
	<text content="that is, "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" for some "/>
	<type/>
	<text content=" and "/>
	<store/>
	<text content=", given any heap "/>
	<heap/>
	<text content=" and stack "/>
	<stack/>
	<text content=" such that "/>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
	<text content=", "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content=" If "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	    <text content=", then "/>
	    <aExpr/>
	    <text content=" is either a valid lvalue "/>
	    <text content="(that is, "/>
	    <eq>
	      <aExpr/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <Sjudge name="v">
	      <assume>
		<plus>
		  <heap/>
		  <stack/>
		</plus>
	      </assume>
	      <lVal/>
	    </Sjudge>
	    <text content=") or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a value "/>
	    <aVal/>
	    <text content=" or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </theorem>
  <proof>
    <p>
      By induction on the type derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
	  (Values) Result is immediate for right execution, and
	  cannot happen for left execution.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id: cannot happen. 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id/>
	    </eq>
	  </btypes:TYPE> is not a closed term.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Immediate for left execution. Right
	  execution and can always continue with E-Rval rule as the
	  stack is well typed
	  (<btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-App: Only right execution is possible, no application is well
	  typed as an lvalue. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<type num="1"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE> is not a value, execution can continue via
	  the E-App1# due to induction hypothesis. Similarly, if 
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-App2#. 
	  Now, consider the case when both
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" and "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  are values. Since we know that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>, from 
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms) we conclude that 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is of the form
	  <btypes:TYPE>
	    <lambda>
	      <id/>
	      <aExpr dash="'"/>
	    </lambda>
	  </btypes:TYPE>. Now, we can take the step E-App.
	</p>
      </li>
      <li>
	<p>
	  Case T-If: Similar to T-App, only right execution is
	  permitted.
	</p>
      </li>
      <li>
	<p>
	  Case T-Set: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<mutable>
		  <ptype/>
		</mutable>
	      </Msub>
	    </Sjudge>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="2"/>
		<ptype/>
	      </Msub>
	    </Sjudge>
	    <text content=", and "/>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  not an lvalue, since we have
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr num="1"/>
	    </Sjudge>
	  </btypes:TYPE>
	  we can take E-:=lhs# by induction hypothesis.
	  Similarly, if
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-:=rhs#.
	</p>
	<p>
	  Finally, we consider the case where
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <eq>
	      <aExpr num="2"/>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>.
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>	    
	  should be one of
	  <btypes:TYPE>
	    <collection or = "yes">
	      <sLoc/>
	      <select>
		<sLoc/>
		<path/>
	      </select>
	      <deref>
		<hLoc/>
	      </deref>
	      <select>
		<deref>
		  <hLoc/>
		</deref>
		<path/>
	      </select>
	    </collection>
	  </btypes:TYPE>.
	  Now, we proceed by induction on the length of
	  <btypes:TYPE>
	    <lVal/>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <sLoc/>
		</eq>
	      </btypes:TYPE>. We know from induction hypothesis
	      that that 
	      <btypes:TYPE>
		<Sjudge name="v">
		  <assume>
		    <heap/>
		    <stack/>
		  </assume>
		  <sLoc/>
		</Sjudge>
	      </btypes:TYPE> and from 
	      <btypes:TYPE>
		<defn tag="valid-lval"/>
	      </btypes:TYPE>, we conclude that
	      <btypes:TYPE>
		<in>
		  <sLoc/>
		  <dom>
		    <stack/>
		  </dom>
		</in>
	      </btypes:TYPE>. Now, execution can continue
	      with E-:Stack.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lVal/>
		  <deref>
		    <hLoc/>
		  </deref>
		</eq>
	      </btypes:TYPE>, the execution can continue with step	    
	      E:-Heap.
	    </p>
	  </li>
	  <li>
	    <p>
	      Assume (by hypothesis) that the execution can continue for 
	      some 
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1" dash="'"/>
		  <select>
		    <sLoc/>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, let
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <sLoc/>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We know that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aExpr num="1"/>
		    <mutable>
		      <ptype/>
		    </mutable>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
		<text content=" and "/>
		<Msub>
		  <type num="1"/>
		  <mutable>
		    <ptype/>
		  </mutable>
		</Msub>
	      </btypes:TYPE>.
	      That is,
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <select>
		      <fst>
			<sLoc/>
		      </fst>
		      <path/>
		    </select>
		    <type num="1"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. 
	      The first two steps of this derivation must be 
	      T-Sloc and T-Fst.
	      From the assumption of T-Fst rule, we must have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <sLoc/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE> for some type
	      <btypes:TYPE>
		<type num="2"/>
	      </btypes:TYPE>.
	      Now, from the assumption of T-Sloc rule, we must have
	      <btypes:TYPE>
		<Msub>
		  <mapsto>
		    <store/>
		    <sLoc/>
		  </mapsto>
		  <pair>
		    <type num="1"/>
		    <type num="2"/>
		  </pair>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, if 
	      <btypes:TYPE>
		<mapsto>
		  <stack/>
		  <sLoc/>
		  <aVal/>
		</mapsto>
	      </btypes:TYPE>, 
	      since we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <tqExpr >
		    <stack/>
		    <heap/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>, 
	      we conclude that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Empty/>
		    <store/>
		  </assume>
		  <Msub>
		    <aVal/>
		    <pair>
		      <type num="1"/>
		      <type num="2"/>
		    </pair>
		  </Msub>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(f) and
	      <btypes:TYPE>
		<lem tag="T-sub-inversion"/>
	      </btypes:TYPE> (inversion of copy-coercion), we conclude
	      that 
	      <btypes:TYPE>
		<eq>
		  <aVal/>
		  <Pair>
		    <aVal num="1"/>
		    <aVal num="2"/>
		  </Pair>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(c and g), we conclude that the
	      execution can continue using the E:-S.1 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <sLoc/>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      the execution can continue using E:-S.2 rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similar to the above induction, we can show that if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <fst>
		      <deref>
			<hLoc/>
		      </deref>
		    </fst>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H1 rule, and if
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <select>
		    <snd>
		      <deref>
			<hLoc/>
		      </deref>
		    </snd>
		    <path/>
		  </select>
		</eq>
	      </btypes:TYPE>, 
	      execution can continue using the E:-H2 rule.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Dup: Only right execution is
	  permitted, and can take E-Dup# or E-Dup as
	  applicable.
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr num="1"/>
	      </deref>
	    </eq>
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr num="1"/>
		<ref>
		  <type/>
		</ref>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  Execution can take EL-^# or E-^# as
	  applicable if
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is a value, then, from
	  <btypes:TYPE>
	    <lem tag="T-canonical"/>
	  </btypes:TYPE> (canonical forms), we conclude that 
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <hLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>.
	  Now, since this is an lvalue, we are done in the case of
	  left execution. In the case of right execution, we can
	  take step E-^.
	</p>
      </li>
      <li>
	<p>
	  Case T-Pair: Similar to case T-Dup
	</p>
      </li>
      <li>
	<p>
	  Case T-Fst, Case T-Snd: Similar to case T-Deref.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <let kind="m">
		<id/>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </let>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, we can take E-Let-M.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-P: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="p">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <Msub>
		<aExpr/>
		<type/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>.
	  If
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, the execution can take E-Let-P.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-Weakening">
    <title>Weakening</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>,
      then
      <btypes:TYPE>
	<Forall/>
	<supeq>
	  <gamma dash="'"/>
	  <gamma/>
	</supeq>
	<text content=" and "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=", "/>
	<Sjudge>
	  <assume>
	    <gamma dash="'"/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
  </proof>
  <lemma id="T-Subtype-properties">
    <title>Properties of Copy Coercion</title>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Msub>
		  <type/>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</Msub>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <type/>
		  </maxz>
		  <type dash="'"/>
		</Msub>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<eq>
		  <maxz>
		    <type/>
		  </maxz>
		  <maxz>
		    <type dash="'"/>
		  </maxz>
		</eq>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type/>
		  </minz>
		  <minz>
		    <type dash="'"/>
		  </minz>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eq>
	      <maxz>
		<type/>
	      </maxz>
	      <maxz>
		<type dash="'"/>
	      </maxz>
	    </eq>
	  </btypes:TYPE>
	  or equivalently 
	  <btypes:TYPE>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>, then
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <Msub>
	      <maxz>
		<type/>
	      </maxz>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type/>
 	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
 	      <type num="2"/>
	      <type/>
	    </Msub>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists>
	      <type num="3"/>
	    </Exists>
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>, and
	  <btypes:TYPE>
	    <Msub>
	      <type num="3"/>
	      <type num="2"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Property 1 and 2: By straightforward induction on the derivation of
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE>.
    </p>
    <p>
      Property 3: By construction of 
      <btypes:TYPE>
	<type num="3"/>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  From property 1.b above, we have
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="1"/>
	    </eq>
	  </btypes:TYPE>.
	  Similarly, we have
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="2"/>
	    </eq>
	  </btypes:TYPE>.
	  Therefore,
	  <btypes:TYPE>
	    <eq under="minz">
	      <type/>
	      <type num="1"/>
	      <type num="2"/>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Let us pick
	  <btypes:TYPE>
	    <type num="3"/>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq>
	      <type num="3"/>
	      <eq under="minz">
		<type/>
		<type num="1"/>
		<type num="2"/>
	      </eq>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From S-Refl rule in 
	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="1"/>
	    </Msub>
	  </btypes:TYPE>. From this using property 1.a, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <minz>
		<type num="1"/>
	      </minz>
	    </Msub>
	  </btypes:TYPE>.
	  From case&nbsp;(2), we can write this as
	  <btypes:TYPE>
	    <Msub>
	      <type num="1"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	  Similarly, we obtain
	  <btypes:TYPE>
	    <Msub>
	      <type num="2"/>
	      <type num="3"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
    <p>
      Property 4: Similar to Property 3.
    </p>
  </proof>
  <lemma id="T-SSubstitution">
    <title>Subtype Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Msub>
	  <type num="1"/>
	  <type num="2"/>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <set>
	    <type num="1"/>
	    <type num="2"/>
	  </set>
	</models>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<Msub>
	  <Subst>
	    <aSubMap/>
	    <type num="1"/>
	  </Subst>
	  <minz>
	    <Subst>
	      <aSubMap/>
	      <type num="2"/>
	    </Subst>
	  </minz>
	</Msub>
      </btypes:TYPE> and
      <btypes:TYPE>
	<Msub>
	  <maxz>
	    <Subst>
	      <aSubMap/>
	      <type num="1"/>
	    </Subst>
	  </maxz>
	  <Subst>
	    <aSubMap/>
	    <type num="2"/>
	  </Subst>
	</Msub>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By using
      <btypes:TYPE>
	<lem tag="T-Subtype-properties"/>
      </btypes:TYPE> (properties 1 and 2)
      and
      <btypes:TYPE>
	<lem tag="T-sub-min"/>
      </btypes:TYPE>.
    </p>
  </proof>
<!--   <proof> -->
<!--     <p> -->
<!--       By induction on the derivation of  -->
<!--       <btypes:TYPE> -->
<!-- 	<Msub> -->
<!-- 	  <type num="1"/> -->
<!-- 	  <type num="2"/> -->
<!-- 	</Msub> -->
<!--       </btypes:TYPE>. We give the proof for the first property only, -->
<!--       the second property is similarly proved. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Refl is trivial. Cases S-Trans follows from induction -->
<!-- 	  hypothesis. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Fn: Here,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="a"/> -->
<!-- 		<type num="r"/> -->
<!-- 	      </fn> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="a" dash="'"/> -->
<!-- 		<type num="r" dash="'"/> -->
<!-- 	      </fn> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>, and we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <fn> -->
<!-- 		<type num="a"/> -->
<!-- 		<type num="r"/> -->
<!-- 	      </fn> -->
<!-- 	      <fn> -->
<!-- 		<type num="a" dash="'"/> -->
<!-- 		<type num="r" dash="'"/> -->
<!-- 	      </fn> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From the assumptions of this derivation of -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <fn> -->
<!-- 		    <type num="a"/> -->
<!-- 		    <type num="r"/> -->
<!-- 		  </fn> -->
<!-- 		  <fn> -->
<!-- 		    <type num="a" dash="'"/> -->
<!-- 		    <type num="r" dash="'"/> -->
<!-- 		  </fn> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>, we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type num="a"/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type num="a" dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <type num="r"/> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <type num="r" dash="'"/> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Therefore, we must have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minz> -->
<!-- 		      <type num="a"/> -->
<!-- 		    </minz> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minz> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		    </minz> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <maxz> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </maxz> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <maxz> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </maxz> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Further, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minz> -->
<!-- 			<type num="a"/> -->
<!-- 		      </minz> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minz> -->
<!-- 			<type num="a" dash="'"/> -->
<!-- 		      </minz> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <maxz> -->
<!-- 			<type num="r"/> -->
<!-- 		      </maxz> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <maxz> -->
<!-- 			<type num="r" dash="'"/> -->
<!-- 		      </maxz> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(2.c) and  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lem tag="T-msm_eq_ms"/> -->
<!-- 	      </btypes:TYPE>, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="a"/> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		    </Subst> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </Subst> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(2.d) and S-Fn rule, we conclude that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="a"/> -->
<!-- 		      <type num="r"/> -->
<!-- 		    </fn> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="a" dash="'"/> -->
<!-- 		      <type num="r" dash="'"/> -->
<!-- 		    </fn> -->
<!-- 		  </Subst> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>	       -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Pair: Follows from induction hypothesis, and the fact -->
<!-- 	  that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type num="1"/> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type num="2"/> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> implies -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<pair> -->
<!-- 		  <type num="1"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</pair> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <pair> -->
<!-- 		    <type num="1"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </pair> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-Mut: Cannot happen for first property (follows from -->
<!-- 	  induction hypothesis for the second property). -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case S-MT1: There are two sub-cases to consider: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <in> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <dom> -->
<!-- 		<aSubMap/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <notin> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <dom> -->
<!-- 		<aSubMap/> -->
<!-- 	      </dom> -->
<!-- 	    </notin> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Suppose -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<notin> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		  <dom> -->
<!-- 		    <aSubMap/> -->
<!-- 		  </dom> -->
<!-- 		</notin> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      That is, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <tvar name="alpha"/> -->
<!-- 		  </Subst> -->
<!-- 		  <tvar name="alpha"/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>.  -->
<!-- 	      We know that  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <stype/> -->
<!-- 		  </minzT> -->
<!-- 		  <type/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Therefore, we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <minzT> -->
<!-- 		      <stype/> -->
<!-- 		    </minzT> -->
<!-- 		  </Subst> -->
<!-- 		  <Subst> -->
<!-- 		    <aSubMap/> -->
<!-- 		    <type/> -->
<!-- 		  </Subst> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>, and further -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <minzT> -->
<!-- 			<stype/> -->
<!-- 		      </minzT> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      From case&nbsp;(5.a) and -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lem tag="T-msm_eq_ms"/> -->
<!-- 	      </btypes:TYPE>, we can write: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <stype/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		  <minzT> -->
<!-- 		    <Subst> -->
<!-- 		      <aSubMap/> -->
<!-- 		      <type/> -->
<!-- 		    </Subst> -->
<!-- 		  </minzT> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!-- 	<p> -->
<!-- 	  Since a substitution on strcturally equal types must preserve -->
<!-- 	  equality, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<minz> -->
<!-- 		  <stype/> -->
<!-- 		</minz> -->
<!-- 	      </Subst> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type/> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  Otherwise,  -->
<!-- 	  It must be true that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<stype/> -->
<!-- 	      </Subst> -->
<!-- 	      <stype dash="'"/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> for some base type  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype dash="'"/> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  because otherwise, the substitution will -->
<!-- 	  violate the grammar within the type -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <mbTop> -->
<!-- 	      <tvar name="alpha"/> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<stype/> -->
<!-- 	      </Subst> -->
<!-- 	    </mbTop> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Given this, we can conclude that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	      <stype dash="''"/> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> for some type -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype dash="''"/> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  By induction hypothesis, we know that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Now, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <maxzT> -->
<!-- 	      <stype/> -->
<!-- 	    </maxzT> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  is equal to  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype/> -->
<!-- 	  </btypes:TYPE> or -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <mutable> -->
<!-- 	      <stype/> -->
<!-- 	    </mutable> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Since  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <stype/> -->
<!-- 	  </btypes:TYPE> is not a maybe type,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <maxzT> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <stype/> -->
<!-- 		</Subst> -->
<!-- 	      </maxzT> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<maxzT> -->
<!-- 		  <stype/> -->
<!-- 		</maxzT> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. Therefore, we have, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <maxzT> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <stype/> -->
<!-- 		</Subst> -->
<!-- 	      </maxzT> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. The result is obtainable from S-MT1 rule. -->
<!-- 	  Let -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <stype num="1"/> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<Msub> -->
<!-- 		  <maxzT> -->
<!-- 		    <stype/> -->
<!-- 		  </maxzT> -->
<!-- 		</Msub> -->
<!-- 	      </Subst> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <stype num="2"/> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  Since we have  -->
	  
<!-- 	  By inspecting the copy coercion rules, we determine that in -->
<!-- 	  order for the relationship  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <stype num="1"/> -->
<!-- 	      <minz> -->
<!-- 		<Subst> -->
<!-- 		  <aSubMap/> -->
<!-- 		  <type/> -->
<!-- 		</Subst> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE> to hold,  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <minz> -->
<!-- 	      <Subst> -->
<!-- 		<aSubMap/> -->
<!-- 		<type/> -->
<!-- 	      </Subst> -->
<!-- 	    </minz> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </proof> -->
  <lemma id="T-Renaming">
    <title>Type Renaming</title>
    <p>
      For any substitution
      <btypes:TYPE>
	<eq>
	  <aSubMap/>
	  <plural>
	    <SubMap>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </SubMap>
	  </plural>
	</eq>
      </btypes:TYPE> where
      <btypes:TYPE>
	<mutex>
	  <set>
	    <tvars name="beta"/>
	  </set>
	  <ftvs>
	    <gamma/>
	    <store/>
	    <type/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE> 
	  then
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <TDjudge cst="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE> 
	  then
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<subst>
		  <aCtset/>
		  <tvars name="alpha"/>
		  <tvars name="beta"/>
		</subst>
		<Subst>
		  <aSubMap/>
		  <gamma/>
		</Subst>
		<Subst>
		  <aSubMap/>
		  <store/>
		</Subst>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By straightforward induction on the derivation of 
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and
      <btypes:TYPE>
	<TDjudge cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
      Note that a textual substitution is necessary on the 
      constraint set 
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> since
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <aCtset/>
	</Subst>
      </btypes:TYPE> does not substitute on the variables on the LHS
      of constraints in 
      <btypes:TYPE>
	<aCtset/>
      </btypes:TYPE> (see substitution rules in 
      figure&nbsp;<xref ref="subst_rules"/>).
      Further, 
      <btypes:TYPE>
	<subst>
	  <aCtset/>
	  <tvars name="alpha"/>
	  <tvars name="beta"/>
	</subst>
      </btypes:TYPE> subsumes (and is consistent with)
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <aCtset/>
	</Subst>
      </btypes:TYPE> since we are only substituting 
      variables for variables.      
    </p>
  </proof>
  <lemma id="Consistency-Propagation">
    <title>Consistency of Substitution over Type Derivation</title>
    <p>
      If
      <btypes:TYPE>
	<CST sp="yes">
	  <TDjudge>
	    <aExpr/>
	    <type/>
	  </TDjudge>
	</CST>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <set>
	    <gamma/>
	    <store/>
	    <type/>
	  </set>
	</models>
      </btypes:TYPE>, then,
      <btypes:TYPE>
	<models name="cst">
	  <aSubMap/>
	  <spset>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </spset>
	</models>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. 
    </p>
    <ol>
      <li>
	<p>
	  At any step of the derivation, let
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> be a type used in the derivation such that 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <gamma/>
	    </in>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <store/>
	    </in>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <in>
	      <type num="s"/>
	      <type/>
	    </in>
	  </btypes:TYPE> do not (necessarily) hold. For example, 
	  <btypes:TYPE>
	    <type dash="'"/>
	  </btypes:TYPE> in T-Id, 
	  <btypes:TYPE>
	    <fn>
	      <type num="a"/>
	      <type num="r"/>
	    </fn>
	  </btypes:TYPE> in T-App, or the type obtained by any
	  sub-derivation (for some sub-expression).
	</p>
      </li>
      <li>
	<p>
	  Through a suitable renaming of variables, and using
	  <btypes:TYPE>
	    <lem tag="T-Renaming"/>
	  </btypes:TYPE>, we can ensure
	  <btypes:TYPE>
	    <subeq>
	      <inter>
		<dom>
		  <aSubMap/>
		</dom>
		<ftvs>
		  <type num="s"/>
		</ftvs>
	      </inter>
	      <ftvs>
		<gamma/>
		<store/>
		<type/>
	      </ftvs>
	    </subeq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  We want to show
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>.
	  Therefore, we proceed by induction on the structure of 
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE>. The only interesting cases are
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case 
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbTop>
		<tvar/>
		<ptype/>
	      </mbTop>
	    </eq>
	  </btypes:TYPE>:
	</p>
	<ol>
	  <li>
	    <p>
	      By induction hypothesis, we have
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap/>
		  <ptype/>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<in>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</in>
	      </btypes:TYPE>:
	    </p>
	    <ol>
	      <li>
		<p>
		  Due to the assumption 
		  <btypes:TYPE>
		    <CST sp="yes">
		      <TDjudge>
			<aExpr/>
			<type/>
		      </TDjudge>
		    </CST>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <defn tag="maybe-consistent"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <Exists/>
		    <in>
		      <mbTop>
			<tvar/>
			<ptype dash="'"/>
		      </mbTop>
		      <collection or="yes">
			<gamma/>
			<store/>
			<type/>
		      </collection>
		    </in>
		  </btypes:TYPE> such that
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype/>
		      <ptype dash="'"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From the assumption
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
		      </set>
		    </models>
		  </btypes:TYPE>, and 
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <ptype dash="'"/>
		    </models>
		  </btypes:TYPE>.
		  From this, case&nbsp;(4.a) and
		  <btypes:TYPE>
		    <lem tag="Cst-additive"/>
		  </btypes:TYPE> (aggregation), we obtain
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<ptype/>
			<ptype dash="'"/>
		      </set>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(4.b.i and 4.b.ii), and
		  <btypes:TYPE>
		    <lem tag="T-sub-min"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	      <li>
		<p>
		  From the assumption
		  <btypes:TYPE>
		    <models name="cst">
		      <aSubMap/>
		      <set>
			<gamma/>
			<store/>
			<type/>
		      </set>
		    </models>
		  </btypes:TYPE>, case&nbsp;(4.b.i), and	  
		  <btypes:TYPE>
		    <defn tag="subst-consistent"/>
		  </btypes:TYPE>, we know that 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>, for some 
		  <btypes:TYPE>
		    <tvar name="beta"/>
		  </btypes:TYPE>, or
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<tvar/>
		      </Subst>
		      <ptype dash="''"/>
		    </eq>
		  </btypes:TYPE>, such that 
		  <btypes:TYPE>
		    <eq under="minzT">
		      <ptype dash="''"/>
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. Using case&nbsp;(4.b.iii), we can
		  write this as
		  <btypes:TYPE>
		    <eq under="minzT">
		      <Subst>
			<aSubMap/>
			<ptype dash="'"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		      <ptype dash="''"/>
		    </eq>
		  </btypes:TYPE>.      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <ftvs>
		    <gamma/>
		    <store/>
		    <type/>
		  </ftvs>
		</notin>
	      </btypes:TYPE>, then, we know that
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <dom>
		    <aSubMap/>
		  </dom>
		</notin>
	      </btypes:TYPE>, and therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap/>
		    <tvar/>
		  </Subst>
		  <tvar/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
	<p>
	  Therefore, in all cases, for some
	  <btypes:TYPE>
	    <tvar name="beta"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <tvar name="beta"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<tvar/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minzT">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case
	  <btypes:TYPE>
	    <eq>
	      <type num="s"/>
	      <mbFull>
		<stype/>
		<ptype/>
	      </mbFull>
	    </eq>
	  </btypes:TYPE>:
	  Similar to the previous case, we conclude that
	  for some
	  <btypes:TYPE>
	    <stype dash="'"/> 
	  </btypes:TYPE> and 
	  <btypes:TYPE>
	    <ptype dash="''"/>
	  </btypes:TYPE>, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <stype dash="'"/> 
	    </eq>
	  </btypes:TYPE>, or
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<stype/>
	      </Subst>
	      <ptype dash="''"/>
	    </eq>
	  </btypes:TYPE> such that
	  <btypes:TYPE>
	    <eq under="minz">
	      <ptype dash="''"/>
	      <Subst>
		<aSubMap/>
		<ptype/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  From cases&nbsp;(4 and 5), and 
	  <btypes:TYPE>
	    <defn tag="subst-consistent"/>
	  </btypes:TYPE>, we conclude that
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <type num="s"/>
	    </models>
	  </btypes:TYPE>. 
	</p>
      </li>
      <li>
	<p>
	  By repeating the same argument over all types
	  <btypes:TYPE>
	    <type num="s"/>
	  </btypes:TYPE> used in the derivation of
	  <btypes:TYPE>
	    <TDjudge>
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>, we finally obtain
	  <btypes:TYPE>
	    <models name="cst">
	      <aSubMap/>
	      <spset>
		<TDjudge>
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </spset>
	    </models>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="Composistion-Rearrange">
    <title>Composition Consistency</title>
    <p>
      If:
    </p>
    <p>
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="1"/>
	  <set>
	    <type/>
	  </set>
	</Cst>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="2"/>
	  <set>
	    <type/>
	  </set>
	</Cst>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="1"/>
	  <set>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </set>
	</Cst>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<mutex>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <ftvs>
	    <aSubMap num="1"/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>,
    </p>
    <p>
      Then, 
      <btypes:TYPE>
	<Exists/>
	<eq>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE> such that:
    </p>
    <p>
      <btypes:TYPE>
	<eq>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <dom>
	    <aSubMap num="2" dash="'"/>
	  </dom>
	</eq>
      </btypes:TYPE>, 
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="2" dash="'"/>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>, and 
      <btypes:TYPE>
	<Cst>
	  <aSubMap num="2" dash="'"/>
	  <set>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </set>
	</Cst>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By construction of
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE>.
      Let
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> be an idempotent substitution equivalent to 
      <btypes:TYPE>
	<compose>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</compose>
      </btypes:TYPE>.
      <btypes:TYPE>
	<aSubMap num="2" dash="'"/>
      </btypes:TYPE> can be choosen as a part of 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> that contains substitutions only for
      <btypes:TYPE>
	<dom>
	  <aSubMap num="2"/>
	</dom>
      </btypes:TYPE>.
      <!-- NOTE: NOTE: Here, we will have
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <aSubMap num="2" dash="'"/>
	  </Subst>
	  <aSubMap num="2" dash="'"/>
	</eq>
      </btypes:TYPE>,
      REMEMBER: This is for reference only. Substitution on 
      substitutions was removed. That must be re-introduced
      if this like is un-commented. -->
    </p>
  </proof>
  <lemma id="T-TSubstitution">
    <title>Type Substitution</title>
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <TDjudge cst="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <models name="cst">
	      <assume>
		<aSubMap/>
	      </assume>
	      <spset>
		<TDjudge>
		  <aExpr/>
		  <type/>
		</TDjudge>
	      </spset>
	    </models>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Sat>
	      <Subst>
		<aSubMap/>
		<aCtset/>
	      </Subst>
	      <Subst>
		<aSubMap/>
		<spset>
		  <TDjudge>
		    <aExpr/>
		    <type/>
		  </TDjudge>
		</spset>
	      </Subst>
	    </Sat>	      
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <mutex>
	      <ftvs>
		<aSubMap/>
	      </ftvs>
	      <pred name="gtv">
		<gamma/>
	      </pred>
	    </mutex>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <Subst>
	      <aSubMap/>
	      <aCtset/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <gamma/>
	    </Subst>
	    <Subst>
	      <aSubMap/>
	      <store/>
	    </Subst>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <Subst>
	      <aSubMap/>
	      <type/>
	    </Subst>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>. We proceed by case analysis on the last step of
      the derivation.
      Let
      <btypes:TYPE>
	<eq>
	  <aCtset num="s"/>
	  <Subst>
	    <aSubMap/>
	    <aCtset/>
	  </Subst>
	</eq>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  Cases T-Unit, T-True, T-False, T-Hloc and T-Sloc are trivial.
	</p>
      </li>
      <li>
	<p>
	  Case T-Id:
	</p>
	<ol>
	  <li>
	    <p>
	      We have
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>	
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma/>
			  <id/>
			  <TS>
			    <tvars/>
			    <type num="i"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap num="n"/>
			  <set>
			    <type num="i"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap/>
			  </dom>
			  <set>
			    <tvars/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <id/>
			  <Subst>
			    <aSubMap num="n"/>
			    <type num="i"/>
			  </Subst>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>      
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aExpr/>
		      <id/>
		    </eq>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <eq>
		      <type/>
		      <Subst>
			<aSubMap num="n"/>
			<type num="i"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <spset>
			<TDjudge>
			  <id/>
			  <Subst>
			    <aSubMap num="n"/>
			    <type num="i"/>
			  </Subst>
			</TDjudge>
		      </spset>
		    </models>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <aCtset num="s"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TDjudge>
			    <id/>
			    <Subst>
			      <aSubMap num="n"/>
			      <type num="i"/>
			    </Subst>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>		      
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From assumption&nbsp;(4), we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		    <set>
		      <tvars/>
		    </set>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	      Since
	      <btypes:TYPE>
		<eq>
		  <dom>
		    <aSubMap num="n"/>
		  </dom>
		  <set>
		    <tvars/>
		  </set>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <dom>
		      <aSubMap num="n"/>
		    </dom>
		    <ftvs>
		      <aSubMap/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a.i and 2.b), we have
	      <btypes:TYPE>	
		<mapsto>
		  <Subst>
		    <aSubMap/>
		    <gamma/>
		  </Subst>
		  <id/>
		  <TS>
		    <tvars/>
		    <Subst>
		      <aSubMap/>
		      <type num="i"/>
		    </Subst>
		  </TS>
		</mapsto>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  From 	
		  <btypes:TYPE>
		    <defn tag="constraint-colection-ext"/>
		  </btypes:TYPE>, we have
		  <btypes:TYPE>
		    <eq>
		      <spset>
			<TDjudge>
			  <id/>
			  <type/>
			</TDjudge>
		      </spset>
		      <spset>
			<gamma/>
			<store/>
			<type num="i"/>
			<type/>
		      </spset>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(2.a.iii and 2.d.i) and 
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we have
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <set>
			<type num="i"/>
		      </set>
		    </models>
		  </btypes:TYPE>.
		  Again using case&nbsp;(2.a.iv), we obtain
		  <btypes:TYPE>
		    <Sat>
		      <aCtset num="s"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="i"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>, which implies
		  <btypes:TYPE>
		    <CST sp="yes">
		      <Subst>
			<aSubMap/>
			<type num="i"/>
		      </Subst>
		    </CST>
		  </btypes:TYPE>.
		  Now using 
		  <btypes:TYPE>
		    <defn tag="subst-consistent"/>
		  </btypes:TYPE>, we obtain
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<type num="i"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(2.a.i), we have
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap num="n"/>
		      <set>
			<type num="i"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similar to case (2.d.ii), we obtain
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<Subst>
			  <aSubMap num="n"/>
			  <type num="i"/>
			</Subst>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.d.i, 2.d.ii, 2.d.iii, and 2.b), 
	      and
	      <btypes:TYPE>
		<lem tag="Composistion-Rearrange"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<Exists/>
		<aSubMap num="m"/>
	      </btypes:TYPE> such that:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aSubMap num="m"/>
		      </dom>
		      <dom>
			<aSubMap num="n"/>
		      </dom>
		      <set>
			<tvars/>
		      </set>
		    </eq>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		      <Subst>
			<sSubMap/>
			<Subst>
			  <aSubMap num="n"/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="m"/>
			<Subst>
			  <aSubMap/>
			  <type num="i"/>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>		
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap num="m"/>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="i"/>
			</Subst>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.c, 2.e.i and 2.e,iii), and the T-Id rule
	      we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap num="m"/>
		      <Subst>
			<aSubMap/>
			<type num="i"/>
		      </Subst>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.f and 2.e.ii), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From 	
	      <btypes:TYPE>
		<defn tag="constraint-colection-ext"/>
	      </btypes:TYPE>, we have:
	      <btypes:TYPE>
		<eq>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<id/>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="i"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		</eq>
	      </btypes:TYPE>.
	      Clearly, 
	      <btypes:TYPE>
		<subeq>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="i"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <spset>
			<gamma/>
			<store/>
			<type num="i"/>
			<type/>
		      </spset>
		    </Subst>
		  </spset>
		</subeq>
	      </btypes:TYPE>.	      
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(2.a.iv and 2.d.i), we have
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <Subst>
		    <aSubMap/>
		    <spset>
		      <gamma/>
		      <store/>
		      <type num="i"/>
		      <type/>
		    </spset>
		  </Subst>
		</Sat>
	      </btypes:TYPE>. Now, from 
	      <btypes:TYPE>
		<lem tag="maybe-cst-properties"/>
	      </btypes:TYPE> (property-3), we obtain
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <spset>
			<gamma/>
			<store/>
			<type num="i"/>
			<type/>
		      </spset>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE>.	      
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, from cases&nbsp;(3.i and 3.h) and
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening), we obtain
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <spset>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="i"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </spset>
		</Sat>
	      </btypes:TYPE> and therefore
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<id/>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		</Sat>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Finally, from cases&nbsp;(2.g and 2.j) and
	      <btypes:TYPE>
		<defn tag="consistent-typing"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <aCtset/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <id/>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: Follows from induction hypothesis, using the 
	  T-Lambda rule.
	</p>
      </li>
      <li>
	<p>
	  Case T-App: 
	</p>
	<ol>
	  <li>
	    <p>
	      In this case, we have:
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<TDjudge>
			  <aExpr num="1"/>
			  <type num="1"/>
			</TDjudge>
			<Msub>
			  <type num="1"/>
			  <fn>
			    <type num="a"/>
			    <type num="r"/>
			  </fn>
			</Msub>
		      </tyPre>
		      <tyPre>
			<TDjudge Msub="yes">
			  <aExpr num="2"/>
			  <type num="2"/>
			</TDjudge>
			<Msub>
			  <type num="2"/>
			  <minz>
			    <type num="a"/>
			  </minz>
			</Msub>
			<Msub>
			  <maxz>
			    <type num="r"/>
			  </maxz>
			  <type/>
			</Msub>
		      </tyPre>
		      <tyConc>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </tyConc>
		    </tyRule>
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <models name="cst">
		      <assume>
			<aSubMap/>
		      </assume>
		      <spset>
			<TDjudge>
			  <apply>
			    <aExpr num="1"/>
			    <aExpr num="2"/>
			  </apply>
			  <type/>
			</TDjudge>
		      </spset>
		    </models>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap/>
			<aCtset/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<spset>
			  <TDjudge>
			    <apply>
			      <aExpr num="1"/>
			      <aExpr num="2"/>
			    </apply>
			    <type/>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      By induction hypothesis (by using case&nbsp;(4.a.i), 
	      weakening on cases&nbsp;(4.a.ii and 4.a.iii), and
	      assumption&nbsp;(4)), we have:
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset num="s"/>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr num="1"/>
		    <Subst>
		      <aSubMap/>
		      <type num="1"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset num="s"/>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aExpr num="2"/>
		    <Subst>
		      <aSubMap/>
		      <type num="2"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>. That is,
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="1"/>
			<Subst>
			  <aSubMap/>
			  <type num="1"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <aCtset num="s"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <Subst>
			      <aSubMap/>
			      <gamma/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr num="1"/>
			    <Subst>
			      <aSubMap/>
			      <type num="1"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<aExpr num="2"/>
			<Subst>
			  <aSubMap/>
			  <type num="2"/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <aCtset num="s"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <Subst>
			      <aSubMap/>
			      <gamma/>
			    </Subst>
			    <Subst>
			      <aSubMap/>
			      <store/>
			    </Subst>
			  </assume>
			  <tqExpr>
			    <aExpr num="2"/>
			    <Subst>
			      <aSubMap/>
			      <type num="2"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(4.a.i), we have
	      <btypes:TYPE>
		<Msub>
		  <type num="1"/>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		</Msub>
	      </btypes:TYPE>. Using weakening on case&nbsp;(4.a.ii)
	      and 
	      <btypes:TYPE>
		<lem tag="T-SSubstitution"/>
	      </btypes:TYPE>, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <fn>
			<type num="a"/>
			<type num="r"/>
		      </fn>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>, which is equivalent to
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="1"/>
		  </Subst>
		  <fn>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <type num="r"/>
		    </Subst>
		  </fn>
		</Msub>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, we obtain
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>. 
	      Using weakening on case&nbsp;(4.a.ii)
	      and 
	      <btypes:TYPE>
		<lem tag="T-msm_eq_ms"/>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <minz>
			<type num="a"/>
		      </minz>
		    </Subst>
		  </minz>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		  </minz>
		</eq>
	      </btypes:TYPE>. 
	      <btypes:TYPE>
		<Msub>
		  <Subst>
		    <aSubMap/>
		    <type num="2"/>
		  </Subst>
		  <minz>
		    <Subst>
		      <aSubMap/>
		      <type num="a"/>
		    </Subst>
		  </minz>
		</Msub>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, we obtain
	      <btypes:TYPE>
		<Msub>
		  <maxz>
		    <Subst>
		      <aSubMap/>
		      <type num="r"/>
		    </Subst>
		  </maxz>
		  <Subst>
		    <aSubMap/>
		    <type/>
		  </Subst>
		</Msub>
	      </btypes:TYPE>. 
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.b.i, 4.b.ii, 4.c, 4.d and 4.e) and
	      using T-App rule, we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="1"/>
		    </apply>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Using weakening on case&nbsp;(4.a.ii), we obtain
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <fn>
		    <type num="a"/>
		    <type num="r"/>
		  </fn>
		  <type/>
		</Sat>
	      </btypes:TYPE>. Using this and cases&nbsp;(4.b.ii
	      and 4.b.iv), and 
	      <btypes:TYPE>
		<lem tag="Cst-additive"/>
	      </btypes:TYPE> (aggregation), along with 
	      <btypes:TYPE>
		<defn tag="constraint-colection-ext"/>
	      </btypes:TYPE> (constraint collection), we conclude that 
	      <btypes:TYPE>
		<Sat>
		  <aCtset num="s"/>
		  <spset>
		    <Sjudge>
		      <assume>
			<Subst>
			  <aSubMap/>
			  <gamma/>
			</Subst>
			<Subst>
			  <aSubMap/>
			  <store/>
			</Subst>
		      </assume>
		      <tqExpr>
			<apply>
			  <aExpr num="1"/>
			  <aExpr num="2"/>
			</apply>
			<Subst>
			  <aSubMap/>
			  <type/>
			</Subst>
		      </tqExpr>
		    </Sjudge>
		  </spset>
		</Sat>
	      </btypes:TYPE>	      
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(4.f and 4.g), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap/>
		      <aCtset/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <apply>
		      <aExpr num="1"/>
		      <aExpr num="2"/>
		    </apply>
		    <Subst>
		      <aSubMap/>
		      <type/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>	      	      
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Let-P: In this case, we have
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<TDjudge Msub="yes">
		  <vExp/>
		  <type/>
		</TDjudge>
		<pred name="Immut">
		  <type/>
		</pred>
		<eq>
		  <set>
		    <tvars name="alpha"/>
		  </set>
		  <diff>
		    <ftvs>
		      <type/>
		    </ftvs>
		    <ftvs>
		      <gamma/>
		      <store/>
		    </ftvs>
		  </diff>
		</eq>
	      </tyPre>
	      <tyPre>
		<Sjudge>
		  <assume>
		    <extend>
		      <gamma/>
		      <mapping>
			<id/>
			<TS>
			  <tvars/>
			  <type/>
			</TS>
		      </mapping>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type dash="'"/>
		  </tqExpr>
		</Sjudge>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <paren>
		    <let kind="p">
		      <id/>
		      <vExp/>
		      <aExpr/>
		    </let>
		  </paren>
		  <type dash="'"/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<p>
	  Proof is similar to T-App case. Without loss of generality,
	  we can assume that
	  <btypes:TYPE>
	    <mutex>
	      <ftvs>
		<aSubMap/>
	      </ftvs>
	      <set>
		<tvars/>
	      </set>
	    </mutex>
	  </btypes:TYPE> since type schemes are equal under 
	  <btypes:TYPE>
	    <tvar name="alpha"/>
	  </btypes:TYPE>-renaming of generalized variables.
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-VSubstitution">
    <title>Value Substitution</title>
    <p>
      If
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<aCtset/>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <TS>
		      <tvars/>
		      <type num="v"/>
		    </TS>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <TDjudge cst="yes">
	      <aVal/>
	      <type num="v"/>
	    </TDjudge>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <pred name="Immut">
	      <type num="v"/>
	    </pred>
	  </btypes:TYPE>
	  <!-- This predicate is necessary since the pair rule can
	  derive mutable types for pair of values (v,v) and the
	  substitution can go wrong if performed on the lhs of
	  an assignment. This predicate effectively rules out
	  substitution on the lhs of an assignment.--> 	
	</p>
      </li>
    </ol>
    <p>
      Then,
      <btypes:TYPE>
	<Exists/>
	<subeq>
	  <aCtset dash="'"/>
	  <aCtset/>
	</subeq>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <aCtset dash="'"/>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the type derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <aCtset/>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<TS>
		  <tvars/>
		  <type num="v"/>
		</TS>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>
      We proceed by case analysis on the final step of the
      derivation.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id name="y"/>
	    </eq>
	    <text content=", where "/>
	    <in>
	      <id name="y"/>
	      <extend>
		<gamma/>
		<id/>
		<aTS/>
	      </extend>
	    </in>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<neq>
		  <eq>
		    <aExpr/>
		    <id name="y"/>
		  </eq>
		  <id name="x"/>
		</neq>
	      </btypes:TYPE>, then,
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>.
	      and the desired result
	      <btypes:TYPE>
		<TDjudge cst="yes">
		  <id name="y"/>
		  <type/>
		</TDjudge>
	      </btypes:TYPE>
	      is immediate from the assumtion
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset/>
		    <extend>
		      <gamma/>
		      <tqExpr>
			<id/>
			<TS>
			  <tvars/>
			  <type num="v"/>
			</TS>
		      </tqExpr>
		    </extend>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<eq>
		  <aExpr/>
		  <id name="x"/>
		  <id name="y"/>
		</eq>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <subst>
		    <id name="y"/>
		    <id name="x"/>
		    <aVal/>
		  </subst>
		  <aVal/>
		</eq>
	      </btypes:TYPE> and
	      <btypes:TYPE>
		<eq>
		  <type/>
		  <Subst>
		    <aSubMap/>
		    <type num="v"/>
		  </Subst>
		</eq>
	      </btypes:TYPE>.
	      Let
	      <btypes:TYPE>
		<eq>
		  <gamma dash="'"/>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <TS>
			<tvars/>
			<type num="v"/>
		      </TS>
		    </tqExpr>
		  </extend>
		</eq>
	      </btypes:TYPE>.
	      In this case, we have
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma dash="'"/>
			  <id name="y"/>
			  <TS>
			    <tvars/>
			    <type num="v"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap/>
			  <set>
			    <type num="v"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap/>
			  </dom>
			  <set>
			    <tvars/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>        
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <aCtset/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap/>
			      <type num="v"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <TDjudge cst="yes">
		      <aVal/>
		      <type num="v"/>
		    </TDjudge>
		  </btypes:TYPE>. That is,
		</p>
		<ol>
		  <li>
		    <p>
		      <btypes:TYPE>
			<TDjudge>
			  <aVal/>
			  <type num="v"/>
			</TDjudge>
		      </btypes:TYPE>
		    </p>
		  </li>
		  <li>
		    <p>
		      <btypes:TYPE>
			<Sat>
			  <aCtset/>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="v"/>
			    </TDjudge>
			  </spset>
			</Sat>
		      </btypes:TYPE>
		    </p>
		  </li>
		</ol>
	      </li>
	    </ol>
	    <p>
	      We need to show that 
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <aCtset dash="'"/>
		  <aCtset/>
		</supeq>
		<ST/>
		<Sjudge>
		  <assume>
		    <aCtset dash="'"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap/>
		      <type num="v"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Without loss of generality, we can assume that 
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<gamma/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<gamma/>
		      </Subst>
		      <gamma/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<store/>
		      </ftvs>
		    </mutex>
		  </btypes:TYPE>. That is,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap/>
			<store/>
		      </Subst>
		      <store/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <ftvs>
			<aSubMap/>
		      </ftvs>
		      <pred name="gtv">
			<gamma/>
		      </pred>
		    </mutex>
		  </btypes:TYPE>. 
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE> 
		    <ftvs>
		      <range>
			<aSubMap/>
		      </range>
		    </ftvs>
		  </btypes:TYPE> consists of type variables in
		  <btypes:TYPE> 
		    <diff>
		      <ftvs>
			<gamma/>
			<store/>
			<type num="v"/>
		      </ftvs>
		      <set>
			<tvars/>
		      </set>
		    </diff>
		  </btypes:TYPE> or fresh type variables.
		</p>
		<p>
		  The above properties can always be made to
		  hold by suitable renaming of variables and using 
		  <btypes:TYPE>
		    <lem tag="T-Renaming"/>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<tvars/>
		      </set>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>. 
		  <br/>
		  This is because, due to renamability of variables, we have
		  <btypes:TYPE>
		    <eq>
		      <inter>
			<ftvs>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="v"/>
			    </TDjudge>
			  </spset>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </inter>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </eq>
		  </btypes:TYPE> , and any 
		  <btypes:TYPE> 
		    <subeq>
		      <set>
			<tvars name="beta"/>
		      </set>
		      <set>
			<tvars/>
		      </set>
		    </subeq>
		    <ST/>
		    <notin>
		      <tvar name="beta"/>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </notin>
		  </btypes:TYPE> can be ignored.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.b.i and 1.b.ii) we can say that
	      <btypes:TYPE>
		<Exists/>
		<supeq>
		  <aCtset num="big"/>
		  <aCtset/>
		</supeq>
		<ST/>
		<Sat>
		  <aCtset num="big"/>
		  <Subst>
		    <aSubMap/>
		    <spset>
		      <type num="v"/>
		    </spset>
		  </Subst>
		</Sat>
	      </btypes:TYPE>.
	      This is because:
	    </p>
	    <ol>
	      <li>
		<p>
		  From case&nbsp;(1.b.i) we have
		  <btypes:TYPE>
		    <Cst>
		      <aSubMap/>
		      <set>
			<type num="v"/>
		      </set>
		    </Cst>
		  </btypes:TYPE>.
		  From this, using
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <Cst>
		      <assume/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </Cst>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(1.b.ii) and
		  <btypes:TYPE>
		    <lem tag="Cst-Weakening"/>
		  </btypes:TYPE> (weakening), we obtain
		  <btypes:TYPE>
		    <Sat>
		      <aCtset/>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="v"/>
			</Subst>
		      </set>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Since 
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<Subst>
			  <aSubMap/>
			  <type num="v"/>
			</Subst>
		      </set>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </subeq>
		  </btypes:TYPE>, using case&nbsp;(1.i) and
		  <btypes:TYPE>
		    <lem tag="maybe-cst-properties"/>
		  </btypes:TYPE> (property-4), we conclude that 
		  <btypes:TYPE>
		    <Exists/>
		    <supeq>
		      <aCtset num="big"/>
		      <aCtset/>
		    </supeq>
		    <ST/>
		    <Sat>
		      <aCtset num="big"/>
		      <Subst>
			<aSubMap/>
			<spset>
			  <type num="v"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<Forall/>
		<in>
		  <grouping>
		    <Tceq>
		      <tvar name="beta"/>
		      <ptype/>
		    </Tceq>
		    <text content=" or "/>
		    <ceq>
		      <tvar name="beta"/>
		      <ptype/>
		    </ceq>
		  </grouping>
		  <aCtset/>
		</in>
		<ST/>
		<notin>
		  <tvar name="beta"/>
		  <set>
		    <tvars/>
		  </set>
		</notin>
	      </btypes:TYPE>, 
	      <btypes:TYPE>
		<mutex>
		  <ftvs>
		    <ptype/>
		  </ftvs>
		  <set>
		    <tvars/>
		  </set>
		</mutex>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      Otherwise, due to case&nbsp;(1.d), 
	      <btypes:TYPE>
		<Exists/>
		<in>
		  <grouping>
		    <Tceq>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		    </Tceq>
		    <text content=" or "/>
		    <ceq>
		      <tvar name="beta"/>
		      <Subst>
			<aSubMap/>
			<ptype/>
		      </Subst>
		    </ceq>
		  </grouping>
		  <aCtset num="big"/>
		</in>
	      </btypes:TYPE> such that
	      <btypes:TYPE>
		<neq>
		  <Subst>
		    <aSubMap/>
		    <ptype/>
		  </Subst>
		  <ptype/>
		</neq>
	      </btypes:TYPE>, which violates the restriction
	      <btypes:TYPE>
		<meta>
		  <aCtset num="big"/>
		</meta>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      We can write
	      <btypes:TYPE>
		<eq>
		  <aCtset/>
		  <unin>
		    <aCtset num="e"/>
		    <aCtset num="t"/>
		    <aCtset num="a"/>
		    <aCtset num="r"/>
		  </unin>
		</eq>
	      </btypes:TYPE> where:
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aCtset num="e"/>
		      </dom>
		      <ftvs>
			<gamma/>
			<store/>
		      </ftvs>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aCtset num="t"/>
		      </dom>
		      <diff>
			<ftvs>
			  <type num="v"/>
			</ftvs>
			<ftvs>
			  <gamma/>
			  <store/>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </diff>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <dom>
			<aCtset num="a"/>
		      </dom>
		      <set>
			<tvars/>
		      </set>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <mutex>
		      <dom>
			<aCtset num="e"/>
		      </dom>
		      <dom>
			<aCtset num="t"/>
		      </dom>
		      <dom>
			<aCtset num="a"/>
		      </dom>
		      <dom>
			<aCtset num="r"/>
		      </dom>
		    </mutex>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  Let 
 		  <btypes:TYPE>
		    <eq>
		      <aCtset num="et"/>
		      <unin>
			<aCtset num="e"/>
			<aCtset num="t"/>
		      </unin>
		    </eq>
		  </btypes:TYPE> and
 		  <btypes:TYPE>
		    <eq>
		      <aCtset num="ar"/>
		      <unin>
			<aCtset num="a"/>
			<aCtset num="r"/>
		      </unin>
		    </eq>
		  </btypes:TYPE> 
		</p>
	      </li>
	      <li>
		<p>
		  From case(1.f.i), weakening on (1.a.ii), and
		  <btypes:TYPE>
		    <lem tag="maybe-cst-properties"/>
		  </btypes:TYPE> (property-8), we have
		  <btypes:TYPE>
		    <subeq>
		      <ftvs>
			<range>
			  <aCtset num="e"/>
			</range>
		      </ftvs>
		      <ftvs>
			<gamma/>
			<store/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, using case&nbsp;(1.e), we conclude that 
		  <btypes:TYPE>
		    <subeq>
		      <ftvs>
			<range>
			  <aCtset num="t"/>
			</range>
		      </ftvs>
		      <diff>
			<ftvs>
			  <gamma/>
			  <store/>
			  <type num="v"/>
			</ftvs>
			<set>
			  <tvars/>
			</set>
		      </diff>
		    </subeq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Therefore, we have
		  <btypes:TYPE>
		    <mutex>
		      <ftvs>
			<aCtset num="et"/>
		      </ftvs>
		      <dom>
			<aCtset num="at"/>
		      </dom>
		    </mutex>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Let 
	    </p>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <set>
			<tvars name="beta"/>
		      </set>
		      <dom>
			<aCtset num="r"/>
		      </dom>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="a"/>
		      <plural>
			<SubMap>
			  <tvar name="alpha"/>
			  <tvar name="gamma"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <tvars name="gamma"/>
		  </btypes:TYPE> are new type variables.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="b"/>
		      <plural>
			<SubMap>
			  <tvar name="beta"/>
			  <tvar name="delta"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <tvars name="delta"/>
		  </btypes:TYPE> are new type variables.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aSubMap num="ab"/>
		      <compose>
			<aSubMap num="a"/>
			<aSubMap num="b"/>
		      </compose>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aCtset num="ab"/>
		      <subst>
			<subst>
			  <aCtset/>
			  <tvars name="alpha"/>
			  <tvars name="gamma"/>
			</subst>
			<tvars name="beta"/>
			<tvars name="delta"/>
		      </subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
		<p>
		  Due to case&nbsp;(1.g), 
		  <btypes:TYPE>
		    <eq>
		      <aCtset num="ab"/>
		      <unin>
			<aCtset num="et"/>
			<aCtset num="ar" dash="'"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>
		    <eq>
		      <aCtset num="ar" dash="'"/>
		      <subst>
			<subst>
			  <aCtset num="ar"/>
			  <tvars name="alpha"/>
			  <tvars name="gamma"/>
			</subst>
			<tvars name="beta"/>
			<tvars name="delta"/>
		      </subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <type num="va"/>
		      <Subst>
			<aSubMap num="a"/>
			<type num="v"/>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>	
		    <eq>
		      <aSubMap dash="'"/>
		      <plural>
			<SubMap>
			  <tvar name="gamma"/>
			  <type num="s"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>, where
		  <btypes:TYPE>	
		    <eq>
		      <aSubMap/>
		      <plural>
			<SubMap>
			  <tvar name="alpha"/>
			  <type num="s"/>
			</SubMap>
		      </plural>
		    </eq>
		  </btypes:TYPE>
		</p>
		<p>
		  Note that 
 		  <btypes:TYPE>	
		    <Forall/>
		    <type num="s"/>
		  </btypes:TYPE> above,
 		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap num="ab"/>
			<type num="s"/>
		      </Subst>
		      <type num="s"/>
		    </eq>
		  </btypes:TYPE> due to case&nbsp;(1.c.iv).
		</p>
		<p>
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<gamma/>
		      </Subst>
		      <gamma/>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<store/>
		      </Subst>
		      <store/>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>	
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<type num="va"/>
		      </Subst>
		      <Subst>
			<aSubMap/>
			<type num="v"/>
		      </Subst>
		      <type/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  Let
		  <btypes:TYPE>
		    <eq>
		      <aCtset dash="'"/>
		      <unin>
			<aCtset/>
			<aCtset num="ab"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  This can be written as:<br/>
		  <btypes:TYPE>
		    <eq>
		      <aCtset dash="'"/>
		      <unin>
			<aCtset num="et"/>
			<aCtset num="ar"/>
			<aCtset num="et"/>
			<aCtset num="ar" dash="'"/>
		      </unin>
		      <unin>
			<aCtset/>
			<aCtset num="ar" dash="'"/>
		      </unin>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Since 
		  <btypes:TYPE>
		    <dom>
		      <aCtset num="ar" dash="'"/>
		    </dom>
		  </btypes:TYPE> consists of new type variables,
		  we have
		  <btypes:TYPE>
		    <meta>
		      <aCtset dash="'"/>
		    </meta>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Further, since
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<aCtset/>
		      </Subst>
		      <aCtset/>
		    </eq>
		  </btypes:TYPE>, we have
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap dash="'"/>
			<aCtset dash="'"/>
		      </Subst>
		      <unin>
			<aCtset/>
			<Subst>
			  <aSubMap dash="'"/>
			  <aCtset num="ar" dash="'"/>
			</Subst>
		      </unin>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1.b.iii and 1.h) using
	      <btypes:TYPE>
		<lem tag="T-Renaming"/>
	      </btypes:TYPE> (renaming), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset num="ab"/>
		    <Subst>
		      <aSubMap num="ab"/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap num="ab"/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap num="ab"/>
		      <type num="v"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      From cases&nbsp;(1.f and 1.h), we can write this as
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset num="ab"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type num="va"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      From cases&nbsp;(1.j, 1.i.i and 1.i.iii) and
	      <btypes:TYPE>
		<lem tag="Cst-Weakening"/>
	      </btypes:TYPE> (weakening) (property-5), we obtain
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <aCtset dash="'"/>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type num="va"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Similarly, by applying variable renaming on 
	      case&nbsp;(1.b.i and 1.b.ii), we obtain
	    </p>
	    <ol>
	      <li>
		<btypes:TYPE>
		  <Hrules>
		    <tyRule>
		      <tyPre>
			<mapsto>
			  <gamma dash="'"/>
			  <id name="y"/>
			  <TS>
			    <tvars name="gamma"/>
			    <type num="va"/>
			  </TS>
			</mapsto>
			<Cst>
			  <aSubMap/>
			  <set>
			    <type num="va"/>
			  </set>
			</Cst>
			<eq>
			  <dom>
			    <aSubMap dash="'"/>
			  </dom>
			  <set>
			    <tvars name="gamma"/>
			  </set>
			</eq>
		      </tyPre>
		      <tyConc>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap dash="'"/>
			      <type num="va"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </tyConc>
		    </tyRule>        
		  </Hrules>
		</btypes:TYPE>
	      </li>
	      <li>
		<p>
		  <btypes:TYPE>
		    <Sat>
		      <aCtset dash="'"/>
		      <spset>
			<Sjudge>
			  <assume>
			    <gamma dash="'"/>
			    <store/>
			  </assume>
			  <tqExpr>
			    <id name="y"/>
			    <Subst>
			      <aSubMap dash="'"/>
			      <type num="va"/>
			    </Subst>
			  </tqExpr>
			</Sjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      From case&nbsp;(1.l.i), we have
	      <btypes:TYPE>
		<Cst>
		  <aSubMap dash="'"/>
		  <set>
		    <type num="va"/>
		  </set>
		</Cst>
	      </btypes:TYPE>, which implies by weakening,
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <set>
		    <type num="va"/>
		  </set>
		</models>
	      </btypes:TYPE>, and further due to case&nbsp;(1.h.vii), 
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <set>
		    <gamma/>
		    <store/>
		    <type num="va"/>
		  </set>
		</models>
	      </btypes:TYPE>.
	      Case&nbsp;(1.h) implies
	      <btypes:TYPE>
		<CST sp="yes">
		  <TDjudge>
		    <aVal/>
		    <type num="va"/>
		  </TDjudge>
		</CST>
	      </btypes:TYPE>. Using these facts with
	      <btypes:TYPE>
		<lem tag="Consistency-Propagation"/>
	      </btypes:TYPE>, we conclude that 
	      <btypes:TYPE>
		<models name="cst">
		  <aSubMap dash="'"/>
		  <spset>
		    <TDjudge>
		      <aVal/>
		      <type num="va"/>
		    </TDjudge>
		  </spset>
		</models>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <ol>
	      <li>
		<p>
		  From case&nbsp;(1.l.i), similar to case&nbsp;(1.d), 
		  we conclude that 
		  <btypes:TYPE>
		    <Exists/>
		    <supeq>
		      <aCtset dash="''"/>
		      <aCtset dash="'"/>
		    </supeq>
		    <ST/>
		    <Sat>
		      <aCtset dash="''"/>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <type num="va"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		  Due to idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap dash="'"/>
		  </btypes:TYPE>, we can write this as
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap dash="'"/>
			<aCtset dash="''"/>
		      </Subst>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <type num="va"/>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  By weakening on case&nbsp;(1.k), we obtain
		  <btypes:TYPE>
		    <Sjudge>
		      <assume>
			<aCtset dash="''"/>
			<gamma/>
			<store/>
		      </assume>
		      <tqExpr>
			<aVal/>
			<type num="va"/>
		      </tqExpr>
		    </Sjudge>
		  </btypes:TYPE>. This implies
		  <btypes:TYPE>
		    <Sat>
		      <aCtset dash="''"/>
		      <spset>
			<TDjudge>
			  <aVal/>
			  <type num="va"/>
			</TDjudge>
		      </spset>
		    </Sat>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  Evidently, 
		  <btypes:TYPE>
		    <subeq>
		      <set>
			<type num="va"/>
		      </set>
		      <spset>
			<TDjudge>
			  <aVal/>
			  <type num="va"/>
			</TDjudge>
		      </spset>
		    </subeq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(1.c.v and 1.h.ii) we conclude that
		  <btypes:TYPE>
		    <subeq>
		      <dom>
			<aSubMap dash="'"/>
		      </dom>
		      <ftvs>
			<type num="v"/>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>. This implies
		  <btypes:TYPE>
		    <subeq>
		      <inter>
			<dom>
			  <aSubMap dash="'"/>
			</dom>
			<ftvs>
			  <spset>
			    <TDjudge>
			      <aVal/>
			      <type num="va"/>
			    </TDjudge>
			  </spset>
			</ftvs>
		      </inter>
		      <ftvs>
			<set>
			  <type num="v"/>
			</set>
		      </ftvs>
		    </subeq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(1.n.ii, 1.m, 1.n.iii, 1.n.i and
		  1.n.iv) and 
		  <btypes:TYPE>
		    <lem tag="cst-streangthening-cor"/>
		  </btypes:TYPE> (strengthening), we conclude that
		  <btypes:TYPE>
		    <Sat>
		      <Subst>
			<aSubMap dash="'"/>
			<aCtset dash="''"/>
		      </Subst>
		      <Subst>
			<aSubMap dash="'"/>
			<spset>
			  <TDjudge>
			    <aVal/>
			    <type num="va"/>
			  </TDjudge>
			</spset>
		      </Subst>
		    </Sat>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Evidently,
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap dash="'"/>
		  </dom>
		  <pred name="gtv">
		    <gamma/>
		  </pred>
		</mutex>
	      </btypes:TYPE>. 
	      Now, from cases&nbsp;(1.n.ii, 1.m and 1.n.v) and
	      <btypes:TYPE>
		<lem tag="T-TSubstitution"/>
	      </btypes:TYPE> (type substitution), we conclude that
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap dash="'"/>
		      <aCtset dash="''"/>
		    </Subst>
		    <Subst>
		      <aSubMap dash="'"/>
		      <gamma/>
		    </Subst>
		    <Subst>
		      <aSubMap dash="'"/>
		      <store/>
		    </Subst>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <Subst>
		      <aSubMap dash="'"/>
		      <type num="va"/>
		    </Subst>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	      From case&nbsp;(1.h.vii), this can be written as
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <Subst>
		      <aSubMap dash="'"/>
		      <aCtset dash="''"/>
		    </Subst>
		    <gamma/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aVal/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Now, 
	      <btypes:TYPE>
		<eq>
		  <aCtset dash="''"/>
		  <unin>
		    <aCtset/>
		    <aCtset num="rest"/>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	      From case&nbsp;(1.i.iv), we have
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap dash="'"/>
		    <aCtset dash="''"/>
		  </Subst>
		  <unin>
		    <aCtset/>
		    <Subst>
		      <aSubMap dash="'"/>
		      <aCtset num="rest"/>
		    </Subst>
		  </unin>
		</eq>
	      </btypes:TYPE>.
	      Therefore, 
	      <btypes:TYPE>
		<supeq>
		  <Subst>
		    <aSubMap dash="'"/>
		    <aCtset dash="''"/>
		  </Subst>
		  <aCtset/>
		</supeq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Lambda: We have
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lambda>
		<id name="y"/>
		<aExpr dash="'"/>
	      </lambda>
	    </eq>
	    <text content=", and "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </eq>
	    
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <aTS/>
		  </tqExpr>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
	<p>
	  We can assume that
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	  Since it is clear that the type
	  <btypes:TYPE>
	    <type num="1"/>
	  </btypes:TYPE>
	  of
	  <btypes:TYPE>
	    <id name="y"/>
	  </btypes:TYPE>
	  can either use variables already in
	  <btypes:TYPE>
	    <gamma/>
	  </btypes:TYPE>
	  or fresh type variables, we know that
	  <btypes:TYPE>
	    <eq>
	      <inter>
		<ftvs>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <type num="1"/>
		    </tqExpr>
		  </extend>
		</ftvs>
		<ftvs>
		  <aTS/>
		</ftvs>
	      </inter>
	      <Empty/>
	    </eq>
	  </btypes:TYPE>.
	  Thus, by weakening lemma, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  , and, by induction hypothesis,
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr dash="'"/>
		  <id/>
		  <aVal/>
		</subst>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	  Finally, by the T-Lambda rule, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<lambda>
		  <id name="y"/>
		  <paren>
		    <subst>
		      <aExpr dash="'"/>
		      <id/>
		      <aVal/>
		    </subst>
		  </paren>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and thus,
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <lambda>
		    <id name="y"/>
		    <aExpr dash="'"/>
		  </lambda>
		  <id/>
		  <aVal/>
		</subst>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, which is the desired result.
	</p>
      </li>
      <li>
	<p>
	  T-Set case is similar, except that the substitution
	  cannot happen on the LHS of an assignment, since we do
	  not perform substitution of mutable values.
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-LSubstitution">
    <title>Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <aCtset/>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type num="x"/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, then
      <btypes:TYPE>
	<Sjudge>
	  <aCtset/>
	  <assume>
	    <gamma/>
	    <extend>
	      <store/>
	      <mapping>
		<sLoc/>
		<type num="x"/>
	      </mapping>
	    </extend>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the type derivation of
      <btypes:TYPE>
	<Sjudge>
	  <aCtest/>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, similar to lemma <xref
	ref="T-VSubstitution"/>.
    </p>
  </proof>
<!--   <lemma id="T-sh-safety"> -->
<!--     <title>Stack and Heap Assignment</title> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="If "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<hLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<extend> -->
<!-- 		  <heap/> -->
<!-- 		  <mapping> -->
<!-- 		    <hLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <text content="Similarly, if "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	    <text content=" and  "/> -->
<!-- 	    <Msub> -->
<!-- 	      <mapsto> -->
<!-- 		<store/> -->
<!-- 		<sLoc/> -->
<!-- 	      </mapsto> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aVal dash="'"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", then, "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<extend> -->
<!-- 		  <stack/> -->
<!-- 		  <mapping> -->
<!-- 		    <sLoc/> -->
<!-- 		    <aVal dash="'"/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       Immediate from the definition of stack and heap typing. -->
<!--     </p> -->
  <!--   </proof> -->
  <theorem id="T-preservation">
    <title>Preservation</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge cst="yes">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<TDjudge cst="yes">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> then,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <supeq>
	      <aCtset dash="'"/>
	      <aCtset/>
	    </supeq>
	  </btypes:TYPE> 
	  such that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<aCtset dash="'"/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<aCtset dash="'"/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge
>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <supeq>
	      <aCtset dash="'"/>
	      <aCtset/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<aCtset dash="'"/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <Msub>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<aCtset dash="'"/>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>, and 
	  <!-- This cannot be replaced directly with an Msub at the
	  derivation as the type `t' is obtained from a previous
	  derivation, and can be a mutable one -->
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </theorem>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>. We proceed by the case analysis of the final
      step.
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot
	  happen.
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <sLoc/>
	    </eq>
	  </btypes:TYPE>.
	</p>
	<btypes:TYPE>
	  <Hrules>
	    <tyRule>
	      <tyPre>
		<mapsto>
		  <store/>
		  <sLoc/>
		  <type/>
		</mapsto>
	      </tyPre>
	      <tyConc>
		<TDjudge>
		  <sLoc/>
		  <type/>
		</TDjudge>
	      </tyConc>
	    </tyRule>
	  </Hrules>
	</btypes:TYPE>
	<ol>
	  <li>
	    <p>
	      <btypes:TYPE>
		<levalOp/> 
	      </btypes:TYPE> None Applicable.
	    </p>
	  </li>
	  <li>
	    <p>
	      <btypes:TYPE>
		<evalOp/> 
	      </btypes:TYPE> E-Rval:
	    </p>
	    <btypes:TYPE>
	      <Hrules>
		<opRule>
		  <opPre>
		    <mapsto>
		      <stack/>            
		      <sLoc/>
		      <aVal/>
		    </mapsto>
		  </opPre>
		  <opConc>
		    <eval>
		      <opState>
			<stack/>
			<heap/>
			<sLoc/>
		      </opState>
		      <opState>
			<stack/>
			<heap/>
			<aVal/>
		      </opState>
		    </eval>
		  </opConc>
		</opRule>
	      </Hrules>
	    </btypes:TYPE>
	    <ol>
	      <li>
		<p>
		  <btypes:TYPE>
		    <eq>
		      <aExpr dash="'"/>
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <aVal/>
		    </eq>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <heap dash="'"/>
		      <heap/>
		    </eq>
		  </btypes:TYPE>, and
		  <btypes:TYPE>
		    <eq>
		      <stack dash="'"/>
		      <stack/>
		    </eq>
		  </btypes:TYPE>
		</p>
	      </li>
	      <li>
		<p>
		  From 
		  <btypes:TYPE>
		    <TDjudge name="*">
		      <plus>
			<heap/>
			<stack/>
		      </plus>
		    </TDjudge>
		  </btypes:TYPE> and
		  <btypes:TYPE>
		    <defn tag="stack-heap-typing"/>
		  </btypes:TYPE> (Stack and Heap Typing), we have
		  <btypes:TYPE>
		    <TDjudge Msub="yes" name="*">
		      <mapsto>
			<stack/>
			<sLoc/>
		      </mapsto>
		      <type/>
		    </TDjudge>
		  </btypes:TYPE>. 
		  That is,
		  <btypes:TYPE>
		    <TDjudge Msub="yes" name="*">
		      <aVal/>
		      <type/>
		    </TDjudge>
		  </btypes:TYPE>. 
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-App: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <apply> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </apply> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <fn> -->
<!-- 		<type num="2"/> -->
<!-- 		<type num="0"/> -->
<!-- 	      </fn> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <tqExpr> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </tqExpr> -->
<!-- 	    <text content = " where "/> -->
<!-- 	    <eq> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <minz> -->
<!-- 		<type num="2" dash="'"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq>                 -->
<!-- 	    <eq> -->
<!-- 	      <type num="0"/> -->
<!-- 	      <maxz> -->
<!-- 		<type num="0" dash="'"/> -->
<!-- 	      </maxz> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<p>               -->
<!-- 	  This cannot happen for left execution.  -->
<!-- 	  For right execution, we proceed by further case -->
<!-- 	  analysis of the applicable execution rules for -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eval> -->
<!-- 	      <opState> -->
<!-- 		<stack/> -->
<!-- 		<heap/> -->
<!-- 		<aExpr/> -->
<!-- 	      </opState> -->
<!-- 	      <opState> -->
<!-- 		<stack dash="'"/> -->
<!-- 		<heap dash="'"/> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </opState> -->
<!-- 	    </eval> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App1#: -->
<!-- 	      We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <apply> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		  </apply> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      By induction hypothesis, we have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		    <fn> -->
<!-- 		      <type num="2"/> -->
<!-- 		      <type num="0"/> -->
<!-- 		    </fn>      -->
<!-- 		  </Msub>                  -->
<!-- 		</Sjudge>                     -->
<!-- 		<text content=" for some "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      One of the assumptions of the T-App rule states that  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<TDjudge Msub="yes"> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <type num="2"/> -->
<!-- 		</TDjudge> -->
<!-- 	      </btypes:TYPE>, and by weakening lemma, we have,  -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <Msub> -->
<!-- 		    <aExpr num="2"/> -->
<!-- 		    <type num="2"/> -->
<!-- 		  </Msub> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. Finally, by the T-App rule, we -->
<!-- 	      conclude that -->
<!-- 	      <btypes:TYPE>                     -->
<!-- 		<tqExpr> -->
<!-- 		  <paren> -->
<!-- 		    <apply> -->
<!-- 		      <aExpr num="1" dash="'"/>                         -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </apply> -->
<!-- 		  </paren> -->
<!-- 		  <type/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App2#: Similar to the previous -->
<!-- 	      sub-case.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      Case E-App: We have: -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <lambda> -->
<!-- 		    <id/> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		  </lambda> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <subst> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <id/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </subst> -->
<!-- 		</eq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <extend> -->
<!-- 		      <stack/> -->
<!-- 		      <mapping> -->
<!-- 			<sLoc/> -->
<!-- 			<aVal/> -->
<!-- 		      </mapping> -->
<!-- 		    </extend> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      By the inversion lemma for  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<lambda> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="0"/> -->
<!-- 		</lambda> -->
<!-- 	      </btypes:TYPE> we have -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <extend> -->
<!-- 		      <gamma> -->
<!-- 			<id/> -->
<!-- 			<type num="2" dash="'"/> -->
<!-- 		      </gamma> -->
<!-- 		      <store/> -->
<!-- 		    </extend> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <aExpr num="0"/> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Further from location substitution lemma, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Sjudge> -->
<!-- 		  <assume> -->
<!-- 		    <gamma/> -->
<!-- 		    <store dash="'"/> -->
<!-- 		  </assume> -->
<!-- 		  <tqExpr> -->
<!-- 		    <subst> -->
<!-- 		      <aExpr num="0"/> -->
<!-- 		      <id/> -->
<!-- 		      <sLoc/> -->
<!-- 		    </subst> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </tqExpr> -->
<!-- 		</Sjudge> -->
<!-- 		<text content=" where "/> -->
<!-- 		<supeq> -->
<!-- 		  <store dash="'"/> -->
<!-- 		  <store/> -->
<!-- 		</supeq> -->
<!-- 		<text content=" and "/> -->
<!-- 		<tqExpr> -->
<!-- 		  <mapsto> -->
<!-- 		    <store/> -->
<!-- 		    <sLoc/> -->
<!-- 		  </mapsto> -->
<!-- 		  <type num="2" dash="'"/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	    </p> -->
<!-- 	    <p> -->
<!-- 	      Thus, we have  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type num="0" dash="'"/> -->
<!-- 		</Msub> -->
<!-- 		<text content=" and "/> -->
<!-- 		<Msub> -->
<!-- 		  <type num="0"/> -->
<!-- 		  <type/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Therefore, it is clear that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type num="0" dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>.                   -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Set: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <assign> -->
<!-- 		<aExpr num="1"/> -->
<!-- 		<aExpr num="2"/> -->
<!-- 	      </assign> -->
<!-- 	    </eq> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/> -->
<!-- 	      <mutable> -->
<!-- 		<type/> -->
<!-- 	      </mutable> -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=", and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="2"/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	    <Sjudge name="lval"> -->
<!-- 	      <assume/>                   -->
<!-- 	      <aExpr num="1"/>                   -->
<!-- 	    </Sjudge>                 -->
<!-- 	  </btypes:TYPE> -->
<!-- 	</p> -->
<!-- 	<p> -->
<!-- 	  If the step taken is E-:=#lhs or E-:=#rhs, -->
<!-- 	  the result follows from the induction hypothesis and -->
<!-- 	  T-Set rule (as in the case of T-App).                -->
<!-- 	  If the step taken is E-:=Stack or E-:=Heap, the -->
<!-- 	  result follows from the stack and heap assignment lemma. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Deref: We have:  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <deref> -->
<!-- 		<aExpr dash="'"/> -->
<!-- 	      </deref> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <ref> -->
<!-- 		<type/> -->
<!-- 	      </ref>                   -->
<!-- 	    </TDjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  If the step taken is EL-^# or E-^#, -->
<!-- 	  the result follows from induction hypothesis and T-Deref -->
<!-- 	  rule.  -->
<!-- 	  If the step taken is E-^ (right execution only)  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <aExpr dash="'"/>                   -->
<!-- 	  </btypes:TYPE> is a value, and from canonical forms -->
<!-- 	  lemma, we know that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr dash="'"/>                   -->
<!-- 	      <hLoc/> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <in> -->
<!-- 	      <hLoc/> -->
<!-- 	      <dom> -->
<!-- 		<store/> -->
<!-- 	      </dom> -->
<!-- 	    </in> -->
<!-- 	  </btypes:TYPE> -->
<!-- 	  and the result follows from the fact that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 	      </assume> -->
<!-- 	      <plus> -->
<!-- 		<heap/> -->
<!-- 		<stack/> -->
<!-- 	      </plus> -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-P: Right execution only. We have: -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <aExpr/> -->
<!-- 	      <paren> -->
<!-- 		<let kind="p"> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		  <aExpr num="2"/> -->
<!-- 		</let> -->
<!-- 	      </paren> -->
<!-- 	    </eq> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <TDjudge Msub="yes"> -->
<!-- 	      <aExpr num="1"/>                 -->
<!-- 	      <type num="1"/>                 -->
<!-- 	    </TDjudge> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge name="gen"> -->
<!-- 	      <assume> -->
<!-- 		<gamma/> -->
<!-- 		<store/> -->
<!-- 		<aExpr num="1"/> -->
<!-- 	      </assume>                 -->
<!-- 	      <GEN> -->
<!-- 		<type/> -->
<!-- 		<aTS/> -->
<!-- 	      </GEN> -->
<!-- 	    </Sjudge>       -->
<!-- 	    <text content=" and "/> -->
<!-- 	    <Sjudge> -->
<!-- 	      <assume> -->
<!-- 		<extend> -->
<!-- 		  <gamma/> -->
<!-- 		  <mapping> -->
<!-- 		    <id/>                       -->
<!-- 		    <aTS/> -->
<!-- 		  </mapping> -->
<!-- 		</extend> -->
<!-- 		<store/> -->
<!-- 	      </assume>                 -->
<!-- 	      <tqExpr> -->
<!-- 		<aExpr num="2"/> -->
<!-- 		<type num="2"/> -->
<!-- 	      </tqExpr>                 -->
<!-- 	    </Sjudge> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  There are two sub-cases to consider: -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take step E-Let#,                    -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eval> -->
<!-- 		  <opState> -->
<!-- 		    <stack/> -->
<!-- 		    <heap/> -->
<!-- 		    <aExpr num="1"/> -->
<!-- 		  </opState> -->
<!-- 		  <opState> -->
<!-- 		    <stack dash="'"/> -->
<!-- 		    <heap dash="'"/> -->
<!-- 		    <aExpr num="1" dash="'"/> -->
<!-- 		  </opState> -->
<!-- 		</eval> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      and  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr dash="'"/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aExpr num="1" dash="'"/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 		<text content=". If "/>                     -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aVal/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      It is clear that  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE> implies -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Value"> -->
<!-- 		  <aExpr num="1" dash="'"/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>.                      -->
<!-- 	      Now, the result follows -->
<!-- 	      from the induction hypothesis and the E-Let-P rule. -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      If we take the step E-Let-P,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aExpr/> -->
<!-- 		  <paren> -->
<!-- 		    <let kind="p"> -->
<!-- 		      <id/> -->
<!-- 		      <aVal/> -->
<!-- 		      <aExpr num="2"/> -->
<!-- 		    </let> -->
<!-- 		  </paren> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      Since  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<tqExpr> -->
<!-- 		  <id/> -->
<!-- 		  <aTS/> -->
<!-- 		</tqExpr> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	      has a polymorphic type,  -->
<!-- 	      (that is, -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <aTS/> -->
<!-- 		  <forall> -->
<!-- 		    <tvars name="alpha"/> -->
<!-- 		    <type name="s"/> -->
<!-- 		  </forall> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>) -->
<!-- 	      we know that -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<pred name="Immut"> -->
<!-- 		  <type/> -->
<!-- 		</pred> -->
<!-- 	      </btypes:TYPE>. -->
<!-- 	      Also, from canonical forms lemma, all values have -->
<!-- 	      an immutable type. Therefore,  -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <type/> -->
<!-- 		  <type num="1"/> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE>. Now, the result follows from -->
<!-- 	      value substitution lemma.  -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol>             -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Case T-Let-M: Similar to T-Let-P, except that we should -->
<!-- 	  always use the GEN-EXPANSIVE rule during generalization, -->
<!-- 	  and use the location substitution lemma instead of  -->
<!-- 	  the value substitution lemma -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Cases T-If, T-Dup are similar.   -->
<!-- 	</p> -->
<!--       </li> -->
    </ol>
  </proof>
  <lemma id="T-preservation-cor">
    <title>Corollary to Preservation</title>
    <p>
      If
      <btypes:TYPE>
	<TDjudge name="*">
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<TDjudge name="*">
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</TDjudge>
      </btypes:TYPE> then,
    </p>
    <ol>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	  </btypes:TYPE>
	  such that
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <Msub>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </Msub>
	    </Sjudge>
	  </btypes:TYPE>,
	  <btypes:TYPE>
	    <Sjudge name="*">
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <Msub>
	      <type/>
	      <type dash="'"/>
	    </Msub>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Using 
      <btypes:TYPE>
	<thm tag="T-preservation"/>
      </btypes:TYPE>.
    </p>
  </proof>
  <definition id="stuck_state">
    <title>Stuck State</title>
    <p>
      A system state
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      is said to be <term>stuck</term> if
      <btypes:TYPE>
	<neq>
	  <aExpr/>
	  <aVal/>
	</neq>
      </btypes:TYPE>
      and there are no
      <btypes:TYPE>
	<stack dash="'"/>
	<text content=", "/>
	<heap dash="'"/>
	<text content=", and "/>
	<aExpr dash="'"/>
      </btypes:TYPE>
      such that
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>.
    </p>
  </definition>
  <theorem id="T-soundness">
    <title>Type Soundness</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>,
      <btypes:TYPE>
	<Sjudge name="*">
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
      </btypes:TYPE>, and
      <btypes:TYPE>
	<eval many="yes">
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      then
      <btypes:TYPE>
	<opState>
	  <stack dash="'"/>
	  <heap dash="'"/>
	  <aExpr dash="'"/>
	</opState>
      </btypes:TYPE>.
      is not stuck.
      That is, execution of a well typed expression cannot lead to
      a stuck state. Here,
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE > represents the
      reflexive-transitive-closure of
      <btypes:TYPE>
	<evalOp/>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By straightforward induction on the length of
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE>. If
      <btypes:TYPE>
	<eq>
	  <aExpr/>
	  <aVal/>
	</eq>
      </btypes:TYPE>, proof is immediate. Otherwise, from
      Lemma&nbsp;<xref ref="T-progress"/> (Progress),
      we know that we can take at least one step forward. Further,
      from Lemma&nbsp;<xref ref="T-preservation-cor"/> (Preservation),
      we know that a (left/right) execution of a well
      typed expression in with respect to a well typed stack and heap
      will always result in another well typed expression, stack
      and heap. Proof now follows from induction hypothesis.
    </p>
  </proof>
  </sect1>
<!--   <lemma id="cann-derivation"> -->
<!--     <title>Canonical Type Derivation</title> -->
<!--     <p> -->
<!--       If -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!--       </btypes:TYPE> -->
<!--       and -->
<!--       <btypes:TYPE> -->
<!-- 	<CST> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <type/> -->
<!-- 	</CST> -->
<!--       </btypes:TYPE>, then -->
<!--       <btypes:TYPE> -->
<!-- 	<Exists> -->
<!-- 	  <approx> -->
<!-- 	    <type dash="'"/> -->
<!-- 	    <type/> -->
<!-- 	  </approx> -->
<!-- 	</Exists> -->
<!--       </btypes:TYPE> such that -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!--       </btypes:TYPE> -->

<!--       <btypes:TYPE> -->
<!-- 	<CST> -->
<!-- 	  <gamma/> -->
<!-- 	  <store/> -->
<!-- 	  <type/> -->
<!-- 	</CST> -->
<!--       </btypes:TYPE> -->
<!--     </p> -->
<!--   </lemma> -->
<!--   <lemma id="T-Subtype-properties"> -->
<!--     <title>Properties of Copy Coercion</title> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type dash="'"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	</p> -->
<!-- 	<ol> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <type/> -->
<!-- 		  <minz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<Msub> -->
<!-- 		  <maxz> -->
<!-- 		    <type/> -->
<!-- 		  </maxz> -->
<!-- 		  <type dash="'"/> -->
<!-- 		</Msub> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <maxz> -->
<!-- 		    <type/> -->
<!-- 		  </maxz> -->
<!-- 		  <maxz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </maxz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	  <li> -->
<!-- 	    <p> -->
<!-- 	      <btypes:TYPE> -->
<!-- 		<eq> -->
<!-- 		  <minz> -->
<!-- 		    <type/> -->
<!-- 		  </minz> -->
<!-- 		  <minz> -->
<!-- 		    <type dash="'"/> -->
<!-- 		  </minz> -->
<!-- 		</eq> -->
<!-- 	      </btypes:TYPE> -->
<!-- 	    </p> -->
<!-- 	  </li> -->
<!-- 	</ol> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type/> -->
<!--  	      <type num="2"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Exists> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  If -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!--  	      <type num="2"/> -->
<!-- 	      <type/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, then, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Exists> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Exists> -->
<!-- 	  </btypes:TYPE> such that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>, and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--       Property 1: By straightforward induction on the copy-coercion -->
<!--       derivation, and using -->
<!--       <btypes:TYPE> -->
<!-- 	<defn tag="maybe-consistent"/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <p> -->
<!--       Property 2: By construction of  -->
<!--       <btypes:TYPE> -->
<!-- 	<type num="3"/> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--     <ol> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From 	   -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE> and -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <lem tag="Cst-Weakening"/> -->
<!-- 	  </btypes:TYPE> (weakening), we have  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>.  -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From the above case, and property 1.d above, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Similarly, we have -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From cases&nbsp;(2 and 3), we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Let us pick -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <type num="3"/> -->
<!-- 	  </btypes:TYPE> such that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <eq> -->
<!-- 	      <type num="3"/> -->
<!-- 	      <minz> -->
<!-- 		<type/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	      <minz> -->
<!-- 		<type num="2"/> -->
<!-- 	      </minz> -->
<!-- 	    </eq> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  It is evident that  -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type/> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  From S-Refl rule in  -->
<!-- 	  figure&nbsp;<xref ref="Msubtype_rules"/>, we know that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. From this, and the fact that -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <CST> -->
<!-- 	      <type num="1"/> -->
<!-- 	    </CST> -->
<!-- 	  </btypes:TYPE>, using property 1.a, we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <minz> -->
<!-- 		<type num="1"/> -->
<!-- 	      </minz> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	  From case&nbsp;(5), we can write this as -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--       <li> -->
<!-- 	<p> -->
<!-- 	  Similarly, we obtain -->
<!-- 	  <btypes:TYPE> -->
<!-- 	    <Msub> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </Msub> -->
<!-- 	  </btypes:TYPE>. -->
<!-- 	</p> -->
<!--       </li> -->
<!--     </ol> -->
<!--     <p> -->
<!--       Property 3: Similar to Property 2. -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="cann-derivation-subst"> -->
<!--     <title>Canonical Derivation under Substitution</title> -->
<!--     <p> -->
<!--       If -->
<!--       <btypes:TYPE> -->
<!-- 	<TDjudge> -->
<!-- 	  <aExpr/> -->
<!-- 	  <type/> -->
<!-- 	</TDjudge> -->
<!-- 	<text content=" and "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <set> -->
<!-- 	    <gamma/> -->
<!-- 	    <store/> -->
<!-- 	    <type/> -->
<!-- 	  </set> -->
<!-- 	</models> -->
<!-- 	<text content=", then "/> -->
<!-- 	<models name="cst"> -->
<!-- 	  <assume> -->
<!-- 	    <aSubMap/> -->
<!-- 	  </assume> -->
<!-- 	  <DBrac> -->
<!-- 	    <TDjudge> -->
<!-- 	      <aExpr/> -->
<!-- 	      <type/> -->
<!-- 	    </TDjudge> -->
<!-- 	  </DBrac> -->
<!--  	</models> -->
<!--       </btypes:TYPE>. -->
<!--     </p> -->
<!--   </lemma> -->
<!--   <proof> -->
<!--     <p> -->
<!--     </p> -->
<!--   </proof> -->
<!--   <lemma id="norm-subst-compose">
    <title>Multiple Substitution Canonicalization</title>
    <p>
      COMMENT: Only S1 needs to be idempotent in this case
      If
      <btypes:TYPE>
	<mutex>
	  <dom>
	    <aSubMap num="2"/>
	  </dom>
	  <ftvs>
	    <aSubMap num="1"/>
	  </ftvs>
	</mutex>
      </btypes:TYPE>, 
      then, 
      <br/>
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <Subst>
		<aSubMap num="1"/>
		<type/>
	      </Subst>
	    </Subst>
	  </Subst>
	  <Subst>
	    <aSubMap num="1"/>
	    <Subst>
	      <aSubMap num="2"/>
	      <type/>
	    </Subst>
	  </Subst>
	  <Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <aSubMap num="2"/>
	    </Subst>
	    <Subst>
	      <aSubMap num="1"/>
	      <type/>
	    </Subst>
	  </Subst>
	</eq>
      </btypes:TYPE>
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the structure of 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>. The only interesting cases are
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</eq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbFull>
	    <tvar/>
	    <ptype/>
	  </mbFull>
	</eq>
      </btypes:TYPE>.
      We only show that proof for
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	</eq>
      </btypes:TYPE>.
    </p>
    <ol>
      <li>
	<p>
	  By induction hypothesis, we have
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap num="1"/>
		<Subst>
		  <aSubMap num="2"/>
		  <Subst>
		    <aSubMap num="1"/>
		    <ptype/>
		  </Subst>
		</Subst>
	      </Subst>
	      <Subst>
		<aSubMap num="1"/>
		<Subst>
		  <aSubMap num="2"/>
		  <ptype/>
		</Subst>
	      </Subst>
	      <Subst>
		<Subst>
		  <aSubMap num="1"/>
		  <aSubMap num="2"/>
		</Subst>
		<Subst>
		  <aSubMap num="1"/>
		  <ptype/>
		</Subst>
	      </Subst>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </notin>
	  </btypes:TYPE> and
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="2"/>
	      </dom>
	    </notin>
	  </btypes:TYPE>, the result follows from 
	  induction hypothesis.
	</p>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <in>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </in>
	  </btypes:TYPE>, then,
	</p>
	<ol>
	  <li>
	    <p>
	      Since
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		  <ftvs>
		    <aSubMap num="1"/>
		  </ftvs>
		</mutex>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<notin>
		  <tvar/>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		</notin>
	      </btypes:TYPE>.
	      Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="2"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <mbTop>
		    <tvar/>	
		    <Subst>
		      <aSubMap num="2"/>
		      <ptype/>
		    </Subst>
		  </mbTop>
		</eq>
	      </btypes:TYPE>
	    </p>
	  </li>
	  <li>
	    <p>
	      Further, since
	      <btypes:TYPE>
		<mutex>
		  <dom>
		    <aSubMap num="2"/>
		  </dom>
		  <ftvs>
		    <aSubMap num="1"/>
		  </ftvs>
		</mutex>
	      </btypes:TYPE>, we have
	      <btypes:TYPE>
		<eq>
		  <inter>
		    <dom>
		      <aSubMap num="2"/>
		    </dom>
		    <ftvs>
		      <range>
			<aSubMap num="1"/>
		      </range>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
	      </btypes:TYPE>. Therefore, if
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>, then
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="2"/>
		    <ptype num="1"/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <tvar name="beta"/>
		</eq>
	      </btypes:TYPE>. Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <mbTop>
		    <tvar name="beta"/>
		    <Subst>
		      <aSubMap num="1"/>
		      <ptype/>
		    </Subst>
		  </mbTop>
		</eq>
	      </btypes:TYPE>.
	    </p>
	    <ol>		
	      <li>
		<p>
		  Due to case&nbsp;(3.b), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<tvar name="beta"/>
		      </Subst>
		      <tvar name="beta"/>
		    </eq>
		  </btypes:TYPE>. This, along with case&nbsp;(3.c) 
		  gives us
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Due to the idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap num="1"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <Subst>
			      <aSubMap num="1"/>
			      <ptype/>
			    </Subst>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <aSubMap num="1"/>
			  <Subst>
			    <aSubMap num="2"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <mbTop>
			<tvar name="beta"/>
			<Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <aSubMap num="2"/>
			  </Subst>
			  <Subst>
			    <aSubMap num="1"/>
			    <ptype/>
			  </Subst>
			</Subst>
		      </mbTop>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Now, the result follows from induction hypothesis.
		  From cases&nbsp;(1, 3.c.ii, 3.c.iii, and 3.c.iv),
		  we have 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	  <li>
	    <p>
	      Suppose
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <tvar/>
		  </Subst>
		  <ptype num="1"/>
		</eq>
                <ST/>
		<neq>
		  <ptype num="1"/>
		  <tvar name="beta"/>
		</neq>
	      </btypes:TYPE>. Therefore,
	      <btypes:TYPE>
		<eq>
		  <Subst>
		    <aSubMap num="1"/>
		    <mbTop>
		      <tvar/>
		      <ptype/>
		    </mbTop>
		  </Subst>
		  <ptype num="1"/>
		</eq>
	      </btypes:TYPE>
	      (ref: substitution rules in 
	      figure&nbsp;<xref ref="subst_rules"/>).
	    </p>
	    <ol>		
	      <li>
		<p>
		  Due to case&nbsp;(3.b), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<ptype num="1"/>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>. This, along with case&nbsp;(3.d) 
		  gives us
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="2"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  From case&nbsp;(3.d.1), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>
		  Due to the idempotence of the substitution
		  <btypes:TYPE>
		    <aSubMap num="1"/>
		  </btypes:TYPE>,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <ptype/>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		  Therefore,
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Similarly, 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <ptype/>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	      <li>
		<p>
		  Due to case&nbsp;(3.a), 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<mbTop>
			  <tvar/>
			  <Subst>
			    <aSubMap num="2"/>
			    <ptype/>
			  </Subst>
			</mbTop>
		      </Subst>
		      <ptype num="1"/>
		    </eq>
		  </btypes:TYPE>
		  (ref: substitution rules in 
		  figure&nbsp;<xref ref="subst_rules"/>).
		</p>
	      </li>
	      <li>
		<p>
		  From cases&nbsp;(3.d.ii, 3.d.iii, and 3.d.iv),
		  we have 
		  <btypes:TYPE>
		    <eq>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <Subst>
			    <aSubMap num="1"/>
			    <mbTop>
			      <tvar/>
			      <ptype/>
			    </mbTop>
			  </Subst>
			</Subst>
		      </Subst>
		      <Subst>
			<aSubMap num="1"/>
			<Subst>
			  <aSubMap num="2"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		      <Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <aSubMap num="2"/>
			</Subst>
			<Subst>
			  <aSubMap num="1"/>
			  <mbTop>
			    <tvar/>
			    <ptype/>
			  </mbTop>
			</Subst>
		      </Subst>
		    </eq>
		  </btypes:TYPE>.
		</p>
	      </li>
	    </ol>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If
	  <btypes:TYPE>
	    <in>
	      <tvar/>
	      <dom>
		<aSubMap num="2"/>
	      </dom>
	    </in>
	  </btypes:TYPE>, then,
	  <btypes:TYPE>
	    <notin>
	      <tvar/>
	      <dom>
		<aSubMap num="1"/>
	      </dom>
	    </notin>
	  </btypes:TYPE>. The proof for this case is similar to
	  case&nbsp;(3). However, in this case, it is possible
	  that
	  <btypes:TYPE>
	    <neq>
	      <inter>
		<dom>
		  <aSubMap num="1"/>
		</dom>
		<ftvs>
		  <range>
		    <aSubMap num="2"/>
		  </range>
		</ftvs>
	      </inter>
	      <Empty/>
	    </neq>
	  </btypes:TYPE>, which leads a further level of case analysis.
	</p>
      </li>
    </ol>
  </proof> -->
