<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
                "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="static_semantics"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Static Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
  <!-- Can we have just one kind of type instead of restricting
  mutable and maybe types to only contain unconstrained types? 

  This means that we will permit types such as:
  'a!'b|'d|'e!bool and M'a|'b.

  Further, with this setup, can we elide the M'a|t type, and
  instead use the typing M('a|t) ?

  While there is nothing wrong with these types themselves, they
  complicate the unification algorithm. For example, suppose
  p: bool x bool, and consider the expression
  
  \x. x:= p.

  The unification algorithm will initially assign x: 'a|'b, and at
  the set rule, generate constraints
  { 'a|'b = M('c|'d), bool x bool = 'e|'d }

  This will reduce to { 'a|'b = M('c|boolxbool) }
  Now, we will need a rule that unifies mutable vs maybe types
  correctly ... -->
  <btypes:TYPE>       
    <grammar>
      <bnf desc="Unct. Types">
	<pType/>
	<alternatives>
	  <tvar/>
	  <unit/>
	  <bool/>
	  <fn><type/><type/></fn>                  
	</alternatives>
      </bnf>
      <bnfc desc="">
	<alternatives>
	  <ref><type/></ref>
	  <mutable><pType/></mutable>
	  <pair><type/><type/></pair>
	</alternatives>
      </bnfc>
      <bnf desc="M-Vars">
	<sType/>
	<alternatives>
	  <tvar/>
	  <mutable>
	    <tvar/>
	  </mutable>
	</alternatives>
      </bnf>
      <bnf desc="Types">
	<type/>
	<alternatives>
	  <pType/>
	  <mbTop>
	    <tvar/>
	    <pType/>
	  </mbTop>
	  <mbFull>
	    <sType/>
	    <pType/>
	  </mbFull>
	</alternatives>
      </bnf>
      <bnf desc="Type Scheme">          
	<aTS/>
	<alternatives>
	  <type/>
	  <forall>                    
 	    <tvars/>
	    <ctype>
	      <type/>
	      <aCtset/>
	    </ctype>
	  </forall>
	</alternatives>
      </bnf>
      <bnf desc="Constraints">
	<constraint/>
	<alternatives>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type/>
	  </Pcst>
	</alternatives>
      </bnf>
      <bnf desc="Constraint Sets">
	<aSet/>
	<alternatives>
	  <Empty/>
	  <set>
	    <unspecified/>
	  </set>
	  <unin>
	    <aSet/>
	    <aSet/>
	  </unin>
	</alternatives>            
      </bnf>
      <!--       <bnf desc="Sets"> -->
      <!-- 	<aCtset/> -->
      <!-- 	<alternatives> -->
      <!-- 	  <Empty/> -->
      <!-- 	  <set> -->
      <!-- 	    <plural> -->
      <!-- 	      <constraint/> -->
      <!-- 	    </plural> -->
      <!-- 	  </set> -->
      <!-- 	  <unin> -->
      <!-- 	    <aCtset/> -->
      <!-- 	    <aCtset/> -->
      <!-- 	  </unin> -->
      <!-- 	</alternatives>             -->
      <!--       </bnf> -->
      <bnf desc="Substitutions">            
	<aSubMap/>            
	<alternatives>
	  <EmptySubst/>
	  <SubMap>
	    <tvar/>
	    <type/>
	  </SubMap>
	  <SubMap>
	    <lKind k="var"/>
	    <lKind/>
	  </SubMap>
	  <compose>
	    <aSubMap/>
	    <aSubMap/>
	  </compose>
	</alternatives>
      </bnf>
      <bnf desc="Binding Environment">
	<gamma/>
	<alternatives>
	  <Empty/>
	  <extend>
	    <gamma/>
	    <mapping>
	      <id/>
	      <aTS/>
	    </mapping>
	  </extend>
	</alternatives>
      </bnf>
      <bnf desc="Store Typing">
	<store/>
	<alternatives>
	  <Empty/>
	  <extend>
	    <store/>
	    <mapping>
	      <loc/>
	      <type/>
	    </mapping>
	  </extend>
	</alternatives>
      </bnf>
      <bnf desc="Solvable Entities">
	<solvable/>
	<alternatives>
	  <type/>
	  <aTS/>
	  <gamma/>
	  <store/>
	  <solvables/>
	</alternatives>
      </bnf>
    </grammar>
  </btypes:TYPE>
  <p>
    We represent mathematical properties as: 
    <btypes:TYPE>
      <models name="property">
	<text content="assumption"/>
	<text content="subject"/>
      </models>
    </btypes:TYPE>.
    As a matter of notational convenience in the case of
    substitutions, we write: 
    <btypes:TYPE>
      <aSubMap num="a.b"/> 
    </btypes:TYPE> to mean
    <btypes:TYPE>
      <compose>
	<aSubMap num="a"/> 
	<aSubMap num="b"/> 
      </compose>
    </btypes:TYPE>. 
  </p>
  <definition id="aleq">      
    <title>Algebraic equivalences</title>
    <p>
      In our algebra of types, we define the following equivalence:
      <btypes:TYPE>
	<eq>
	  <mutable>
	    <mutable>
	      <pType/>
	    </mutable>
	  </mutable>
	  <mutable>
	    <pType/>
	  </mutable>
	</eq>
      </btypes:TYPE>.
      That is, the mutable type constructor is idempotent. 
    </p>
  </definition>
  <definition id="structural_containment">
    <title>Structural Containment</title>
    <p>
      We define a structural containment relation 
      <btypes:TYPE>
	<in>
	  <type/>
	  <solvable/>
	</in>
      </btypes:TYPE> as follows:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <type dash="'"/>
	    </in>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <type/>
	  </btypes:TYPE> is structurally present as a part of 
	  <btypes:TYPE>
	    <type dash="'"/>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <forall>
		<tvars/>
		<type dash="'"/>
	      </forall>
	    </in>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <set>
		<tvars/>
	      </set>
	    </in>
	  </btypes:TYPE> or
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <type dash="'"/>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <gamma/>
	    </in>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <Exists>
	      <in>
		<mapping>
		  <id/>
		  <aTS/>
		</mapping>
		<gamma/>
	      </in>
	    </Exists>          
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <aTS/>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <store/>
	    </in>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <Exists>
	      <in>
		<mapping>
		  <loc/>
		  <type dash="'"/>
		</mapping>
		<store/>
	      </in>
	    </Exists>          
	  </btypes:TYPE> such that 
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <type dash="'"/>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <solvables/>
	    </in>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <in>
	      <type/>
	      <solvable/>
	    </in>
	  </btypes:TYPE>, for any
	  <btypes:TYPE>
	    <in>       
	      <solvable/>
	      <set>
		<solvables/>
	      </set>
	    </in>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </definition>
  <definition id="top_ceq">      
    <title>Top-level Copy Compatibility</title>
    <p> 
      We define a restricted version of copy compatibility
      (<btypes:TYPE>
	<TceqOp/>
      </btypes:TYPE>) as follows:
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre/>
	  <tyConc>
	    <Tceq>                
	      <type/>
	      <type/>
	    </Tceq>
	  </tyConc>                
	</tyRule>
	<tyRule>
	  <tyPre>
	    <Tceq>
	      <type num="1"/>
	      <type num="2"/>
	    </Tceq>
	  </tyPre>
	  <tyConc>
	    <Tceq>
	      <type num="2"/>
	      <type num="1"/>
	    </Tceq>
	  </tyConc>
	</tyRule>
	<tyRule>
	  <tyPre/>
	  <tyConc>
	    <Tceq>                
	      <mutable>
		<pType/>
	      </mutable>
	      <pType/>
	    </Tceq>
	  </tyConc>
	</tyRule>
      </Hrules>
    </btypes:TYPE>
  </definition>
  <definition id="copy_sem"> <title>Copy Compatibility</title> <p> We
    define the copy compatibility relationship (<btypes:TYPE> <ceqOp/>
    </btypes:TYPE>) as follows:
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre/>
	  <tyConc>
	    <ceq>                
	      <type/>
	      <type/>
	    </ceq>
	  </tyConc>                
	</tyRule>   
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type num="1"/>
	      <type num="2"/>
	    </ceq>	    
	  </tyPre>
	  <tyConc>
	    <ceq>
	      <type num="2"/>
	      <type num="1"/>
	    </ceq>
	  </tyConc>                
	</tyRule>
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type num="1"/>
	      <type num="2"/>
	    </ceq>
	    <ceq>                
	      <type num="2"/>
	      <type num="3"/>
	    </ceq>	    
	  </tyPre>
	  <tyConc>
	    <ceq>
	      <type num="1"/>
	      <type num="3"/>
	    </ceq>
	  </tyConc>                
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type/>
	      <pType/>
	    </ceq>	    
	  </tyPre>
	  <tyConc>
	    <ceq>                
	      <type/>
	      <mutable>
		<pType/>
	      </mutable>
	    </ceq>
	  </tyConc>                
	</tyRule>   
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type num="1"/>
	      <type num="1" dash="'"/>
	    </ceq>
	    <ceq>
	      <type num="2"/>
	      <type num="2" dash="'"/>
	    </ceq>
	  </tyPre>
	  <tyConc>
	    <ceq>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	      <pair>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </pair>
	    </ceq>
	  </tyConc>                
	</tyRule>
      </Hrules>
    </btypes:TYPE>
  </definition>
  <definition id="maybe-types">      
    <title>``Maybe'' types </title>
    <p> 
      A (top-level) maybe type 
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <pType/>
	</mbTop>
      </btypes:TYPE> represents the constrained type
      <btypes:TYPE>
	<ctype>
	  <tvar/>
	  <set>
	    <Tceq>
	      <tvar/>
	      <pType/>
	    </Tceq>
	  </set>
	</ctype>
      </btypes:TYPE>.
    </p>
    <p>
      The (full) maybe type 
      <btypes:TYPE>
	<mbFull>
	  <sType/>
	  <pType/>
	</mbFull>
      </btypes:TYPE> represents the constrained type
      <btypes:TYPE>
	<ctype>
	  <sType/>
	  <set>
	    <ceq>
	      <sType/>
	      <pType/>
	    </ceq>
	  </set>
	</ctype>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="subst">      
    <title>Substitution</title>      
    <p>
      Substitution on an entity 
      <btypes:TYPE>
	<textmath content="X"/> 
      </btypes:TYPE> in our algebra of types and expressions is
      written 
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <textmath content="X"/> 
	</Subst>
      </btypes:TYPE> and is defined in figure&nbsp;<xref ref="subst_rules"/>.
    </p>
  </definition>
  <definition id="wf-subst">
    <title>Well-formed Substitutions</title>
    <p>
      A substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> is said to be well-formed with respect to
      a sentence
      <btypes:TYPE>
	<textmath content="X"/> 
      </btypes:TYPE> in the above grammar if:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <aSubMap/>
	  </btypes:TYPE> is idempotent.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <Subst>
	      <aSubMap/>
	      <textmath content="X"/> 
	    </Subst>
	  </btypes:TYPE> is still a valid sentence in the same language.
	</p>
      </li>
    </ol>
  </definition>
  <p>
    The first condition requires that for any 
    <btypes:TYPE>
      <textmath content="X"/> 
    </btypes:TYPE>,
    <btypes:TYPE>
      <eq>
	<Subst>
	  <aSubMap/>
	  <textmath content="X"/> 
	</Subst>
	<Subst>
	  <aSubMap/>
	  <Subst>
	    <aSubMap/>
	    <textmath content="X"/> 
	  </Subst>
	</Subst>
      </eq>
    </btypes:TYPE>. The actual condition we require here is that the
    substitution 
    <btypes:TYPE>
      <aSubMap/>
    </btypes:TYPE> satisfies the occurs check. Since any substitution
    that satisfies the occurs check can be written equivalently as an
    idempotent substitution, we require this stronger property without
    loss of generality. This means that substitutions such as
    <btypes:TYPE>
      <compose>
	<SubMap>
	  <tvar name="alpha"/> 
	  <tvar name="beta"/> 
	</SubMap>
	<SubMap>
	  <tvar name="beta"/> 
	  <unit/> 
	</SubMap>
      </compose>
    </btypes:TYPE> are not well formed, and must instead be written
    (equivalently) as: 
    <btypes:TYPE>
      <compose>
	<SubMap>
	  <tvar name="alpha"/> 
	  <unit/> 
	</SubMap>
	<SubMap>
	  <tvar name="beta"/> 
	  <unit/> 
	</SubMap>
      </compose>
    </btypes:TYPE>. An implication of idempotence is that
    <btypes:TYPE>
      <eq>
	<inter>
	  <dom>
	    <aSubMap/>
	  </dom>
	  <range>
	    <aSubMap/>
	  </range>
	</inter>
	<Empty/>
      </eq>
    </btypes:TYPE>.
  </p>
  <p>
    The second condidtion requires that the substitution 
    <btypes:TYPE>
      <aSubMap/>
    </btypes:TYPE> does not violate the syntax of the 
    language. For example, the substitution
    <btypes:TYPE>
      <SubMap>
	<tvar/>
	<mbTop>
	  <tvar name="beta"/>
	  <type/>
	</mbTop>
      </SubMap>
    </btypes:TYPE> is not a well formed substitution on 
    <btypes:TYPE>
      <mutable>
	<tvar/>
      </mutable>
    </btypes:TYPE>. In the rest of the document, we say substitutions
    to mean well-formed substitutions unless otherwise specified.
  </p>
  <definition id="special">
    <title>Specialization</title>
    <p>
      We write
      <btypes:TYPE>
	<spEq>
	  <type num="1"/>
	  <type num="2"/>
	</spEq>
      </btypes:TYPE>, that is,
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> is a specialization of (or less general than)
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<Exists>
	  <aSubMap/>
	</Exists>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<eq>
	  <type num="1"/>
	  <Subst>
	    <aSubMap/>
	    <type num="2"/>
	  </Subst>
	</eq>
      </btypes:TYPE>.
      We write
      <btypes:TYPE>
	<genEq>
	  <type num="1"/>
	  <type num="2"/>
	</genEq>
      </btypes:TYPE>, that is,
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> is more general than
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<spEq>
	  <type num="2"/>
	  <type num="1"/>
	</spEq>
      </btypes:TYPE>.
    </p>
    <p>
      We write
      <btypes:TYPE>
	<spEq>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</spEq>
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<Exists>
	  <aSubMap/>
	</Exists>
      </btypes:TYPE> such that
      <btypes:TYPE>
	<eq>
	  <aSubMap num="1"/>
	  <compose>
	    <aSubMap/>
	    <aSubMap num="2"/>
	  </compose>
	</eq>
      </btypes:TYPE>.
      We write
      <btypes:TYPE>
	<genEq>
	  <aSubMap num="1"/>
	  <aSubMap num="2"/>
	</genEq>
      </btypes:TYPE>
      iff
      <btypes:TYPE>
	<spEq>
	  <aSubMap num="2"/>
	  <aSubMap num="1"/>
	</spEq>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="pcst">      
    <title>Meta Polymorphic Constraints (MPC)</title>      
    <p>
      The constraint 
      <btypes:TYPE>
	<Pcst>
	  <lKind/>
	  <type/>
	  <type dash="'"/>
	</Pcst>
      </btypes:TYPE>, where
      <btypes:TYPE>
	<spEq>
	  <type dash="'"/>
	  <type/>
	</spEq>
      </btypes:TYPE>, is used to express types that are polymorphic
      <em>over</em> polymorphism and mutability. 
    </p>
  </definition>
  <definition id="max_min">      
    <title>Max and Min Mutability</title>      
    <p> 
      The operators
      <btypes:TYPE><maxzOp/></btypes:TYPE> and
      <btypes:TYPE><minzOp/></btypes:TYPE> increase or
      decrease the mutability of a type upto a copy-boundary. 
      The operators
      <btypes:TYPE><maxzTOp/></btypes:TYPE> and
      <btypes:TYPE><minzTOp/></btypes:TYPE> increase or
      decrease the topmost level mutability of a type. 
    </p>
    <btypes:TYPE>
      <!-- Full maximization -->
      <VEqns>
	<equation>
	  <lhs>
	    <maxz>
	      <tvar/>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <tvar/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <unit/>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <unit/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <bool/>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <bool/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <ref>
		<type/>
	      </ref>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <ref>
		<type/>
	      </ref>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <mutable>
		<pType/>
	      </mutable>
	    </maxz>
	  </lhs>
	  <rhs>
	    <maxz>
	      <pType/>
	    </maxz>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </maxz>
	  </lhs>
	  <rhs>
	    <mutable>
	      <pair>
		<maxz>
		  <type/>	
		</maxz>
		<maxz>
		  <type dash="'"/>
		</maxz>
	      </pair>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxz>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </maxz>
	  </lhs>
	  <rhs>
	    <maxz>
	      <pType/>
	    </maxz>
	  </rhs>
	</equation>
	<equation sep="yes">
	  <lhs>
	    <maxz>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </maxz>
	  </lhs>
	  <rhs>
	    <maxz>
	      <pType/>
	    </maxz>
	  </rhs>
	</equation>
      </VEqns>
      <!-- Full Minimization -->
      <VEqns>
	<equation>
	  <lhs>
	    <minz>
	      <tvar/>
	    </minz>
	  </lhs>
	  <rhs>
	    <tvar/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <unit/>
	    </minz>
	  </lhs>
	  <rhs>
	    <unit/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <bool/>
	    </minz>
	  </lhs>
	  <rhs>
	    <bool/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </minz>
	  </lhs>
	  <rhs>
	    <fn>
	      <type/>
	      <type dash="'"/>
	    </fn>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <ref>
		<type/>
	      </ref>
	    </minz>
	  </lhs>
	  <rhs>
	    <ref>
	      <type/>
	    </ref>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <mutable>
		<pType/>
	      </mutable>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <pType/>
	    </minz>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </minz>
	  </lhs>
	  <rhs>
	    <pair>
	      <minz>
		<type/>	
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </pair>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minz>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <pType/>
	    </minz>
	  </rhs>
	</equation>
	<equation sep="true">
	  <lhs>
	    <minz>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </minz>
	  </lhs>
	  <rhs>
	    <minz>
	      <pType/>
	    </minz>
	  </rhs>
	</equation>
      </VEqns>
      <!-- Top-Level Maximization -->
      <VEqns>
	<equation>
	  <lhs>
	    <maxzT>
	      <tvar/>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <tvar/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <unit/>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <unit/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <bool/>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <bool/>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <ref>
		<type/>
	      </ref>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <ref>
		<type/>
	      </ref>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <mutable>
		<pType/>
	      </mutable>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <maxzT>
	      <pType/>
	    </maxzT>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mutable>
	      <pair>
		<type/>	
		<type dash="'"/>
	      </pair>
	    </mutable>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <maxzT>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <maxzT>
	      <pType/>
	    </maxzT>
	  </rhs>
	</equation>
	<equation sep="yes">
	  <lhs>
	    <maxzT>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </maxzT>
	  </lhs>
	  <rhs>
	    <mbFull>
	      <maxzT>
		<sType/>
	      </maxzT>
	      <pType/>
	    </mbFull>
	  </rhs>
	</equation>
      </VEqns>
      <!-- Top-Level Minimization -->
      <VEqns>
	<equation>
	  <lhs>
	    <minzT>
	      <tvar/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <tvar/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <unit/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <unit/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <bool/>
	    </minzT>
	  </lhs>
	  <rhs>
	    <bool/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </minzT>
	  </lhs>
	  <rhs>
	    <fn>
	      <type/>
	      <type dash="'"/>
	    </fn>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <ref>
		<type/>
	      </ref>
	    </minzT>
	  </lhs>
	  <rhs>
	    <ref>
	      <type/>
	    </ref>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <mutable>
		<pType/>
	      </mutable>
	    </minzT>
	  </lhs>
	  <rhs>
	    <minzT>
	      <pType/>
	    </minzT>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </minzT>
	  </lhs>
	  <rhs>
	    <pair>
	      <type/>	
	      <type dash="'"/>
	    </pair>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzT>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </minzT>
	  </lhs>
	  <rhs>
	    <minzT>
	      <pType/>
	    </minzT>
	  </rhs>
	</equation>
	<equation sep="4pt">
	  <lhs>
	    <minzT>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </minzT>
	  </lhs>
	  <rhs>
	    <mbFull>
	      <minzT>
		<sType/>
	      </minzT>
	      <pType/>
	    </mbFull>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="deepmut">      
    <title>Deep Mutability Minimization</title>      
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <minzD>
	      <tvar/>
	    </minzD>
	  </lhs>
	  <rhs>
	    <tvar/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <unit/>
	    </minzD>
	  </lhs>
	  <rhs>
	    <unit/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <bool/>
	    </minzD>
	  </lhs>
	  <rhs>
	    <bool/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </minzD>
	  </lhs>
	  <rhs>
	    <fn>
	      <type/>
	      <type dash="'"/>
	    </fn>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <ref>
		<type/>
	      </ref>
	    </minzD>
	  </lhs>
	  <rhs>
	    <ref>
	      <minzD>
		<type/>
	      </minzD>
	    </ref>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <mutable>
		<pType/>
	      </mutable>
	    </minzD>
	  </lhs>
	  <rhs>
	    <minzD>
	      <pType/>
	    </minzD>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </minzD>
	  </lhs>
	  <rhs>
	    <pair>
	      <minzD>
		<type/>	
	      </minzD>
	      <minzD>
		<type dash="'"/>
	      </minzD>
	    </pair>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <minzD>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </minzD>
	  </lhs>
	  <rhs>
	    <minzD>
	      <pType/>
	    </minzD>
	  </rhs>
	</equation>
	<equation sep="4pt">
	  <lhs>
	    <minzD>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </minzD>
	  </lhs>
	  <rhs>
	    <minzD>
	      <pType/>
	    </minzD>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="concrete">      
    <title>Concretizability Predicate</title>      
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <concrete>
	      <unit/>
	    </concrete>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <bool/>
	    </concrete>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <fn>
		<type/>
		<type dash="'"/>
	      </fn>
	    </concrete>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <ref>
		<type/>
	      </ref>
	    </concrete>
	  </lhs>
	  <rhs>
	    <concrete>
	      <type/>
	    </concrete>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <mutable>
		<pType/>
	      </mutable>
	    </concrete>
	  </lhs>
	  <rhs>
	    <concrete>
	      <pType/>
	    </concrete>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <pair>
		<type/>
		<type dash="'"/>
	      </pair>
	    </concrete>
	  </lhs>
	  <rhs>
	    <AND>
	      <concrete>
		<type/>	
	      </concrete>
	      <concrete>
		<type dash="'"/>
	      </concrete>
	    </AND>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </concrete>
	  </lhs>
	  <rhs>
	    <concrete>
	      <pType/>
	    </concrete>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <concrete>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </concrete>
	  </lhs>
	  <rhs>
	    <concrete>
	      <pType/>
	    </concrete>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <grouping>
	      <concrete>
		<type/>
	      </concrete>
	      <textit content="(otherwise)"/>
	    </grouping>
	  </lhs>
	  <rhs>
	    <FALSE/>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="immut-types">
    <title>(Im)Mutability Predicates</title>
    <p>
      <btypes:TYPE>
	<pred name="Immut">
	  <type/>
	</pred>
      </btypes:TYPE> gurantees that the type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is not-mutable and invariable upto the
      function boundary. This predicate does not hold to type variables
      that are not contained within a function type. Similarly, 
      the predicate
      <btypes:TYPE>
	<pred name="Mut">
	  <type/>
	</pred>
      </btypes:TYPE> holds for any type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> that is mutable, not considering mutability
      within function types.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="Immut">
	      <unit/>
	    </pred>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Immut">
	      <bool/>
	    </pred>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Immut">
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </pred>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Immut">
	      <ref>
		<type/>
	      </ref>                
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Immut">
	      <type/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Immut">
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </pred>
	  </lhs>
	  <rhs>
	    <AND>
	      <pred name="Immut">
		<type num="1"/>
	      </pred>
	      <pred name="Immut">
		<type num="2"/>
	      </pred>
	    </AND>
	  </rhs>
	</equation>
	<equation sep="yes">
	  <lhs>
	    <grouping>
	      <pred name="Immut">
		<type/>
	      </pred>
	      <text content=" (otherwise) "/>
	    </grouping>
	  </lhs>
	  <rhs>
	    <FALSE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mut">
	      <mutable>
		<pType/>
	      </mutable>
	    </pred>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mut">
	      <ref>
		<type/>
	      </ref>	      
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Mut">
	      <type/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mut">
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </pred>
	  </lhs>
	  <rhs>
	    <OR>
	      <pred name="Mut">
		<type num="1"/>
	      </pred>
	      <pred name="Mut">
		<type num="2"/>
	      </pred>
	    </OR>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <grouping>
	      <pred name="Mut">
		<mbTop>
		  <tvar/>
		  <pType/>
		</mbTop>
	      </pred>
	    </grouping>
	  </lhs>
	  <rhs>
	    <pred name="Mut">
	      <minzT>
		<pType/>
	      </minzT>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mut">
	      <mbFull>
		<mutable>
		  <tvar/>
		</mutable>
		<pType/>
	      </mbFull>
	    </pred>
	  </lhs>
	  <rhs>
	    <TRUE/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mut">
	      <mbFull>
		<tvar/>
		<pType/>
	      </mbFull>
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Mut">
	      <minz>
		<pType/>
	      </minz>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <grouping>
	      <pred name="Mut">
		<type/>
	      </pred>
	      <text content=" (otherwise) "/>
	    </grouping>
	  </lhs>
	  <rhs>
	    <FALSE/>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="eq-minz">      
    <title><btypes:TYPE><eqOp under="minzT"/></btypes:TYPE> and
      <btypes:TYPE><eqOp under="minz"/></btypes:TYPE></title>      
    <p>
      We write
      <btypes:TYPE>
	<eq under="minzT">
	  <type num="1"/>
	  <type num="2"/>
	</eq>
      </btypes:TYPE> if
      <btypes:TYPE>
	<minzT>
	  <type num="1"/>
	  <type num="2"/>
	</minzT>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq under="minz">
	  <type num="1"/>
	  <type num="2"/>
	</eq>
      </btypes:TYPE> if
      <btypes:TYPE>
	<minz>
	  <type num="1"/>
	  <type num="2"/>
	</minz>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="pcst-sat">      
    <title>MPC Satisfaction</title>      
    <p>
      A substitution 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> satisfies the set of constraints
      <btypes:TYPE>
	<set>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type num="1"/>
	  </Pcst>
	  <unspecified/>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type num="n"/>
	  </Pcst>
	</set>
      </btypes:TYPE> if and only if:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind/>
	      </Subst>
	      <lKind k="mono"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <unspecified/>
	      <Subst>
		<aSubMap/>
		<type num="n"/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>, or
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind/>
	      </Subst>
	      <lKind k="poly"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <collection>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="1"/>
		</Subst>
	      </pred>
	      <unspecified/>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="n"/>
		</Subst>
	      </pred>
	    </collection>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="ExtToSol">
    <title>Application to Solvable Entities</title>
    <p>
      If <btypes:TYPE><pred name="F"/></btypes:TYPE>
      is a function from <btypes:TYPE><type/></btypes:TYPE>
      to <btypes:TYPE><set><type/></set></btypes:TYPE>, we extend the
      definition of the function to all solvable entities 
      (that is, <btypes:TYPE><solvable/></btypes:TYPE> to 
      <btypes:TYPE><set><type/></set></btypes:TYPE>) as follows:
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="F">
	      <forall>
		<tvars/>
		<type/>
	      </forall>
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="F">
		<tvars/>
	      </pred>
	      <pred name="F">
		<type/>
	      </pred>                  
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="F">
	      <gamma/>
	    </pred>
	  </lhs>
	  <rhs>
	    <grouping>
	      <Unin>
		<pred name="F">
		  <aTS num="i"/>
		</pred>
	      </Unin>
	      <text content=", "/>
	      <Forall/>
	      <in>
		<mapping>
		  <id/>
		  <aTS num="i"/>
		</mapping>
		<gamma/>
	      </in>
	    </grouping>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="F">
	      <store/>
	    </pred>
	  </lhs>
	  <rhs>
	    <grouping>
	      <Unin>
		<pred name="F">
		  <type num="i"/>
		</pred>
	      </Unin>
	      <text content=", "/>
	      <Forall/>
	      <in>
		<mapping>
		  <loc/>
		  <type num="i"/>
		</mapping>
		<store/>
	      </in>
	    </grouping>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
    <p>
      We also write
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="F">
	      <solvables/>
	    </pred>
	  </lhs>
	  <rhs>
	    <Unin>
	      <pred name="F">
		<solvable/>
	      </pred>
	    </Unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="F">
	      <aSubMap/>
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="F">
		<dom>
		  <aSubMap/>
		</dom>
	      </pred>
	      <pred name="F">
		<range>
		  <aSubMap/>
		</range>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="F">
	      <Pcst>
		<lKind/>
		<type num="1"/>
		<type num="2"/>
	      </Pcst>
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="F">
		<type num="1"/>
	      </pred>
	      <pred name="F">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="F">
	      <aCtset/>
	    </pred>
	  </lhs>
	  <rhs>
	    <grouping>
	      <Unin>
		<pred name="F">
		  <constraint num="i"/>
		</pred>
	      </Unin>
	      <text content=", "/>
	      <Forall/>
	      <in>
		<constraint num="i"/>
		<aCtset/>
	      </in>
	    </grouping>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>.
  </definition>
  <definition id="ftvs">
    <title>Free Type Variables</title>
    <p>
      We denote the set of free type variables in a type
      <btypes:TYPE><type/></btypes:TYPE> as
      <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>. 
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <ftvs>
	      <tvar/>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <set>
	      <tvar/>
	    </set>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <unit/>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <bool/>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <empty/>                
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <ref>
		<type/>
	      </ref>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <ftvs>                  
	      <type/>                  
	    </ftvs>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <mutable>
		<pType/>
	      </mutable>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <ftvs>                  
	      <type/>                  
	    </ftvs>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </ftvs>
	  </lhs>
	  <rhs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>                    
	      <ftvs>
		<type num="2"/>
	      </ftvs>                    
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>
	    </ftvs>                                  
	  </lhs>
	  <rhs>
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>                    
	      <ftvs>
		<type num="2"/>
	      </ftvs>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </ftvs>                                  
	  </lhs>
	  <rhs>
	    <unin>
	      <ftvs>
		<tvar/>
	      </ftvs>                    
	      <ftvs>
		<pType/>
	      </ftvs>                    
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <ftvs>
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </ftvs>                                  
	  </lhs>
	  <rhs>
	    <unin>
	      <ftvs>
		<sType/>
	      </ftvs>
	      <ftvs>
		<pType/>
	      </ftvs>
	    </unin>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>.
  </definition>
  <definition id="MNTVs">
    <title>mtvs, Mtvs, Ntvs</title>
    <p>
      <btypes:TYPE>
	<pred name="mtv">
	  <solvable/>
	</pred>
      </btypes:TYPE> defines the set of all type variables
      <btypes:TYPE>
	<tvars/>
      </btypes:TYPE> 
      such that
      <btypes:TYPE>
	<tvar/>
      </btypes:TYPE> occurs in 
      <btypes:TYPE>
	<solvable/>
      </btypes:TYPE>
      within a maybe type in the form 
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <pType/>
	</mbTop>            
      </btypes:TYPE>.
      Similarly,
      <btypes:TYPE>
	<pred name="Mtv">
	  <solvable/>
	</pred>
      </btypes:TYPE> defines the set of all type variables
      <btypes:TYPE>
	<tvars/>
      </btypes:TYPE>
      such that
      <btypes:TYPE>
	<tvar/>
      </btypes:TYPE> occurs in     
      <btypes:TYPE>
	<solvable/>
      </btypes:TYPE> 
      within a maybe type in the form
      <btypes:TYPE>
	<mbFull>
	  <tvar/>
	  <pType/>
	</mbFull>            
      </btypes:TYPE> or 
      <btypes:TYPE>
	<mbFull>
	  <mutable>
	    <tvar/>
	  </mutable>
	  <pType/>
	</mbFull>            
      </btypes:TYPE>.
      <btypes:TYPE>
	<pred name="ntv">
	  <solvable/>
	</pred>
      </btypes:TYPE> defines the set of unconstrained variables (that
      don't appear in any of the above two forms).
    </p>
    <btypes:TYPE>
      <!-- mtvs -->
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <tvar/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <unit/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <bool/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <ref>
		<type/>
	      </ref>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="mtv">
	      <type/>
	    </pred>
	  </rhs>
	</equation>	
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <mutable>
		<pType/>
	      </mutable>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="mtv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="mtv">
		<type num="1"/>
	      </pred>
	      <pred name="mtv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="mtv">
		<type num="1"/>
	      </pred>
	      <pred name="mtv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>                            
	    </pred>
	  </lhs>
	  <rhs>
 	    <unin>
	      <set>
		<tvar/>
	      </set>
	      <pred name="mtv">
		<pType/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="mtv">
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="mtv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
      </VEqns>
      <!-- Mtvs -->
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <tvar/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <unit/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <bool/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <ref>
		<type/>
	      </ref>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Mtv">
	      <type/>
	    </pred>
	  </rhs>
	</equation>	
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <mutable>
		<pType/>
	      </mutable>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Mtv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="Mtv">
		<type num="1"/>
	      </pred>
	      <pred name="Mtv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="Mtv">
		<type num="1"/>
	      </pred>
	      <pred name="Mtv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>                       
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="Mtv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <mbFull>
		<tvar/>
		<pType/>
	      </mbFull>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <set>
		<tvar/>
	      </set>
	      <pred name="Mtv">
		<pType/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="Mtv">
	      <mbFull>
		<mutable>
		  <tvar/>
		</mutable>
		<pType/>
	      </mbFull>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <set>
		<tvar/>
	      </set>
	      <pred name="Mtv">
		<pType/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
      </VEqns>
      <!-- ntvs -->
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <tvar/>
	    </pred>
	  </lhs>
	  <rhs>
	    <set>
	      <tvar/>
	    </set>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <unit/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <bool/>
	    </pred>
	  </lhs>
	  <rhs>
	    <empty/>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <ref>
		<type/>
	      </ref>                            
	    </pred>              
	  </lhs>
	  <rhs>
	    <pred name="ntv">
	      <type/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <mutable>
		<pType/>
	      </mutable>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="ntv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="ntv">
		<type num="1"/>
	      </pred>
	      <pred name="ntv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <pair>
		<type num="1"/>
		<type num="2"/>
	      </pair>                            
	    </pred>
	  </lhs>
	  <rhs>
	    <unin>
	      <pred name="ntv">
		<type num="1"/>
	      </pred>
	      <pred name="ntv">
		<type num="2"/>
	      </pred>
	    </unin>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <mbTop>
		<tvar/>
		<pType/>
	      </mbTop>
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="ntv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="ntv">
	      <mbFull>
		<sType/>
		<pType/>
	      </mbFull>
	    </pred>
	  </lhs>
	  <rhs>
	    <pred name="ntv">
	      <pType/>
	    </pred>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="GTVs">
    <title>Generalized Type variables</title>
    <p>
      <btypes:TYPE>
	<pred name="gtv">
	  <sigma/>
	</pred>
      </btypes:TYPE> defines the set of all generalized type variables 
      in a type-scheme. We extend this definition to a binding
      environment in a straightforward way.
    </p>
    <btypes:TYPE>
      <VEqns>
	<equation>
	  <lhs>
	    <pred name="gtv">
	      <TS>
		<tvars/>
		<type/>
	      </TS>
	    </pred>
	  </lhs>
	  <rhs>
	    <set>
	      <tvars/>
	    </set>	      
	  </rhs>
	</equation>
	<equation>
	  <lhs>
	    <pred name="gtv">
	      <gamma/>
	    </pred>
	  </lhs>
	  <rhs>
	    <grouping>
	      <Unin>
		<pred name="gtv">
		  <aTS num="i"/>
		</pred>
	      </Unin>
	      <text content=", "/>
	      <Forall/>
	      <in>
		<mapping>
		  <id/>
		  <aTS num="i"/>
		</mapping>
		<gamma/>
	      </in>
	    </grouping>
	  </rhs>
	</equation>
      </VEqns>
    </btypes:TYPE>
  </definition>
  <definition id="maybe-consistent">
    <title>Consistency of Maybe types</title>
    <p>
      We identify the following consistency property on maybe types.
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <grouping>
	      <text content="If "/>
	      <in>
		<mbTop>
		  <tvar/>
		  <pType/>
		</mbTop>
		<solvables/>
	      </in>
	      <text content=" and "/>
	      <in>
		<mbTop>
		  <tvar/>
		  <pType dash="'"/>
		</mbTop>
		<solvables/>
	      </in>
	      <text content=", then "/>
	      <eq under="minzT">
		<pType/>
		<pType dash="'"/>
	      </eq>
	    </grouping>
	  </tyPre>
	  <tyPre>
	    <grouping>
	      <text content="If "/>
	      <in>
		<mbFull>
		  <sType/>
		  <pType/>
		</mbFull>
		<solvables/>
	      </in>
	      <text content=", "/>
	      <in>
		<mbFull>
		  <sType dash="'"/>
		  <pType dash="'"/>
		</mbFull>
		<solvables/>
	      </in>
	      <text content=", and "/>
	      <eq under="minzT">
		<sType/>
		<sType dash="'"/>
	      </eq>
	      <text content=", then "/>
	      <eq under="minz">
		<pType/>
		<pType dash="'"/>
	      </eq>
	    </grouping>
	  </tyPre>
	  <tyPre>
	    <eq>
	      <inter>
		<pred name="mtv">
		  <solvables/>
		</pred>
		<pred name="ntv">
		  <solvables/>
		</pred>
	      </inter>
	      <Empty/>
	    </eq>
	  </tyPre>
	  <tyPre>
	    <eq>
	      <inter>
		<pred name="Mtv">
		  <solvables/>
		</pred>
		<pred name="ntv">
		  <solvables/>
		</pred>
	      </inter>
	      <Empty/>
	    </eq>
	  </tyPre>
	  <tyPre>
	    <eq>
	      <inter>
		<pred name="mtv">
		  <solvables/>
		</pred>
		<pred name="Mtv">
		  <solvables/>
		</pred>
	      </inter>
	      <Empty/>
	    </eq>
	  </tyPre>
	  <tyConc>
	    <CST>
	      <solvables/>
	    </CST>
	  </tyConc>
	</tyRule>
      </Hrules>
    </btypes:TYPE>
    <p>
      As a notational convenience, we write
      <btypes:TYPE>
	<Cst>
	  <assume/>
	  <solvable/>
	</Cst>
      </btypes:TYPE> as a shorthand for
      <btypes:TYPE>
	<Cst>
	  <assume/>
	  <set>
	    <solvable/>
	  </set>
	</Cst>
      </btypes:TYPE>
    </p>
  </definition>
  <definition id="subst-consistent">
    <title>Consistency of substitutions</title>
    <p>
      A consistent substitution is a well formed substitution that
      does not violate the constraints embedded as maybe types.
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <grouping>
	      <Forall/>
	      <in>
		<mbTop>
		  <tvar/>
		  <pType/>
		</mbTop>
		<solvable/>
	      </in>
	      <text content=", "/>
	      <eq>
		<Subst>
		  <aSubMap/>
		  <tvar/>
		</Subst>
		<tvar name="beta"/>
	      </eq>
	      <text content=" or "/>
	      <eq>
		<Subst>
		  <aSubMap/>
		  <tvar/>
		</Subst>
		<pType dash="'"/>
	      </eq>
	      <text content=" such that "/>
	      <eq>
		<minzT>
		  <pType dash="'"/>
		</minzT>
		<minzT>
		  <Subst>
		    <aSubMap/>
		    <pType/>
		  </Subst>
		</minzT>
	      </eq>
	    </grouping>
	  </tyPre>
	  <tyPre>
	    <grouping>
	      <Forall/>
	      <in>
		<mbFull>
		  <sType/>
		  <pType/>
		</mbFull>
		<solvable/>
	      </in>
	      <text content=", "/>
	      <eq>
		<Subst>
		  <aSubMap/>
		  <sType/>
		</Subst>
		<sType dash="'"/>
	      </eq>
	      <text content=" or "/>
	      <eq>
		<Subst>
		  <aSubMap/>
		  <sType/>
		</Subst>
		<pType dash="'"/>
	      </eq>
	      <text content=" such that "/>
	      <eq>
 		<minz>
		  <pType dash="'"/>
		</minz>
		<minz>
		  <Subst>
		    <aSubMap/>
		    <pType/>
		  </Subst>
		</minz>
	      </eq>
	    </grouping>
	  </tyPre>
	  <tyConc>
	    <models name="cst">
	      <assume>
		<aSubMap/>
	      </assume>
	      <solvable/>
	    </models>
	  </tyConc>
	</tyRule>
      </Hrules>
      <Hrules>
	<tyRule>
	  <tyPre>
	    <grouping>
	      <Forall/>
	      <in>
		<solvable/>
		<set>
		  <solvables/>
		</set>
	      </in>
	      <text content=", "/>
	      <models name="cst">
		<assume>
		  <aSubMap/>
		</assume>
		<solvable/>
	      </models>
	    </grouping>
	  </tyPre>
	  <tyConc>
	    <models name="cst">
	      <assume>
		<aSubMap/>
	      </assume>
	      <set>
		<solvables/>
	      </set>
	    </models>
	  </tyConc>
	</tyRule>
      </Hrules>
    </btypes:TYPE>
  </definition>
<!--   <definition id="approx-types"> -->
<!--     <title>Approximate Types</title> -->
<!--     <p> -->
<!--       We define a notion of equivalence in types which are -->
<!--       structurally identical except for type variables corresponding -->
<!--       to top-level maybe-types. -->
<!--     </p> -->
<!--     <btypes:TYPE> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre/> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <type/> -->
<!-- 	      <type/> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <approx> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </approx> -->
<!-- 	    <approx> -->
<!-- 	      <type num="2"/> -->
<!-- 	      <type num="3"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <type num="1"/> -->
<!-- 	      <type num="2"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <approx> -->
<!-- 	      <pType num="1"/> -->
<!-- 	      <pType num="2"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <mutable> -->
<!-- 		<pType num="1"/> -->
<!-- 	      </mutable> -->
<!-- 	      <mutable> -->
<!-- 		<pType num="2"/> -->
<!-- 	      </mutable> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--       <Hrules> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <approx> -->
<!-- 	      <pType num="1"/> -->
<!-- 	      <pType num="1" dash="'"/> -->
<!-- 	    </approx> -->
<!-- 	    <approx> -->
<!-- 	      <pType num="2"/> -->
<!-- 	      <pType num="2" dash="'"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <pair> -->
<!-- 		<pType num="1"/> -->
<!-- 		<pType num="2"/> -->
<!-- 	      </pair> -->
<!-- 	      <pair> -->
<!-- 		<pType num="1" dash="'"/> -->
<!-- 		<pType num="2" dash="'"/> -->
<!-- 	      </pair> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <approx> -->
<!-- 	      <pType num="1"/> -->
<!-- 	      <pType num="2"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <mbTop> -->
<!-- 		<tvar name="alpha"/> -->
<!-- 		<pType num="1"/> -->
<!-- 	      </mbTop> -->
<!-- 	      <mbTop> -->
<!-- 		<tvar name="beta"/> -->
<!-- 		<pType num="2"/> -->
<!-- 	      </mbTop> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!-- 	<tyRule> -->
<!-- 	  <tyPre> -->
<!-- 	    <approx> -->
<!-- 	      <pType num="1"/> -->
<!-- 	      <pType num="2"/> -->
<!-- 	    </approx> -->
<!-- 	  </tyPre> -->
<!-- 	  <tyConc> -->
<!-- 	    <approx> -->
<!-- 	      <mbFull> -->
<!-- 		<tvar name="alpha"/> -->
<!-- 		<pType num="1"/> -->
<!-- 	      </mbFull> -->
<!-- 	      <mbFull> -->
<!-- 		<tvar name="beta"/> -->
<!-- 		<pType num="2"/> -->
<!-- 	      </mbFull> -->
<!-- 	    </approx> -->
<!-- 	  </tyConc> -->
<!-- 	</tyRule> -->
<!--       </Hrules> -->
<!--     </btypes:TYPE> -->
<!--   </definition> -->
  </sect1>
