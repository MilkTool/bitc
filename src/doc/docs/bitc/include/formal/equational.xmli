<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect1 id="eq-infer"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Equational Type Inference</title> 
  <btypes:TYPE>        
    <grammar>
      <bnf desc="Types">
	<type/>
	<alternatives>
	  <tvar name="alpha"/>
	  <unit/>
	  <bool/>
	  <fn M="yes"><type/><type/></fn>                  
	</alternatives>
      </bnf>
      <bnfc desc="">
	<alternatives>
	  <ref><type/></ref>
	  <mutable><type/></mutable>
	</alternatives>
      </bnfc>
      <bnf desc="Constr. Type">
	<aCtype/>
	<alternatives>
	  <type/>
	  <ctype>
	    <type/>
	    <aCtset/>
	  </ctype>
	</alternatives>
      </bnf>
      <bnf desc="Type Scheme">          
	<aTS/>
	<alternatives>
	  <aCtype/>
	  <forall>                    
	    <tvar name="alpha"/>
	    <aTS/>
	  </forall>
	</alternatives>
      </bnf>
      <bnf desc="Constraints">
	<constraint/>
	<alternatives>
	  <eq>
	    <type/>
	    <type/>
	  </eq>
	  <ceq>
	    <type/>
	    <type/> 
	  </ceq>
	  <Tsub>
	    <type/>
	    <type/> 
	  </Tsub>
	  <Pcst>
	    <lKind/>
	    <type/>
	    <type/>
	  </Pcst>
	</alternatives>
      </bnf>
      <bnf desc="Constraint Sets">
	<aCtset/>
	<alternatives>
	  <Empty/>
	  <set>
	    <plural>
	      <constraint/>
	    </plural>
	  </set>
	  <unin>
	    <aCtset/>
	    <aCtset/>
	  </unin>
	</alternatives>            
      </bnf>
      <bnf desc="Substitutions">            
	<aSubMap/>            
	<alternatives>
	  <EmptySubst/>
	  <SubMap>
	    <tvar name="alpha"/>
	    <type/>
	  </SubMap>
	  <SubMap>
	    <lKind k="var"/>
	    <lKind/>
	  </SubMap>
	  <compose>
	    <aSubMap/>
	    <aSubMap/>
	  </compose>
	</alternatives>
      </bnf>
    </grammar>
  </btypes:TYPE>
  <p>
    The application of a substitution
    <btypes:TYPE>
      <aSubMap/>
    </btypes:TYPE> on X is written as
    <btypes:TYPE>
      <Subst>
	<aSubMap/>
	<text content="X"/>
      </Subst>
    </btypes:TYPE>. 
    As a matter of notational convenience, we write:
    <btypes:TYPE>
      <aSubMap num="a.b"/> 
    </btypes:TYPE> to mean
    <btypes:TYPE>
      <compose>
	<aSubMap num="a"/> 
	<aSubMap num="b"/> 
      </compose>
    </btypes:TYPE>. Note that
    <btypes:TYPE>
      <eq>
	<Subst>
	  <aSubMap num="a.b"/> 
	  <text content="x"/>
	</Subst>
	<Subst>
	  <compose>
	    <aSubMap num="a"/> 
	    <aSubMap num="b"/> 
	  </compose>
	  <text content="x"/>
	</Subst>
	<Subst>
	  <aSubMap num="a"/> 
	  <Subst>
	    <aSubMap num="b"/>                 
	    <text content="x"/>
	  </Subst>
	</Subst>
	<Subst>
	  <aSubMap num="b"/>                 
	  <Subst>
	    <aSubMap num="a"/> 
	    <text content="x"/>
	  </Subst>
	</Subst>
      </eq>
    </btypes:TYPE>.        
  </p>
  <definition id="meta">      
    <title>Meta Constructors</title>      
    <p>
      <btypes:TYPE>
	<floor>
	  <type/>
	</floor>
      </btypes:TYPE>
      and 
      <btypes:TYPE>
	<ceil>
	  <type/>
	</ceil>
      </btypes:TYPE>
      are "meta-constructors" which (respectively) minimize and
      maximize the mutability of a type, but are interpreted
      lazily. The meta-constructors are idempotent. 
    </p>
  </definition>
  Note that in our type system, we have restricted meta types to be
  syntactically present only as part of function types.
  <definition id="pcst">      
    <title>Meta Polymorphic Constraints</title>      
    <p>
      The constraint 
      <btypes:TYPE>
	<Pcst>
	  <lKind/>
	  <type/>
	  <type dash="'"/>
	</Pcst>
      </btypes:TYPE> is used to express types that are polymorphic
      <em>over</em> polymorphism and mutability. 
      The type 
      <btypes:TYPE>
	<type dash="'"/>
      </btypes:TYPE> can only be a specialization of 
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>, obtained through some substitution.        
      A Substitution over the polymorphic constraint is defined as:
      <btypes:TYPE>
	<eq>
	  <Subst>
	    <aSubMap/>
	    <Pcst>
	      <lKind/>
	      <type/>
	      <type dash="'"/>
	    </Pcst>
	  </Subst>
	  <Pcst>
	    <Subst>
	      <aSubMap/>                
	      <lKind/>
	    </Subst>
	    <type/>              
	    <Subst>
	      <aSubMap/>
	      <type dash="'"/>
	    </Subst>
	  </Pcst>
	</eq>
      </btypes:TYPE>.
      A substitution 
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> satisfies the set of constraints
      <btypes:TYPE>
	<set>
	  <Pcst>
	    <lKind k="var"/>
	    <type/>
	    <type num="1"/>
	  </Pcst>
	  <unspecified/>
	  <Pcst>
	    <lKind k="var"/>
	    <type/>
	    <type num="n"/>
	  </Pcst>
	</set>
      </btypes:TYPE> if and only if:
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind k="var"/>
	      </Subst>
	      <lKind k="mono"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<type num="1"/>
	      </Subst>
	      <unspecified/>
	      <Subst>
		<aSubMap/>
		<type num="n"/>
	      </Subst>
	    </eq>
	  </btypes:TYPE>, or
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <Subst>
		<aSubMap/>
		<lKind k="var"/>
	      </Subst>
	      <lKind k="poly"/>
	    </eq>
	  </btypes:TYPE>
	  and
	  <btypes:TYPE>
	    <collection>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="1"/>
		</Subst>
	      </pred>
	      <unspecified/>
	      <pred name="Immut">
		<Subst>
		  <aSubMap/>
		  <type num="n"/>
		</Subst>
	      </pred>
	    </collection>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>
  <definition id="define_infer">
    <title>Type Inference</title> 
    <p>
      Type inference is a program
      transformation that accepts a program in which
      <progident>let</progident> expressions are not annotated
      with their kinds, and returns the same programs in which
      <progident>let</progident> expressions are annotated with
      their kinds and all expressions are annotated with their
      types.
    </p>
  </definition>
  <p>
    The equational type inference algorithm is as shown in
    Figure&nbsp;<xref ref="eq_infer"/>. 
    The inference judgment 
    <btypes:TYPE>
      <TEjudge>
	<assume>
	  <gamma/>
	  <store/>
	</assume>
	<conclude>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</conclude>
	<constrain>
	  <aCtset/>
	</constrain>
      </TEjudge>
    </btypes:TYPE>
    should be understood as: given the binding context
    <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
    <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
    <btypes:TYPE><type/></btypes:TYPE> for the expression 
    <btypes:TYPE><aExpr/></btypes:TYPE> under the constraints
    <btypes:TYPE><aCtset/></btypes:TYPE>. 
    The Unification algorithm is given in 
    figure&nbsp;<xref ref="eq_unify"/> with some auxiliary
    definitions and translations defined in 
    figure&nbsp;<xref ref="eq_helper"/>. 
    The unification algorithm takes in a set of constraints
    <btypes:TYPE><aCtset/></btypes:TYPE> and either fails with an
    error <btypes:TYPE><error/></btypes:TYPE>, or succeeds to 
    result in a pair consisting of residual constraints
    <btypes:TYPE><aCtset/></btypes:TYPE> 
    (which should only contain constraints of the form:
    <btypes:TYPE>
      <!-- a <= t  -->
      <Tsub>
	<tvar name="alpha"/>
	<type/>
      </Tsub>
      <text content=","/>
      <space/>
      <!-- t <= a  -->
      <Tsub>
	<type/>
	<tvar name="alpha"/>
      </Tsub>
      <text content=", "/>
      <space/>
      <!-- however, both of the cases a <= t and t <= a
      cannot occur since it can be reduced -->
      <!-- P(k, t1, t2)  -->
      <Pcst>
	<lKind k="var"/>
	<type/>
	<type dash="'"/>
      </Pcst>
      <text content=", and"/>
      <space/>
      <Pcst>
	<lKind k="poly"/>
	<type num="g"/>
	<type num="i"/>
      </Pcst>
      <text content=", where"/>
      <space/>
      <pred name="Immut">
	<type num="i"/>
      </pred>
      <text content=", and"/>
      <space/>
      <neq>
	<pred name="dtv">
	  <type num="i"/>
	</pred>
	<Empty/>
      </neq>
      <text content="."/>            
    </btypes:TYPE>)
    and a list of
    substitutions <btypes:TYPE><aSubMap/></btypes:TYPE> for the
    constraints solved in this pass.
  </p>
  <definition id="stvs-eq">
    <title>Shallow Type Variables</title>
    <p>
      The set of type variables embedded in a type up to a 
      reference/function boundary. 
    </p>
    <p>
      <btypes:TYPE>
	<fnxn name="stv">
	  <tvar name="alpha"/>
	  <set>
	    <tvar name="alpha"/>
	  </set>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <unit/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <bool/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <fn>
	    <type/>
	    <type dash="'"/>
	  </fn>
	  <Empty/>
	</fnxn>          
	<br/>
	<fnxn name="stv">
	  <ref>
	    <type/>
	  </ref>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="stv">
	  <mutable>
	    <type/>
	  </mutable>
	  <pred name="stv">
	    <type/>
	  </pred>
	</fnxn>
	<br/>
      </btypes:TYPE>
    </p>
  </definition>    
  <definition id="dtvs-eq">
    <title>Deep Type Variables</title>
    <p>
      The set of type variables embedded in a type up to a 
      function boundary. 
    </p>
    <p>        
      <btypes:TYPE>
	<fnxn name="dtv">
	  <tvar name="alpha"/>
	  <set>
	    <tvar name="alpha"/>
	  </set>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <unit/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <bool/>
	  <Empty/>
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <fn>
	    <type/>
	    <type dash="'"/>
	  </fn>
	  <Empty/>
	</fnxn>          
	<br/>
	<fnxn name="dtv">
	  <mutable>
	    <type/>
	  </mutable>
	  <pred name="dtv">
	    <type/>
	  </pred>		
	</fnxn>
	<br/>
	<fnxn name="dtv">
	  <ref>
	    <type/>
	  </ref>
	  <pred name="dtv">
	    <type/>
	  </pred>		
	</fnxn>
      </btypes:TYPE>
    </p>
  </definition>    
  <theorem id="eq-unify-correct">
    <title>Correctness of Unification</title>
    <p>
      If:
      <btypes:TYPE>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <aCtset dash="'"/>
	    <aSubMap/>
	  </Pair>
	</eq>
	<text content=", then"/>
	<Exists>
	  <aSubMap num="s"/>
	</Exists>          
	<text content=" such that "/>
	<models name="sat"> 
	  <assume>
	    <aSubMap num="s"/>
	  </assume>
	  <aCtset dash="'"/>
	</models>
      </btypes:TYPE>
    </p>
  </theorem>
  <theorem id="eq-unify-decidable">
    <title>Decidability of Unification</title>
    <p>
      The unification algorithm
      <btypes:TYPE>
	<unf>
	  <aCtset/>
	</unf>
	<text content=" computes to some "/>
	<Pair>
	  <aCtset dash="'"/>
	  <aSubMap/>
	</Pair>
	<text content=" or fails with "/>
	<error/>
	<text content=" decidably in a finite number of steps."/>
      </btypes:TYPE>
    </p>
  </theorem>
  <theorem id="eq-infer-sound">
    <title>Soundness of Type Inference</title>
    <p>
      If:
      <btypes:TYPE>
	<TEjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
	<text content=" and "/>
	<eq>
	  <unf>
	    <aCtset/>
	  </unf>
	  <Pair>
	    <aCtset num="u"/>
	    <aSubMap num="u"/>
	  </Pair>
	</eq>
	<text content=", then "/>
	<Forall>
	  <aSubMap num="s"/>
	</Forall>
	<text content=" such that "/>
	<models name="sat"> 
	  <assume>
	    <aSubMap num="s"/>
	  </assume>
	  <aCtset num="u"/>
	</models>
	<text content=", "/>  
	<Sjudge>
	  <assume>
	    <canonical>
	      <Subst>
		<scomp>
		  <aSubMap num="u"/>
		  <aSubMap num="s"/>
		</scomp>
		<gamma/>
	      </Subst>
	    </canonical>
	    <canonical>
	      <Subst>
		<scomp>
		  <aSubMap num="u"/>
		  <aSubMap num="s"/>
		</scomp>
		<store/>
	      </Subst>
	    </canonical>
	  </assume>
	  <tqExpr>
	    <canonical>
	      <Subst>
		<scomp>
		  <aSubMap num="u"/>
		  <aSubMap num="s"/>
		</scomp>                
		<aExpr/>
	      </Subst>
	    </canonical>
	    <canonical>
	      <Subst>
		<scomp>
		  <aSubMap num="u"/>
		  <aSubMap num="s"/>
		</scomp>                                  
		<type/>
	      </Subst>
	    </canonical>
	  </tqExpr>
	</Sjudge>	                
      </btypes:TYPE>.
    </p>
  </theorem>
  <theorem id="eq-infer-complete">
    <title>Completeness of Type Inference</title>
    <p>
      If:
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>	                          
	<text content=" then "/>
	<Exists>
	  <aSubMap/>
	</Exists>
	<text content=" such that "/>
	<TEjudge>
	  <assume>
	    <gamma dash="'"/>
	    <store dash="'"/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type dash="'"/>
	    </tqExpr>
	  </conclude>
	  <constrain>
	    <aCtset/>
	  </constrain>
	</TEjudge>
	<text content=", "/>
	<models name="sat"> 
	  <assume>
	    <aSubMap/>
	  </assume>
	  <aCtset/>
	</models>
	<text content=", "/>
	<eq>
	  <gamma/>
	  <canonical>
	    <Subst>
	      <aSubMap/>
	      <gamma dash="'"/>
	    </Subst>
	  </canonical>
	</eq>
	<text content=", "/>
	<eq>
	  <store/>
	  <canonical>
	    <Subst>
	      <aSubMap/>
	      <store dash="'"/>
	    </Subst>
	  </canonical>
	</eq>
	<text content=" and "/>
	<eq>
	  <type/>
	  <canonical>
	    <Subst>
	      <aSubMap/>
	      <type dash="'"/>
	    </Subst>
	  </canonical>
	</eq>
      </btypes:TYPE>.
    </p>
  </theorem>
  </sect1>
