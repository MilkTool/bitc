<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE figure PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <sect2 id="type_system"    
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <title>Static Semantics of <btypes:TYPE><language/></btypes:TYPE></title>
  <btypes:TYPE>        
    <grammar>
      <bnf desc="Types">
	<type/>
	<alternatives>
	  <tvar name="alpha"/>
	  <unit/>
	  <bool/>
	  <fn><type/><type/></fn>                  
	</alternatives>
      </bnf>
      <bnfc desc="">
	<alternatives>
	  <ref><type/></ref>
	  <mutable><type/></mutable>
	</alternatives>
      </bnfc>
      <bnf desc="Constr. Type">
	<aCtype/>
	<alternatives>
	  <type/>
	  <ctype>
	    <type/>
	    <aCtset/>
	  </ctype>
	</alternatives>
      </bnf>
      <bnf desc="Type Scheme">          
	<aTS/>
	<alternatives>
	  <aCtype/>
	  <forall>                    
	    <tvar name="alpha"/>
	    <aTS/>
	  </forall>
	</alternatives>
      </bnf>
      <bnf desc="Constraints">
	<constraint/>
	<alternatives>
	  <Tsub>
	    <tvar name="alpha"/>
	    <type/>
	  </Tsub>
	</alternatives>
      </bnf>
      <bnf desc="Constraint Sets">
	<aCtset/>
	<alternatives>
	  <Empty/>
	  <set>
	    <plural>
	      <constraint/>
	    </plural>
	  </set>
	  <unin>
	    <aCtset/>
	    <aCtset/>
	  </unin>
	</alternatives>            
      </bnf>
      <bnf desc="Binding Environment">
	<gamma/>
	<alternatives>
	  <Empty/>
	  <extend>
	    <gamma/>
	    <mapping>
	      <id/>
	      <aTS/>
	    </mapping>
	  </extend>
	</alternatives>
      </bnf>
      <bnf desc="Store Typing">
	<store/>
	<alternatives>
	  <Empty/>
	  <extend>
	    <store/>
	    <mapping>
	      <loc/>
	      <type/>
	    </mapping>
	  </extend>
	</alternatives>
      </bnf>
      <bnf desc="Logical Relations">
	<LOGIC/>
	<alternatives>
	  <TRUE/>
	  <FALSE/>
	  <AND>
	    <LOGIC/>
	    <LOGIC/>
	  </AND>
	  <OR>
	    <LOGIC/>
	    <LOGIC/>
	  </OR>
	</alternatives>
      </bnf>
      <bnfc>
	<alternatives>              
	  <NOT>
	    <LOGIC/>
	  </NOT>
	  <pred name="Predicate">
	    <plural>
	      <LOGIC/>
	    </plural>
	  </pred>
	</alternatives>
      </bnfc>
      <bnf desc="Solvable Entities">
	<solvable/>
	<alternatives>
	  <type/>
	  <gamma/>
	  <store/>
	  <aExpr/>
	</alternatives>
      </bnf>
    </grammar>
  </btypes:TYPE>
  <p>
    We represent mathematical properties as: 
    <btypes:TYPE>
      <models name="property">
	<text content="assumption"/>
	<text content="subject"/>
      </models>
    </btypes:TYPE>.
  </p>
  <p>
    Figure&nbsp;<xref ref="subtype_rules"/> shows the copy coercion
    rules. The location semantics (lvalue) rules 
    are shown in figure&nbsp;<xref ref="lval_rules"/>.
    Figure&nbsp;<xref ref="decl_rules"/> shows the declarative
    type rules, rules for type generalization. 
    The standard type judgment  
    <btypes:TYPE>
      <TDjudge>
	<aExpr/>
	<type/>
      </TDjudge>
    </btypes:TYPE> is understood as: given a binding environment 
    <btypes:TYPE>
      <gamma/>
    </btypes:TYPE> and store typing
    <btypes:TYPE>
      <store/>
    </btypes:TYPE>, the expression
    <btypes:TYPE>
      <aExpr/>
    </btypes:TYPE> has type
    <btypes:TYPE>
      <type/>
    </btypes:TYPE>.
  </p>
  <p>
    We use the following shorthand notation:
  </p>
  <example>
    <p>
      <btypes:TYPE>
	<leadsto>
	  <DBrac>
	    <TDjudge sub="yes">
	      <aExpr/>
	      <type/>
	    </TDjudge>
	  </DBrac>
	  <DBrac>
	    <collection>
	      <TDjudge>
		<aExpr/>
		<type dash="'"/>
	      </TDjudge>
	      <Tsub>
		<type/>
		<type dash="'"/>
	      </Tsub>
	    </collection>
	  </DBrac>
	</leadsto>
      </btypes:TYPE>
    </p>
  </example>
  <p>
    Figure&nbsp;<xref ref="decl_rules"/> shows a generalized
    declarative type system and associated rules for type
    generalization. The type judgment  
    <btypes:TYPE>
      <TDjudge>
	<aExpr/>
	<type/>
      </TDjudge>
    </btypes:TYPE> is understood as: given a binding environment 
    <btypes:TYPE>
      <gamma/>
    </btypes:TYPE> and store typing
    <btypes:TYPE>
      <store/>
    </btypes:TYPE>, the expression
    <btypes:TYPE>
      <aExpr/>
    </btypes:TYPE> has type
    <btypes:TYPE>
      <type/>
    </btypes:TYPE>.
  </p>
  <definition id="aleq">      
    <title>Algebraic equivalences</title>
    <p>
      In our algebra of types, we define the following equivalence:
      <btypes:TYPE>
	<equiv>
	  <mutable>
	    <mutable>
	      <type/>
	    </mutable>
	  </mutable>
	  <mutable>
	    <type/>
	  </mutable>
	</equiv>
      </btypes:TYPE>.
      That is, the mutable type constructor is idempotent. 
    </p>
  </definition>
  <definition id="copy_sem">      
    <title>Copy Compatibility</title>
    <p> 
      We define the copy compatibility relationship 
      (<btypes:TYPE>
	<ceqOp/>
      </btypes:TYPE>) as follows:
    </p>
    <btypes:TYPE>
      <Hrules>
	<tyRule>
	  <tyPre/>
	  <tyConc>
	    <ceq>                
	      <type/>
	      <type/>
	    </ceq>
	  </tyConc>                
	</tyRule>   
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type/>
	      <type dash="'"/>
	    </ceq>	    
	  </tyPre>
	  <tyConc>
	    <ceq>                
	      <type/>
	      <mutable>
		<type dash="'"/>
	      </mutable>
	    </ceq>
	  </tyConc>                
	</tyRule>   
	<tyRule>
	  <tyPre>
	    <ceq>                
	      <type/>
	      <type dash="'"/>
	    </ceq>	    
	  </tyPre>
	  <tyConc>
	    <ceq>
	      <mutable>
		<type/>
	      </mutable>
	      <type dash="'"/>
	    </ceq>
	  </tyConc>                
	</tyRule>   
      </Hrules>
    </btypes:TYPE>
  </definition>
  <p>
    In terms of the copy-coercion rules shown in
    Figure&nbsp;<xref ref="decl_rules"/>, we can define copy
    compatibility as: 
  </p>
  <example>
    <p>
      <btypes:TYPE>
	<equiv>
	  <ceq>
	    <type num="1"/>
	    <type num="2"/>
	  </ceq>
	  <Tsub>
	    <type num="1"/>
	    <minz>
	      <type num="2"/>
	    </minz>
	  </Tsub>
	</equiv>              
      </btypes:TYPE>
    </p>
  </example>
  <p>
    The S-Ref rule ensures that copy compatibility does not
    extend beyond a ref-boundary. Since two function types are
    equal regardless of the shallow mutability of the argument and
    return positions, we write all function types in normalized
    form.  The (contravariant) argument type is written in the
    maximally immutable form (devoid of shallow mutability), and the
    (covariant) return type is written in the maximally mutable
    form.  This ensures that the ``outer'' type of a function is
    maximally permissive with respect to mutability. The S-Fn rule
    therefore is invariant in terms of its arguments and return
    types. [This normalization is different from the type displayed to the
    user, which is discussed in section&nbsp;<xref ref="proposal"/>.]  
  </p>
  <definition id="max_min">      
    <title>Max and Min Mutability</title>      
    <p> 
      The operators
      <btypes:TYPE><maxzOp/></btypes:TYPE> and
      <btypes:TYPE><minzOp/></btypes:TYPE> increase or
      decrease the mutability of a type, and are defined as:
    </p>
    <example>
      <p>
	<btypes:TYPE>
	  <eq>                
	    <maxz>
	      <mutable>
		<type/>
	      </mutable>
	    </maxz>
	    <mutable>
	      <type/>
	    </mutable>
	  </eq>
	  <text content="  and  "/>
	  <eq> 
	    <maxz>
	      <type/>
	    </maxz>
	    <mutable>
	      <type/>
	    </mutable>
	  </eq>
	  `<text content=", where "/>
	  <neq>                
	    <type/>
	    <mutable>
	      <type dash="'"/>
	    </mutable>
	  </neq>
	  <br/>
	  <eq>                
	    <minz>
	      <mutable>
		<type/>
	      </mutable>
	    </minz>
	    <type/>
	  </eq>
	  <text content="  and  "/>
	  <eq> 
	    <minz>
	      <type/>
	    </minz>
	    <type/>
	  </eq>
	  <text content=", where "/>
	  <neq>                
	    <type/>
	    <mutable>
	      <type dash="'"/>
	    </mutable>
	  </neq>
	</btypes:TYPE> 
      </p>
    </example>
  </definition>
  <p>
    It is obvious that 
    <btypes:TYPE>
      <forall>
	<type/>
	<ceq> 
	  <minz>
	    <type/>
	  </minz>
	  <type/>
	  <maxz>
	    <type/>
	  </maxz>
	</ceq>
      </forall>
      <text content=", and "/>
      <forall>
	<type/>
	<type dash="'"/>
	<iff>
	  <ceq> 
	    <type/>
	    <type dash="'"/>
	  </ceq>
	  <eq>
	    <minz>
	      <type/>
	    </minz>
	    <minz>
	      <type dash="'"/>
	    </minz>
	  </eq>
	  <eq>
	    <maxz>
	      <type/>
	    </maxz>
	    <maxz>
	      <type dash="'"/>
	    </maxz>
	  </eq>                
	</iff>
      </forall>          
      <text content="."/>
    </btypes:TYPE>
  </p>
  <definition id="structural_containment">
    <title>Structural Containment</title>
    <p>
      We define a structural containment relation 
      <btypes:TYPE>
	<in>
	  <type/>
	  <solvable/>
	</in>
      </btypes:TYPE> as follows.
      <btypes:TYPE>
	<in>
	  <type/>
	  <type dash="'"/>
	</in>
      </btypes:TYPE> if
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is structurally present as a part of 
      <btypes:TYPE>
	<type dash="'"/>
      </btypes:TYPE>.
      <btypes:TYPE>
	<in>
	  <type/>
	  <aExpr/>
	</in>
      </btypes:TYPE> if
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is structurally present as a part of  
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>, as a type annotation.
      <btypes:TYPE>
	<in>
	  <type/>
	  <gamma/>
	</in>
      </btypes:TYPE> if
      <btypes:TYPE>
	<Exists>
	  <in>
	    <mapping>
	      <id/>
	      <type dash="'"/>
	    </mapping>
	    <gamma/>
	  </in>
	</Exists>          
      </btypes:TYPE> such that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <type dash="'"/>
	</in>
      </btypes:TYPE>.
      <btypes:TYPE>
	<in>
	  <type/>
	  <store/>
	</in>
      </btypes:TYPE> if
      <btypes:TYPE>
	<Exists>
	  <in>
	    <mapping>
	      <loc/>
	      <type dash="'"/>
	    </mapping>
	    <store/>
	  </in>
	</Exists>          
      </btypes:TYPE> such that 
      <btypes:TYPE>
	<in>
	  <type/>
	  <type dash="'"/>
	</in>
      </btypes:TYPE>.
      We write
      <btypes:TYPE>
	<in>
	  <type/>
	  <solvables/>
	</in>
      </btypes:TYPE> if
      <btypes:TYPE>
	<in>
	  <type/>
	  <solvable/>
	</in>
      </btypes:TYPE>, for any
      <btypes:TYPE>
	<in>       
	  <solvable/>
	  <set>
	    <solvables/>
	  </set>
	</in>
      </btypes:TYPE>.
    </p>
  </definition>
  <definition id="ftvs">
    <title>Free Type Variables</title>
    <p>
      We denote the set of free type variables in a type
      <btypes:TYPE><type/></btypes:TYPE> as
      <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>. 
    </p>
    <example>
      <p>
	<btypes:TYPE>
	  <eq>
	    <ftvs>
	      <tvar name="alpha"/>
	    </ftvs>
	    <tvar name="alpha"/>                
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <unit/>
	    </ftvs>
	    <empty/>                
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <bool/>
	    </ftvs>
	    <empty/>                
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <ref>
		<type/>
	      </ref>
	    </ftvs>
	    <ftvs>                  
	      <type/>                  
	    </ftvs>
	  </eq>              
	  <br/>
	  <eq>
	    <ftvs>
	      <mutable>
		<type/>
	      </mutable>
	    </ftvs>
	    <ftvs>                  
	      <type/>                  
	    </ftvs>
	  </eq>          
	  <br/>
	  <eq>
	    <ftvs>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </ftvs>                                  
	    <unin>
	      <ftvs>
		<type num="1"/>
	      </ftvs>                    
	      <ftvs>
		<type num="2"/>
	      </ftvs>                    
	    </unin>                
	  </eq>          
	  <br/>
	  <eq>
	    <ftvs>
	      <types num="i"/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<type num="i"/>
	      </ftvs>
	    </Unin>
	  </eq>
	  <br/>
	  <eq>
	    <ftvs>
	      <aTS/>
	    </ftvs>
	    <unin>
	      <ftvs>
		<tvars name="alpha"/>
	      </ftvs>
	      <ftvs>
		<type/>
	      </ftvs>                  
	    </unin>
	  </eq>
	  <text content=", where "/>
	  <eq>
	    <aTS/>
	    <forall>
	      <tvars name="alpha"/>
	      <type/>
	    </forall>
	  </eq>              
	  <br/>
	  <eq>
	    <ftvs>
	      <gamma/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<aTS num="i"/>
	      </ftvs>
	    </Unin>                  
	  </eq>
	  <text content=", "/>
	  <Forall/>
	  <in>
	    <mapping>
	      <id/>
	      <aTS num="i"/>
	    </mapping>
	    <gamma/>
	  </in>
	  <br/>
	  <eq>
	    <ftvs>
	      <store/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<type num="i"/>
	      </ftvs>
	    </Unin>                  
	  </eq> 
	  <text content=", "/>
	  <Forall/>
	  <in>
	    <mapping>
	      <loc/>
	      <type num="i"/>
	    </mapping>
	    <store/>
	  </in>
	  <br/>
	  <eq>
	    <ftvs>
	      <aExpr/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<type num="i"/>
	      </ftvs>
	    </Unin>                  
	  </eq> 
	  <text content=", "/>
	  <Forall/>
	  <in>
	    <type num="i"/>
	    <aExpr/>
	  </in>
	  <br/>
	  <eq>
	    <ftvs>
	      <solvables/>
	    </ftvs>
	    <Unin>
	      <ftvs>
		<solvable/>
	      </ftvs>
	    </Unin>
	  </eq>
	</btypes:TYPE>.
      </p>
    </example>
  </definition>
  <definition id="val_res">
    <title>Value Restriction</title>
    <p>
      We define some definitions used in the enforcement of value
      restriction in Figure&nbsp;<xref ref="decl_rules"/>.
    </p>
    <example>
      <p>
	<btypes:TYPE>
	  <fnxn name="Value">
	    <aVal/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <id/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <hLoc/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <sLoc/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <dup>
	      <aExpr/>
	    </dup>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <deref>
	      <aExpr/>
	    </deref>
	    <pred name="Value">
	      <aExpr/>
	    </pred>
	  </fnxn>
	  <br/>
	  <eq>
	    <grouping>
	      <pred name="Value">
		<if>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		  <aExpr num="3"/>
		</if>
	      </pred>
	      <br/>
	    </grouping>
	    <AND>
	      <pred name="Value">
		<aExpr num="1"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="2"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="3"/>
	      </pred>
	    </AND>
	  </eq>
	  <br/>
	  <fnxn name="Value">
	    <let>
	      <id/>
	      <aExpr num="1"/>
	      <aExpr num="2"/>
	    </let>
	    <AND>
	      <pred name="Value">
		<aExpr num="1"/>
	      </pred>
	      <pred name="Value">
		<aExpr num="2"/>
	      </pred>
	    </AND>
	  </fnxn>
	  <br/>
	  <fnxn name="Value">
	    <grouping>
	      <aExpr/>
	      <text content=" (otherwise) "/>
	    </grouping>
	    <FALSE/>
	  </fnxn>
	  <br/>
	  <br/>
	  <fnxn name="Expansive">
	    <aExpr/>
	    <NOT>
	      <pred name="Value">
		<aExpr/>
	      </pred>
	    </NOT>
	  </fnxn>
	  <br/>
	  <br/>
	  <fnxn name="Immutable">
	    <unit/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immutable">
	    <bool/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immutable">
	    <fn>
	      <type num="1"/>
	      <type num="2"/>
	    </fn>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immutable">
	    <ref>
	      <type/>
	    </ref>                
	    <pred name="Immutable">
	      <type/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Immutable">
	    <grouping>
	      <type/>
	      <text content=" (otherwise) "/>
	    </grouping>
	    <FALSE/>
	  </fnxn>
	  <br/>
	  <br/>
	  <fnxn name="Immut">
	    <unit/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <bool/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <tvar name="alpha"/>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <fn>
	      <type num="1"/>
	      <type num="2"/>
	    </fn>
	    <TRUE/>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <ref>
	      <type/>
	    </ref>                
	    <pred name="Immut">
	      <type/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <forall>
	      <tvars name="alpha"/>
	      <type/>
	    </forall>
	    <pred name="Immut">                
	      <type/>
	    </pred>
	  </fnxn>
	  <br/>
	  <fnxn name="Immut">
	    <grouping>
	      <type/>
	      <text content=" (otherwise) "/>
	    </grouping>

	    <FALSE/>
	  </fnxn>
	  <br/>
	  <br/>
	  <fnxn name="Mut">
	    <type/>
	    <NOT>
	      <pred name="Immut">
		<type/>
	      </pred>
	    </NOT>
	  </fnxn>
	</btypes:TYPE>
      </p>
    </example>
  </definition>
  <definition>
    <title>Stack and Heap Typing</title>
    <p>
      A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
      <btypes:TYPE><stack/></btypes:TYPE> are said to be
      <em>well typed</em> with respect to a binding context 
      <btypes:TYPE><gamma/></btypes:TYPE> and store typing
      <btypes:TYPE><store/></btypes:TYPE>, and written 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge>
	<text content=" if "/>
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Tsub>
		<mapsto><heap/><hLoc/></mapsto>
		<mapsto><store/><hLoc/></mapsto>
	      </Tsub>
	    </Sjudge>            
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Tsub>
		<mapsto><stack/><sLoc/></mapsto>
		<mapsto><store/><sLoc/></mapsto>
	      </Tsub>
	    </Sjudge>            
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </definition>      
  <lemma id="T-inversion">
    <title>Inversion of Typing Relation</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <Unit/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <true/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <false/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <hLoc/>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </eq>
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <lambda>
		<id/>
		<aExpr/>
	      </lambda>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1" dash="'"/>
		<type num="2" dash="'"/>
	      </fn>
	    </eq>
	    <text content=" such that "/>
	    <eq>
	      <type num="1" dash="'"/>
	      <minz>
		<type num="1"/>
	      </minz>
	    </eq>
	    <text content=", "/>
	    <eq>
	      <type num="2" dash="'"/>
	      <maxz>
		<type num="2"/>
	      </maxz>
	    </eq>
	    <text content=", and, "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>                        
		    <type num="1"/>                        
		  </mapping>
		</extend>
		<store/>
	      </assume>                  
	      <tqExpr>
		<aExpr/>                    
		<type num="2"/>                    
	      </tqExpr>            
	    </Sjudge>
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li> 
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <TDjudge>
	      <deref>
		<aExpr/>
	      </deref>
	      <type/>
	    </TDjudge>
	    <text content=" then "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Tsub>
		<aExpr/>                      
		<type dash="'"/>
	      </Tsub>                    
	    </Sjudge>                  
	    <text content="."/>                
	  </btypes:TYPE>
	</p>
      </li>          
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of typing relation.
    </p>
  </proof>
  <lemma id="T-sub-inversion">
    <title>Inversion of Copy Coercion</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <bool/>
	    </Tsub>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <bool/>
	    </eq>
	    <text content=" or "/>                
	    <eq>
	      <type/>
	      <mutable>
		<bool/>
	      </mutable>
	    </eq>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <unit/>
	    </Tsub>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <unit/>
	    </eq>
	    <text content=" or "/>                
	    <eq>
	      <type/>
	      <mutable>
		<bool/>
	      </mutable>
	    </eq>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Tsub>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>                  
	    </eq>
	    <text content=" or "/>
	    <eq>
	      <type/>
	      <mutable>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>     
	      </mutable>             
	    </eq>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>
	    </Tsub>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <ref>
		<type dash="'"/>
	      </ref>                  
	    </eq>
	    <text content=" or "/>
	    <eq>
	      <type/>
	      <mutable>
		<ref>
		  <type dash="'"/>
		</ref>                  
	      </mutable>             
	    </eq>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <mutable>
		<type dash="'"/>
	      </mutable>
	    </Tsub>
	    <text content=" then "/>                
	    <eq>
	      <type/>
	      <mutable>
		<type dash="''"/>
	      </mutable>
	    </eq>
	    <text content=" such that "/>                
	    <Tsub>
	      <type dash="''"/>
	      <type dash="'"/>                  
	    </Tsub>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/> 
	    <Tsub>
	      <type/>
	      <mutable>
		<type dash="'"/>
	      </mutable>
	    </Tsub>
	    <text content=" then "/>                
	    <Tsub>
	      <type/>
	      <type dash="'"/>
	    </Tsub>
	    <text content="."/>                                
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the copy coercion derivation. 
    </p>
  </proof>
  <lemma id="T-canonical">
    <title>Canonical Forms</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>                
	    <TDjudge sub="yes">
	      <aVal/>
	      <unit/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <Unit/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge sub="yes">
	      <aVal/>
	      <bool/>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is either "/>
	    <true/>
	    <text content=" or "/>
	    <false/>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge sub="yes">
	      <aVal/>
	      <ref><type/></ref>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <hLoc/>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <aVal/>
	    <text content=" is a value, and "/>
	    <TDjudge sub="yes">
	      <aVal/>
	      <fn><type num="1"/><type num="2"/></fn>
	    </TDjudge>
	    <text content=", then, "/>
	    <aVal/>
	    <text content=" is "/>
	    <lambda><id/><aExpr/></lambda>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of
      <btypes:TYPE>
	<TDjudge sub="yes">
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE>.
    </p>
    <p>
      If 
      <btypes:TYPE>
	<TDjudge sub="yes">
	  <aVal/>
	  <bool/>
	</TDjudge>
      </btypes:TYPE>, 
      
      we have
      <btypes:TYPE>
	<TDjudge>
	  <aVal/>
	  <type/>
	</TDjudge>
	<text content=" and "/>
	<Tsub>
	  <type/>
	  <bool/>
	</Tsub>
      </btypes:TYPE> 
      
      by Inversion of copy coercion relation,
      <btypes:TYPE>
	<eq>
	  <type/>
	  <bool/>
	</eq>
	<text content=" or "/>
	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE>.
      
      If 
      <btypes:TYPE>
	<eq>
	  <type/>
	  <bool/>
	</eq>
      </btypes:TYPE>, it is clear that the final rule in the
      derivation must be T-True, or T-False, in which case the
      result is immediate. 

      The case  
      <btypes:TYPE>
	<eq>
	  <type/>
	  <mutable>
	    <bool/>
	  </mutable>
	</eq>
      </btypes:TYPE> cannot happen because there is no rule that
      derives a mutable type for a value, and we assume that the
      induction hypothesis 
      <btypes:TYPE>
	<TDjudge>
	  <aVal/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> holds.
    </p>
    <p>
      Other cases of the lemma are similar.
    </p>
  </proof>
  <lemma id="T-progress">
    <title>Progress</title>
    <p>
      <btypes:TYPE>
	<text content="If "/>
	<aExpr/>
	<text content=" is a closed, well typed term, "/> 
	<text content="that is, "/> 
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" for some "/> 
	<type/>
	<text content=" and "/> 
	<store/>
	<text content=", given any heap "/> 
	<heap/>
	<text content=" and stack "/> 
	<stack/>
	<text content=" such that "/> 
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge> 
	<text content=", "/>            
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content=" If "/>                
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	    <text content=", then "/>              
	    <aExpr/>
	    <text content=" is either a valid lvalue "/> 
	    <lVal/>
	    <text content=" (that is, "/>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	    <text content=" or "/> 
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	    <text content=") or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that:"/>               
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content="."/>   
	  </btypes:TYPE>
	</p>
      </li>
      <li>
	<p>              
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a value "/> 
	    <aVal/>
	    <text content=" or else "/> 
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>               
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation. 
    </p>
    <ol>
      <li>
	<p>
	  Case T-Unit, T-True, T-False, T-Hloc, T-Lambda:
	  (Values) Result is immediate for right execution, and
	  cannot happen for right execution
	</p>
      </li>
      <li>
	<p>
	  Case T-Id: cannot happen, there is no execution rule for
	  variables. 
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Immediate for left execution. Right
	  execution and can always continue with E-Rval rule as the
	  stack is well typed 
	  (<btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge> 
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-App: Only right execution is possible, no application is well
	  typed as an lvalue. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>                  
	    </eq>
	    <text content=", "/>
	    <Tsub>
	      <aExpr num="1"/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Tsub>                  
	    <text content=", and "/>
	    <Tsub>
	      <aExpr num="2"/>
	      <type num="1"/>
	    </Tsub>                
	  </btypes:TYPE>.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" or "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-App1# or
	  E-App2#. Otherwise, when both 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	    <text content=" and "/>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  are values, by canonical forms lemma, 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is of the form
	  <btypes:TYPE>
	    <lambda>
	      <id/>
	      <aExpr dash="'"/>
	    </lambda>
	  </btypes:TYPE>,
	  and we can take the step E-App. 
	</p>
      </li>
      <li>
	<p>
	  Case T-If: Similar to T-App, only right execution is
	  permitted.
	</p>
      </li>
      <li>
	<p>
	  Case T-Set: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>  
	    </eq>
	    <text content=", "/>
	    <Tsub>
	      <aExpr num="1"/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </Tsub>                  
	    <text content=", "/>
	    <TDjudge sub="yes">
	      <aExpr num="1"/>
	      <mutable>
		<type/>
	      </mutable>
	    </TDjudge>
	    <text content=", "/>
	    <TDjudge sub="yes">
	      <aExpr num="2"/>
	      <type/>
	    </TDjudge>
	    <text content=", and "/>
	    <Sjudge name="lval">
	      <assume/>                  
	      <aExpr num="1"/>                  
	    </Sjudge>
	  </btypes:TYPE>.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  not an lvalue, since we have  
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>                  
	      <aExpr num="1"/>                  
	    </Sjudge>
	  </btypes:TYPE>
	  we can take E-:=lhs# by induction hypothesis.
	  Similarly, if 
	  <btypes:TYPE>
	    <aExpr num="2"/>
	  </btypes:TYPE>
	  is not a value, we can take E-:=rhs#.
	  Finally, if
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <lVal/>
	    </eq>
	    <text content=" and "/>
	    <eq>
	      <aExpr num="1"/>
	      <aVal/>
	    </eq>
	  </btypes:TYPE>,
	  we can take the step E-:=Stack or E-:=Heap as
	  applicable. 
	</p>
      </li>
      <li>
	<p>
	  Case T-Dup: Only right execution is
	  permitted, and can take E-Dup# or E-Dup as
	  applicable. 
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr num="1"/>
	      </deref>
	    </eq>
	    <text content=", and "/>
	    <TDjudge sub="yes">
	      <aExpr num="1"/>                  
	      <ref>
		<type/>
	      </ref>                  
	    </TDjudge>
	  </btypes:TYPE>.
	  Execution can take EL-^# or E-^# as
	  applicable if  
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value.
	  If 
	  <btypes:TYPE>
	    <Tsub>
	      <aExpr num="1"/>
	      <ref>
		<type/>
	      </ref>
	    </Tsub>
	  </btypes:TYPE>
	  is a value, then, from the canonical forms lemma, 
	  <btypes:TYPE>
	    <eq>
	      <aExpr num="1"/>
	      <hLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>.            
	  Now, since this is an lvalue, we are done in the case of
	  left execution. In the case of right execution, we can
	  take step E-^ since the heap is well typed 
	  (<btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge> 
	  </btypes:TYPE>).
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-M: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="m">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Tsub>
	      <type/>
	      <type num="1"/>
	    </Tsub>
	    <text content=", "/>
	    <Sjudge name="gen">
	      <assume>
		<gamma/>
		<store/>
		<aExpr num="1"/>
	      </assume>                
	      <GEN>
		<type/>
		<aTS/>
	      </GEN>
	    </Sjudge>      
	    <text content=", and"/>
	    <Sjudge name="loc">
	      <assume/>
	      <tqExpr>
		<id/>
		<aTS/>	
	      </tqExpr>
	    </Sjudge>
	    <text content=", and"/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>                      
		    <aTS/>
		  </mapping>
		</extend>
		<store/>
	      </assume>                
	      <tqExpr>
		<aExpr num="2"/>
		<type num="2"/>
	      </tqExpr>                
	    </Sjudge>
	  </btypes:TYPE>.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, we can take E-Let-M.              
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-P: Only right execution is applicable. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="m">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=", "/>
	    <Tsub>
	      <type/>
	      <type num="1"/>
	    </Tsub>
	    <text content=", "/>
	    <Sjudge name="gen">
	      <assume>
		<gamma/>
		<store/>
		<aExpr num="1"/>
	      </assume>                
	      <GEN>
		<type/>
		<aTS/>
	      </GEN>
	    </Sjudge>      
	    <text content=", and"/>
	    <Sjudge name="term">
	      <assume/>
	      <tqExpr>
		<id/>
		<aTS/>	
	      </tqExpr>
	    </Sjudge>
	    <text content=", and"/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>                      
		    <aTS/>
		  </mapping>
		</extend>
		<store/>
	      </assume>                
	      <tqExpr>
		<aExpr num="2"/>
		<type num="2"/>
	      </tqExpr>                
	    </Sjudge>
	  </btypes:TYPE>.
	  If 
	  <btypes:TYPE>
	    <aExpr num="1"/>
	  </btypes:TYPE>
	  is not a value, we can take E-Let#.
	  Otherwise, can take E-Let-P.
	</p>
      </li>
      <li>
	<p>
	  Case T-TqExpr and Case T-Let-M-Tq, T-Let-P-Tq are
	  similar.  
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-Weakening">
    <title>Weakening</title>
    <p>
      We will write
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <GEN>
	      <type/>
	      <aTS/>
	    </GEN>
	  </tqExpr>
	</Sjudge>
	<text content=" as a shorthand for "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", and "/>            
	<Sjudge name="gen">
	  <assume>
	    <gamma/>
	    <store/>
	    <aExpr/>
	  </assume>
	  <GEN>
	    <type/>
	    <aTS/>
	  </GEN>
	</Sjudge>
	<text content="."/>
      </btypes:TYPE>           
    </p>
    <ol>
      <li>          
	<p>
	  If 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>                
	  </btypes:TYPE>
	  then,
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <gamma dash="'"/>
		  <gamma/>
		</supeq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <type/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  If 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<GEN>
		  <type/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	    <text content=", "/>
	    <eq>
	      <aTS/>
	      <forall>
		<tvars name="alpha"/>
		<type/>
	      </forall>
	    </eq>
	  </btypes:TYPE>
	</p>
	<ol>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <gamma dash="'"/>
		  <gamma/>
		</supeq>                
		<text content=" and "/>
		<eq>
		  <inter>
		    <ftvs>
		      <gamma dash="'"/>
		    </ftvs>
		    <ftvs>
		      <tvars name="alpha"/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma dash="'"/>
		    <store/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <GEN>
		      <type/>
		      <aTS/>
		    </GEN>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      If
	      <btypes:TYPE>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
		<text content=" and "/>
		<eq>
		  <inter>
		    <ftvs>
		      <store dash="'"/>
		    </ftvs>
		    <ftvs>
		      <tvars name="alpha"/>
		    </ftvs>
		  </inter>
		  <Empty/>
		</eq>               
		<text content=" then "/>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <tqExpr>
		    <aExpr/>
		    <GEN>
		      <type/>
		      <aTS/>
		    </GEN>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	  </li>
	</ol>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Straightforward induction on the typing derivation.
    </p>
  </proof>
  <lemma id="T-VSubstitution">
    <title>Value Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<aTS/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", "/>            
	<pred name="Immut">
	  <aTS/>
	</pred>
	<text content=" and "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aVal/>
	    <type num="v"/>
	  </tqExpr>
	</Sjudge>
	<text content=", and "/>
	<Sjudge name="gen">
	  <assume>
	    <gamma/>
	    <store/>
	    <aExpr/>
	  </assume>
	  <GEN>
	    <type num="v"/>
	    <aTS/>
	  </GEN>
	</Sjudge>
	<text content=" then "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <aVal/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>            
      </btypes:TYPE>          
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<aTS/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>.
      We proceed by case analysis on the final step of the
      derivation. 
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id: We have 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <id name="y"/>
	    </eq>
	    <text content=", where "/>
	    <in>
	      <id name="y"/>
	      <extend>
		<gamma/>
		<id/>
		<aTS/>
	      </extend>
	    </in>
	  </btypes:TYPE>.
	</p>
	<p>
	  There are two sub cases to consider. If 
	  <btypes:TYPE>
	    <eq>
	      <id name="x"/>
	      <id name="y"/>
	    </eq>
	  </btypes:TYPE>,
	  then, 
	  <btypes:TYPE>
	    <eq>
	      <subst>
		<id name="y"/>
		<id name="x"/>
		<aVal/>
	      </subst>
	      <aVal/>                
	    </eq>
	  </btypes:TYPE>,
	  and the result type 
	  <btypes:TYPE>
	    <type/>
	  </btypes:TYPE> is an instantiation of the type scheme 
	  <btypes:TYPE>
	    <aTS/>
	  </btypes:TYPE>.
	  One of the assumptions of the lemma states that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>. That is, 
	  <btypes:TYPE>
	    <spEq>
	      <type/>
	      <aTS/>
	    </spEq>
	  </btypes:TYPE>, and we can infer any more-specific type
	  (and in particular the type being instantiated at the
	  T-Id rule) instead for this substitution of the
	  expression    
	  <btypes:TYPE>
	    <aVal/>
	  </btypes:TYPE>.
	  Therefore, we have
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr/>
		  <id/>
		  <aVal/>
		</subst>
		<type/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
	<p>
	  If 
	  <btypes:TYPE>
	    <neq>
	      <id name="x"/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>, then 
	  <btypes:TYPE>
	    <eq>
	      <subst>
		<id name="y"/>
		<id name="x"/>
		<aVal/>
	      </subst>
	      <id name="y"/>
	    </eq>
	  </btypes:TYPE>,
	  and the result is immediate.
	</p>
      </li>
      <li>
	<p>
	  Case T-Lambda: We have 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <lambda>
		<id name="y"/>
		<aExpr dash="'"/>
	      </lambda>
	    </eq>
	    <text content=", and "/>
	    <eq>
	      <type/>
	      <fn>
		<type num="1"/>
		<type num="2"/>
	      </fn>
	    </eq>
	    
	    <text content=", and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id/>
		    <aTS/>
		  </tqExpr>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.              
	</p>
	<p>
	  We can assume that
	  <btypes:TYPE>
	    <neq>
	      <id/>
	      <id name="y"/>
	    </neq>
	  </btypes:TYPE>.
	  Since it is clear that the type
	  <btypes:TYPE>
	    <type num="1"/>
	  </btypes:TYPE>
	  of 
	  <btypes:TYPE>
	    <id name="y"/>
	  </btypes:TYPE>
	  can either use variables already in               
	  <btypes:TYPE>
	    <gamma/>
	  </btypes:TYPE>
	  or fresh type variables, we know that 
	  <btypes:TYPE>
	    <eq>
	      <inter>
		<ftvs>
		  <extend>
		    <gamma/>
		    <tqExpr>
		      <id name="y"/>
		      <type num="1"/>
		    </tqExpr>
		  </extend>
		</ftvs>
		<ftvs>
		  <aTS/>
		</ftvs>
	      </inter>
	      <Empty/>
	    </eq>
	  </btypes:TYPE>.
	  Thus, by weakening lemma, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<aVal/>
		<GEN>
		  <type num="v"/>
		  <aTS/>
		</GEN>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>
	  , and, by induction hypothesis, 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <tqExpr>
		    <id name="y"/>
		    <type num="1"/>
		  </tqExpr>
		</extend>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <aExpr dash="'"/>
		  <id/>
		  <aVal/>
		</subst>
		<type num="2"/>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>.
	  Finally, by the T-Lambda rule, we have:
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<lambda>
		  <id num="y"/>
		  <paren>
		    <subst>
		      <aExpr dash="'"/>
		      <id/>                      
		      <aVal/>
		    </subst>
		  </paren>
		</lambda>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, and thus
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<subst>
		  <lambda>
		    <id num="y"/>
		    <aExpr dash="'"/>
		  </lambda>                    
		  <id/>                      
		  <aVal/>                  
		</subst>
		<fn>
		  <type num="1"/>
		  <type num="2"/>
		</fn>
	      </tqExpr>
	    </Sjudge>
	  </btypes:TYPE>, which is the desired result.
	</p>
      </li>
      <li>
	<p>
	  T-Set case is similar, except that the substitution
	  cannot happen on the LHS of an assignment, since we do
	  not perform substitution of mutable values. 
	</p>
      </li>
      <li>
	<p>
	  Other cases are similar.
	</p>
      </li>
    </ol>
  </proof>
  <lemma id="T-LSubstitution">
    <title>Location Substitution</title>
    <p>
      If
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type num="0"/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=", and for some "/>
	<supeq>
	  <store dash="'"/>
	  <store/>
	</supeq>
	<text content=", "/>
	<tqExpr>
	  <mapsto>
	    <store/>
	    <sLoc/>
	    <type num="0"/>
	  </mapsto>
	</tqExpr>
	<text content=", then "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store dash="'"/>
	  </assume>
	  <tqExpr>
	    <subst>
	      <aExpr/>
	      <id/>
	      <sLoc/>
	    </subst>
	    <type/>
	  </tqExpr>
	</Sjudge>            
      </btypes:TYPE>.          
    </p>
  </lemma>
  <proof>
    <p>
      By induction on the typing derivation of
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <extend>
	      <gamma/>
	      <tqExpr>
		<id/>
		<type/>
	      </tqExpr>
	    </extend>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>, similar to lemma <xref
	ref="T-VSubstitution"/>.
    </p>
  </proof>
  <lemma id="T-sh-safety">
    <title>Stack and Heap Assignment</title>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<extend>
		  <heap/>
		  <mapping>
		    <hLoc/>
		    <aVal/>
		  </mapping>
		</extend>
		<stack/>
	      </plus>
	    </Sjudge>
	    <text content=", and "/>
	    <Tsub>
	      <mapsto>
		<store/>
		<hLoc/>
	      </mapsto>
	      <type/>
	    </Tsub>
	    <text content=", and "/>
	    <TDjudge>
	      <aVal dash="'"/>
	      <type/>
	    </TDjudge>
	    <text content=", then, "/>               
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<extend>
		  <heap/>
		  <mapping>
		    <hLoc/>
		    <aVal dash="'"/>
		  </mapping>
		</extend>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="Similarly, if "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<extend>
		  <stack/>
		  <mapping>
		    <sLoc/>
		    <aVal/>
		  </mapping>
		</extend>
	      </plus>
	    </Sjudge>
	    <text content=" and  "/>
	    <Tsub>
	      <mapsto>
		<store/>
		<sLoc/>
	      </mapsto>
	      <type/>
	    </Tsub>
	    <text content=", and "/>
	    <TDjudge>
	      <aVal dash="'"/>
	      <type/>
	    </TDjudge>
	    <text content=", then, "/>                 
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<extend>
		  <stack/>
		  <mapping>
		    <sLoc/>
		    <aVal dash="'"/>
		  </mapping>
		</extend>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      Immediate from the definition of stack and heap typing.
    </p>
  </proof>
  <lemma id="T-preservation">
    <title>Preservation</title>
    <p>
      <btypes:TYPE>          
	<text content="If "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" and "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge> 
	<text content=" then, "/>    
      </btypes:TYPE>
    </p>
    <ol>
      <li>
	<p>
	  <btypes:TYPE>
	    <text content="If "/>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content=", then, there exists a "/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	    <text content=" such that "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>                    
	    </Sjudge>
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>              
	</p>
      </li>
      <li>
	<p>
	  <btypes:TYPE>          
	    <text content="If "/>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content=", there exists a "/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>                
	    <text content=" such that "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <Tsub>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </Tsub>                    
	    </Sjudge>
	    <text content=",  "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	    <text content=" and "/>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</p>
      </li>
    </ol>
  </lemma>
  <proof>
    <p>
      By induction on the derivation of 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
      </btypes:TYPE>. We proceed by the case analysis of the final
      step. 
    </p>
    <ol>
      <li>
	<p>
	  Case T-Id, T-True, T-False, T-Hloc, T-Lambda  cannot
	  happen. 
	</p>
      </li>
      <li>
	<p>
	  Case T-Sloc: Only right execution is applicable. 
	  We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <sLoc/>
	    </eq>
	    <text content=" and "/>
	    <tqExpr>
	      <mapsto>
		<store/>
		<sLoc/>
	      </mapsto>
	      <type/>
	    </tqExpr>
	  </btypes:TYPE>.
	  The only applicable step is E-Rval, and we have
	  <btypes:TYPE>
	    <eq>
	      <aExpr dash="'"/>
	      <mapsto>
		<stack/>
		<sLoc/>
	      </mapsto>
	    </eq>
	  </btypes:TYPE>.
	  From the definition of stack typing, we have:
	  <btypes:TYPE>
	    <Tsub>
	      <mapsto>
		<stack/>
		<sLoc/>
	      </mapsto>
	      <mapsto>
		<store/>
		<sLoc/>
	      </mapsto>
	    </Tsub>
	  </btypes:TYPE>              
	  and thus 
	  <btypes:TYPE>
	    <Tsub>
	      <aExpr dash="'"/>
	      <type/>
	    </Tsub>
	  </btypes:TYPE>              
	  which implies
	  <btypes:TYPE>              
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </eq>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case T-App:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <apply>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </apply>
	    </eq>
	    <text content=", and "/>
	    <TDjudge sub="yes">
	      <aExpr num="1"/>
	      <fn>
		<type num="2"/>
		<type num="0"/>
	      </fn>
	    </TDjudge>
	    <text content=", and "/>
	    <TDjudge sub="yes">
	      <aExpr num="2"/>
	      <type num="2"/>
	    </TDjudge>
	    <text content=", and "/>
	    <Tsub>
	      <type num="0"/>
	      <type/>
	    </Tsub>
	    <text content=", and "/>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	    <text content = " where "/>
	    <eq>
	      <type num="2"/>
	      <minz>
		<type num="2" dash="'"/>
	      </minz>
	    </eq>                
	    <eq>
	      <type num="0"/>
	      <maxz>
		<type num="0" dash="'"/>
	      </maxz>
	    </eq>
	    <text content=" and "/>
	  </btypes:TYPE>.
	</p>
	<p>              
	  This cannot happen for left execution. 
	  For right execution, we proceed by further case
	  analysis of the applicable execution rules for
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>.
	</p>
	<ol>
	  <li>
	    <p>
	      Case E-App1#:
	      We have:
	      <btypes:TYPE>
		<eval>
		  <opState>
		    <stack/>
		    <heap/>
		    <aExpr num="1"/>
		  </opState>
		  <opState>
		    <stack dash="'"/>
		    <heap dash="'"/>
		    <aExpr num="1" dash="'"/>
		  </opState>
		</eval>
		<text content=" and "/>
		<eq>
		  <aExpr dash="'"/>
		  <apply>
		    <aExpr num="1" dash="'"/>
		    <aExpr num="2"/>
		  </apply>
		</eq>
	      </btypes:TYPE>.
	      By induction hypothesis, we have:
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <Tsub>
		    <aExpr num="1" dash="'"/>
		    <fn>
		      <type num="2"/>
		      <type num="0"/>
		    </fn>     
		  </Tsub>                 
		</Sjudge>                    
		<text content=" for some "/>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
	      </btypes:TYPE>.
	      One of the assumptions of the T-App rule states that 
	      <btypes:TYPE>                    
		<TDjudge sub="yes">
		  <aExpr num="2"/>
		  <type num="2"/>
		</TDjudge>
	      </btypes:TYPE>, and by weakening lemma, we have, 
	      <btypes:TYPE>                    
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <Tsub>
		    <aExpr num="2"/>
		    <type num="2"/>
		  </Tsub>
		</Sjudge>
	      </btypes:TYPE>. Finally, by the T-App rule, we
	      conclude that
	      <btypes:TYPE>                    
		<tqExpr>
		  <paren>
		    <apply>
		      <aExpr num="1" dash="'"/>                        
		      <aExpr num="2"/>
		    </apply>
		  </paren>
		  <type/>
		</tqExpr>
	      </btypes:TYPE>.
	    </p>
	  </li>
	  <li>
	    <p>
	      Case E-App2#: Similar to the previous
	      sub-case. 
	    </p>
	  </li>
	  <li>
	    <p>
	      Case E-App: We have:
	      <btypes:TYPE>
		<eq>
		  <aExpr num="1"/>
		  <lambda>
		    <id/>
		    <aExpr num="0"/>
		  </lambda>
		</eq>
		<text content=" and "/>
		<eq>
		  <aExpr num="2"/>
		  <aVal/>
		</eq>
		<text content=" and "/>
		<text content=" and "/>
		<eq>
		  <aExpr dash="'"/>
		  <subst>
		    <aExpr num="0"/>
		    <id/>
		    <sLoc/>
		  </subst>
		</eq>
		<text content=" and "/>
		<eval>
		  <opState>
		    <extend>
		      <stack/>
		      <mapping>
			<sLoc/>
			<aVal/>
		      </mapping>
		    </extend>
		    <heap/>
		    <aExpr num="1"/>
		  </opState>
		  <opState>
		    <stack dash="'"/>
		    <heap dash="'"/>
		    <aExpr num="1" dash="'"/>
		  </opState>
		</eval>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      By the inversion lemma for 
	      <btypes:TYPE>
		<lambda>
		  <id/>
		  <aExpr num="0"/>
		</lambda>
	      </btypes:TYPE> we have
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <extend>
		      <gamma>
			<id/>
			<type num="2" dash="'"/>
		      </gamma>
		      <store/>
		    </extend>
		  </assume>
		  <tqExpr>
		    <aExpr num="0"/>
		    <type num="0" dash="'"/>
		  </tqExpr>
		</Sjudge>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      Further from location substitution lemma, we have 
	      <btypes:TYPE>
		<Sjudge>
		  <assume>
		    <gamma/>
		    <store dash="'"/>
		  </assume>
		  <tqExpr>
		    <subst>
		      <aExpr num="0"/>
		      <id/>
		      <sLoc/>
		    </subst>
		    <type num="0" dash="'"/>
		  </tqExpr>
		</Sjudge>
		<text content=" where "/>
		<supeq>
		  <store dash="'"/>
		  <store/>
		</supeq>
		<text content=" and "/>
		<tqExpr>
		  <mapsto>
		    <store/>
		    <sLoc/>
		  </mapsto>
		  <type num="2" dash="'"/>
		</tqExpr>
	      </btypes:TYPE>.
	    </p>
	    <p>
	      Thus, we have 
	      <btypes:TYPE>
		<Tsub>
		  <type num="0"/>
		  <type num="0" dash="'"/>
		</Tsub>
		<text content=" and "/>
		<Tsub>
		  <type num="0"/>
		  <type/>
		</Tsub>
	      </btypes:TYPE>.
	      Therefore, it is clear that
	      <btypes:TYPE>
		<eq>
		  <minz>
		    <type num="0" dash="'"/>
		  </minz>
		  <minz>
		    <type/>
		  </minz>
		</eq>
	      </btypes:TYPE>.                  
	    </p>
	  </li>
	</ol>
      </li>
      <li>
	<p>
	  Case T-Set:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <assign>
		<aExpr num="1"/>
		<aExpr num="2"/>
	      </assign>
	    </eq>
	    <text content=", and "/>
	    <TDjudge sub="yes">
	      <aExpr num="1"/>
	      <mutable>
		<type/>
	      </mutable>
	    </TDjudge>
	    <text content=", and "/>
	    <TDjudge sub="yes">
	      <aExpr num="2"/>
	      <type/>
	    </TDjudge>
	    <Sjudge name="lval">
	      <assume/>                  
	      <aExpr num="1"/>                  
	    </Sjudge>                
	  </btypes:TYPE>
	</p>
	<p>
	  If the step taken is E-:=#lhs or E-:=#rhs,
	  the result follows from the induction hypothesis and
	  T-Set rule (as in the case of T-App).               
	  If the step taken is E-:=Stack or E-:=Heap, the
	  result follows from the stack and heap assignment lemma.
	</p>
      </li>
      <li>
	<p>
	  Case T-Deref: We have: 
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <deref>
		<aExpr dash="'"/>
	      </deref>
	    </eq>
	    <text content=" and "/>
	    <TDjudge sub="yes">
	      <aExpr dash="'"/>                  
	      <ref>
		<type/>
	      </ref>                  
	    </TDjudge>
	  </btypes:TYPE>.
	  If the step taken is EL-^# or E-^#,
	  the result follows from induction hypothesis and T-Deref
	  rule. 
	  If the step taken is E-^ (right execution only) 
	  <btypes:TYPE>
	    <aExpr dash="'"/>                  
	  </btypes:TYPE> is a value, and from canonical forms
	  lemma, we know that 
	  <btypes:TYPE>
	    <eq>
	      <aExpr dash="'"/>                  
	      <hLoc/>
	    </eq>
	    <text content=" and "/>
	    <in>
	      <hLoc/>
	      <dom>
		<store/>
	      </dom>
	    </in>
	  </btypes:TYPE>
	  and the result follows from the fact that
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>.
	</p>
      </li>
      <li>
	<p>
	  Case T-Let-P: Right execution only. We have:
	  <btypes:TYPE>
	    <eq>
	      <aExpr/>
	      <paren>
		<let kind="p">
		  <id/>
		  <aExpr num="1"/>
		  <aExpr num="2"/>
		</let>
	      </paren>
	    </eq>
	    <text content=" and "/>
	    <TDjudge sub="yes">
	      <aExpr num="1"/>                
	      <type num="1"/>                
	    </TDjudge>
	    <text content=" and "/>
	    <Tsub>
	      <type/>
	      <type num="1"/>
	    </Tsub>
	    <text content=" and "/>
	    <Sjudge name="gen">
	      <assume>
		<gamma/>
		<store/>
		<aExpr num="1"/>
	      </assume>                
	      <GEN>
		<type/>
		<aTS/>
	      </GEN>
	    </Sjudge>      
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<extend>
		  <gamma/>
		  <mapping>
		    <id/>                      
		    <aTS/>
		  </mapping>
		</extend>
		<store/>
	      </assume>                
	      <tqExpr>
		<aExpr num="2"/>
		<type num="2"/>
	      </tqExpr>                
	    </Sjudge>
	  </btypes:TYPE>.
	  There are two sub-cases to consider:
	</p>
	<ol>
	  <li>
	    <p>
	      If we take step E-Let#,                   
	      <btypes:TYPE>
		<eval>
		  <opState>
		    <stack/>
		    <heap/>
		    <aExpr num="1"/>
		  </opState>
		  <opState>
		    <stack dash="'"/>
		    <heap dash="'"/>
		    <aExpr num="1" dash="'"/>
		  </opState>
		</eval>
	      </btypes:TYPE>
	      and 
	      <btypes:TYPE>
		<eq>
		  <aExpr dash="'"/>
		  <paren>
		    <let kind="p">
		      <id/>
		      <aExpr num="1" dash="'"/>
		      <aExpr num="2"/>
		    </let>
		  </paren>
		</eq>
		<text content=". If "/>                    
		<eq>
		  <aExpr/>
		  <aVal/>
		</eq>
	      </btypes:TYPE>
	      It is clear that 
	      <btypes:TYPE>
		<pred name="Value">
		  <aExpr num="1"/>
		</pred>
	      </btypes:TYPE> implies
	      <btypes:TYPE>
		<pred name="Value">
		  <aExpr num="1" dash="'"/>
		</pred>
	      </btypes:TYPE>.                     
	      Now, the result follows
	      from the induction hypothesis and the E-Let-P rule.
	    </p>
	  </li>
	  <li>
	    <p>
	      If we take the step E-Let-P, 
	      <btypes:TYPE>
		<eq>
		  <aExpr/>
		  <paren>
		    <let kind="p">
		      <id/>
		      <aVal/>
		      <aExpr num="2"/>
		    </let>
		  </paren>
		</eq>
	      </btypes:TYPE>
	      Since 
	      <btypes:TYPE>
		<tqExpr>
		  <id/>
		  <aTS/>
		</tqExpr>
	      </btypes:TYPE>
	      has a polymorphic type, 
	      (that is,
	      <btypes:TYPE>
		<eq>
		  <aTS/>
		  <forall>
		    <tvars name="alpha"/>
		    <type name="s"/>
		  </forall>
		</eq>
	      </btypes:TYPE>)
	      we know that
	      <btypes:TYPE>
		<pred name="Immut">
		  <type/>
		</pred>
	      </btypes:TYPE>.
	      Also, from canonical forms lemma, all values have
	      an immutable type. Therefore, 
	      <btypes:TYPE>
		<eq>
		  <type/>
		  <type num="1"/>
		</eq>
	      </btypes:TYPE>. Now, the result follows from
	      value substitution lemma. 
	    </p>
	  </li>
	</ol>            
      </li>
      <li>
	<p>
	  Case T-Let-M: Similar to T-Let-P, except that we should
	  always use the GEN-EXPANSIVE rule during generalization,
	  and use the location substitution lemma instead of 
	  the value substitution lemma
	</p>
      </li>
      <li>
	<p>
	  Cases T-If, T-Dup, T-TqExpr, and T-Let-M-Tq T-Let-P-Tq are
	  similar.  
	</p>
      </li>
    </ol>
  </proof>
  <definition id="stuck_state">
    <title>Stuck State</title>
    <p>
      A system state 
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      is said to be <term>stuck</term> if
      <btypes:TYPE>
	<neq>
	  <aExpr/>
	  <aVal/>
	</neq>
      </btypes:TYPE>
      and there are no 
      <btypes:TYPE>
	<stack dash="'"/>
	<text content=", "/>
	<heap dash="'"/>
	<text content=", and "/>
	<aExpr dash="'"/>
      </btypes:TYPE>   
      such that 
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>.
    </p>
  </definition>      
  <theorem id="T-soundness">
    <title>Type Soundness</title>
    <p>
      If 
      <btypes:TYPE>
	<Sjudge>
	  <assume>
	    <Empty/>
	    <store/>
	  </assume>
	  <tqExpr>
	    <aExpr/>
	    <type/>
	  </tqExpr>
	</Sjudge>
	<text content=" and "/>
	<Sjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <plus>
	    <heap/>
	    <stack/>
	  </plus>
	</Sjudge> 
	<text content=" and "/>
	<eval many="yes">
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
	<text content=" then "/>
	<opState>
	  <stack dash="'"/>
	  <heap dash="'"/>
	  <aExpr dash="'"/>
	</opState>
	<text content=" is not stuck."/>            
      </btypes:TYPE>
      That is, execution of a well typed expression cannot lead to
      a stuck state. Here, 
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE > represents the 
      reflexive-transitive-closure of 
      <btypes:TYPE>
	<evalOp/>
      </btypes:TYPE>.
    </p>
  </theorem>
  <proof>
    <p>
      By straightforward induction on the length of   
      <btypes:TYPE>
	<evalOp many="yes"/>
      </btypes:TYPE>. If 
      <btypes:TYPE>
	<eq>
	  <aExpr/>
	  <aVal/>
	</eq>
      </btypes:TYPE>, proof is immediate. Otherwise, from 
      Lemma&nbsp;<xref ref="T-progress"/> (Progress),
      we know that we can take at least one step forward. Further,
      from Lemma&nbsp;<xref ref="T-preservation"/> (Preservation),
      we know that a (left/right) execution of a well
      typed expression in with respect to a well typed stack and heap
      will always result in another well typed expression, stack
      and heap. Proof now follows from induction hypothesis.  
    </p>
  </proof>
  </sect2>
