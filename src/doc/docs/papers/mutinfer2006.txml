<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <article id="mutinfer" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo>
    <title>Design of Type and Mutability Inference in BitC</title>
    <subtitle>SRL Technical Report SRL2006-01</subtitle>
    <authorgroup>
      <author>
	<firstname>Swaroop</firstname>
	<surname>Sridhar</surname>
      </author>
      <author>
	<firstname>Jonathan</firstname>
	<surname>Shapiro</surname>
	<degree>Ph.D.</degree>
      </author>
      <affiliation>
	<orgname>Systems Research Laboratory</orgname>
	<address>Dept. of Computer Science</address>
	<address>Johns Hopkins University</address>
      </affiliation>
    </authorgroup>
    <pubdate>September 12, 2006</pubdate>
    <copyright>
      <year>2006</year>
      <holder>Swaroop Sridhar</holder>
      <holder>Jonathan S. Shapiro</holder>
    </copyright>
    <categories>
      <category>report</category>
    </categories>
    <synopsis>
      <p>
        Discussion about the issues with type inference in the presence of
        unboxed mutability.
      </p>
    </synopsis>
  </docinfo>

  <abstract latex.incolumn="yes">
    <p>
      BitC is a call-by-value language that supports unboxed
      mutability. This enables us to allow some freedom in the 
      compatibility of types with respect to their mutability at copy
      boundaries -- that is, the type of the copy of a value might
      differ in mutability with respect to  the original value. 
      However, this kind of compatibility interacts with type inference
      in surprising ways, because there is no longer a unique way to
      type an expression. This introduces a trade-off between the degree
      of freedom in type-compatibility vs. the amount of user annotations
      we require, as well as the amount of polymorphism we can
      preserve. This document explores these trade-offs and their
      implications as a matter of theory and practice.  
    </p>
  </abstract>
  <pagebreak/>
  <!-- <toc/> -->
  <sect1>
    <title>Introduction</title>
    <p>
      Modern programming languages such as ML <cite
      ref="milner97definition"/> or Haskell <cite
      ref="peytonjones2003haskellrevisedreport"/> provide newer,
      stronger, and more expressive type systems than traditional
      systems programming languages such as C<cites>
	<cite ref="Kernighan1988C"/>
	<cite ref="ISO1999ANSI-C"/>
      </cites>
      or Ada <cite ref="ISO1995Ada"/>. 
      These features improve the robustness and safety of programs,
      and it is highly desirable to incorporate them into languages
      that can be used for high-performance ``systems'' codes. The key
      missing features for this are state (mutability) and low-level
      representation. Languages such as C#  support for state
      and representation, but do not support type inference,
      higher-order types, or mathematically well-founded mechanisms
      for abstraction.
    </p>
    <p>
      While there have been recent efforts to integrate low-level
      representation features into Haskell <cite
      ref="Diatchki2005Representation"/>, modern languages do not
      provide effective support for low-level representation
      management, or value types, and explicitly seek to discourage
      the use of ``state'' (mutable locations). As a result, these
      languages are ill-suited to the development of operating systems
      and high-performance ``systems'' codes.  BitC is an attempt to
      unify all of these features into a single, consistent language
      framework.
    </p>
    <p>
      A key feature of the newer languages is <term>type
      inference</term>: a mechanism by which the compiler
      automatically assigns the proper types to variables with minimal
      programmer annotation. Type inference preserves all of the
      consistency advantages of static typing, but lowers the burden
      on the programmer, which facilitates more rapid prototyping and
      development.
    </p>
    <p>
      The integration of mutability introduces some subtle and tricky
      issues for type inference. In particular, first-class language
      support for mutability introduces the need for copy
      compatibility rules (e.g. a mutable object of type <em>T</em>
      can be assigned a value that is copied from an immutable object
      of type <em>T</em>). These rules weaken the unification
      constraints that allow type inference to proceed, and introduce
      the possibility that the inference mechanism may not be able to
      automatically infer a type. The problem here is pragmatic rather
      than ideological: we do not view programmer specification of
      types as bad <foreignphrase>per se</foreignphrase> (indeed, in
      certain places BitC <em>requires</em> annotations), but ease of
      prototyping requires that these annotations be minimized. Copy
      compatibility rules entail a loss of principal typings. This
      note examines the possible <foreignphrase>ad hoc</foreignphrase>
      resolution rules, and identifies why the rule we have selected
      for BitC is both formally sound and pragmatically practical.
    </p>
    <p>
      For the same reason, we would like to automatically infer which
      variables are mutable so that the type inference mechanism knows
      to assign monomorphic types to these variables (which is
      necessary to eliminate some very obscure and confusing
      errors). The BitC compiler provides a limited degree of
      inference for variable mutability. The issues and tradeoffs
      involved in achieving this are discussed here.
    </p>
    <p>
      This paper defines the typing rules for the BitC programming
      language, and the mechanisms used to infer types in BitC. Once a
      soundness proof has been constructed, the rules presented here
      will be integrated into the BitC specification.
    </p>
    <p>
      The program examples in this document are written in the
      programming language BitC. Readers may find it helpful to refer
      to the <link href="http://coyotos.org/docs/bitc/spec.html">BitC
      language specification</link><cite ref="shapBitcSpec2006"/>.
    </p>
    <pagebreak/>
  </sect1>
  <sect1>
    <title>Notation</title> 
    <sect2>    
      <title>Expressions</title> 
      <p>
	A complete specification of BitC expressions is provided in
	the <link href="http://coyotos.org/docs/bitc/spec.html">BitC
          language specification</link> <cite ref="shapBitcSpec2006"/>.
      </p>
    </sect2>
    <sect2>
      <title>Types</title>    
      <table>
        <tbody>
          <tr valign="top">
            <td> <btypes:TYPE><type/></btypes:TYPE></td>                 
            <td>Any type.</td>
          </tr>   
          <tr valign="top">
            <td> 
              <btypes:TYPE><tvar name="alpha"/></btypes:TYPE>,
              <btypes:TYPE><tvar name="beta"/></btypes:TYPE>,
              <btypes:TYPE><tvar name="gamma"/></btypes:TYPE>,
              ... etc.</td>                 
            <td>Type Variables.</td>
          </tr>   
          <tr valign="top">
            <td>
              <btypes:TYPE><unit/></btypes:TYPE>,
              <btypes:TYPE><bool/></btypes:TYPE>,
              <btypes:TYPE><int sz="8"/></btypes:TYPE>,
              ... </td>                  
            <td> Primitive types. </td>
          </tr>              
          <tr valign="top">
            <td>
              <btypes:TYPE><dummy num="1"/></btypes:TYPE>,
              <btypes:TYPE><dummy num="2"/></btypes:TYPE>,
              ... </td>                  
            <td> Dummy types. </td>
          </tr>              
          <tr valign="top">
            <td>
              <btypes:TYPE><struct/> </btypes:TYPE> </td>                 
            <td>Any structure type with no type arguments.</td>
          </tr>   
          <tr valign="top">
            <td><btypes:TYPE>
                <struct name="s"></struct>                  
              </btypes:TYPE> </td>                 
            <td>The structure `s' with no type arguments.</td>
          </tr>   
          <tr valign="top">
            <td> <btypes:TYPE>
                <struct name="s">
                  <types/>
                </struct>
              </btypes:TYPE></td>                 
            <td>Any structure type with type arguments
              <btypes:TYPE><types/></btypes:TYPE>.</td> 
          </tr>  
          <tr valign="top">
            <td>
              <btypes:TYPE><union/></btypes:TYPE>, 
              <btypes:TYPE>
                <union name="u"></union>                  
              </btypes:TYPE>,
              <btypes:TYPE>
                <union name="u">
                  <types/>
                </union>
              </btypes:TYPE></td>                  
            <td>Union types, notation as described for structures.</td>
          </tr>               
          <tr valign="top">
            <td><btypes:TYPE><comp/></btypes:TYPE></td>                 
            <td> (Meta-syntax for) either structure or union type.</td>
          </tr> 
          <tr valign="top">
            <td> <btypes:TYPE><struct kind="val"/></btypes:TYPE>,
              <btypes:TYPE><union kind="val"/></btypes:TYPE>,
              <btypes:TYPE><comp kind="val"/></btypes:TYPE> </td>                  
            <td>Value structure / union types.</td>
          </tr> 
          <tr valign="top">
            <td><btypes:TYPE><struct kind="ref"/></btypes:TYPE>,
              <btypes:TYPE><union kind="ref"/></btypes:TYPE>,
              <btypes:TYPE><comp kind="ref"/></btypes:TYPE> </td>
            <td>Reference structure / union types.</td>
          </tr>  
          <tr valign="top">
            <td><btypes:TYPE><array><type/></array></btypes:TYPE></td>
            <td>Array of <btypes:TYPE><type/></btypes:TYPE>.</td>
          </tr> 
          <tr valign="top">
            <td><btypes:TYPE><vector><type/></vector></btypes:TYPE></td>                 
            <td>Vector of <btypes:TYPE><type/></btypes:TYPE>.</td>
          </tr> 
          <tr valign="top">
            <td> 
              <btypes:TYPE> <ref> <type/> </ref> </btypes:TYPE> </td>
            <td>The type:
              <progident>(ref <btypes:TYPE><type/></btypes:TYPE>)
              </progident>. </td>    
          </tr>              
          <tr valign="top">
            <td> <btypes:TYPE>
                <fn><type num="1"/><type num="2"/></fn>
              </btypes:TYPE> </td>		      
            <td>The type: Function from
              <btypes:TYPE><type num="1"/></btypes:TYPE> to
              <btypes:TYPE><type num="2"/></btypes:TYPE>. </td>   
          </tr>              
          <tr valign="top">
            <td> <btypes:TYPE><mutable><type/></mutable></btypes:TYPE> </td>                 
            <td>The type: <progident>(mutable
                <btypes:TYPE><type/></btypes:TYPE>)</progident> 
              This represents the mutability of the <em> outermost 
              </em> type constructor only. </td> 
          </tr> 
          <tr valign="top">
            <td> <btypes:TYPE><maybe><type/></maybe></btypes:TYPE> </td>                 
            <td>The type: <progident>(maybe-mutable
                <btypes:TYPE><type/></btypes:TYPE>)</progident>. 
              Similar to
              <btypes:TYPE><mutable><type/></mutable></btypes:TYPE>,
              but mutability status undecided.  </td> 
          </tr>              
          <tr valign="top">
            <td><btypes:TYPE><ctype><type/><aCtset/></ctype></btypes:TYPE>
            </td>
            <td>Constrained type <btypes:TYPE><type/></btypes:TYPE>
              with the set of constraints
              <btypes:TYPE><aCtset/></btypes:TYPE>.  </td> 
          </tr>              
          <tr valign="top">
            <td> <btypes:TYPE><MBpair><type num="1"/>
                  <aHset/></MBpair> </btypes:TYPE> </td>
            <td> <btypes:TYPE><type num="1"/></btypes:TYPE>, with
              a set of types <btypes:TYPE><aHset/></btypes:TYPE> as
              <em>hints</em> to resolve the mutability status of
              <btypes:TYPE><type num="1"/></btypes:TYPE>.</td> 
          </tr>              
          <tr valign="top">
            <td> 
              <btypes:TYPE> <exception/> </btypes:TYPE> </td>
            <td> Exception type.</td> 
          </tr>              
          <tr valign="top">
            <td> 
              <btypes:TYPE> <paren> <type/> </paren> </btypes:TYPE> </td>
            <td> Same as <btypes:TYPE><type/></btypes:TYPE>, used for
              explicit paranthesization.</td> 
          </tr>              
        </tbody>
      </table>      
      <p>
        The type <btypes:TYPE><maybe><type/></maybe></btypes:TYPE> is
        referred to in English text as
        maybe-mutable-<btypes:TYPE><type/></btypes:TYPE> or simply
        maybe-<btypes:TYPE><type/></btypes:TYPE> (interchangeably) in 
        the rest of the document. Collections of such types shall be
        referred to as ``maybe mutable-types'' or simply ``maybe types''
        (interchangeably).
      </p>
      <sect3>
        <title>Examples</title> 
        <p>
          First, we introduce some commonly used composite
          types throughout the the document. 
        </p>
        <literallayout>
(defstruct (pair 'a 'b):val fst: 'a snd: 'b)
struct pair: (pair 'a 'b)</literallayout>         
        <p indent="no">        
          pair: <btypes:TYPE>
            <Spair>
              <tvar name="alpha"/>
              <tvar name="beta"/>
            </Spair></btypes:TYPE>
        </p>
        <literallayout>
(defunion (list 'a) nil (cons car:'a cdr:(list 'a)))
union list: (list 'a)</literallayout>
        <p indent="no">
          list: <btypes:TYPE><Ulist><tvar name="alpha"/></Ulist></btypes:TYPE>
        </p>
        <literallayout>
(defunion (optional 'a):val  none (some it:'a))
union optional: (optional 'a)</literallayout>
        <p indent="no">
          optional: <btypes:TYPE><optional><tvar name="alpha"/></optional></btypes:TYPE>
        </p>

        <p>
          As an example of the shallowness of mutable and maybe mutable 
          constructors,
          <btypes:TYPE>
            <mutable>
              <Spair>
                <int sz="32"/>
                <maybe><bool/></maybe>                  
              </Spair>
            </mutable>          
          </btypes:TYPE>
          denotes the type: 
          <progident>(mutable (pair int32 (maybe bool)))</progident>.
          That is, a mutable structure of value type `pair',
          parameterized over immutable int32 and maybe mutable bool.         
        </p>
      </sect3>
    </sect2>

    <sect2>
      <title>Type Expressions</title>
      <p>
        This section introduces some operators that work on types. The
        meaning and purpose of these operators will become clear in
        the later sections of the document. All of the following
        operators have lower precedence than the type-constructors
        defined in the previous section.
      </p>
      <table>
        <tbody>
          <tr valign="top">
            <td>            
              <btypes:TYPE>
                <eq>                
                  <type num="1"/><type num="2"/>
                </eq>
              </btypes:TYPE> 
            </td>
            <td>Equality of types.</td>
          </tr>   
          <tr valign="top">
            <td>            
              <btypes:TYPE>
                <ceq>                
                  <type num="1"/><type num="2"/>
                </ceq>
              </btypes:TYPE> 
            </td>
            <td>Copy compatibility of types.</td>
          </tr>   
          <tr valign="top">
            <td>            
              <btypes:TYPE>
                <lnk>                
                  <type num="1"/><type num="2"/>
                </lnk>
              </btypes:TYPE> 
            </td>
            <td>Unification Linkage between two types.</td>
          </tr>
        </tbody>
      </table>
    </sect2>
  </sect1>

  <sect1>
    <title>Location Arguments and Returns</title> 
    <p>
      In BitC, the following expressions accept locations
      (addresses of cells) at positions indicated as
      <progident><em>loc</em></progident>, and return locations 
      as their result (except <progident>set!</progident>, which returns
      <btypes:TYPE><unit/></btypes:TYPE>):   
    </p>
    <literallayout>
id
(array-nth <em>loc</em> ndx)
(vector-nth e ndx)
(member <em>loc</em> ident)
(deref e)
(set! <em>loc</em> e)</literallayout>
    <p>
      Location semantics check ensures that there can (deeply) be no 
      non-location as the first argument of a
      <progident>set!</progident>. This ensures that the 
      programmer's intuition of what is being
      <progident>set!</progident>ed is not violated by compiler
      transformations (example: by the introduction of 
      temporaries due to transformation into an SSA form). All other forms
      can have an expression that returns a non-location at location
      positions <em>only</em> if they are not (deeply) within a
      <progident>set!</progident> expression.
    </p>

  </sect1>

  <sect1>
    <title>Copy Compatibility</title> 
    <p>
      Unlike ML, BitC supports unboxed mutability -- that is, mutable
      values need not be wrapped by a ``ref cell.'' Since BitC is a
      call-by-value language, it is desirable that we allow some
      freedom in the compatibility of types with respect to their
      mutability at copy boundaries (ex: new binding, actual vs formal
      arguments). That is, the type of the copy of a value might
      differ in mutability with respect to the original value. This
      kind of type-compatibility shall hereinafter be called as
      copy compatibility, denoted by
      <btypes:TYPE><ceqOp/></btypes:TYPE>.
    </p>
    
    <p>
      For example:
    </p>
    <literallayout>
(define (plus1 x:(mutable int32)) (set! x (+ x 1)) x)       
val plus1: (fn (mutable int32) int32)

(define v1 (plus1 10:int32))
val v1: int32</literallayout>
    <p indent="no">
      <em>Note:</em> 
      In the application 
      <progident>(plus1 10:int32)</progident> above, the type of the 
      actual argument <progident>10</progident> is <btypes:TYPE><int
          sz="32"/></btypes:TYPE> and that of the formal argument
      <progident>x</progident> is <btypes:TYPE><mutable><int
      sz="32"/></mutable></btypes:TYPE>, and
      (<btypes:TYPE><mutable><int sz="32"/></mutable></btypes:TYPE>)
      <btypes:TYPE><ceqOp/></btypes:TYPE> 
      (<btypes:TYPE><int sz="32"/></btypes:TYPE>).

    </p>

    <p> 
      However, this freedom must be constrained at a ref-boundary<footnote>
        <p>Ref-boundary refers to the fact a type is encapsulated
          within a reference type constructor (ex:
          <btypes:TYPE><vector><type/></vector></btypes:TYPE>).</p>
      </footnote> since only the reference is getting copied and the
      type of the thing referenced cannot differ. It is imperative
      that we maintain the invariant that <em> every location must
        have exactly one type </em> at all times (see Appendix <xref
        ref="mut_into_immut"/>). In this sense, mutability is actually
      an attribute of the <em>location</em> in question, rather than
      the type associated with that location.
    </p>

    <sect2> 
      <title>Definition</title>
      <p>
        When a value is copied onto a <em>new location</em> as the
        result of a copy operation, the type of the value stored in
        the new location is <em>only</em> required to be
        copy compatible with the type of the original
        value. Therefore, we define 
        <btypes:TYPE><ceqOp/></btypes:TYPE> as: 
      </p>

      <ul> 
        <li>  
          <p> 
            <btypes:TYPE>
              <ceq>                
                <mutable><type/></mutable>
                <type/>
              </ceq>
            </btypes:TYPE> 
            -- shallow top level mutability compatibility.
          </p>  
        </li>  
        <li>  
          <p> 
            <btypes:TYPE>
              <ceq>                
                <array><mutable><type/></mutable></array>
                <array><type/></array>
              </ceq>
            </btypes:TYPE>            
            -- since arrays are value types, and the entire array is
            copied by value.
          </p>  
        </li>  
        <li>  
          <p>
            <btypes:TYPE>
              <ceq>                
                <comp kind="val">
                  <types num="1"/></comp>                
                <comp kind="val">
                  <types num="2"/></comp>
              </ceq>
            </btypes:TYPE> 
            iff 
            <btypes:TYPE>
              <ceq>                
                <types num="11"/>
                <types num="21"/>
              </ceq>
            </btypes:TYPE>
            and
            <btypes:TYPE>
              <eq>                
                <types num="12"/>
                <types num="22"/>
              </eq>
            </btypes:TYPE>, where          
            <btypes:TYPE><types num="11"/></btypes:TYPE>
            &isin;<btypes:TYPE><types num="1"/></btypes:TYPE>,
            <btypes:TYPE><types num="21"/></btypes:TYPE>
            &isin;<btypes:TYPE><types num="2"/></btypes:TYPE> 
            are the set of type arguments that are <em> not </em> used 
            within another reference type-constructor, and
            <btypes:TYPE><types num="12"/></btypes:TYPE>
            &isin;<btypes:TYPE><types num="1"/></btypes:TYPE>,
            <btypes:TYPE><types num="22"/></btypes:TYPE>
            &isin;<btypes:TYPE><types num="2"/></btypes:TYPE>
            are the rest of the type arguments.
          </p>
          
          <p>
            The mutability at the fields of structures and unions are
            determined by their corresponding definitions. However, we
            do have some freedom with the compatibility of the
            type-arguments of <em> value </em> structures and
            unions. For example: 
            <btypes:TYPE>
              <ceq>
                <Spair>
                  <type num="1"/>
                  <type num="2"/>  </Spair>
                <Spair>
                  <mutable> <type num="1"/> </mutable>
                  <type num="2"/>  </Spair>
                <Spair>
                  <type num="1"/>
                  <mutable><type num="2"/></mutable> </Spair>
                <Spair>
                  <mutable><type num="1"/></mutable>
                  <mutable><type num="2"/></mutable> </Spair>
              </ceq> </btypes:TYPE>.  
            However, we cannot allow copy compatibility if
            the type-argument is used anywhere in the definition
            <em> within </em> another reference type. 

            For example, for the  following structure,
          </p>
          <literallayout>
(defstruct (St 'a 'b):val f1:'a f2:(vector 'b))
struct St: (St 'a 'b)</literallayout>
          <p indent="no">
            Two values whose types are parametrized over this
            structure are copy compatible if and only if their first 
            type-arguments (that satisfy <progident>'a</progident>
            above) are copy compatible and the second
            type-arguments (that satisfy <progident>'b</progident>
            above) are strictly compatible.
          </p>  
        </li>  
      </ul> 
      
    </sect2>    

    <sect2>
      <title>Application</title>
      <p> 
	In theory, it is <em>sufficient</em> to require (only)
        copy compatibility at:
      </p>
      <ul>
        <li>          
          <p>
            A new binding.
          </p>
        </li>
        <li>          
          <p>
            The argument and return positions of any expression 
            that does not (respectively) expect or return a location. 
          </p>
        </li>
      </ul>
      
      <p>
        The value returned by an expression returning a
        non-location will will invariably end up in an expression that
        does not expect a location, and will thus (in turn) invoke
        the copy compatibility rule. The main reason 
        to allow copy compatibility here is to allow explicit
        type-qualification of the return values of applications with a
        different but copy compatible type. For example:
      </p>        

      <literallayout>
(define (id x) x)
val id:(fn ('a) 'a)

(define xyz (id 10:int32):(mutable int32))
val xyz: int32 </literallayout>
    </sect2>    
  </sect1>

  <sect1>
    <title>Impact on Type Inference</title>
    <p>
      Freedom in compatibility of types with respect to mutability at
      copy-boundaries means we can no longer infer a unique type for
      an expression that involves copy compatibility. For example, in
      the following expression,
    </p>

    <literallayout>
(let ((p 10:int32)) ... )</literallayout>
 
    <p indent="no">
      we know that the type of the literal <progident>10</progident>
      on the RHS is <btypes:TYPE><int sz="32"/></btypes:TYPE>, but
      what is the type of <progident>p</progident>? It could either be
      <btypes:TYPE><int sz="32"/></btypes:TYPE> or
      <btypes:TYPE><mutable><int sz="32"/></mutable></btypes:TYPE>.
    </p>
    
    <p>
      When we cannot ascertain the mutability status of a type,
      we give it the type 
      <btypes:TYPE><maybe><type/></maybe></btypes:TYPE>, which means
      that it is <em>undecided</em> as to whether the actual type is
      <btypes:TYPE><mutable><type/></mutable></btypes:TYPE> or the
      immutable type <btypes:TYPE><type/></btypes:TYPE>.
      <btypes:TYPE><maybe><type/></maybe></btypes:TYPE> can later
      resolve to <btypes:TYPE><mutable><type/></mutable></btypes:TYPE>
      or <btypes:TYPE><type/></btypes:TYPE> due to further
      unification.  <!-- Furthermore, all type variables are
      understood to always have an undecided mutability status. That
      is, <btypes:TYPE><tvar name="alpha"/></btypes:TYPE> is a
      shorthand for &maybe;<btypes:TYPE><tvar
      name="alpha"/></btypes:TYPE>. -->

    </p>

    <sect2>
      <title>Unification</title>
      <p>
        This section provides the algorithm for type unification 
        in the presence of copy compatibility. The Unify() function
        will either fail with an error
        (<btypes:TYPE><error/></btypes:TYPE>), or will 
        succeed with a set of <em>linkages</em> of the unified
        types. These unification linkages are denoted by 
        <btypes:TYPE><lnk>
            <type num="1"/>
            <type num="2"/> </lnk> </btypes:TYPE>, which can be
        understood to mean ``<btypes:TYPE><type
        num="1"/></btypes:TYPE> resolves to <btypes:TYPE><type
        num="2"/></btypes:TYPE> due to unification.''
      </p>
      <example>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <unify>
		<type/>
		<type/>
	      </unify>
	      <empty/>
	    </eq>
	    <br/>	    
	    <eq>
	      <unify>
		<mutable><type/></mutable>
		<type/>
	      </unify>
	      <error/>
	    </eq>
	  </btypes:TYPE>
	</p>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <unify>
		<maybe><type num="1"/></maybe>
		<mutable><type num="2"/></mutable>
	      </unify>
	      <unin>
		<unify>
		  <type num="1"/>
		  <type num="2"/>
		</unify>
		<set>
		  <lnk>
		    <maybe><type num="1"/></maybe>
		    <mutable><type num="2"/></mutable>                  
		  </lnk>
		</set>
	      </unin>
	    </eq>
	    <br/>
	    
	    <eq>
	      <unify>
		<maybe><type num="1"/></maybe>
		<type num="2"/>
	      </unify>
	      <unin>
		<unify>
		  <type num="1"/>
		  <type num="2"/>
		</unify>
		<set>
		  <lnk>
		    <maybe><type num="1"/></maybe>
		    <type num="2"/>                  
		  </lnk>
		</set>
	      </unin>
	    </eq>
	    <br/>

	    <eq>
	      <unify>
		<mutable><type num="1"/></mutable>
		<mutable><type num="2"/></mutable>
	      </unify>
	      <unify>
		<type num="1"/>
		<type num="2"/>
	      </unify>
	    </eq>
	    <br/>

	    <eq>
	      <unify>
		<maybe><type num="1"/></maybe>
		<maybe><type num="2"/></maybe>
	      </unify>
	      <unin>
		<unify>
		  <type num="1"/>
		  <type num="2"/>
		</unify>
		<set>
		  <lnk>
		    <maybe><type num="1"/></maybe>
		    <maybe><type num="2"/></maybe>
		  </lnk>
		</set>
	      </unin>
	    </eq>
	  </btypes:TYPE>
	</p>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <unify>
		<tvar name="alpha"/>
		<type/>
	      </unify>
	      <set>
		<lnk>
		  <tvar name="alpha"/>
		  <type/>
		</lnk>
              </set>
	    </eq>
	  </btypes:TYPE>
	</p>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <unify>
		<ref><type num="1"/></ref>
		<ref><type num="2"/></ref>
	      </unify>
	      <unify>
		<type num="1"/>
		<type num="2"/>
	      </unify>
	    </eq>
	    <br/>
	    <eq>
	      <unify>
		<fn><type num="1"/><type num="2"/></fn>
		<fn><type num="3"/><type num="4"/></fn>
	      </unify>
	      <unin>
		<unify>
		  <type num="1"/>
		  <type num="3"/>
		</unify>
		<unify>
		  <type num="2"/>
		  <type num="4"/>
		</unify>
	      </unin>
	    </eq>
	    <br/>          
	    <eq>
	      <unify>
		<array><type num="1"/></array>
		<array><type num="2"/></array>
	      </unify>
	      <unify>
		<type num="1"/>
		<type num="2"/>
	      </unify>
	    </eq>
	    <br/>
	    <eq>
	      <unify>
		<vector><type num="1"/></vector>
		<vector><type num="2"/></vector>
	      </unify>
	      <unify>
		<type num="1"/>
		<type num="2"/>
	      </unify>
	    </eq>
	    <br/>
	    <eq>
	      <unify>
		<comp name="p"><types num="i"/></comp>
		<comp name="p"><types num="j"/></comp>
	      </unify>
	      <Unin>
		<unify>
		  <type num="i"/>
		  <type num="j"/>
		</unify>
	      </Unin>              
	    </eq>
	    <br/>
	    <eq>
	      <unify>
		<type num="1"/>
		<type num="2"/>
	      </unify>
	      <error/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </example>
      <p>
        All Unification rules are commutative.
        The unification linkages are just a mechanism of accumulating
        equality constraints among types. They are represented as
        (uni-directional) linkages so that it is easy to visualize the
        type obtained as the result of unification by just following the
        unification links. Moreover, we don't have to solve any
        equality constraints after unification -- they
        are instead ``solved'' incrementally, each time we form a
        linkage. If the set of linkages obtained as the result of
        unification has two linkages
        <btypes:TYPE>
          <lnk>
            <type num="1"/> <type num="2"/>
          </lnk>
        </btypes:TYPE>
        and
        <btypes:TYPE>
          <lnk>
            <type num="1"/> <type num="3"/>
          </lnk>
        </btypes:TYPE>
        where 
        <btypes:TYPE>
          <neq><type num="2"/><type num="3"/>
          </neq></btypes:TYPE>        
        it is a contradiction, and hence a type error<footnote>
          <p>The Union operation on constraint sets must be careful to
            preserve this property. </p></footnote>.        
      </p>
      
      <p>
        Note the order and manner in which maybe types are
        handled. Two types 
        <btypes:TYPE><maybe><type num="1"/></maybe></btypes:TYPE> and 
        <btypes:TYPE><maybe><type num="2"/></maybe></btypes:TYPE> must
        be linked even after 
        <btypes:TYPE><type num="1"/></btypes:TYPE> and 
        <btypes:TYPE><type num="2"/></btypes:TYPE> have
        unified, in order to ensure that their mutability also resolves the
        same way. Otherwise, all we have said is that the inner types
        must be strictly equal, and we might (due to further
        unification) end up in a situation where we infer 
        <btypes:TYPE>
          <lnk> <mutable><type/></mutable> <type/> 
          </lnk></btypes:TYPE> or 
        
        <btypes:TYPE>
          <lnk> <type/> <mutable><type/></mutable>
          </lnk></btypes:TYPE>.
        
        We can, if we prefer, introduce such linkages for all
        other types as well. The mutability wrappers must be processed even
        before type-variable linkages are processed. Otherwise, we can
        end up having types like
        <btypes:TYPE><maybe><mutable><type/></mutable></maybe></btypes:TYPE>,
        that is, <progident>(maybe (mutable 
          <btypes:TYPE><type/></btypes:TYPE>))</progident>, which can
        later ``legally'' form the type <progident>(immutable (mutable 
          <btypes:TYPE><type/></btypes:TYPE>))</progident>, which is a
        contradiction.
      </p>

      <p>
        If the type of the <em>lvalue</em> argument of a
        <progident>set!</progident> has type 
        <btypes:TYPE><maybe><type/></maybe></btypes:TYPE>, we will
        infer the constraint (rather, the linkage) 
        <btypes:TYPE>
          <lnk><maybe><type/></maybe> 
            <mutable><type/></mutable> </lnk>
        </btypes:TYPE>.
      </p>
      
      <p>
        We will now define a function UnifiedType(), that
        unifies two types, and returns the <em>final</em> type
        obtained as the result of unification. That is, it returns the
        type obtained by transitively following linkages produced as a
        result of unification, or returns
        <btypes:TYPE><error/></btypes:TYPE> if unification fails.
      </p>
      <example>
	<p>
        <btypes:TYPE>
          <eq>
            <UnifiedType>
              <type num="1"/><type num="2"/> </UnifiedType>
            <TheType>
              <type num="1"/>
              <unify>
                <type num="1"/><type num="2"/> </unify></TheType>
          </eq>
        </btypes:TYPE>
        </p>
      </example>
      <p indent="no">
        and
      </p>
      <example>
	<p>
	  <btypes:TYPE>
	    <eq>
	      <TheType>
		<type num="1"/>
		<unin>
		  <lnk><type num="1"/><type num="2"/></lnk>
		  <aLnset/></unin>
	      </TheType>
	      <TheType>
		<type num="2"/>
		<unin>
		  <lnk><type num="1"/><type num="2"/></lnk>
		  <aLnset/></unin>
	      </TheType>            
	    </eq>
	    <br/>
	    <eq>
	      <TheType><mutable> <type/> </mutable><aLnset/></TheType>
	      <mutable><TheType><type/><aLnset/></TheType> </mutable>
	    </eq>
	    <br/>
	    <eq>
	      <TheType><maybe> <type/> </maybe><aLnset/></TheType>
	      <maybe><TheType><type/><aLnset/></TheType> </maybe>
	    </eq>
	    <br/>
	    <eq>
	      <TheType><ref><type/></ref><aLnset/></TheType>
	      <ref><TheType><type/><aLnset/></TheType></ref>
	    </eq>
	    <br/>
	    <eq>
	      <TheType><fn> <type num="1"/><type num="2"/> </fn>
		<aLnset/></TheType>
	      <fn><TheType> <type num="1"/> <aLnset/></TheType>
		<TheType><type num="2"/> <aLnset/> </TheType> </fn>
	    </eq>
	    <br/>
	    <eq>
	      <TheType><array><type/></array><aLnset/></TheType>
	      <array><TheType><type/><aLnset/></TheType></array>
	    </eq>
	    <br/>
	    <eq>
	      <TheType><vector><type/></vector><aLnset/></TheType>
	      <vector><TheType><type/><aLnset/></TheType></vector>
	    </eq> 
	    <br/>
	    <eq>
	      <TheType><comp name="p"><types name="i"/></comp>
		<aLnset/></TheType>
	      <comp name="p">
		<aggregate><TheType>
		    <type name="i"/><aLnset/></TheType></aggregate>
	      </comp>
	    </eq>
	    <br/>
	    <eq>
	      <TheType>
		<type/>
		<aLnset/>
	      </TheType> 
	      <type/>
	    </eq>
	    <br/>          
	    <eq>
	      <TheType>
		<type/>
		<error/>
	      </TheType> 
	      <error/>
	    </eq>
	  </btypes:TYPE>
	</p>
      </example>
      <p indent = "no">
        All functions that operate on types (including the Unifier
        itself)<footnote><p> Except, of course, the function
            TheType().</p></footnote> shall be understood to operate on
        types that are obtained after all unification linkages are
        followed. That is, 
        f(<btypes:TYPE><type/></btypes:TYPE>) is a shorthand for         
        f(<btypes:TYPE><type/></btypes:TYPE>,
        <btypes:TYPE><aLnset/></btypes:TYPE>), wherein the
        <em>first</em> rule of the function is:
      </p>
      <example>
	<p>
	  f(<btypes:TYPE>
	    <type num="1"/></btypes:TYPE>,
	  <btypes:TYPE><unin>
	      <lnk><type num="1"/><type num="2"/></lnk>
	      <aLnset/></unin></btypes:TYPE>) = 
	  f(<btypes:TYPE>
	    <TheType>
	      <type num="1"/>              
	      <unin>
		<lnk><type num="1"/><type num="2"/></lnk>
		<aLnset/></unin>
	    </TheType></btypes:TYPE>,
	  <btypes:TYPE><unin>
	      <lnk><type num="1"/><type num="2"/></lnk>
	      <aLnset/></unin></btypes:TYPE>)
	</p>
      </example>
      <p indent="no">
        These details are not shown in subsequent functions in the
        interest of brevity. Also, the operation on constrained types
        is not explicitely shown. Application (of a function) on a
        constrained type is the same as applying the function on the
        unconstrained type, because following unification linkages
        will have the effect of performing resultant substitutions in
        the constraint set as well. </p>
    </sect2>
    
    <sect2>
      <title>An Example</title>

      <p>
        In this section, we illustrate our inference mechanism with
        the help of an example. Consider the following definition:
      </p>

      <literallayout>
(define p:(pair (mutable int32) bool) 
  (pair (the int32 1) #t))
val p:(pair (mutable int32) bool)</literallayout>

      <p indent="no">
        In order to illustrate the types obtained after every step of
        inference, we will annotate this expression with 
        <font color="blue"><em>[numbers]</em></font> and then
        indicate the unification performed (if any) and the type obtained
        at each step. The annotations that use quoted numbers as in
        <font color="blue"><em>[n']</em></font> indicate the type
        inferred for the <em> copy </em> of the value
        at the corresponding unquoted annotation 
        <font color="blue"><em>[n]</em></font>. 
      </p>

      <literallayout>
<font color="blue"><em>[12]</em></font>(define <font
color="blue"><em>[6]</em></font> <font
color="blue"><em>[1]</em></font>p: <font
color="blue"><em>[5]</em></font>(pair <font
color="blue"><em>[3]</em></font>(mutable <font
color="blue"><em>[2]</em></font>int32) <font
color="blue"><em>[4]</em></font>bool) 
        <font
color="blue"><em>[11']</em></font> <font
color="blue"><em>[11]</em></font>(pair <font
color="blue"><em>[9']</em></font> <font
color="blue"><em>[9]</em></font>(the <font 
color="blue"><em>[8]</em></font>int32 <font
color="blue"><em>[7]</em></font>1) <font 
color="blue"><em>[10']</em></font> <font 
color="blue"><em>[10]</em></font>#t))</literallayout>

      <p>
        <font color="blue"><em>[1]</em></font> = 
        <btypes:TYPE><tvar
            name="alpha"/></btypes:TYPE><br/>  
        <font color="blue"><em>[2]</em></font> =
        <btypes:TYPE><int sz="32"/></btypes:TYPE><br/> 
        <font color="blue"><em>[3]</em></font> =
        <btypes:TYPE><mutable><int
              sz="32"/></mutable></btypes:TYPE><br/>  
        <font color="blue"><em>[4]</em></font> =
        <btypes:TYPE><bool/></btypes:TYPE><br/> 
        <font color="blue"><em>[5]</em></font> =        
        <btypes:TYPE><Spair>
            <mutable><int sz="32"/></mutable><bool/>
          </Spair></btypes:TYPE><br/>
        <font color="blue"><em>[6]</em></font> = 
        UnifiedType(<font color="blue"><em>[1]</em></font>, 
        <font color="blue"><em>[5]</em></font>) = 
        <btypes:TYPE><Spair>
            <mutable><int sz="32"/></mutable><bool/>
          </Spair></btypes:TYPE><br/>
        <font color="blue"><em>[7]</em></font> =         
        <btypes:TYPE><ctype>
            <tvar name="beta"/>
            <set><Tclass name="IntLit"><tvar name="beta"/>
              </Tclass></set></ctype></btypes:TYPE><br/>
        <font color="blue"><em>[8]</em></font> =
        <btypes:TYPE><int sz="32"/></btypes:TYPE> <br/> 
        <font color="blue"><em>[9]</em></font> =
        UnifiedType(<font color="blue"><em>[7]</em></font>, 
        <font color="blue"><em>[8]</em></font>) = 
        <btypes:TYPE><int sz="32"/></btypes:TYPE> <br/> 
        <font color="blue"><em>[9']</em></font> =
        <btypes:TYPE><maybe><int sz="32"/></maybe></btypes:TYPE> <br/> 
        <font color="blue"><em>[10]</em></font> =
        <btypes:TYPE><bool/></btypes:TYPE> <br/> 
        <font color="blue"><em>[10']</em></font> =
        <btypes:TYPE><maybe><bool/></maybe></btypes:TYPE> <br/> 
        <font color="blue"><em>[11]</em></font> =
        <btypes:TYPE><Spair>
            <maybe><int sz="32"/></maybe>
            <maybe><bool/></maybe></Spair></btypes:TYPE> <br/>   
        <font color="blue"><em>[11']</em></font> = 
        <btypes:TYPE><maybe><Spair>
              <maybe><int sz="32"/></maybe> 
              <maybe><bool/></maybe>
            </Spair></maybe></btypes:TYPE><br/>
        <font color="blue"><em>[12]</em></font> = 
        UnifiedType(<font color="blue"><em>[6]</em></font>, 
        <font color="blue"><em>[11']</em></font>) =
        <btypes:TYPE><Spair>
            <mutable><int sz="32"/></mutable> <bool/>
          </Spair></btypes:TYPE><br/>
      </p>
      
    </sect2>
    
    <sect2>
      <title>Principality of Inferred Types</title>
      <p>    
        The main idea of maybe types is to keep the mutability
        status of types ``open'' to further unification, and thus
        infer most-general (or principal) types at every step of
        inference. However, at a let-boundary<footnote><p>Let-boundary
            refers to the point where we have typed the bindings of a
            <progident>let</progident>,
            <progident>letrec</progident>, or
            <progident>define</progident> expression, and are about to 
            generalize the types of the bound identifiers to obtain a
            (possibly) polymorphic type.</p></footnote>, it is
        no longer possible to keep the mutability status of types
        ``open'' to further unification --- at least in the case of
        universally quantified types --- due to the value-restriction
        <cite ref="wrightValRes1995"/>. 
        That is, in the case of the expression: 
      </p>
      <literallayout>
(let ((p nil)) ... )</literallayout>
      
      <p indent="no">
        we cannot give <progident>p</progident> the type:        
        <btypes:TYPE><TS><tvar name="alpha"/>
            <maybe><Ulist><tvar name="alpha"/></Ulist></maybe>
          </TS></btypes:TYPE>
        due to the value restriction. We can either give
        <progident>p</progident> 
        the polymorphic type 
        <btypes:TYPE><TS><tvar name="alpha"/>
            <Ulist><tvar name="alpha"/></Ulist>
          </TS></btypes:TYPE>, or the monomorphic type
        <btypes:TYPE><maybe><Ulist><tvar
                name="alpha"/></Ulist></maybe></btypes:TYPE>. 
        That is, in this system, there is no <em>principal type</em>
        that we can infer for <progident>p</progident>. 
        Given this, we must ``default'' these maybe types to
        either mutable or immutable at a let-boundary. In the next
        section, we will identify some choices for defaulting these
        maybe types, and discuss their merits and limitations.
      </p>

      <p>
        In contrast, ML infers principal types<footnote>
          <p>Except in some cases of operator overloading in SML.</p>
        </footnote> although it does not infer principal typings<cite
          ref="JimPrincipalTypings1996"/>. In order to achieve
        principality of inferred types, ML imposes the restriction
        that <em>only</em> references can be mutated, and <em>all</em>
        references must be mutable. This leaves the inference engine
        with exactly one choice (of the type to infer) when it looks
        at an expression. In BitC, we trade principality of inferred
        types in preference to a more expressive language (and type
        system). Section&nbsp;<xref ref="tradeoffs"/> deals with the
        various
        issues that arise due to this non-principality of inferred
        types.   
      </p>
      
      <p>
        It might be useful to note that this is not the
        only case in which we run into the non-principality problem in
        BitC. We do not infer structure types automatically from the
        field labels in the case of expressions like  
      </p>
      <literallayout>
s.fld
      </literallayout>
      <p indent="no">
        We cannot infer the type of <progident>s</progident> because,
        in BitC, we do not require field labels to be unique. So there
        is no principal type we can infer for the above expression,
        and it fails to type check. This problem is similar to SML's
        record selection using the <progident>#</progident> operator.
      </p>
    </sect2>
    
    <sect2 id="valresintro">
      <title>Interaction with ``Relaxed'' Value Restriction</title>
      <p>
        In BitC, we adopt the <em>relaxed</em> Value Restriction
        proposed by Jacques Garrigue<cite ref="garrigueValRes2004"/>,
        which states that even in an expansive expression, type
        variables that occur purely in non-contravariant (non-argument)
        positions can be generalized. 

        More formally, this means that, in an <em>expansive</em>
        expression <progident>e</progident> with type
        <btypes:TYPE><type/></btypes:TYPE>, the generalizable type
        variables are given by:
      </p>
      <example>
	<p>
	  <btypes:TYPE>
	    <diff>
	      <ftvs><type/></ftvs>
	      <ftvs><gamma/></ftvs>
	      <V_><type/></V_>
	    </diff>
	  </btypes:TYPE>
	</p>
      </example>
      <p>
        where:
      </p>
      <example>
	<p>
	  <btypes:TYPE><ftvs><type/></ftvs></btypes:TYPE>
	  is the set of all the free type variables in
	  <btypes:TYPE><type/></btypes:TYPE>,
	  <br/>
	  <btypes:TYPE><ftvs><gamma/></ftvs></btypes:TYPE>
	  is the set of all the free type variables captured in the
	  environment 
	  <btypes:TYPE><gamma/></btypes:TYPE>, and 
	  <br/>
	  <btypes:TYPE><V_><type/></V_></btypes:TYPE>
	  is the function which returns the set of "dangerous"
	  type variables to be removed from the set of generalizable
	  ones, and is defined (in the context of BitC) as:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<V_><tvar name="alpha"/></V_>
		<empty/>
	      </eq>
	    </btypes:TYPE>
	    <br/>
	    <btypes:TYPE>
	      <eq>
		<V_><mutable><type/></mutable></V_>
		<ftvs><type/></ftvs>
	      </eq>
	    </btypes:TYPE>
	    <br/>
	    <btypes:TYPE>
	      <eq>
		<V_><fn><type num="1"/><type num="2"/></fn></V_>
		<unin>
		  <ftvs><type num="1"/></ftvs>
		  <V_><type num="2"/></V_>
		</unin>              
	      </eq>
	    </btypes:TYPE>
	    <br/>
	    <btypes:TYPE>
	      <eq>
		<V_><comp><types num="i"/></comp></V_>
		<Unin><V_><type num="i"/></V_></Unin> 
	      </eq>
	    </btypes:TYPE> 
	  </p>
	</example>
      </example>
      <p>
        However, in a language that has unboxed mutability and unboxed
        composite values, this restriction turns out to be
        insufficient to ensure soundness. For example:
      </p>

      <literallayout>
(define p:(mutable bool, 'a) (#t, none))
val p: (mutable bool, (optional 'b)) ??</literallayout>
      <p>
        According to the above algorithm, we see that the value
        constructor <progident>none</progident> has the type
        <btypes:TYPE>          
          <optional>
            <tvar name="alpha"/>
          </optional></btypes:TYPE>,
        and the type variable <btypes:TYPE> <tvar name="alpha"/>
        </btypes:TYPE> occurs in 
        non-contravariant  position, and can thus be generalized. Now,
        if we give p the type
        <btypes:TYPE>          
          <TS>
            <tvar name="alpha"/>
            <Spair>
              <mutable><bool/></mutable>
              <optional>
                <tvar name="alpha"/>
              </optional></Spair></TS></btypes:TYPE>,        
        we can then write:
      </p>
      <literallayout>        
(let ((r1:(optional int8) p.snd)
       (r2:(optional double) p.snd)) ... )</literallayout>

      <p>
        which is clearly not OK because <progident>r1</progident> and 
        <progident>r2</progident> have different sizes
        and this requires the polyinstantiation
        <progident>p.snd</progident> and thus its 
        container <progident>p</progident>, which has other mutable
        components. Therefore, we cannot give <progident>p</progident>
        a polymorphic type here.

        In Section&nbsp;<xref ref="ValRes"/>, we will describe a revised
        version of Garrigue's restriction, that is sound in the
        presence of composite value types. The idea is to make the
        value restriction <em>propagate</em> to enclosing container
        type until we reach a ref-boundary. 
      </p>
      
      <p>
        In SML, all type variables in expansive expressions are
        monomorphed. While this will solve our problem, we did not
        adopt this solution because we wanted to preserve as much
        polymorphism as possible (especially in the case of reference
        types). Many use cases for adapting the relaxed restriction
        including the need for polymorphism in accessor functions can
        be found in  <cite ref="garrigueValRes2004"/>.
        Cyclone solves this problem by imposing a stricter rule
        (rather reminiscent of Haskell's monomorphism restriction<cite
          ref="H98rep"/>) that <em>only</em> functions
        are given polymorphic types<cite
          ref="GrossmanCyclone2006"/>. This is a reasonable thing to 
        do in cyclone where most values are mutable, and where there
        is a distinction between <em>functions </em> and <em>function
          values</em>, but, is too restrictive for our purposes. 
      </p>
    </sect2>
    
    <sect2 id="tradeoffs">
      <title>Inference Trade Offs</title>
      <p>
        As we have seen in the previous section, we introduced 
        maybe types in order to provide freedom of
        copy compatibility. However, in doing so, we ``lost'' precise
        mutability information about these types. This, combined with the
        fact that we must default these maybe types at a let-boundary, can
        result in inferred types that are quite surprising to the
        programmer. In this section we will consider the various issues in
        the trade-off between freedom and precision. In an ideal scheme, we
        should have:
      </p>

      <ul>
        <li>
          <p>
            <em>Soundness:</em> The inferred types must be correct.
          </p>
        </li>
        <li>
          <p>
            <em>Completeness:</em> It should be possible to infer all possible
            sound types, albeit with qualifications.
          </p>
        </li>
        <li>
          <p>
            <em>Less programmer annotations:</em> The inference must be useful,
            and must not require excessive annotations in the ``common
            case.'' Since the ``common case'' is a subjective usability issue,
            we can approximate this to say: ``it must retain as much
            available information as possible.''
          </p>
        </li>
        <li>
          <p>
            <em>Contained mutability:</em> The inference engine must
            not infer mutable types in ways that are ``too surprising'' to the
            user. From the standpoint of good programming practice, this
            might be stated as ``mutability should not be promiscuously
            inferred.'' 
          </p>
        </li>
      </ul>   

      <sect3>
        <title>Fixing Maybe Types</title>
        <p>
          This section explores the different possible ``fixes'' to default
          the maybe mutable types at a let-boundary. We will illustrate
          their effects using the example: 
        </p>
        <literallayout>
(let ((p (pair n:(mutable int32) (lambda (x) x)))
      (q #f)) body)
<em>[Intermediate]</em> p: (maybe (pair (maybe int32) (maybe (fn ('a) 'a))))
<em>[Intermediate]</em> q: (maybe bool)</literallayout>

        <p indent="no">
          where we have obtained the types:
	</p>
	<example>
	  <p>
	    <progident>p</progident>:
	    <btypes:TYPE><maybe><Spair>
		  <maybe><int sz="32"/></maybe>
		  <paren><maybe>
		      <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		    </maybe></paren>
		</Spair></maybe></btypes:TYPE> <br/>
	    <progident>q</progident>:
	    <btypes:TYPE><maybe><bool/></maybe></btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  and are now at the step of generalization.
	</p>
        <ul>
          <li>
            <p>
              FIX1: Fix <em>all</em> maybe types to immutable types deeply. 
              This is in some sense the most ``conservative'' approach. It
              preserves as much polymorphism as possible at the cost of  
              requiring programmer annotation for <em> every </em> mutable
              definition. 
            </p>

            <p>
              Using this fix, we obtain:
	    </p>
	    <example>
	      <p>
		<progident>p</progident>:
		<btypes:TYPE><TS>
		    <tvar name="alpha"/>
		    <Spair>                    
		      <int sz="32"/>
		      <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		    </Spair></TS></btypes:TYPE> <br/>
		<progident>q</progident>:
		<btypes:TYPE><bool/></btypes:TYPE>
	      </p>
	    </example>
	    <p>
              Any attempt to <progident>set!</progident>
              <progident>p</progident> or <progident>q</progident> in
              <progident>body</progident> will fail to type-check.
            </p>    
          </li>

          <li>
            <p>
              FIX2: In the case of <em> local </em> definitions, fix
              all maybe types to immutable types deeply
              <em> only if </em>  the type is polymorphic. This method
              preserves all of the polymorphism in FIX1, but also the
              mutability of fully-concrete types undecided (and thus
              open for further unification). The downside to using
              FIX2 of course, is that it tends to allow mutability in
              ways the programmer might be caught by surprise.  
            </p>
            <p>
              Using this fix, we obtain:
	    </p>
	    <example>
	      <p>
		<progident>p</progident>:
		<btypes:TYPE><TS>
		    <tvar name="alpha"/>
		    <Spair>                    
		      <int sz="32"/>
		      <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		    </Spair></TS></btypes:TYPE> <br/>
		<progident>q</progident>:
		<btypes:TYPE><maybe><bool/></maybe></btypes:TYPE>
	      </p>
	    </example>
	    <p>
              Any attempt to <progident>set!</progident>
              <progident>p</progident> in  <progident>body</progident> will
              fail to type-check, but a <progident>set!</progident> on
              <progident>q</progident> will work fine, giving
              <progident>q</progident> the type 
              <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE><br/> 
            </p>
          </li>
          <li>
            <p>
              FIX3: Same as FIX1, except that if a <em> locally
              </em> defined identifier is used as the target (LHS) of
              a <progident>set!</progident>, it is given a shallowly
              mutable type. Since this fix infers shallow mutability,
              it will reduce the need for explicit type qualifications
              by the programmer in the common case (ex: iterators).
              However, it also has the problem of unintentional
              mutability (as in FIX2), but the spread of mutability is
              contained shallowly in this case.  
            </p>

            <p>
              Using this fix, if <progident>p</progident> and
              <progident>q</progident> are <progident>set!</progident>ed in
              <progident>body</progident>, we obtain:
	    </p>
	    <example>
	      <p>
              <progident>p</progident>:
              <btypes:TYPE>
                <mutable><Spair>                    
                    <int sz="32"/>
                    <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
                  </Spair></mutable></btypes:TYPE> <br/>
              <progident>q</progident>:
              <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE>
	      </p>
	    </example>
	    <p indent="no">
	      otherwise:
	    </p>
	    <example>
	      <p>
              <progident>p</progident>:
              <btypes:TYPE><TS>
                  <tvar name="alpha"/>
                  <Spair>                    
                    <int sz="32"/>
                    <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
                  </Spair></TS></btypes:TYPE> <br/>
              <progident>q</progident>:
              <btypes:TYPE><bool/></btypes:TYPE>
	      </p>
	    </example>
	    <p>
              Any attempt to <progident>set!</progident>
              <progident>p</progident> or <progident>q</progident> in
              <progident>body</progident> will succeed, but an attempt
              to <progident>set!</progident>
              <progident>p.fst</progident> will fail.
            </p>
          </li>
          <li>
            <p>
              FIX4: Fix all maybe types to whatever they were obtained
              from. If this does not completely resolve all maybe types, they
              are resolved to their immutable variants as the last resort.
              This requires a little more sophistication in the
              inference engine and the unifier.
              The idea here is to preserve the mutability information as
              a matter of ``natural'' flow of inference, but will allow the
              possibility of the user overriding these decisions by explicit
              annotations. 
            </p>
            <p>
              Using this fix, we obtain:
	    </p>
	    <example>
	      <p>
		<progident>p</progident>:
		<btypes:TYPE>
		  <Spair>                    
		    <mutable><int sz="32"/></mutable>
		    <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		  </Spair></btypes:TYPE> <br/>
		<progident>q</progident>:
		<btypes:TYPE><bool/></btypes:TYPE>
	      </p>
	    </example>
	    <p>
              Any attempt to <progident>set!</progident>
              <progident>p</progident> or <progident>q</progident> in
              <progident>body</progident> will fail, but an attempt to
              <progident>set!</progident> <progident>p.fst</progident> will succeed.
            </p>
          </li>
        </ul>    
        <p>
          FIX2 and FIX3 must <em> only </em> be used in the case of
          <em>local</em> definitions. If we allow the types of
          top-level forms to be determined by their use cases, it will
          create a lot of indeterminism problems as the top level
          definitions have unlimited scope. Interfaces will no longer be
          definitive, and programs will start influencing the types of
          the libraries they use, making the order in which
          units-of-compilation are processed significant. Even
          within the same unit of compilation, the order in which
          top-level forms are written will influence the outcome of
          types in unpleasant ways. Therefore, in the
          interest of programmer sanity, we freeze type of a
          top-level form by the end of the definition.
        </p>
        <p>
          FIX4 can be used in conjunction with FIX2 to obtain the
          types:
	</p>
	<example>
	  <p>
	    <progident>p</progident>:
	    <btypes:TYPE>
	      <maybe><Spair>                    
		  <mutable><int sz="32"/></mutable>
		  <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		</Spair></maybe></btypes:TYPE> <br/>
	    <progident>q</progident>:
	    <btypes:TYPE><maybe><bool/></maybe></btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
          or, in conjunction with FIX3 to obtain (in the presence of
          mutation):
	</p>
	<example>
	  <p>
	    <progident>p</progident>:
	    <btypes:TYPE>
	      <mutable><Spair>                    
		  <mutable><int sz="32"/></mutable>
		  <fn><tvar name="alpha"/><tvar name="alpha"/></fn>
		</Spair></mutable></btypes:TYPE> <br/>
	    <progident>q</progident>:
	    <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE>
	  </p>
	</example>
      </sect3>
      <sect3>
        <title>Where to Introduce Copy Compatibility?</title>
        <p>
          We have already stated that, in principle, we can introduce
          copy compatibility at the argument or return position of any
          expression that does not (respectively) expect or return a
          location. However, in practice, we may want to constrain this
          freedom to a smaller subset in favor of tighter inference. From a
          usability standpoint, we must individually make a decision
          regarding type compatibility about each of the following kinds of
          expressions: 
        </p>  

        <ul>   
          <li>
            <p>
              New <progident>let</progident> bindings.    
            </p>
            
            <p>
              Introducing a new binding is one of the most natural forms where 
              copy compatibility can be invoked. For example:
            </p>

            <literallayout>   
(define p:(mutable bool) #t:bool)
val p: (mutable bool)</literallayout>   

          </li>

          <li>
            <p>
              Arguments of function applications.
            </p>

            <p>
              Passing arguments to a function is the the other natural
              form where we think about copy compatibility. For
              example: 
            </p>

            <literallayout>   
(define (getFalse false:(mutable bool)) (set! false #f) false) 
val getFalse: (fn (mutable bool) (mutable bool))

(define q (getFalse #t))
val q: bool</literallayout>   
          </li>  
          
          <li>
            <p>
              Return values of function applications.
            </p> 
            
            <p>
              Strictly speaking, copy compatibility is not necessary at
              return locations as the return result must invariably end up in a
              position that will in turn invoke copy compatibility. The main
              reason to preserve this is to write expressions like:
            </p>

            <literallayout>
(define (id x) x)
val id: (fn ('a) 'a)

(define xyz (id n:(mutable int32)):int32)
val xyz: int32</literallayout>

            <p indent="no">
              where we explicitly qualify the result of an application to a
              different but copy compatible type. The other reason, of course, is
              to preserve intuition and symmetry between arguments and return types.
            </p>

            <p>
              However, we can end up in some interesting situations
              because of this freedom. For
              example:<footnote>
		<p>
		  <progident>copy-compat</progident>is
		  an internal typeclass that relates any two copy
		  compatible types.
		</p>
	      </footnote>
            </p>

            <literallayout>
(import ls bitc.list)
(define (list->vector lst)
  (make-vector (length lst) 
    (lambda (n) (ls.list-nth lst n))))
val list->vector: (forall ((copy-compat 'a 'b)) 
                     (fn ((list 'a)) (vector 'b)))</literallayout> 
            <p indent="no">
              The type of <progident>list->vector</progident> appears
              to be <btypes:TYPE><fn> <Ulist><tvar
              name="alpha"/></Ulist> <vector><tvar
              name="alpha"/></vector> </fn></btypes:TYPE>.  However,
              because of the copy compatibility at the return of the
              inner lambda, the type is actually
              <btypes:TYPE>
                <ctype>
                  <fn>
                    <Ulist><tvar name="alpha"/></Ulist>
                    <vector><tvar name="beta"/></vector></fn>
                  <set>
                    <ceq><tvar name="alpha"/>
                      <tvar name="beta"/></ceq></set></ctype>
              </btypes:TYPE>.
              </p>
              
            <p indent="no">
              Then if we write:
            </p>

            <literallayout>
(define (lvm lst:(list (mutable bool))) (list->vector lst))
val lvm: (fn ((list (mutable bool))) (vector bool)) </literallayout>

            <p indent="no">
              the type of <progident>lvm</progident> is
              <btypes:TYPE><fn>
                  <Ulist><mutable><bool/></mutable></Ulist>
                  <vector><bool/></vector>
                </fn></btypes:TYPE>
              and not   
              <btypes:TYPE><fn>
                  <Ulist><mutable><bool/></mutable></Ulist>
                  <vector><mutable><bool/></mutable></vector>
                </fn></btypes:TYPE>!
              (because we must default the maybe types at top-level).
            </p>

            <p>
              The fix for this --- as we would expect --- is 
              additional programmer annotations in order to 
              clamp the type of <progident>list->vector</progident> to
              <btypes:TYPE><fn>
                  <Ulist><tvar name="alpha"/></Ulist>
                  <vector><tvar name="alpha"/></vector>
                </fn></btypes:TYPE>,
              as in: 
            </p>
            
            <literallayout>
(define (list->vector lst)
  (make-vector (length lst) 
    (lambda (n) (ls.list-nth lst n))):(vector 'a))
val list->vector: (fn ((list 'a)) (vector 'a))</literallayout>
          </li>  

          <li>
            <p>
              Arguments/return values of value constructors -- 
              structure/union constructors,
              <progident>vector</progident>,
              <progident>array</progident>,
              <progident>make-vector</progident>.   
            </p> 

            <p>
              It is actually tempting to allow copy compatibility at
              argument and return positions of constructor
              applications also, because a copy is anyway being
              performed, and it would be nice to write things like: 
            </p>

            <literallayout>
(defstruct St f1:(mutable bool) f2:(mutable int32))
struct St: St
              
(let ((p (St #t 25)))
  (set! p.f1 #f))</literallayout>

            <p indent="no">  
              That is, even though the structure constructor is
              expecting a arguments of type
              <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE>
              and 
              <btypes:TYPE><mutable><int
                    sz="32"/></mutable></btypes:TYPE>, 
              it can be satisfied by literal arguments #t and 25 with
              types <btypes:TYPE><bool/></btypes:TYPE> and
              <btypes:TYPE><int sz="32"/></btypes:TYPE>  
              respectively. Otherwise, we will have to write:
            </p>

            <literallayout>
(let ((mTrue:(mutable bool) #t)
      (m25:(mutable int32) 25)
      (p (St mTrue m25)))
  (set! p.f1 #f))</literallayout>

            <p indent="no">
              or, we will have to accept mutable type qualification on
              literals, and then write:
            </p> 

            <literallayout>
(let ((p (St #t:(mutable bool) 25:(mutable int32))))
  (set! p.f1 #f))</literallayout>
            
            <p indent="no"> 
              However, if we allow copy compatibility at constructor
              arguments, the inference of parametrized types becomes a
              little surprising. 
            </p>
            
            <literallayout>
(define mTrue:(mutable bool) #t)
val mTrue: (mutable bool)

(define p (cons mTrue nil))
val p: (list bool)</literallayout>
            
            <p indent="no"> 
              As a result of copy compatibility, the type of the RHS
              is
              <btypes:TYPE><maybe>
                  <Ulist><maybe><bool/></maybe></Ulist></maybe></btypes:TYPE>.
              Note that we lost the mutability 
              information to allow freedom of compatibility even
              though <btypes:TYPE><Ulist><type/></Ulist></btypes:TYPE>
              is a <em>reference</em> type. Now, if we default
              maybe types to immutable, we will obtain the type
              <btypes:TYPE><Ulist><bool/></Ulist></btypes:TYPE>
              for <progident>p</progident>, 
              which does not ``seem'' like what the user
              intended. 
              Here, we can argue two ways:
            </p>
            <ul>
              <li>
                <p>
                  Constructors actually accept a location but
                  internally make a copy of the argument, for which
                  we do not invoke copy compatibility. 
                </p>                
              </li>
              <li>
                <p>
                  Just because the list was constructed from a mutable
                  value, it does not mean that the user intends to
                  make a list of mutable elements. So, we must invoke
                  copy compatibility here.
                </p>                
              </li>
            </ul>
            <p>
              In expressions that contain a deep nesting of
              constructors, copy compatibility will lead to rather
              ugly qualification requirements. For example: 
            </p>

            <literallayout>
(define r:(vector (list (mutable 'a))) (vector (cons mTrue nil)))
val r: (vector (list (mutable bool)))</literallayout>

            <p indent="no">    
              If the needed mutability is not shallow, the user will
              have to write out the detailed type up to the level in
              which the mutability is desired (as in the above
              example), which is not very pleasant.  
            </p>

            <p>
              Having said this, there is actually another possibility,
              which is to allow copy compatibility at constructor
              boundaries, but default the maybe types to what they
              were before inference threw away their mutability
              status. The next section explores this case. 
            </p>
          </li>

          <li>
            <p>
              Arguments/return values of other non-location returning
              expressions like conditionals --
              <progident>if</progident>,  
              <progident>switch</progident>,
              <progident>try/catch</progident>, 
              <progident>and</progident>, 
              <progident>or</progident>, 
              <progident>not</progident>,   ... etc. 
            </p> 

            <p>
              Allowing copy compatibility at these positions will
              allow us to write expressions like:
            </p>

            <literallayout>
(define p:int32 (if #t 1:int32 n:(mutable int32)))
val p: int32</literallayout>
            
            <p indent="no">
              The rationale here is that the result of these
              expressions cannot appear in any position expecting a
              location, and it is therefore ``safe'' to think of them
              as if an application to the function  
              <progident>if</progident> had happened.
            </p>

            <p>
              However, as is usual, this will lead to further loss of
              mutability information. For example:
            </p>

            <literallayout>
(define (vectorizer1 x) (vector x))
(define (vectorizer2 x) (vector (if #t x x)))

;; Types obtained without copy compatibility at constructor arguments
val vectorizer1: (fn ('a) (vector 'a))
val vectorizer2: (forall ((copy-compat 'a 'b)) (fn ('a) (vector 'b)))</literallayout>

            <p indent="no">
              Here, <progident>vectorizer1</progident> has the type
              <btypes:TYPE><fn>
                  <tvar name="alpha"/>
                  <vector><tvar name="alpha"/></vector>
                </fn></btypes:TYPE>
              <progident>vectorizer2</progident> has the type 
              <btypes:TYPE>
                <ctype>
                  <fn>
                    <tvar name="alpha"/>
                    <vector><tvar name="beta"/></vector></fn>
                  <set>
                    <ceq><tvar name="alpha"/>
                      <tvar name="beta"/></ceq></set></ctype>
              </btypes:TYPE>
              even if we say that constructor arguments 
              <em> do not </em> invoke copy-inference.  
            </p>
          </li>
        </ul>        
      </sect3>

      <sect3>
        <title>How Much of Copy Compatibility to Accept?</title>
        <p>
          We have already stated that, in theory, we can infer a
          copy compatible, but different type for every new value
          created due to a copy-operation. However, in practice, we may
          choose to allow <em>only</em> top-most level of
          mutability-compatibility in favor of a more precise inference.
        </p>
      </sect3>

      <sect3>
        <title>Compatibility of Function Types</title>
        <p>Consider the following function definition:
        </p>
        <literallayout>
(define (mut-c c) (set! c #\a) c)</literallayout>

        <p indent="no">
          From the implementation of the function
          <progident>mut-c</progident>, we infer the type
          <btypes:TYPE>
            <fn>
              <mutable><char/></mutable>
              <mutable><char/></mutable></fn></btypes:TYPE>
          for it. However, as the caller of this function, it is
          reasonable to think of <progident>mut-c</progident>
          as having the type 
          <btypes:TYPE>
            <fn>
              <mutable><char/></mutable>
              <mutable><char/></mutable></fn></btypes:TYPE>
          or
          <btypes:TYPE>
            <fn>
              <mutable><char/></mutable>
              <mutable><char/></mutable></fn></btypes:TYPE>, due
          to the copy compatibility at function argument and return
          positions. Moreover, while writing a proclamation, we would
          like to write the type from the caller's perspective without
          disclosing the mutability information of the <em>internal
            copy</em> of the arguments or return types. 
          For example:
        </p>
        <literallayout>
(proclaim mut-c: (fn (char) char))</literallayout>

        <p>We will hereinafter refer to the type of a function from the
          implementation viewpoint as the ``internal type'' and the one
          from the caller's viewpoint as the ``external type'' of a
          function. The external type can be obtained by simply dropping
          all mutable wrappers at copy compatible positions.</p>
        
        <p>
          Now, when the user explicitly writes a function type, should
          this be taken as the internal type, or the external type of
          the function? That is, should the following definition: </p>
        <literallayout>
(define mut-c:(fn (char) char) (lambda (c) (set! c #\a) c)</literallayout>
        
        <p indent = "no"> be type correct? Similarly, can
          <progident>mut-c</progident> be supplied as an actual argument
          when the formal argument expects the type
          <btypes:TYPE>
            <fn>
              <char/><char/></fn></btypes:TYPE>? </p>
        <literallayout>
(defstruct St fnxn: (fn (char) char))

(define xyz (St mut-c)</literallayout>
      
        <p>In other words, this leads to a notion of compatibility of
          function types in terms of the copy compatibility of their
          argument and return types. It may not be good to call this
          copy compatibility because it is not compatibility created due
          to the copy of the function value, but is a
          consequence of copy compatibility at argument and return
          positions.</p>

        <p>Finally, should the user be ever allowed to write the
          internal type of a function? One possible solution to this
          problem is given in Section&nbsp;<xref ref="proposal"/></p>
        
      </sect3>
      <sect3>
        <title>Type Class Instances</title>
        <p>With regard to type class method declarations, it is
          reasonable to expect that they should also declare external
          types without constraining the internal types (and this the
          implementation) of the instances supplied for these
          methods. </p>

        <p>Due to copy compatibility, at method argument and return
          positions, the compiler must only accept those instances
          whose methods have different external type signatures. For
          example: </p> 
        <literallayout>
(deftypeclass (CL1 'a)
  fn1: (fn ('a) 'a))

(definstance (CL1 bool) 
  (lambda (x:bool) x))
(definstance (CL1 (mutable bool)) 
  (lambda (x:(mutable bool)) x))</literallayout>

        <p>cannot be permitted because the two instances for
          <progident>CL1</progident> are in-differentiable from the
          caller's perspective. However, we can allow:</p>

        <literallayout>
(deftypeclass (CL2 'a)
  fn1: (fn ((vector 'a)) 'a))

(definstance (CL2 bool) 
  (lambda (x) (vector-nth x 0)))

(definstance (CL2 (mutable bool)) 
  (lambda (x) (vector-nth x 0)))</literallayout>
      </sect3>      
    </sect2>
  </sect1>

  <sect1 id="proposal">
    <title>Proposed Solution</title>
    <p> Keeping in mind, the various trade-offs raised in the previous
      section, we shall now propose a particular policy for handling
      copy compatibility. This is by no means ``the'' solution to the
      problem, but reflects our aesthetic judgment of the best way to
      capture the programmer's intuition about the flow of types in
      the language.
    </p>
    
    <ul>
      <li>
        <p>
          Allow copy compatibility to the full extent, up to a ref-boundary.
        </p> 
      </li>
      
      <li>
        <p>
          Allow copy compatibility to be invoked at arguments of all
          expressions that do not expect a location. Similarly for return
          types of expressions that do not return locations. 
        </p> 
      </li>

      <li>
        <p>
          In order to fix the maybe types, we adopt a hybrid of FIX4 and
          FIX2.
        </p>
        
        <ul>
          <li>
            <p>
              The topmost (shallow) mutability is determined by the FIX2
              rule in the case of local definitions. In the case of global
              definitions, any unresolved topmost mutability is set to
              immutable. 
            </p>
          </li>
          <li>
            <p>
              In the case of any other unresolved-mutability, we will try
              to resolve it by unifying it with --- a simplified form of ---
              the original type, so that we can preserve the original 
              mutability information. Intuitively, this does means that we
              will restore the original mutability status. However, it is
              done through unification because, in cases like 
              <progident>list->vector</progident> above, we must also
              ensure that the copy compatibility constraints on new type
              variables created for the sake of copy compatibility are
              turned into equality constraints. The next section explains
              this rule more formally.  
            </p>
          </li>
          <li>
            <p>
              If there are any residual unresolved maybe types even after
              applying the above rules, fix them to immutable.
            </p>
          </li>
        </ul>
      </li>
      <li>        
        <p>
	  All function types <progident>(fn&nbsp;...)</progident>
	  refer to the external type.<footnote>
	    <p>
	      This is a syntactic restriction that does not yet appear
	      in the specification.
	    </p>
	  </footnote> By
          construction, this means that all functions that are
          copy compatible at function argument and return positions
          are <em>equal</em>. The copy compatibility of function types
          refers to the compatibility of shallow mutability with
          respect to the entire function's type.
	</p>
        <p>
          Function types that declare mutable types at copy compatible
          positions will be rejected as an error. For example:</p>
        <literallayout>
(define abc:(fn ((mutable bool)) 'a) (lambda (x) x)) 
ERROR!</literallayout>
        <p>
          However, any type-qualifications on the arguments of a
          function within its body (as opposed to within the function's
          type) are understood to reflect the internal type. For
          example, the following definition is type-correct.</p>

        <literallayout>
(define abc (lambda (x:mutable bool) (set! x #t) x)) 
val abc: (fn (bool) bool)</literallayout>
        <p>
          Declarations (proclamations) are required to declare a type
          that will exactly match external type inferred for the
          corresponding definition.  </p>          
      </li>      
    </ul>
    <sect2 id="formalization">
      <title>Formalization</title>      
      <sect3>
        <title>Introducing Maybe Types</title>
        <p>  
          We need a new enhancement to our notation of types. The pair:
          <btypes:TYPE> <MBpair> 
              <maybe><type num="1"/></maybe> <aHset/>
            </MBpair> </btypes:TYPE>
          stands for the type <btypes:TYPE><maybe><type
                num="1"/></maybe></btypes:TYPE> 
          with the understanding that the maybe-ness in 
          <btypes:TYPE><maybe><type num="1"/></maybe></btypes:TYPE>
          <em>may</em> be resolved by unifying with one of the types
          in the <em>hint-set</em>
          <btypes:TYPE><aHset/></btypes:TYPE> if
          necessary. <em>Only</em> maybe types are 
          permitted to have hints. 
        </p>
        <p>
          At a copy-boundary, if the type of the original expression is
          <btypes:TYPE><type/></btypes:TYPE>,
          we give the type
          TypeOfCopy(<btypes:TYPE><type/></btypes:TYPE>)
          to the value that was created due to the copy. TypeOfCopy
          is defined as:
        </p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<TypeOfCopy><mutable><type/></mutable></TypeOfCopy> 
		<MBpair><TypeWithoutHint>
		    <TypeOfCopy><type/></TypeOfCopy></TypeWithoutHint>
		  <set><mutable><type/></mutable></set></MBpair>
	      </eq> <br/>
	      
	      <eq>
		<TypeOfCopy><MBpair><maybe><type/></maybe>
		    <aHset/></MBpair></TypeOfCopy>  
		<MBpair> 
		  <typeWithoutHint><TypeOfCopy><type/></TypeOfCopy></typeWithoutHint>  
		  <set><MBpair><maybe><type/></maybe><aHset/></MBpair></set> 
		</MBpair> 
	      </eq> 
	      <br/>
	      <eq>
		<TypeOfCopy><tvar name="alpha"/></TypeOfCopy> 
		<ctype>
		  <MBpair>
		    <tvar name="beta"/> 
		    <set><tvar name="alpha"/></set></MBpair>
		  <set>
		    <ceq><tvar name="alpha"/>
		      <tvar name="beta"/></ceq></set></ctype>
	      </eq> 
	      <br/> 
	      <eq>
		<TypeOfCopy><ref><type/></ref></TypeOfCopy> 
		<MBpair>                
		  <maybe><ref><type/></ref></maybe>
		  <set><ref><type/></ref></set></MBpair>
	      </eq>
	      <br/>
	      <eq>
		<TypeOfCopy><fn><type num="1"/><type
		      num="2"/></fn></TypeOfCopy> 
		<MBpair>
		  <maybe> <paren> <fn><type num="1"/><type num="2"/>
		      </fn> </paren> </maybe>
		  <set><fn><type num="1"/><type num="2"/></fn></set></MBpair>
	      </eq>
	      <br/> 
	      <eq>
		<TypeOfCopy><array><type/></array></TypeOfCopy>
		<MBpair>
		  <maybe><array><TypeOfCopy><type/></TypeOfCopy></array></maybe>
		  <set><array><type/></array></set></MBpair>
	      </eq>
	      <br/> 
	      <eq>
		<TypeOfCopy><vector><type/></vector></TypeOfCopy> 
		<MBpair>
		  <maybe><vector><type/></vector></maybe>
		  <set><vector><type/></vector></set></MBpair>
	      </eq>
	      <br/> 
	      <eq>
		<TypeOfCopy><comp
		    kind="ref"><types/></comp></TypeOfCopy> 
		<MBpair>
		  <maybe><comp kind="ref"><types/></comp></maybe>
		  <set><comp kind="ref"><types/></comp></set></MBpair>
	      </eq>
	      <br/>  
	      <eq>
		<TypeOfCopy><comp
		    kind="val"><types/></comp></TypeOfCopy> 
		<MBpair>
		  <maybe><comp kind="val">
		      <TypeOfCopy><types num="i"/> </TypeOfCopy><types num="j"/>
		    </comp></maybe>
		  <set><comp kind="val"><types/></comp></set></MBpair>
	      </eq>
	    </btypes:TYPE>
	    where, 
	    <btypes:TYPE><types num="i"/></btypes:TYPE>
	    &isin; <btypes:TYPE><types/></btypes:TYPE>
	    are the set of type arguments that are <em> not </em> used 
	    within another reference type-constructor, and
	    <btypes:TYPE><types num="j"/></btypes:TYPE>
	    &isin; <btypes:TYPE><types/></btypes:TYPE>
	    are the rest of the type arguments. <br/>
	    <btypes:TYPE>          
	      <eq>
		<TypeOfCopy><type/></TypeOfCopy> 
		<MBpair>
		  <maybe><type/></maybe>
		  <set><type/></set></MBpair></eq>
	    </btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  and:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>          
	      <eq>
		<TypeWithoutHint><MBpair><maybe><type/></maybe><aHset/></MBpair>
                </TypeWithoutHint>
                <maybe><type/></maybe>
              </eq>
	    </btypes:TYPE>
	  </p>
	</example>
        <p>
          The function <btypes:TYPE><TypeOfCopy><type/></TypeOfCopy> 
          </btypes:TYPE> increases the maybe-ness of a type
          <btypes:TYPE><type/></btypes:TYPE> to the 
          maximum permissible limit, so that the type of the copy can 
          unify with a different but copy compatible type. 
        </p>
        <p>
          We will also have to change our unifier to suite the new
          system of types. Instead of the rule:
        </p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<unify>
		  <maybe><type num="1"/></maybe>
		  <mutable><type num="2"/></mutable>
		</unify>
		<unin>
		  <unify>
		    <type num="1"/>
		    <type num="2"/>
		  </unify>
		  <set>
		    <lnk>
		      <maybe><type num="1"/></maybe>
		      <mutable><type num="2"/></mutable>                  
		    </lnk>
		  </set>
		</unin>
	      </eq>
	    </btypes:TYPE>
	  </p>
	</example>
        <p indent="no">
          we now have:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<unify>
		  <MBpair><maybe><type num="1"/></maybe>
		    <aHset/></MBpair>
		  <mutable><type num="2"/></mutable>
		</unify>
		<unin>
		  <unify>
		    <type num="1"/>
		    <type num="2"/>
		  </unify>
		  <set>
		    <lnk>
		      <MBpair><maybe><type num="1"/></maybe>
			<aHset/></MBpair>
		      <mutable><type num="2"/></mutable>
		    </lnk>
		  </set>
		</unin>
	      </eq>
	      <br/>
	      <eq>
		<unify>
		  <MBpair><maybe><type num="1"/></maybe>
		    <aHset num="1"/></MBpair>
		  <MBpair><maybe><type num="2"/></maybe>
		    <aHset num="2"/></MBpair>
		</unify>
		<unin>
		  <unify>
		    <type num="1"/>
		    <type num="2"/>
		  </unify>
		  <set>
		    <lnk>
		      <MBpair><maybe><type num="1"/></maybe>
			<aHset num="1"/></MBpair>
		      <MBpair><maybe><type num="2"/></maybe>
			<aHset num="2"/></MBpair>
		      <MBpair><maybe><type num="1"/></maybe>
			<unin><aHset num="1"/><aHset num="2"/>
			</unin></MBpair>
		    </lnk>
		  </set>
		</unin>
	      </eq>
	      <br/>
	      <eq>
		<unify>
		  <MBpair><maybe><type num="1"/></maybe>
		    <aHset/></MBpair>
		  <type num="2"/>
		</unify>
		<unin>
		  <unify>
		    <type num="1"/>
		    <type num="2"/>
		  </unify>
		  <set>
		    <lnk>
		      <MBpair><maybe><type num="1"/></maybe>
			<aHset/></MBpair>
		      <type num="2"/>                  
		    </lnk>
		  </set>
		</unin>
	      </eq>
	    </btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  and instead of
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<TheType><maybe> <type/> </maybe><aLnset/></TheType>
		<maybe><TheType><type/><aLnset/></TheType> </maybe>
	      </eq>
	    </btypes:TYPE>
	  </p>
	</example>
        <p indent="no">
	  we have:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<TheType><MBpair><maybe> <type num="1"/> </maybe>
		    <aHset/></MBpair><aLnset/></TheType>
		<MBpair><maybe> <TheType><type num="1"/></TheType>
		  </maybe> <aHset/></MBpair>
	      </eq> <br/>
	    </btypes:TYPE>        
	  </p>
	</example>
        <p>
          Note that the unifier preserves as much hint information as
          possible. When time comes to resolve these maybe types, we
          can pick the most ``appropriate'' hint according to any
          desired policy. 
        </p>
      </sect3>
      
      <sect3>
        <title>Resolving Maybe Types</title>

        <p>
          At a let-boundary, if we have an expression like:
        </p>
        <literallayout>
(let ((<font color="blue"><em>[1]</em></font>p:<font
       color="blue"><em>[2]</em></font>qual <font
       color="blue"><em>[3]</em></font>expr)) body)</literallayout> 
        
        <p indent="no">  
          and if we let:
	</p>
	<example>
	  <p>
          <font color="blue"><em>[1]</em></font> 
          <btypes:TYPE><type/></btypes:TYPE> be the type of
          <progident>p</progident> <em>before</em> generalization. <br/>
          <font color="blue"><em>[2]</em></font> <btypes:TYPE><type
              num="1"/></btypes:TYPE> be the type obtained from explicit
          qualification <progident>qual</progident> <br/>
          <font color="blue"><em>[3]</em></font> <btypes:TYPE><type
              num="2"/></btypes:TYPE> be the inferred type for the <em> copy
            of </em> <progident>expr</progident>,
	  </p>
	</example>
	<p indent="no">
	  then, we have:
	</p>
	<example>
	  <p>
          <btypes:TYPE>
            <eq>
              <type/>
              <Xform name="adjMaybe">
                <Xform name="TopMutAdj">
                  <UnifiedType>
                    <type num="1"/>
                    <type num="2"/>
                  </UnifiedType>
                </Xform>
              </Xform>
            </eq>
          </btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  where:
	</p>
	<example>
	  <p>
          <btypes:TYPE>
            <eq>
              <Xform name="adjMaybe">
                <MBpair> <maybe> <type num="1"/> </maybe>
                  <aHset/></MBpair></Xform>
              <Xform name="Ground">              
                <UnifiedType>
                  <Xform name="adjMaybe">
                    <type num="1"/> </Xform>
                  <Madj> <MBpair> <maybe> <type num="1"/> </maybe>
                      <aHset/></MBpair></Madj>
                </UnifiedType>
              </Xform>
            </eq>
	    <br/>
            <eq>
              <Xform name="adjMaybe">
                <MBpair> <mutable> <type num="1"/> </mutable>
                  <type num="2"/> </MBpair></Xform>
              <mutable> <Xform name="adjMaybe">
                  <type num="1"/> </Xform> </mutable>
            </eq> <br/>

            <eq>
              <Xform name="adjMaybe">
                <MBpair> <type num="1"/>
                  <type num="2"/> </MBpair></Xform>
              <Xform name="adjMaybe">
                <type num="1"/> </Xform>
            </eq> <br/>
            
            <eq>
              <Xform name="adjMaybe">
                <tvar name="alpha"/> </Xform>
              <tvar name="alpha"/>
            </eq> <br/>

            <eq>
              <Xform name="adjMaybe">
                <ref><type/></ref> </Xform> <ref><Xform
                  name="adjMaybe"><type/></Xform></ref> </eq> <br/>

            <eq>
              <Xform name="adjMaybe">
                <fn><type num="1"/> <type num="2"/> </fn> </Xform>
              <fn><Xform name="adjMaybe"><type num="1"/></Xform>
                <Xform name="adjMaybe"><type num="2"/></Xform></fn>
            </eq> <br/>

            <eq>
              <Xform name="adjMaybe">
                <array><type/></array> </Xform>
              <array><Xform name="adjMaybe"><type/></Xform></array>
            </eq> <br/>

            <eq>
              <Xform name="adjMaybe">
                <vector><type/></vector> </Xform>
              <vector><Xform name="adjMaybe"><type/></Xform></vector>
            </eq> <br/>
            
            <eq>
              <Xform name="adjMaybe">
                <comp name="p"><types/></comp> </Xform>
              <comp name="p">
                <aggregate> <Xform name="adjMaybe"><type/></Xform>
                </aggregate> </comp> 
            </eq> <br/>
            
            <eq>
              <Xform name="adjMaybe">
                <type/> </Xform>
              <type/>
            </eq>
          </btypes:TYPE>
          <!-- <footnote>
            <p>The following function, 
              <btypes:TYPE><Madj><type/></Madj></btypes:TYPE> calculates 
              the hint to be used in maybe-ness resolution, if
              necessary.</p></footnote> -->
	  </p>
	</example>
	<p indent="no">
	  and:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <Madj><MBpair>  
		  <maybe> <type num="1"/> </maybe> 
		  <aHset/>
		</MBpair> </Madj>
	    </btypes:TYPE>
	    = <btypes:TYPE><type num="2"/></btypes:TYPE> if &exist; an
	    <em>immutable</em> type <btypes:TYPE><type
		num="2"/></btypes:TYPE> in <progident>map</progident>(
	    <btypes:TYPE><MadjOp/></btypes:TYPE>, 
	    <btypes:TYPE><aHset/></btypes:TYPE>); 
	    <btypes:TYPE><type num="3"/></btypes:TYPE> if &exist; a
	    maybe type <btypes:TYPE><type
		num="3"/></btypes:TYPE> in <progident>map</progident>(
	    <btypes:TYPE><MadjOp/></btypes:TYPE>, 
	    <btypes:TYPE><aHset/></btypes:TYPE>); 
	    the mutable type <btypes:TYPE><type num="4"/></btypes:TYPE>
	    otherwise. <br/>
	    
	    <btypes:TYPE>
	      <eq>
		<Madj><mutable> <type/> </mutable></Madj>
		<mutable><Madj><type/></Madj> </mutable>
	      </eq> <br/>
	      
	      <eq>
		<Madj><tvar name="alpha"/></Madj>
		<tvar name="alpha"/>
	      </eq> <br/>

	      <eq> 
		<Madj><ref><type/></ref></Madj>
		<ref><tvar name="alpha"/></ref>
	      </eq> <br/>

	      <eq>
		<Madj><fn> <type num="1"/><type num="2"/> </fn> </Madj>
		<fn><tvar name="alpha"/><tvar name="beta"/></fn>
	      </eq> <br/>

	      <eq>
		<Madj><array><type/></array></Madj>
		<array><tvar name="alpha"/></array>
	      </eq> <br/>
	      
	      <eq>
		<Madj><vector><type/></vector></Madj>
		<vector><tvar name="alpha"/></vector>
	      </eq> <br/>

	      <eq>
		<Madj><comp name="p"><types/></comp></Madj>
		<comp name="p"><tvars name="alpha"/></comp>
	      </eq> <br/>

	      <eq>
		<Madj><type/></Madj>
		<type/>
	      </eq>
	    </btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  and:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<Xform name="Ground">
		  <mutable> <type/> </mutable></Xform>
		<mutable> <type/> </mutable>
	      </eq> <br/>
	      <eq>
		<Xform name="Ground">
		  <maybe> <type/> </maybe></Xform>
		<type/>
	      </eq> <br/>
	      <eq>
		<Xform name="Ground">
		  <type/></Xform>
		<type/>
	      </eq>
	    </btypes:TYPE>
	  </p>
	</example>
	<p indent="no">
	  and:
	</p>
	<example>
	  <p>
	    TopMutAdj(<btypes:TYPE><mutable><type/></mutable></btypes:TYPE>)
	    = <btypes:TYPE><mutable><type/></mutable></btypes:TYPE> if
	    this is a local definition that is mutated in
	    <progident>body</progident>, 
	    <btypes:TYPE><type/></btypes:TYPE> otherwise. <br/>
	    <btypes:TYPE>
	      <eq>
		<Xform name="TopMutAdj">
		  <MBpair><type num="1"/><type num="2"/></MBpair> </Xform>
		<MBpair>
		  <Xform name="TopMutAdj"><type num="1"/></Xform>
		  <type num="2"/></MBpair>
	      </eq> <br/>
	      
	      <eq>
		<Xform name="TopMutAdj">
		  <type/></Xform>
		<type/>
	      </eq>
	    </btypes:TYPE>
	  </p>        
	</example>
      </sect3>

      <sect3 id="ValRes">
        <title>Value Restriction</title>
        <p>
          The previous section explained how to calculate a type that
          is a candidate for generalization. In this section, we will
          actually explain the generalization step,  and the
          algorithm for value-restriction. We will have a new function
          V<sup>&minus;&minus;</sup> which takes a type and a mode
          parameter. The mode can be one of ``remove'' or ``keep''
          depending on whether we come from a value type or a
          reference type context. 
        </p>
        <p>
          Now, in an expression <progident>e</progident> with type
          <btypes:TYPE><type/></btypes:TYPE>, the set of generalizable
          type variables in <btypes:TYPE><type/></btypes:TYPE> is
          given by:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <diff>
		<ftvs><type/></ftvs>
		<ftvs><gamma/></ftvs>
	      </diff>
	    </btypes:TYPE> if <progident>e</progident> is a
	    <em>value</em>, and
	    <br/>
	    <btypes:TYPE>
	      <diff>
		<ftvs><type/></ftvs>
		<ftvs><gamma/></ftvs>
		<V__ mode="remove"><type/></V__>
	      </diff>
	    </btypes:TYPE> if <progident>e</progident> is
	    <em>expansive,</em>
	  </p>
	</example>
	<p indent="no">
          where:
	</p>
	<example>
	  <p>
	    <btypes:TYPE>
	      <eq>
		<V__ mode="remove"><tvar name="alpha"/></V__>
		<set><tvar name="alpha"/></set>
	      </eq> <br/>

	      <eq>
		<V__ mode="remove">
		  <ctype>
		    <tvar name="alpha"/>
		    <set><Tclass name="IntLit"><tvar name="alpha"/>
		      </Tclass></set></ctype></V__>
		<set><tvar name="alpha"/></set>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="remove">
		  <ctype>
		    <tvar name="alpha"/>
		    <set><Tclass name="FloatLit"><tvar name="alpha"/>
		      </Tclass></set></ctype></V__>
		<set><tvar name="alpha"/></set>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="keep"><tvar name="alpha"/></V__>
		<empty/>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="mode"><mutable><type/></mutable></V__>
		<ftvs><type/></ftvs>
	      </eq> <br/>

	      <eq>
		<V__ mode="mode"><ref><type/></ref></V__>
		<V__ mode="mode"><type/></V__>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="mode"><fn><type num="1"/><type num="2"/></fn></V__>
		<unin>
		  <ftvs><type num="1"/></ftvs>
		  <V__ mode="mode"><type num="2"/></V__>
		</unin>              
	      </eq> <br/>

	      <eq>
		<V__ mode="mode"><array><type/></array></V__>
		<V__ mode="remove"><type/></V__>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="mode"><vector><type/></vector></V__>
		<V__ mode="keep"><type/></V__>
	      </eq> <br/>
	      
	      <eq>
		<V__ mode="mode">
		  <comp kind="val"><types num="i"/></comp></V__>
		<Unin><V__ mode="remove"><type
		      num="i"/></V__></Unin>  
	      </eq> <br/>          
	      
	      <eq>
		<V__ mode="mode">
		  <comp kind="ref"><types num="i"/></comp></V__>
		<Unin><V__ mode="keep"><type
		      num="i"/></V__></Unin>  
	      </eq>
	    </btypes:TYPE> 
	  </p>
	</example>
        <p>
          Note that the <btypes:TYPE><ref><type/></ref></btypes:TYPE>
          <em>does not</em> explicitly pass the keep-mode. This is
          because such types can later be
          <progident>deref</progident>ed, exposing the inner value
          (recall that deref returns a location, and not a
          copy). Therefore, <em> only </em> those type variables which
          are enclosed in reference types that can never be
          dereferenced are safe to be generalized in an expansive
          expression. The IntLit and FloatLit rules above (only)
          expressively state that these primitive integer/floating
          point types are  unboxed value types.
        </p>        
      </sect3>
    </sect2>

    <sect2>
      <title>Some Examples</title>
      <p>
        In this section, we will illustrate our scheme
        with some examples.  
      </p>  

      <literallayout> 
(define xyz:(mutable int32) 10)
val xyz:(mutable int32)

(define p:(mutable 'a) (pair xyz #t))
val p: (mutable (pair (mutable int32) bool))</literallayout>
      
      <p indent="no">
        Inn the above example, <progident>xyz</progident> clearly has the type
        <btypes:TYPE><mutable><int sz="32"/></mutable></btypes:TYPE>. Here is 
        the annotated expression for the definition of
        <progident>p</progident> followed by the types inferred at 
        at every step of inference:
      </p>
      <literallayout> 
<font color="blue"><em>[10]</em></font> <font
color="blue"><em>[9]</em></font> <font
color="blue"><em>[8]</em></font>(define <font 
color="blue"><em>[4]</em></font>  <font 
color="blue"><em>[1]</em></font>p:<font
color="blue"><em>[3]</em></font>(mutable <font
color="blue"><em>[2]</em></font>'a) 
      <font 
color="blue"><em>[7']</em></font> <font 
color="blue"><em>[7]</em></font>(pair <font 
color="blue"><em>[5']</em></font> <font 
color="blue"><em>[5]</em></font>xyz <font 
color="blue"><em>[6']</em></font> <font 
color="blue"><em>[6]</em></font>#t))</literallayout>
      <p>
        Here are the types obtained after each step of inference:
      </p>
      <example>
	<p>
	  <font color="blue"><em>[1]</em></font> = 
	  <btypes:TYPE><tvar
	      name="alpha"/></btypes:TYPE><br/> 
	  
	  <font color="blue"><em>[2]</em></font> = 
	  <btypes:TYPE><tvar
	      name="beta"/></btypes:TYPE><br/> 
	  
	  <font color="blue"><em>[3]</em></font> =
	  <btypes:TYPE><mutable><tvar
		name="beta"/></mutable></btypes:TYPE><br/> 

	  <font color="blue"><em>[4]</em></font> = 
	  UnifiedType(<font color="blue"><em>[1]</em></font>,
	  <font color="blue"><em>[3]</em></font>) = 
	  <btypes:TYPE><mutable><tvar
		name="beta"/></mutable></btypes:TYPE><br/> 

	  <font color="blue"><em>[5]</em></font> =
	  <btypes:TYPE><mutable><int sz="32"/></mutable></btypes:TYPE><br/> 

	  <font color="blue"><em>[5']</em></font> = 
	  TypeOfCopy(<font color="blue"><em>[5]</em></font>) = 
	  <btypes:TYPE><MBpair>
	      <maybe><int sz="32"/></maybe>
	      <set><mutable><int sz="32"/></mutable></set></MBpair>
	  </btypes:TYPE> <br/> 
	  
	  <font color="blue"><em>[6]</em></font> =
	  <btypes:TYPE><bool/></btypes:TYPE> <br/> 
	  
	  <font color="blue"><em>[6']</em></font> = 
	  TypeOfCopy(<font color="blue"><em>[6]</em></font>) = 
	  <btypes:TYPE><MBpair>
	      <maybe><bool/></maybe>
	      <set><bool/></set></MBpair>
	  </btypes:TYPE> <br/> 

	  <font color="blue"><em>[7]</em></font> =
	  <btypes:TYPE>
	    <Spair>
	      <MBpair>
		<maybe><int sz="32"/></maybe>
		<set><mutable><int sz="32"/></mutable></set></MBpair>
	      <MBpair>
		<maybe><bool/></maybe>
		<set><bool/></set></MBpair>
	    </Spair>
	  </btypes:TYPE> <br/> 

	  <font color="blue"><em>[7']</em></font> =
	  TypeOfCopy(<font color="blue"><em>[7]</em></font>) =   
	  <btypes:TYPE>
	    <MBpair break="45">
	      <maybe><Spair>
		  <MBpair>
		    <maybe><int sz="32"/></maybe>
		    <set><mutable>
			<int sz="32"/></mutable></set></MBpair> 
		  <MBpair>
		    <maybe><bool/></maybe>
		    <set><bool/></set></MBpair>
		</Spair></maybe>            
	      
	      <set><Spair>
		  <MBpair>
		    <maybe><int sz="32"/></maybe>
		    <set><mutable><int sz="32"/>
		      </mutable></set></MBpair>
		  <MBpair>
		    <maybe><bool/></maybe>
		    <set><bool/></set></MBpair>
		</Spair></set>
	    </MBpair> 
	  </btypes:TYPE> <br/> 

	  <font color="blue"><em>[8]</em></font> =
	  UnifiedType(<font color="blue"><em>[4]</em></font>,
	  <font color="blue"><em>[7']</em></font>) = 
	  <btypes:TYPE>          
	    <mutable><Spair>
		<MBpair>
		  <maybe><int sz="32"/></maybe>
		  <set><mutable><int sz="32"/>
		    </mutable></set></MBpair>
		<MBpair>
		  <maybe><bool/></maybe>
		  <set><bool/></set></MBpair>
	      </Spair></mutable>
	  </btypes:TYPE> <br/> 

	  <font color="blue"><em>[9]</em></font> =
	  TopMutAdj(<font color="blue"><em>[8]</em></font>) = 
	  <btypes:TYPE>          
	    <mutable><Spair>
		<MBpair>
		  <maybe><int sz="32"/></maybe>
		  <set><mutable><int sz="32"/>
		    </mutable></set></MBpair>
		<MBpair>
		  <maybe><bool/></maybe>
		  <set><bool/></set></MBpair>
	      </Spair></mutable>
	  </btypes:TYPE> <br/> 
	  
	  <font color="blue"><em>[10]</em></font> =
	  adjMaybe(<font color="blue"><em>[9]</em></font>) = 
	  <btypes:TYPE>
	    <mutable><Spair>
		<mutable><int sz="32"/></mutable>
		<bool/>
	      </Spair></mutable>
	  </btypes:TYPE>
	</p>  
      </example>
      <p> In the rest of the examples, we will only show the expressions 
        and the final type obtained. 
        In the following expression:
      </p>
      <literallayout>
(define r (vector (cons mTrue:(mutable bool) nil)))
val r: (vector (list (mutable bool)))</literallayout>
      <p indent="no">
        <progident>r</progident> gets the ``expected'' type
        <btypes:TYPE>
          <vector><Ulist><mutable><bool/></mutable>
            </Ulist></vector></btypes:TYPE>.
        However, it is still possible to get the type
        <btypes:TYPE>
          <vector><Ulist><bool/>
            </Ulist></vector></btypes:TYPE>.
        for <progident>r</progident> 
        through explicit qualification if one desires so.
      </p>

      <literallayout>
(define r:(vector (list bool)) 
  (vector (cons mTrue:(mutable bool) nil)))
val r: (vector (list bool))</literallayout>
      <p>
        Finally, our <progident>list->vector</progident> also gets the
        ``correct'' type, without any type qualifications.
      </p>
      <literallayout>
(import ls bitc.list)
(define (list->vector lst)
  (make-vector (length lst) 
    (lambda (n) (ls.list-nth lst n))))
val list->vector: (fn ((list 'a)) (vector 'a))</literallayout>

      <p indent="no">
        The type inferred for <progident>list->vector</progident> is
        <btypes:TYPE><fn>
            <Ulist><tvar name="alpha"/></Ulist>
            <vector><tvar name="alpha"/></vector>
          </fn></btypes:TYPE>, 
        as is apparent from the definition, and not 
        <btypes:TYPE>
          <ctype>
            <fn>
              <Ulist><tvar name="alpha"/></Ulist>
              <vector><tvar name="beta"/></vector></fn>
            <set>
              <ceq><tvar name="alpha"/>
                <tvar name="beta"/></ceq></set></ctype>
        </btypes:TYPE>.
      </p>

    <p>              
        We will now give some examples that illustrate our
        value-restriction scheme. In these examples, we will
        explicitly write the universal quantification of type
        variables in the case of polymorphic types.
        First, the example we considered in
        Section&nbsp;<xref ref="valresintro"/>:
      </p>
      <literallayout>
(define p:(mutable bool, 'a) (#t, none))
val p: (pair (mutable bool) (optional #X255))</literallayout>

      <p indent="no">
        is now well typed, because <progident>p</progident> is now
        given the non-polymorphic type
        <btypes:TYPE>          
          <Spair>
            <mutable><bool/></mutable>
            <optional>
              <dummy num="255"/>
            </optional></Spair></btypes:TYPE><footnote><p>Monomorphic
            types are forced to dummy types at top-level.
          </p></footnote> 
        
        and not 
        <btypes:TYPE>          
          <TS>
            <tvar name="alpha"/>
            <Spair>
              <mutable><bool/></mutable>
              <optional>
                <tvar name="alpha"/>
              </optional></Spair></TS></btypes:TYPE>.
        
      </p>

      <p>
        All the permissible cases in original (Garrigue) restriction
        are still preserved for reference types :
      </p>
      <literallayout>
(define q:(mutable bool, (list 'a)) (#t, nil))
val q: (pair (mutable bool) (list 'a))</literallayout>

      <p indent="no">
        <progident>q:</progident>
        <btypes:TYPE>          
          <TS>
            <tvar name="alpha"/>
            <Spair>
              <mutable><bool/></mutable>
              <Ulist> <tvar name="alpha"/>                
              </Ulist></Spair></TS></btypes:TYPE>
      </p>

      <p>
        Type-variables wrapped in a reference type are OK even if they
        lie within an encompassing value type.
      </p>
      <literallayout>
(define r:(mutable bool, 'c) (#t, (nil, nil)))
val r: (pair (mutable bool) (pair (list 'a) (list 'b)))</literallayout>
      <example>
	<p>
	  <progident>r:</progident>
	  <btypes:TYPE>          
	    <TS>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	      <Spair>
		<mutable><bool/></mutable>
		<Spair>
		  <Ulist> <tvar name="alpha"/></Ulist>
		  <Ulist> <tvar name="beta"/></Ulist></Spair>
	      </Spair></TS></btypes:TYPE>.
	</p>
      </example>
      <p>
        Type-variables wrapped in a value type must be removed even if they lie
        within an encompassing reference type.
      </p>
      <literallayout>
(define m:(mutable bool, 'b) (#t, (vector none)))
val m: (pair (mutable bool) (vector (optional #X143)))</literallayout>
      <example>
	<p>
	  <progident>m:</progident>
	  <btypes:TYPE>                    
	    <Spair>
	      <mutable><bool/></mutable>
	      <vector>
		<optional><dummy num="143"/>
		</optional></vector>
	    </Spair></btypes:TYPE>
	</p>
      </example>
      <p indent="no">
        Otherwise, one could write:
      </p>
      <literallayout>
(let ((mm1:(optional int8) (vector-nth m.snd 0))
      (mm2:(optional double) (vector-nth m.snd 0))) ... )</literallayout>
      
      <p>
        Accessor-like functions will work OK for reference types but will not 
        work for value types. 
      </p>
      <literallayout>
(define (car x:(list 'a)) ... )
val car: (fn ((list 'a)) 'a)

(define fstElem (car (cons nil nil))
fstElem: (list 'a)</literallayout>
      <example>
	<p>
	  <progident>car:</progident>
	  <btypes:TYPE>                    
	    <TS>
	      <tvar name="alpha"/>
	      <fn>
		<Ulist><tvar name="alpha"/></Ulist>
		<tvar name="alpha"/></fn></TS></btypes:TYPE><br/> 

	  <progident>fstElem:</progident>
	  <btypes:TYPE>                    
	    <TS>
	      <tvar name="alpha"/>
	      <Ulist><tvar name="alpha"/></Ulist></TS></btypes:TYPE><br/>
	</p>
      </example>
      <literallayout>
(define (fst x:('a, 'b)) x.fst)
val fst: (fn ((pair 'a 'b)) 'a)

(define fstPart: (fst (nil, nil))
val fstPart: (list #X432)</literallayout>
      <example>
	<p>
	  <progident>fst:</progident>
	  <btypes:TYPE>                    
	    <TS>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	      <fn>
		<Spair><tvar name="alpha"/><tvar name="beta"/></Spair> 
		<tvar name="alpha"/></fn></TS></btypes:TYPE><br/>

	  <progident>fstPart:</progident>
	  <btypes:TYPE>                              
            <Ulist><dummy num="432"/></Ulist></btypes:TYPE>
	</p>
      </example>
      <p>
        The right thing to do in this case is to define
        <progident>fst</progident> as a <em>term</em> and not as an
        ordinary functions whose application will be considered
        expansive. 
      </p>      
    </sect2>

    
    <sect2 id="limitations">
      <title>Limitations</title>
      <p>
        The algorithm proposed above is not a panacea. First, there is
        a peculiar kind of generality we have lost, which is
        impossible to recover even with explicit qualification (that
        is, with the facilities for qualification present in the
        current language specification). For example, there is no
        qualification for <progident>list->vector</progident> that we
        can use, in order to obtain the type
        <btypes:TYPE>
          <ctype>
            <fn>
              <Ulist><tvar name="alpha"/></Ulist>
              <vector><tvar name="beta"/></vector></fn>
            <set>
              <ceq><tvar name="alpha"/>
                <tvar name="beta"/></ceq></set></ctype>
        </btypes:TYPE>. That is, even if we re-write the definition as
      </p>

      <literallayout>
(import ls bitc.list)
(define list->vector:(forall ((copy-compat 'a 'b)) (fn ((list 'a)) (vector 'b)))
  (lambda (lst)
    (make-vector (length lst) 
      (lambda (n) (ls.list-nth lst n)))))
val list->vector: (fn ((list 'a)) (vector 'a)))</literallayout>

      <p indent="no"> we obtain the type
        <btypes:TYPE>
          <fn>
            <Ulist><tvar name="alpha"/></Ulist>
            <vector><tvar name="alpha"/></vector></fn></btypes:TYPE>
        for <progident>list->vector</progident> according to the above
        algorithm since a statement copy compatibility does not
        preclude equlity.</p>

      <!--
      <p>
        There is a second (weird) case in which the inferred types are
        a little surprising, but this case can be fixed with the right
        type annotation (at the right place). 
        
        Consider the following example:
      </p>
      <literallayout>
(let ((f:(mutable bool) #t)
      (g (lambda (()) (vector f)))) ... )
      </literallayout>
      
      <p indent="no">
        For this expression, we infer the right types: <br/>
        <progident>f:</progident>
        <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE><br/>
        <progident>g:</progident>
        <btypes:TYPE><fn><unit/>
            <vector><mutable><bool/></mutable></vector></fn></btypes:TYPE><br/>         
      </p>

      <p indent="no">
        However, if the example were to be re-written as:
      </p>
      
      <literallayout>
(let ((f #t)
      (g (lambda (()) (vector f)))
      (h (lambda (()) f:(mutable bool)))) ... )
      </literallayout>

      <p indent="no">
        we infer: <br/>
        <progident>f:</progident>
        <btypes:TYPE><mutable><bool/></mutable></btypes:TYPE><br/>
        <progident>g:</progident>
        <btypes:TYPE><fn><unit/>
            <vector><bool/></vector></fn></btypes:TYPE>  (!!)<br/>
      </p>

      <p>
        Note that the qualification on <progident>f</progident> within
        <progident>h</progident> should be honored at the defining
        occurrence of <progident>f</progident>, because mutually
        recursive definitions are typed and generalized together.
        The problem here is that we have previously 
        (Section&nbsp;<xref ref="formalization"/>) imposed the rule
        that, in the type
        <btypes:TYPE> <MBpair> 
            <maybe><type num="1"/></maybe> <type num="2"/> 
          </MBpair> </btypes:TYPE>,      
        the hint <btypes:TYPE><type num="2"/> </btypes:TYPE>
        must either be a type whose mutability status is fixed, or a
        type-variable. Because of this, we also defined TypeOfCopy as: <br/>
        
        <btypes:TYPE>
          <eq>
            <TypeOfCopy>
              <type/>
            </TypeOfCopy>
            <MBpair> 
              <TypeOfCopy><type/></TypeOfCopy> 
              <Madj><type/></Madj>
            </MBpair>
          </eq>
        </btypes:TYPE> <br/> 
        
        <br/>and not<br/>
        
        <btypes:TYPE>
          <eq>
            <TypeOfCopy>
              <type/>
            </TypeOfCopy>
            <MBpair> 
              <TypeOfCopy><type/></TypeOfCopy> 
              <type/>
            </MBpair>
          </eq>
        </btypes:TYPE>. <br/> 

        If we allow maybe types as hints, we can get some ``dynamism''
        in hints, and resolve maybe types based on what they
        appear after all unifications have happened. This will resolve
        the above problem, but, in doing so, we will lose a vital
        property of the type system - determinism. It will no longer
        be possible to write the unification rules for unifying two
        maybe types as:<br/><br/>

        <btypes:TYPE>
          <eq>
            <unify>
              <MBpair><maybe><type num="1"/></maybe>
                <mutable><type num="2"/></mutable></MBpair>
              <MBpair><maybe><type num="3"/></maybe>
                <type num="4"/></MBpair>
            </unify>
            <unin>
              <unify>
                <type num="1"/>
                <type num="3"/>
              </unify>
              <set>
                <lnk>
                  <MBpair><maybe><type num="1"/></maybe>
                    <mutable><type num="2"/></mutable></MBpair>
                  <MBpair><maybe><type num="3"/></maybe>
                    <type num="4"/></MBpair>
                </lnk>
              </set>
            </unin>
          </eq> <br/>
          
          <eq>
            <unify>
              <MBpair><maybe><type num="1"/></maybe>
                <type num="2"/></MBpair>
              <type/>
            </unify>
            <unin>
              <unify>
                <type num="1"/>
                <type/>
              </unify>
              <set>
                <lnk>
                  <MBpair><maybe><type num="1"/></maybe>
                    <type num="2"/></MBpair>
                  <type/>                  
                </lnk>
              </set>
            </unin>
          </eq> <br/>          
        </btypes:TYPE><br/>
        
        which specify that if the unifier is presented with two
        maybe types whose hints differ in mutability, the immutable
        hint wins. Since the unifier sees maybe types in the hints, it
        will form an arbitrary linkage. The inferred types will
        nevertheless be sound, but are no longer statically
        determinable. Therefore, we cannot permit this in our
        type-system.
      </p>

      <p>
        From a usability standpoint, this example is not one to be
        very concerned about. However, we might consider some
        enhancements where we process qualifications on identifiers
        aggressively, or restrict the positions where
        mutable qualifications on expressions returning locations
        might occur. In fact, the rule as is, might be better to
        explain (to programmers) because it does the right thing from 
        whatever type-information was ``apparent'' at the point of
        construction.  
      </p> -->
      <!--      <sect3 id="handling_lim">
      <title>Addressing the Limitations</title>
    </sect3> -->
    </sect2>

    <sect2 id="future">
      <title>Future Considerations</title>      
      <p>
        Function types can be generalized regardless of whether
        they contain any mutable or maybe types within
        them. Therefore, if an expression is a value (that is, not 
        expansive), there is no reason to fix the maybe types
        contained within a function type in order to retain soundness 
        or polymorphism. This way, we can retain the principality
        of types for functions definitions. This approach will ---
        among other things --- resolve the problem with the type of
        <progident>list->vector</progident> identified in the previous
        section. 

      <literallayout>
(import ls bitc.list)
(define (list->vector lst)
  (make-vector (length lst) 
    (lambda (n) (ls.list-nth lst n)))))
val list->vector: (forall ((copy-compat 'a 'b)) (fn ((list 'a)) (vector 'b)))</literallayout>

      <p>
        The type of list->vector will now be 
        <btypes:TYPE>
          <TS>
            <tvar name="alpha"/>
            <tvar name="beta"/>
            <ctype>
              <fn>
                <Ulist><tvar name="alpha"/></Ulist>
                <vector><MBpair><tvar name="beta"/>
                    <tvar name="alpha"/></MBpair></vector></fn>
              <set>
                <ceq><tvar name="alpha"/>
                  <tvar name="beta"/></ceq></set></ctype></TS>
        </btypes:TYPE>. 
        
        That is, we obtain the fully generic type for
        <progident>list->vector</progident>, but also save a hint to
        resolve the types at use occurrences. Therefore, any use of 
        <progident>list->vector</progident> will yield
        ``expected'' types, as in:</p>
      
      <literallayout>
(define (lvm lst:(list (mutable bool))) (list->vector lst))
val lvm: (fn ((list (mutable bool))) (vector (mutable bool))) </literallayout>
      
      
      However, we must <em>only</em> retain those hints that rely on the function
      arguments. Otherwise, this will lead to violation of
      abstraction across the function boundary as the types
      obtained at application will depend on the implementation
      of the function.</p>

      <p>
        There is a further relaxation to the way we fix maybe types
        that can be considered. Whereas we need to fix the maybe-ness
        in the type itself, we may not have to fix the maybe-ness of
        the constraints on the type, in order to retain sound
        typing. This will facilitate cases like:</p>

      <literallayout> 
(deftypeclass (CL2 'a)
   zeroth: (fn ((vector 'a)) 'a))

(definstance (CL2 bool) 
  (lambda (x) (vector-nth x 0)))

(define p:(vector (mutable bool)) (vector (zeroth (vector #t))))
val p:(vector (mutable bool)) </literallayout>

      <p indent="no">
        to type-check even though there is no instance 
        <btypes:TYPE>          
          <Tclass name="CL2"><mutable><bool/></mutable></Tclass>
        </btypes:TYPE> 
        because, for
        <progident>p</progident>, we initially obtain the type  
        <btypes:TYPE>
          <ctype>
            <vector><mutable><bool/></mutable></vector>
            <set><Tclass name="CL2">
                <MBpair><maybe><bool/></maybe><bool/></MBpair></Tclass>
            </set></ctype></btypes:TYPE><footnote><p>Originally, we
            would have obtained the type 
            <btypes:TYPE>
              <ctype>
                <vector><mutable><bool/></mutable></vector>
                <set><Tclass name="CL2">
                    <mutable><bool/></mutable></Tclass>
                </set></ctype></btypes:TYPE>.</p></footnote>, and
        the constraint 
        <btypes:TYPE>          
          <Tclass name="CL2"><MBpair><maybe><bool/></maybe><bool/>
            </MBpair></Tclass></btypes:TYPE>            
        
        can be satisfied by the instance
        <btypes:TYPE>          
          <Tclass name="CL2"><bool/></Tclass></btypes:TYPE>, 
        and we finally get the unconstrained type
        <btypes:TYPE>          
          <vector><mutable><bool/></mutable></vector></btypes:TYPE>.
      </p>
    </sect2>    
  </sect1>
  
  <sect1>
    <title>Acknowledgments</title>
    <p>
      Scott Smith of Johns Hopkins University provided extensive
      ongoing comments, advice, and guidance in the course of this
      work. Mark Jones was kind enough to educate us on type classes,
      which provided an essential basis for integrating these ideas.
    </p>
  </sect1>
  <sect1>
    <title>Conclusion</title>
    <p>
      There is a fundamental conflict of goals between the ability to
      infer principal types and to allow freedom of
      mutability-compatibility at copy-boundaries. We have identified
      various trade-offs and some design choices in this regard, along
      with their pros and cons. We have also selected a strategy based
      on our aesthetic judgment of the best way to capture the
      programmer's intuition about the flow of types.
      By default, our strategy infers types based on the ``natural''
      flow of type information in an expression, but preserves the
      possibility of obtaining other permissible types through
      explicit qualification in most cases.  
    </p>
  </sect1>
  <appendix id="mut_into_immut">
    <title>Other Considerations</title>
    <p>
      While we are thinking about the various trade-offs and possible 
      freedom in compatibility of types with respect to mutability, we 
      might be tempted to relax this rule beyond
      copy compatibility. For example, it feels natural that any value
      that has a deeply mutable type must be able to flow into an
      argument that expects an immutable value. For example, if we
      have a function <progident>vector->string</progident> with type  
      <btypes:TYPE>
        <fn><vector><char/></vector>
          <string/></fn> </btypes:TYPE>      
      we would think that it should be  possible to pass a value with
      type 
      <btypes:TYPE>
        <fn><vector><mutable><char/></mutable></vector>,
          <string/></fn> </btypes:TYPE>      
      as the actual argument to
      <progident>vector->string</progident>. However, this mechanism
      is not sound. 
    </p>
    
    <p>
      While the <progident>vector->string</progident> case will work,
      it does not generalize. To see the problem, consider the
      procedure: 
    </p>

    <literallayout>
(define (vector-return vec:(vector char)) vec)</literallayout>

    <p indent="no">
      <progident>vector-return</progident> has the type
      <btypes:TYPE>
        <fn><vector><char/></vector>
          <vector><char/></vector></fn> </btypes:TYPE>.
      If we allow mutable values to 
      arbitrarily flow into immutable arguments, the application of 
      <progident>vector-return</progident> in
    </p>

    <literallayout>
(let ((mv (vector (mutable #\a) (mutable #\b))))
  (let ((imv (vector-return mv)))
    (== (vector-nth imv 0)
        (begin (set! (vector-nth mv 0) #\c)
	       (vector-nth imv 0)))))</literallayout>
 
    <p indent="no">
      is legal, and the result of this expression is
      <progident>#f</progident>! 
    </p>

    <p>
      Since <btypes:TYPE>
        <vector><char/></vector> </btypes:TYPE> is a
      reference type, if we allow this use of
      <progident>vector-return</progident>, we would end up 
      with <progident>imv</progident> and <progident>mv</progident> 
      pointing to identical content, but disagreeing about 
      the types of the cells. If this were allowed, the compiler would
      never be entitled to believe that vector cells (or more generally,
      the types of fields within value types) are constant (even if so
      declared)! In particular, the compiler cannot safely eliminate
      the extra index into <progident>imv</progident> in this example
      unless it can determine that the first expression of the begin
      form cannot mutate it -- the ``constness'' of
      <progident>imv</progident> is merely a local aberration rather
      than a statement of true immutability. We will in essence, lose
      the mathematical notion of constness if we allow this
      application. Therefore we impose the ``one location, one type''
      rule. 
    </p>  
  </appendix>


  <bibliography>
    <bibentry label="garrigueValRes2004">
      J. Garrigue, ``Relaxing the Value Restriction'' <doctitle>
      International Symposium on Functional and Logic
      Programming</doctitle> 2004.
    </bibentry>
    <bibentry label="GrossmanCyclone2006">
      D. Grossman, ``Quantified Types in an Imperative Language''
      <doctitle>ACM Transactions on Programming Languages and
        Systems</doctitle> 
      2006.
    </bibentry>
    <bibentry label="H98rep">
      S. P. Jones, I. Hughes, <em>et. al.</em> ``Haskell 98 Language
      and Libraries: the Revised Report''  
      <doctitle>Journal of Functional Programming</doctitle>
      January 2003.
    </bibentry>
    <bibentry label="ISO1995Ada">
      ISO,
      <doctitle>International Standard ISO/IEC 8652:1995 (Information
      Technology &mdash; Programming
      Languages &mdash; Ada)</doctitle>
      International Standards Organization (ISO). 1995.
    </bibentry>
    <bibentry label="ISO1999ANSI-C">
      ISO,
      <doctitle>International Standard ISO/IEC 9899:1999 (Programming
      Languages - C)</doctitle>
      International Standards Organization (ISO). 1999.
    </bibentry>
    <bibentry label="JimPrincipalTypings1996">
      Trevor Jim, ``What are principal typings and what are they good for?''
      <doctitle> ACM Symposium on Principals of Programming
        Languages</doctitle> 
      1996.
    </bibentry>
    <bibentry label="Kernighan1988C">
      Brian W. Kernighan and Dennis M. Ritchie. <doctitle>The C Programming
	Language</doctitle>. Prentice Hall, 1988
    </bibentry>
    <bibentry label="milner97definition">
      Robin Milner, Mads Tofte, Robert Harper, and David
      MacQueen. <doctitle>The Definition of Standard ML -
      Revised</doctitle>
      The MIT Press, May 1997.
    </bibentry>
    <bibentry label="peytonjones2003haskellrevisedreport">
      Simon Peyton Jones (ed.). <doctitle>Haskell 98 Language and
	Libraries: The Revised report</doctitle>. Cambridge University
	Press. 2003.
    </bibentry>
    <bibentry label="Diatchki2005Representation">
      Iavor S. Diatchki, Mark P. Jones, and Rebekah Leslie.
      ``High- level Views on Low-level Representations.''
      <doctitle>Proc. 10th ACM Conference on Functional
      Programming</doctitle> (ICFP 2005). pp. 168&ndash;179. Tallinn, Estonia,
      September 2005.
      Published as <doctitle>SIGPLAN Notices</doctitle>
      9<b>(40)</b>. ACM Press. September 2005.
    </bibentry>
    <bibentry label="shapBitcSpec2006">
      J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
      Specification'' 
      <link
        href="http://coyotos.org/docs/bitc/spec.html">
        <progident>http://coyotos.org/docs/bitc/spec.html</progident>
      </link>
    </bibentry>
    <bibentry label="wrightValRes1995">
      A. K. Wright, ``Simple Imperative Polymorphism'' 
      <doctitle> Lisp and Symbolic Computation</doctitle>
      8(4):343--355, 1995.
    </bibentry>
  </bibliography>
</article>

<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->


