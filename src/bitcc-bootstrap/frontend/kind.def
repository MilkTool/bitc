/* -*- Mode: c -*- */
/*
 * Copyright (C) 2005, The EROS Group, LLC.
 *
 * This file is part of the EROS Operating System runtime library.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, 59 Temple Place - Suite 330 Boston, MA 02111-1307, USA.
 */

//
// PRIMARY: Whether this is a ground type in the BitC type system.
//
// CSIMPLE: Whether this is a non-composite type in the emitted C
//          code. Includes all scalar primary types and (eventually)
//          types that are represented as pointers
//
// ATOMIC   Primitive (non-composed values) SSA phase *was* using this
// REF      True if the type is a reference type
// PRIMINT   Primary integer type
// PRIMFLOAT Primary floating point type 
//
 
/*      NAME       PRIMARY CSIMPLE ATOMIC SCALAR REF    PRIMINT PRIMFLOAT*/
DEFKIND(unit,      true,   true,   true,  true,  false, false,  false)
DEFKIND(bool,      true,   true,   true,  true,  false, false,  false)
DEFKIND(char,      true,   true,   true,  true,  false, false,  false)
DEFKIND(word,      true,   true,   true,  true,  false, true,   false)
DEFKIND(int8,      true,   true,   true,  true,  false, true,   false)
DEFKIND(int16,     true,   true,   true,  true,  false, true,   false)
DEFKIND(int32,     true,   true,   true,  true,  false, true,   false)
DEFKIND(int64,     true,   true,   true,  true,  false, true,   false)
DEFKIND(uint8,     true,   true,   true,  true,  false, true,   false)
DEFKIND(uint16,    true,   true,   true,  true,  false, true,   false)
DEFKIND(uint32,    true,   true,   true,  true,  false, true,   false)
DEFKIND(uint64,    true,   true,   true,  true,  false, true,   false)
DEFKIND(float,     true,   true,   true,  true,  false, false,  true)
DEFKIND(double,    true,   true,   true,  true,  false, false,  true)
DEFKIND(quad,      true,   true,   true,  true,  false, false,  true)
//Strings are considered scalars by special dispensation, because they
//are immutable.
DEFKIND(string,    true,   true,   false, true,  true,  false,  true)

//DEFKIND(bitfield,  true,   false,  true,  false, false,  false)
DEFKIND(fn,        true,   false,  true,  true,  false, false,  false)
DEFKIND(tyfn,      true,   false,  true,  false, false, false,  false)
DEFKIND(uconv,     true,   false,  true,  false, false, false,  false)
DEFKIND(uconr,     true,   false,  false, false, true,  false,  false)

DEFKIND(tvar,      false,  false,  false, false, false, false,  false)
DEFKIND(fnarg,     false,  false,  false, false, false, false,  false)
DEFKIND(structv,   false,  false,  false, false, false, false,  false)
DEFKIND(structr,   false,  true,   false, false, true,  false,  false)
DEFKIND(unionv,    false,  false,  false, false, false, false,  false)
DEFKIND(unionr,    false,  true,   false, false, true,  false,  false)
DEFKIND(uvalv,     false,  false,  false, false, false, false,  false)
DEFKIND(uvalr,     false,  true,   false, false, true,  false,  false)
DEFKIND(reprv,     false,  false,  false, false, false, false,  false)
DEFKIND(reprr,     false,  true,   false, false, true,  false,  false)
DEFKIND(array,     false,  false,  false, false, false, false,  false)
DEFKIND(vector,    false,  false,  false, false, true,  false,  false)
DEFKIND(ref,       false,  true,   false, false, true,  false,  false)
// by-ref is not actually used as a type. It is only present to qualify
// at_byreftype since all ASTs must have a type. Since by-ref types
// can only appear within argvecs, the my-ref-ness is marked on the
// component-flags of ty_fnArgvec, and the ty_byref wrapper is
// discarded henceforth.
DEFKIND(byref,     false,  true,   false, false, true,  false,  false)
DEFKIND(mutable,   false,  false,  false, false, false, false,  false)
DEFKIND(mbTop,     false,  false,  false, false, false, false,  false)
DEFKIND(mbFull,    false,  false,  false, false, false, false,  false)
DEFKIND(exn,       false,  false,  false, false, true,  false,  false)
DEFKIND(dummy,     false,  false,  false, false, false, false,  false)

// The following are constraints, stricttly speaking, but are types at
// the next level.
DEFKIND(typeclass, false,  false,  false, false, false, false,  false)
// Copy coersion constraint
DEFKIND(subtype, false,  false,  false, false, false, false,  false)
// Meta polymorphic constraint (MPC)
DEFKIND(pcst, false,  false,  false, false, false, false,  false)
// Kind variable for the MPC
DEFKIND(kvar, false,  false,  false, false, false, false,  false)
// Fixed kinds for the MPC. The type-header has static types
// to identify the two kinds (mono/poly) that can exist.
DEFKIND(kfix, false,  false,  false, false, false, false,  false)

/* For internal use ONLY */
//DEFKIND(closure,   false,  false,  false, false, true,  false,  false)
DEFKIND(letGather, false,  false,  false, false, false, false,  false)

#undef DEFKIND

/* Notes:

The representation of maybe types is an optimized version of the
one described in: 
http://coyotos.org/docs/bitc/formal.html.

Here is the transformation:

Theory:
'a\t1\t2\t3\t4\ti.

Practice:
      component
ty_maybe------------->ti
 |                    ^
 |           comp     |
 |------->t1-----------
   hint   |           ^
          |       comp|
	  ----->t2----
          |hint
          |   ...

For two reasons:
i) The innermost type need not be fetched everytime, it is
   available.
ii) Constraints only matter until type variables are unified with
    something compatible. 
*/
